<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计算机网络【八】]]></title>
    <url>%2Fposts%2F322335c4%2F</url>
    <content type="text"><![CDATA[第6章 应用层每个应用层协议都是为了解决某一类应用问题，而问题的解决又往往是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。应用层的具体内容就是规定应用进程在通信时所遵循的协议。应用层的许多协议都是基于客户服务器方式。客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。客户服务器方式所描述的是进程之间服务和被服务的关系。客户是服务请求方，服务器是服务提供方。6.1域名系统 DNS6.1.1域名系统概述许多应用层软件经常直接使用域名系统 DNS (Domain Name System)，但计算机的用户只是间接而不是直接使用域名系统。互联网采用层次结构的命名树作为主机的名字，并使用分布式的域名系统 DNS。名字到 IP 地址的解析是由若干个域名服务器程序完成的。域名服务器程序在专设的结点上运行，运行该程序的机器称为域名服务器。6.1.2互联网的域名结构互联网采用了层次树状结构的命名方法。 任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。域名的结构由标号序列组成，各标号之间用点隔开：… . 三级域名 . 二级域名 . 顶级域名 各标号分别代表不同级别的域名。域名只是个逻辑概念，并不代表计算机所在的物理地点。变长的域名和使用有助记忆的字符串，是为了便于人来使用。而 IP 地址是定长的 32 位二进制数字则非常便于机器进行处理。域名中的“点”和点分十进制 IP 地址中的“点”并无一一对应的关系。点分十进制 IP 地址中一定是包含三个“点”，但每一个域名中“点”的数目则不一定正好是三个。顶级域名 TLD (Top Level Domain)(1) 国家顶级域名 nTLD.cn 表示中国，.us 表示美国，.uk 表示英国，等等。(2) 通用顶级域名 gTLD最早的顶级域名是：.com （公司和企业）.net （网络服务机构.org （非赢利性组织）.edu （美国专用的教育机构）.gov （美国专用的政府部门）.mil （美国专用的军事部门）.int （国际组织）新增的通用顶级域名：.aero （航空运输企业）.biz （公司和企业）.cat （加泰隆人的语言和文化团体）.coop （合作团体）.info （各种情况）.jobs （人力资源管理者）.mobi （移动产品与服务的用户和提供者）.museum （博物馆）.name （个人）.pro （有证书的专业人员）.travel （旅游业）6.1.3域名服务器一个服务器所负责管辖的（或有权限的）范围叫做区 (zone)。各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。每一个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到 IP 地址的映射。DNS 服务器的管辖范围不是以“域”为单位，而是以“区”为单位。域名服务器有以下四种类型根域名服务器顶级域名服务器权限域名服务器本地域名服务器提高域名服务器的可靠性DNS 域名服务器都把数据复制到几个域名服务器来保存，其中的一个是主域名服务器，其他的是辅助域名服务器。当主域名服务器出故障时，辅助域名服务器可以保证 DNS 的查询工作不会中断。主域名服务器定期把数据复制到辅助域名服务器中，而更改数据只能在主域名服务器中进行。这样就保证了数据的一致性。根域名服务器根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析，只要自己无法解析，就首先求助于根域名服务器。在互联网上共有 13 个不同 IP 地址的根域名服务器，它们的名字是用一个英文字母命名，从 a 一直到 m（前 13 个字母）。根域名服务器共有 13 套装置，不是 13 个机器。这些根域名服务器相应的域名分别是：a.rootservers.netb.rootservers.net…m.rootservers.net到2016年2月，全世界已经在 588 个地点安装了根域名服务器，使世界上大部分 DNS 域名服务器都能就近找到一个根域名服务器。顶级域名服务器顶级域名服务器（即 TLD 服务器）负责管理在该顶级域名服务器注册的所有二级域名。当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。权限域名服务器负责一个区的域名服务器。当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。本地域名服务器本地域名服务器对域名系统非常重要。当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。每一个互联网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，这种域名服务器有时也称为默认域名服务器。域名的解析过程主机向本地域名服务器的查询一般都是采用递归查询。如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文。本地域名服务器向根域名服务器的查询通常是采用迭代查询。当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。 每个域名服务器都维护一个高速缓存，存放最近用过的名字以及从何处获得名字映射信息的记录。可大大减轻根域名服务器的负荷，使互联网上的 DNS 查询请求和回答报文的数量大为减少。为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器，并处理超过合理时间的项（例如，每个项目只存放两天）。当权限域名服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名转换的准确性。6.2 文件传输协议6.2.1 FTP 概述文件传送协议 FTP (File Transfer Protocol) 是互联网上使用得最广泛的文件传送协议。FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。FTP 屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。文件传送并非很简单的问题。原因是众多的计算机厂商研制出的文件系统多达数百种，且差别很大。6.2.2 FTP 的基本工作原理文件传送协议 FTP 只提供文件传送的一些基本的服务，它使用 TCP 可靠的运输服务。FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务FTP 的服务器进程由两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程，负责处理单个请求主进程的工作步骤打开熟知端口（端口号为 21），使客户进程能够连接上。等待客户进程发出连接请求。启动从属进程来处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发地进行。两个连接控制连接在整个会话期间一直保持打开，FTP 客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接不用来传送文件。实际用于传输文件的是“数据连接”。服务器端的控制进程在接收到 FTP 客户发送来的文件传输请求后就创建“数据传送进程”和“数据连接”，用来连接客户端和服务器端的数据传送进程。数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。两个不同的端口号当客户进程向服务器进程发出建立连接请求时，要寻找连接服务器进程的熟知端口 (21)，同时还要告诉服务器进程自己的另一个端口号码，用于建立数据传送连接。接着，服务器进程用自己传送数据的熟知端口 (20) 与客户进程所提供的端口号码建立数据传送连接。由于 FTP 使用了两个不同的端口号，所以数据连接与控制连接不会发生混乱。使用两个不同端口号的好处使协议更加简单和更容易实现。在传输文件时还可以利用控制连接（例如，客户发送请求终止传输）。6.2.3 简单文件传送协议 TFTPTFTP (Trivial File Transfer Protocol) 是一个很小且易于实现的文件传送协议。TFTP 使用客户服务器方式和使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。TFTP 只支持文件传输而不支持交互。TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。每次传送的数据 PDU 中有 512 字节的数据，但最后一次可不足 512 字节。数据 PDU 也称为文件块 (block)，每个块按序编号，从 1 开始。支持 ASCII 码或二进制传送。可对文件进行读或写。使用很简单的首部。TFTP 的工作很像停止等待协议发送完一个文件块后就等待对方的确认，确认时应指明所确认的块编号。发完数据后在规定时间内收不到确认就要重发数据 PDU。发送确认 PDU 的一方若在规定时间内收不到下一个文件块，也要重发确认 PDU。这样就可保证文件的传送不致因某一个数据报的丢失而告失败。开始工作时，TFTP 客户进程发送一个读请求 PDU 或写请求 PDU 给 TFTP 服务器进程，其熟知端口号码为 69。TFTP 服务器进程要选择一个新的端口和 TFTP 客户进程进行通信。若文件长度恰好为 512 字节的整数倍，则在文件传送完毕后，还必须在最后发送一个只含首部而无数据的数据 PDU。若文件长度不是 512 字节的整数倍，则最后传送数据 PDU 的数据字段一定不满 512 字节，这正好可作为文件结束的标志。6.3 远程终端协议 TELNETTELNET 是一个简单的远程终端协议，也是互联网的正式标准。用户用 TELNET 就可在其所在地通过 TCP 连接注册（即登录）到远地的另一个主机上（使用主机名或 IP 地址）。TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远地主机上。现在由于 PC 的功能越来越强，用户已较少使用 TELNET 了。 TELNET 也使用客户服务器方式。在本地系统运行 TELNET 客户进程，而在远地主机则运行 TELNET 服务器进程。 和 FTP 的情况相似，服务器中的主进程等待新的请求，并产生从属进程来处理每一个连接。网络虚拟终端 NVT 格式客户软件把用户的击键和命令转换成 NVT 格式，并送交服务器。服务器软件把收到的数据和命令，从 NVT 格式转换成远地系统所需的格式。向用户返回数据时，服务器把远地系统的格式转换为 NVT 格式，本地客户再从 NVT 格式转换到本地系统所需的格式。6.4 万维网 WWW万维网 WWW (World Wide Web)并非某种特殊的计算机网络，是一个大规模的、联机式的信息储藏所万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。这种访问方式称为“链接”。6.4.1超媒体与超文本万维网是分布式超媒体 (hypermedia) 系统，它是超文本 (hypertext) 系统的扩充。一个超文本由多个信息源链接成。利用一个链接可使用户找到另一个文档。这些文档可以位于世界上任何一个接在互联网上的超文本系统中。超文本是万维网的基础。超媒体与超文本的区别是文档内容不同。超文本文档仅包含文本信息，而超媒体文档还包含其他表示方式的信息，如图形、图像、声音、动画，甚至活动视频图像。万维网的工作方式万维网以客户 - 服务器方式工作。浏览器就是在用户计算机上的万维网客户程序。万维网文档所驻留的计算机则运行服务器程序，因此这个计算机也称为万维网服务器。客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。在一个客户程序主窗口上显示出的万维网文档称为页面 (page)。万维网必须解决的问题(1) 怎样标志分布在整个互联网上的万维网文档？使用统一资源定位符 URL (Uniform Resource Locator) 来标志万维网上的各种文档。使每一个文档在整个互联网的范围内具有唯一的标识符 URL。(2) 用何协议实现万维网上各种超链的链接？在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是超文本传送协议 HTTP (HyperText Transfer Protocol)。HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。(3) 怎样使各种万维网文档都能在互联网上的各种计算机上显示出来，同时使用户清楚地知道在什么地方存在着超链？超文本标记语言 HTML (HyperText Markup Language) 使得万维网页面的设计者可以很方便地用一个超链从本页面的某处链接到互联网上的任何一个万维网页面，并且能够在自己的计算机屏幕上将这些页面显示出来。(4) 怎样使用户能够很方便地找到所需的信息？为了在万维网上方便地查找信息，用户可使用各种的搜索工具（即搜索引擎）。6.4.2 统一资源定位符 URL资源定位符 URL 是对可以从互联网上得到的资源的位置和访问方法的一种简洁表示。URL 给资源的位置提供一种抽象的识别方法，并用这种方法给资源定位。只要能够对资源定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找其属性。URL 相当于一个文件名在网络范围的扩展。因此 URL 是与互联网相连的机器上的任何可访问对象的一个指针。 6.4.3 超文本传送协议 HTTPHTTP 的操作过程为了使超文本的链接能够高效率地完成，需要用 HTTP 协议来传送一切必须的信息。从层次的角度看，HTTP 是面向事务的 (transaction-oriented) 应用层协议，它是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。当我们在浏览器地址栏上输入URL后，浏览器会通过DNS解析到对应IP上，浏览器而根据这个IP将IP地址与Web服务器进行通信，这个通信的协议就是HTTP协议，说白了，HTTP协议就是规定了客户端和服务器端之间通讯的一种规范和格式，只有两者都遵循这个协议，两者在接受和响应请求的时候才能达到一致用户点击鼠标后所发生的事件(1) 浏览器分析超链指向页面的 URL(2) 浏览器向域名系统 DNS 请求解析 www.tsinghua.edu.cn 的 IP 地址(3) DNS 解析出清华大学服务器的 IP 地址(4) 浏览器与服务器建立 TCP 连接(5) 浏览器发出取文件命令：GET /chn/yxsz/index.htm(6) 服务器给出响应，把文件 index.htm 发给浏览器(7) TCP 连接释放(8) 浏览器显示“清华大学院系设置”文件 index.htm 中的所有文本代理服务器代理服务器 (proxy server) 又称为万维网高速缓存 (Web cache)，它代表浏览器发出 HTTP 请求。万维网高速缓存把最近的一些请求和响应暂存在本地磁盘中。当与暂时存放的请求相同的新请求到达时，万维网高速缓存就把暂存的响应发送出去，而不需要按 URL 的地址再去互联网访问该资源。 (1) 浏览器访问互联网的服务器时，要先与校园网的高速缓存建立 TCP 连接，并向高速缓存发出 HTTP 请求报文。(2) 若高速缓存已经存放了所请求的对象，则将此对象放入 HTTP 响应报文中返回给浏览器。(3) 否则，高速缓存就代表发出请求的用户浏览器，与互联网上的源点服务器建立 TCP 连接，并发送 HTTP 请求报文。(4) 源点服务器将所请求的对象放在 HTTP 响应报文中返回给校园网的高速缓存。(5) 高速缓存收到此对象后，先复制在其本地存储器中（为今后使用），然后再将该对象放在 HTTP 响应报文中，通过已建立的 TCP 连接，返回给请求该对象的浏览器。HTTP 的报文结构HTTP 有两类报文：请求报文——从客户向服务器发送请求报文。响应报文——从服务器到客户的回答。由于 HTTP 是面向正文的 (text-oriented)，因此在报文中的每一个字段都是一些 ASCII 码串，因而每个字段的长度都是不确定的。报文由三个部分组成，即开始行、首部行和实体主体。在请求报文中，开始行就是请求行。请求格式：1、请求首行2、请求头(首部行)3、空行4、请求体（或称之为请求正文）请求行常见的请求方法有GET和POST在浏览器地址栏中发送请求，以及点击超链接都是GET请求提交表单既可以使用GET，也可以使用POST方式，推荐使用POST方式，查询数据的时候推荐使用GET方式GET：没有请求体，但空行是存在的，附带的参数有限制，数据容量不能超过1kPOST：存在请求体，可以在请求的实体内容中向服务器发送数据，传送的数据量是无限制的首部行Accept-Charset: ISO-8859-1 ：客户端告诉服务器，所支持的字符集格式Accept-Encoding: gzip,deflate,br ：客户端告诉服务器，所支持的压缩格式Accept-Language: en-us,zh-cn ：客户端告诉服务器，它的语言环境Connection: close/Keep-Alive ：客户端告诉服务器，请求完后是断开链接或保持链接Cookie ：客户端告诉服务器，所带来的的cookie（后面讲）Host:xxxxxx ：客户端告诉服务器，想访问哪台主机User-Agent ：User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36：表示浏览器内核Referer ：xxxxx：客户端告诉服务器，客户机从哪个页面来的，防盗链，前发出请求的地址，例如在浏览器地址栏直接访问服务器，那么没有这个请求头。如果是在www.baidu.com页面上点击链接访问的服务器，那么这个头的值www.baidu.comContent-Type：如果是POST请求，会有这个头，默认值为application/x-www-form-urlencoded，表示请求体内容使用url编码状态码都是三位数字1xx 表示通知信息的，如请求收到了或正在进行处理。2xx 表示成功，如接受或知道了。3xx 表示重定向，表示要完成请求还必须采取进一步的行动。4xx 表示客户的差错，如请求中有错误的语法或不能完成。5xx 表示服务器的差错，如服务器失效无法完成请求。响应报文中状态行例子HTTP/1.1 202 Accepted 接受HTTP/1.1 400 Bad Request 错误的请求HTTP/1.1 404 Not Found 找不到HTTP/1.1 301 Moved Permanently 永久性的转移了Location: http://www.xyz.edu/ee/index.html 新URL在服务器上存放用户的信息万维网站点可以使用 Cookie 来跟踪用户。Cookie 表示在 HTTP 服务器和客户之间传递的状态信息。使用 Cookie 的网站服务器为用户产生一个唯一的识别码。利用此识别码，网站就能够跟踪该用户在该网站的活动。6.4.4 万维网的文档超文本标记语言 HTML 中的 Markup 的意思就是“设置标记”。HTML 定义了许多用于排版的命令（即标签）。HTML 把各种标签嵌入到万维网的页面中。这样就构成了所谓的 HTML 文档。HTML 文档是一种可以用任何文本编辑器创建的 ASCII 码文件。XML (Extensible Markup Language) 是可扩展标记语言，它和 HTML 很相似。但 XML 的设计宗旨是传输数据，而不是显示数据（HTML 是为了在浏览器上显示数据）。XML 不是要替换 HTML，而是对 HTML 的补充。XHTML (Extensible HTML) 是可扩展超文本标记语言，它与 HTML 4.01 几乎是相同的。但 XHTML 是更严格的 HTML 版本，也是一个 W3C 标准（2000年1月），是作为一种 XML 应用被重新定义的 HTML，并将逐渐取代 HTML。新的浏览器都支持 XHTML。6.4.5 万维网的信息检索系统在万维网中用来进行搜索的程序叫做搜索引擎6.5电子邮件简单邮件发送协议：SMTP通用互联网邮件扩充 MIME邮件读取协议：POP3 和 IMAP发信人的用户代理向源邮件服务器发送邮件，以及源邮件服务器向目的邮件服务器发送邮件，都是使用 SMTP 协议。而 POP 协议或 IMAP 协议则是用户从目的邮件服务器上读取邮件所使用的协议TCP/IP 体系的电子邮件系统规定电子邮件地址的格式如下：收件人邮箱名@邮箱所在主机的域名符号“@”读作“at”，表示“在”的意思。例如电子邮件地址xiexiren@tsinghua.org.cn收件人邮箱名这个用户名在该域名的范围内是唯一的。邮箱所在的主机的域名在全世界必须是唯一的基于万维网的电子邮件用户代理 (UA) 的缺点：必须在计算机中安装用户代理软件。但可能不能安装或不允许安装。因此，不方便收发邮件。万维网电子邮件优点：不需要在计算机中再安装用户代理软件。计算机能联网，就能非常方便地收发电子邮件。电子邮件界面非常友好。6.6 动态主机配置协议 DHCP互联网广泛使用的动态主机配置协议 DHCP (Dynamic Host Configuration Protocol) 提供了即插即用连网 (plug-and-play networking) 的机制。这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。DHCP给运行服务器软件、且位置固定的计算机指派一个永久地址，给运行客户端软件的计算机分配一个临时地址。需要 IP 地址的主机在启动时就 向DHCP 服务器广播发送发现报文（DHCPDISCOVER），这时该主机就成为 DHCP 客户。本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCPOFFER）。并不是每个网络上都有DHCP服务器，这样会使DHCP服务器的数量太多。现在是每一个网络至少有一个 DHCP 中继代理，它配置了 DHCP 服务器的 IP 地址信息。当 DHCP 中继代理收到主机发送的发现报文后，就以单播方式向 DHCP 服务器转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再将此提供报文发回给主机。DHCP 服务器分配给 DHCP 客户的 IP 地址的临时的，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为租用期。租用期的数值应由 DHCP 服务器自己决定。DHCP 客户也可在自己发送的报文中（例如，发现报文）提出对租用期的要求。PS：有时候你会感觉突然上不上网了，可能是租用期到了。正在申请，此时可以看看你的网络信息是不是全0。6.7简单网络管理协议 SNMP网络管理包括对硬件、软件和人力的使用、综合与协调，以便对网络资源进行监视、测试、配置、分析、评价和控制，这样就能以合理的价格满足网络的一些需求，如实时运行性能，服务质量等。网络管理常简称为网管。含义：网络管理协议简称为网管协议。需要注意的是，并不是网管协议本身来管理网络。网管协议是管理程序和代理程序之间进行通信的规则。模式体现：简单网络管理协议SNMP (Simple Network Management Protocol) 中的管理程序和代理程序按客户–服务器方式工作。管理程序运行 SNMP 客户程序，向某个代理程序发出请求（或命令），代理程序运行 SNMP 服务器程序，返回响应（或执行某个动作）。在网管系统中，往往是一个（或少数几个）客户程序与很多的服务器程序进行交互。基本功能：SNMP 最重要的指导思想就是要尽可能简单。SNMP 的基本功能包括监视网络性能、检测分析网络差错和配置网络设备等。]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络【七】]]></title>
    <url>%2Fposts%2Fc5481d87%2F</url>
    <content type="text"><![CDATA[5.6 TCP 可靠传输的实现5.6.1 以字节为单位的滑动窗口TCP 使用流水线传输和滑动窗口协议实现高效、可靠的传输。TCP 的滑动窗口是以字节为单位的。发送方 A 和接收方 B 分别维持一个发送窗口和一个接收窗口。发送窗口表示：在没有收到确认的情况下，可以连续把窗口内的数据全部发送出去。接收窗口表示：只允许接收落入窗口内的数据。窗口的运行 发送缓存和接收缓存发送方的应用进程把字节流写入 TCP 的发送缓存。接收方的应用进程从 TCP 的接收缓存中读取字节流。发送缓存用来暂时存放：发送应用程序传送给发送方 TCP 准备发送的数据；TCP 已发送出但尚未收到确认的数据。接收缓存用来暂时存放：按序到达的、但尚未被接收应用程序读取的数据；不按序到达的数据。注意第一，A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。第二，TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。第三，TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。但请注意两点：第一，接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网络的资源。。第二，捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。5.6.2 超时重传时间RTO 的选择由于 TCP 的下层是一个互联网环境，IP 数据报所选择的路由变化很大。因而运输层的往返时间 (RTT) 的方差也很大。如果把超时重传时间设置得太短，就会引起很多报文段的不必要的重传，使网络负荷增大。但若把超时重传时间设置得过长，则又使网络的空闲时间增大，降低了传输效率。TCP 采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间 RTT。TCP保留了RTT的一个加权平均往返时间RTTS（这又称为平滑的往返时间）。第一次测量到 RTT 样本时，RTTS 值就取为所测量到的 RTT 样本值。以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTTS：式中，0 ≤ α ＜ 1。若 α 很接近于零，表示 RTT 值更新较慢。若选择 α接近于 1，则表示 RTT 值更新较快。RFC 6298 推荐的 α 值为 1/8，即 0.125。RTO (Retransmission Time-Out) 应略大于上面得出的加权平均往返时间 RTTS 。往返时间 (RTT) 的测量相当复杂TCP 报文段 1 没有收到确认。重传（即报文段 2）后，收到了确认报文段 ACK。如何判定此确认报文段是对原来的报文段 1 的确认，还是对重传的报文段 2 的确认？Karn 算法在计算平均往返时间 RTT 时，只要报文段重传了，就不采用其往返时间样本。这样得出的加权平均平均往返时间 RTTS 和超时重传时间 RTO 就较准确。但是，这又引起新的问题。当报文段的时延突然增大了很多时，在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据 Karn 算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。修正的 Karn 算法报文段每重传一次，就把 RTO 增大一些：5.6.3 选择确认 SACK问题：若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据？答案是可以的。选择确认 SACK (Selective ACK) 就是一种可行的处理方法.RFC 2018 的规定如果要使用选择确认，那么在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”的选项，而双方必须都事先商定好。如果使用选择确认，那么原来首部中的“确认号字段”的用法仍然不变。只是以后在 TCP 报文段的首部中都增加了 SACK 选项，以便报告收到的不连续的字节块的边界。由于首部选项的长度最多只有 40 字节，而指明一个边界就要用掉 4 字节，因此在选项中最多只能指明 4 个字节块的边界信息。5.7 TCP 的流量控制5.7.1利用滑动窗口实现流量控制一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。流量控制 (flow control) 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。可能发生死锁B 向 A 发送了零窗口的报文段后不久，B 的接收缓存又有了一些存储空间。于是 B 向 A 发送了 rwnd = 400 的报文段。但这个报文段在传送过程中丢失了。A 一直等待收到 B 发送的非零窗口的通知，而 B 也一直等待 A 发送的数据。如果没有其他措施，这种互相等待的死锁局面将一直延续下去。为了解决这个问题，TCP 为每一个连接设有一个持续计时器 (persistence timer)。只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。若窗口不是零，则死锁的僵局就可以打破了。5.7.2 必须考虑传输效率糊涂窗口综合症：每次仅发送一个字节或很少几个字节的数据时，有效数据传输效率变得很低的现象。发送方 TCP 每次接收到一字节的数据后就发送。这样，发送一个字节需要形成 41 字节长的 IP 数据报。效率很低。解决方法：使用 Nagle 算法。若发送应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。第一次先发第一个一字节试探。成了再发当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。接收方糊涂窗口综合症当接收方的 TCP 缓冲区已满，接收方会向发送方发送窗口大小为 0 的报文。若此时接收方的应用进程以交互方式每次只读取一个字节，于是接收方又发送窗口大小为一个字节的更新报文，发送方应邀发送一个字节的数据（发送的 IP 数据报是 41 字节长），于是接收窗口又满了，如此循环往复。原因：接收方应用进程消耗数据太慢，例如：每次只读取一个字节。解决方法：让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。5.8 TCP 的拥塞控制5.8.1 拥塞控制的一般原理在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为拥塞 (congestion)。最坏结果：系统崩溃。网络拥塞往往是由许多因素引起的。例如：点缓存的容量太小；链路的容量不足；处理机处理的速率太慢；拥塞本身会进一步加剧拥塞；增加资源能解决拥塞吗？不能。这是因为网络拥塞是一个非常复杂的问题。简单地采用上述做法，在许多情况下，不但不能解决拥塞问题，而且还可能使网络的性能更坏。拥塞控制与流量控制的区别拥塞控制的一般原理属于闭环控制的有以下几种措施：(1) 监测网络系统，以便检测到拥塞在何时、何处发生。(2) 将拥塞发生的信息传送到可采取行动的地方。(3) 调整网络系统的运行以解决出现的问题。主要指标有：由于缺少缓存空间而被丢弃的分组的百分数；平均队列长度；超时重传的分组数；平均分组时延；分组时延的标准差，等等。上述这些指标的上升都标志着拥塞的增长。解决拥塞的两条思路增加网络可用资源；减少用户对资源的需求。5.8.2 TCP 的拥塞控制方法TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。TCP发送方维持一个拥塞窗口 cwnd (Congestion Window)发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。发送窗口大小不仅取决于接收方窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：真正的发送窗口值 = Min (接收方窗口值，拥塞窗口值)控制拥塞窗口的原则：只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。拥塞的判断重传定时器超时：网络已经发生了拥塞。收到三个重复的 ACK：预示网络可能会出现拥塞（实际可能还未发生拥塞）。TCP拥塞控制算法四种拥塞控制算法（ RFC 5681） ：慢开始 (slow-start)拥塞避免 (congestion avoidance)快重传 (fast retransmit)快恢复 (fast recovery)慢开始 (Slow start)目的：用来确定网络的负载能力或拥塞程度。算法的思路：由小到大逐渐增大拥塞窗口数值。两个变量：拥塞窗口初始拥塞窗口值：2 种设置方法。1 至 2 个最大报文段 （旧标准）2 至 4 个最大报文段 （RFC 5681）窗口值逐渐增大。慢开始门限：防止拥塞窗口增长过大引起网络拥塞。拥塞窗口 cwnd 控制方法：在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个 SMSS 的数值。 使用慢开始算法后，每经过一个传输轮次 (transmission round)，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间 RTT。“传输轮次”更加强调：把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。例如，拥塞窗口 cwnd = 4，这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这 4 个报文段的确认，总共经历的时间。设置慢开始门限状态变量 ssthresh慢开始门限 ssthresh 的用法如下：当 cwnd &lt; ssthresh 时，使用慢开始算法。当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。拥塞避免算法思路：让拥塞窗口 cwnd 缓慢地增大，避免出现拥塞。每经过一个传输轮次，拥塞窗口 cwnd = cwnd + 1。使拥塞窗口 cwnd 按线性规律缓慢增长。在拥塞避免阶段，具有 “加法增大” (Additive Increase) 的特点。就是到达一定门槛了，cwnd 原来近似翻倍的指数型增长变为线性增长当网络出现拥塞时无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（重传定时器超时）：ssthresh = max (cwnd/2，2)cwnd = 1执行慢开始算法目的：迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。快重传算法发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。使用快重传可以使整个网络的吞吐量提高约20%。采用快重传 FR (Fast Retransmission) 算法可以让发送方尽早知道发生了个别报文段的丢失。快重传 算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。快恢复算法当发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法 FR (Fast Recovery) 算法：慢开始门限 ssthresh = 当前拥塞窗口 cwnd / 2 ；新拥塞窗口 cwnd = 慢开始门限 ssthresh ；开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。TCP拥塞控制流程图发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个，即应按以下公式确定：发送窗口的上限值 = Min [rwnd, cwnd]当 rwnd &lt; cwnd 时，是接收方的接收能力限制发送窗口的最大值。当 cwnd &lt; rwnd 时，则是网络的拥塞限制发送窗口的最大值。也就是说，rwnd 和 cwnd 中数值较小的一个，控制了发送方发送数据的速率。5.8.3 主动队列管理 AQMTCP 拥塞控制和网络层采取的策略有密切联系。若路由器对某些分组的处理时间特别长，那么这就可能使这些分组中的TCP报文段经过很长时间才能到达终点，结果引起发送方超时，对这些报文段进行重传。重传会使 TCP 连接的发送端认为在网络中发生了拥塞，但实际上网络并没有发生拥塞。对 TCP 拥塞控制影响最大的就是路由器的分组丢弃策略。路由器的队列通常都是按照“先进先出”FIFO (First In First Out) 的规则处理到来的分组。当队列已满时，以后再到达的所有分组（如果能够继续排队，这些分组都将排在队列的尾部）将都被丢弃。这就叫做尾部丢弃策略 (tail-drop policy)。分组丢弃使发送方出现超时重传，使 TCP 连接进入拥塞控制的慢开始状态。在这种情况下，若发生了路由器中的尾部丢弃，就可能会同时影响到很多条 TCP 连接，结果使这许多 TCP 连接在同一时间突然都进入到慢开始状态。这在 TCP 的术语中称为全局同步 (global syncronization)。全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通信量又突然增大很多。1998 年提出了主动队列管理 AQM (Active Queue Management)。所谓“主动”就是不要等到路由器的队列长度已经达到最大值时才不得不丢弃后面到达的分组，而是在队列长度达到某个值得警惕的数值时（即当网络拥塞有了某些拥塞征兆时），就主动丢弃到达的分组。AQM 可以有不同实现方法，其中曾流行多年的就是随机早期检测 RED (Random Early Detection)。随机早期检测 RED (Random Early Detection)。略（见PPT）多年的实践证明，RED 的使用效果并不太理想。2015 年公布的 RFC 7567 已经把 RFC 2309 列为“陈旧的”，并且不再推荐使用 RED。对路由器进行主动队列管理 AQM 仍是必要的。AQM 实际上就是对路由器中的分组排队进行智能管理，而不是简单地把队列的尾部丢弃。现在已经有几种不同的算法来代替旧的 RED，但都还在实验阶段。5.9TCP 的运输连接管理TCP 连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做客户 (client)。被动等待连接建立的应用进程叫做服务器 (server)。5.9.1 TCP 的连接建立TCP 建立连接的过程叫做握手。握手需要在客户和服务器之间交换三个 TCP 报文段。称之为三报文握手。采用三报文握手主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。B的 TCP 服务器进程先创建传输控制块TCB，准备接受客户进程的连接请求。A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。B 的 TCP 收到连接请求报文段后，如同意，则发回确认。B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号 ack = x + 1，自己选择的序号 seq = y。A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1。A 的 TCP 通知上层应用进程，连接已经建立。B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立。5.9.2 TCP 的连接释放TCP 连接释放过程比较复杂。数据传输结束后，通信的双方都可释放连接。TCP 连接释放过程是四报文握手。数据传输结束后，通信的双方都可释放连接。现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的FIN = 1，其序号seq = u，等待 B 的确认。B 发出确认，确认号 ack = u+1，而这个报文段自己的序号 seq = v。TCP 服务器进程通知高层应用进程。从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据，A 仍要接收。若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。A 收到连接释放报文段后，必须发出确认。 在确认报文段中ACK = 1，确认号 ack = w + 1，自己的序号 seq = u + 1。A 必须等待 2MSL 的时间:第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。第二，防止 “已失效的连接请求报文段”出现在本连接中。理解ACK：1确认号生效（所以只有带ACK的图中ack才会显示出来，可人为绑定）ack：是期望收到对方的下一个报文段的数据的第一个字节的序号。seq:序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。无论哪种报文都会带SYN： 同步 SYN = 1 表示这是一个连接请求或连接接受报文。FIN：FIN=1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。保活计时器用来防止在TCP连接出现长时期的空闲。保活计时器 通常设置为2小时 。若服务器过了2小时还没有收到客户的信息，它就发送探测报文段。若发送了10个探测报文段（每一个相隔75秒）还没有响应，就假定客户出了故障，因而就终止该连接。5.9.3 TCP 的有限状态机箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。图中有三种不同的箭头。粗实线箭头表示对客户进程的正常变迁。粗虚线箭头表示对服务器进程的正常变迁。细线箭头表示异常变迁。]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络【六】]]></title>
    <url>%2Fposts%2F17486a18%2F</url>
    <content type="text"><![CDATA[第五章 运输层5.1运输层协议概述5.1.1 进程之间的通信从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。“逻辑通信”的意思是“好像是这样通信，但事实上并非真的这样通信”。从IP层来说，通信的两端是两台主机。但“两台主机之间的通信”这种说法还不够清楚。严格地讲，两台主机进行通信就是两台主机中的应用进程互相通信。从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。也就是说，端到端的通信是应用进程之间的通信。“主机A和主机B进行通信”实际上是指：“运行在主机A上的某个程序和运行在主机B上的另一个程序进行通信”。端到端的通信是进程之间的通信。即“主机 A 的某个进程和主机 B 上的另一个进程进行通信”。简称为“计算机之间通信”。 运输层的重要功能 ——复用和分用在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信。 这表明运输层有一个很重要的功能——复用 (multiplexing)和分用 (demultiplexing)。运输层向高层用户屏蔽了下面网络核心的细节，它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。但这条逻辑通信信道对上层的表现却因运输层使用的不同协议而有很大的差别。当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条不可靠信道。5.1.2 运输层的两个主要协议TCP/IP 的运输层有两个主要协议：用户数据报协议 UDP (User Datagram Protocol)传输控制协议 TCP (Transmission Control Protocol)两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元 TPDU (Transport Protocol Data Unit)。TCP 传送的数据单位协议是 TCP 报文段(segment)。UDP 传送的数据单位协议是 UDP 报文或用户数据报。5.1.3 运输层的端口运行在计算机中的进程是用进程标识符来标志的。但运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。这是因为在互联网上使用的计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符。为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。由于进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程。有时我们会改换接收报文的进程，但并不需要通知所有发送方。我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程。解决这个问题的方法就是在运输层使用协议端口号 (protocol port number)，或通常简称为端口 (port)。虽然通信的终点是应用进程，但我们可以把端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 来完成。网络层中，通信的对象为不同的主机，而从运输层的角度来看，通信的对象为进程，而端口就代表了进程也就是说，通过 ip 找到主机，通过端口找到对应进程端口用一个 16 位端口号进行标志。端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。由此可见，两个计算机中的进程要互相通信，不仅必须知道对方的 IP 地址（为了找到对方的计算机），而且还要知道对方的端口号（为了找到对方计算机中的应用进程）两大类端口 常用的熟知端口5.2用户数据报协议 UDP5.2.1 UDP 概述UDP 只在 IP 的数据报服务之上增加了很少一点的功能：复用和分用的功能、差错检测的功能特点：① UDP 是无连接的，发送数据之前不需要建立连接，，因此减少了开销和发送数据之前的时延。② UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。③ UDP 是面向报文的。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP 一次交付一个完整的报文。④ UDP 没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求。⑤ UDP 支持一对一、一对多、多对一和多对多的交互通信。⑥ UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。UDP 是面向报文的发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。 应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。 应用程序必须选择合适大小的报文。若报文太长，UDP 把它交给 IP 层后，IP 层在传送时可能要进行分片，这会降低 IP 层的效率。若报文太短，UDP 把它交给 IP 层后，会使 IP 数据报的首部的相对长度太大，这也降低了 IP 层的效率。UDP 首部格式用户数据报 UDP 有两个字段：数据字段和首部字段。首部字段有 8 个字节，由 4 个字段组成，每个字段都是 2 个字节。在计算检验和时，临时把 12 字节的“伪首部”和 UDP 用户数据报连接在一起。伪首部仅仅是为了计算检验和。计算之后就丢弃，不纳入真正首部 5.3 传输控制协议 TCP 概述5.3.1 TCP 最主要的特点TCP 是面向连接的运输层协议，在无连接的、不可靠的 IP 网络服务基础之上提供可靠交付的服务。为此，在 IP 的数据报服务基础之上，增加了保证可靠性的一系列措施。TCP 是面向连接的运输层协议。每一条 TCP 连接只能有两个端点 (endpoint)，每一条 TCP 连接只能是点对点的（一对一）。TCP 提供可靠交付的服务。TCP 提供全双工通信。面向字节流面向字节流TCP 中的“流”(stream) 指的是流入或流出进程的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系。 但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。注意TCP 连接是一条虚连接而不是一条真正的物理连接。TCP 对应用进程一次把多长的报文发送到 TCP 的缓存中是不关心的。TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。TCP 可把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去。5.3.2 TCP 的连接TCP 把连接作为最基本的抽象。每一条 TCP 连接有两个端点。TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做套接字 (socket) 或插口。==端口号拼接到 (contatenated with) IP 地址即构成了套接字。==例如：套接字 socket = (192.169.1.20 : 2028)每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：TCP 连接 ::= {socket1, socket2} = {(IP1: port1)，(IP2: port2)}TCP 连接，IP 地址，套接字:TCP 连接就是由协议软件所提供的一种抽象。TCP 连接的端点是个很抽象的套接字，即（IP 地址：端口号）。同一个 IP 地址可以有多个不同的 TCP 连接。同一个端口号也可以出现在多个不同的 TCP 连接中。Socket 有多种不同的意思：应用编程接口 API 称为 socket API, 简称为 socket。socket API 中使用的一个函数名也叫作 socket。调用 socket 函数的端点称为 socket。调用 socket 函数时其返回值称为 socket 描述符，可简称为 socket。在操作系统内核中连网协议的 Berkeley 实现，称为 socket 实现。5.4可靠传输的工作原理理想的传输条件有以下两个特点：传输信道不产生差错。不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。然而实际的网络都不具备以上两个理想条件。必须使用一些可靠传输协议，在不可靠的传输信道实现可靠传输。那么在TCP中就有两种方式来实现可靠传输了停止等待协议连续 ARQ 协议5.4.1停止等待协议“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。全双工通信的双方既是发送方也是接收方。为了讨论问题的方便，我们仅考虑 A 发送数据，而 B 接收数据并发送确认。因此 A 叫做发送方，而 B 叫做接收方。停止等待协议有两种情况：① 无差错情况 、② 出现差错情况① 无差错情况② 出现差错情况在接收方 B 会出现两种情况：B 接收 M1 时检测出了差错，就丢弃 M1，其他什么也不做（不通知 A 收到有差错的分组）。M1 在传输过程中丢失了，这时 B 当然什么都不知道，也什么都不做。在这两种情况下，B 都不会发送任何信息。 但A都必须重发分组，直到B正确接收为止，这样才能实现可靠通信。问题：A如何知道 B 是否正确收到了 M1 呢？ 解决方法：超时重传A 为每一个已发送的分组都设置了一个超时计时器。A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 。若A在超时计时器规定时间内没有收到B的确认，就认为分组错误或丢失，就重发该分组。问题：若分组正确到达B，但B回送的确认丢失或延迟了，A未收到B的确认，会超时重发。B 可能会收到重复的 M1 。B如何知道收到了重复的分组，需要丢弃呢？ 解决方法：编号A为每一个发送的分组都进行编号。若B收到了编号相同的分组，则认为收到了重复分组，丢弃重复的分组，并回送确认。B为发送的确认也进行编号，指示该确认是对哪一个分组的确认。A根据确认及其编号，可以确定它是对哪一个分组的确认，避免重发发送。若为重复的确认，则将其丢弃。超时重传发送的是同一个编号的分组！确认丢失和确认迟到确认丢失若 B 所发送的对 M1 的确认丢失了，那么 A 在设定的超时重传时间内不能收到确认，但 A 并无法知道：是自己发送的分组出错、丢失了，或者 是 B 发送的确认丢失了。因此 A 在超时计时器到期后就要重传 M1。假定 B 又收到了重传的分组 M1。这时 B 应采取两个行动：第一，丢弃这个重复的分组 M1，不向上层交付。第二，向 A 发送确认。不能认为已经发送过确认就不再发送，因为 A 之所以重传 M1 就表示 A 没有收到对 M1 的确认。确认迟到传输过程中没有出现差错，但 B 对分组 M1 的确认迟到了。A 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。B 仍然会收到重复的 M1，并且同样要丢弃重复的 M1，并重传确认分组。注意在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发。分组和确认分组都必须进行编号。超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。自动重传请求 ARQ通常 A 最终总是可以收到对所有发出的分组的确认。如果 A 不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信。使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。像上述的这种可靠传输协议常称为自动重传请求 ARQ (Automatic Repeat reQuest)。意思是重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。总结停止等待协议要点停止等待。发送方每次只发送一个分组。在收到确认后再发送下一个分组。编号。对发送的每个分组和确认都进行编号。自动重传请求。发送方为每个发送的分组设置一个超时计时器。若超时计时器超时，发送方会自动重传分组。简单，但信道利用率太低。重复受到，则丢弃当前重复受到的数据。5.4.2连续 ARQ 协议基本思想：发送方一次可以发出多个分组。使用滑动窗口协议控制发送方和接收方所能发送和接收的分组的数量和编号。每收到一个确认，发送方就把发送窗口向前滑动。接收方一般采用累积确认的方式。采用回退N（Go-Back-N）方法进行重传。①累积确认接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对==按序到达==的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。==注意：是按序到达的最后一个分组！====例如传1 2 3 4 5====收到1 2 4 5 确认的是2不是5！没有确认3之后收到的4和5都会在3超时后被丢弃！(窗口协议中没有明确规定如何处理没按顺序到达的数据，一般是暂存等待)==优点：容易实现，即使确认丢失也不必重传。缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。②Go-back-N（回退 N）如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分组。可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。TCP 可靠通信的具体实现TCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。TCP 两端的四个窗口经常处于动态变化之中。TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。③滑动窗口协议滑动窗口协议比较复杂，是 TCP 协议的精髓所在。发送方维持的发送窗口，它的意义是：位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。 5.5 TCP 报文段的首部格式TCP 虽然是面向字节流的，但 TCP 传送的数据单元却是报文段。一个 TCP 报文段分为首部和数据两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。TCP 报文段首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。源端口和目的端口字段——各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。序号字段——占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。确认号字段——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。数据偏移（即首部长度）——占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。保留字段——占 6 位，保留为今后使用，但目前应置为 0。紧急 URG —— 当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。确认 ACK —— 只有当 ACK =1 时确认号字段才有效。当 ACK =0 时，确认号无效。推送 PSH (PuSH) —— 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。复位 RST (ReSeT) —— 当 RST=1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。同步 SYN —— 同步 SYN = 1 表示这是一个连接请求或连接接受报文。终止 FIN (FINish) —— 用来释放一个连接。FIN=1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。窗口字段 —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。检验和 —— 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。紧急指针字段 —— 占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。选项字段 —— 长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”MSS (Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度。数据字段加上 TCP 首部才等于整个的 TCP 报文段。所以，MSS是“TCP 报文段长度减去 TCP 首部长度”。窗口扩大选项 ——占 3 字节，其中有一个字节表示移位值 S。新的窗口值等于 TCP 首部中的窗口位数增大到 (16 + S)，相当于把窗口值向左移动 S 位后获得实际的窗口大小。时间戳选项——占 10 字节，其中最主要的字段时间戳值字段（4 字节）和时间戳回送回答字段（4 字节）。选择确认选项——在后面的 5.6.3 节介绍。填充字段 —— 这是为了使整个首部长度是 4 字节的整数倍。为什么要规定 MSS ？MSS 与接收窗口值没有关系。若选择较小的 MSS 长度，网络的利用率就降低。若 TCP 报文段非常长，那么在 IP 层传输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数据报片装配成原来的 TCP 报文段。当传输出错时还要进行重传。这些也都会使开销增大。因此，MSS 应尽可能大些，只要在 IP 层传输时不需要再分片就行。但最佳的 MSS 是很难确定的。]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络【五】]]></title>
    <url>%2Fposts%2F724621c1%2F</url>
    <content type="text"><![CDATA[4.4网际控制报文协议 ICMP4.4.1ICMP 报文的种类ICMP是（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。一种面向无连接的协议，用于传输出错报告控制信息，在网络安全方面有广泛应用；ICMP就是一个“错误侦测与回报机制”，其目的就是检测网路的连线状况，确保连线的准确性，其功能如下：侦测远端主机是否存在建立及维护路由资料重导资料传送路径（ICMP重定向）资料流量控制。ICMP在沟通之中，主要是透过不同的类别(Type)与代码(Code) 让机器来识别不同的连线状况为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。ICMP 是互联网的标准协议。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。但 ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议。ICMP 报文的种类有两种，即 ICMP 差错报告报文*和 *ICMP 询问报文ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关ICMP 差错报告报文共有 4 种终点不可达时间超过参数问题改变路由（重定向）(Redirect)根据之前的ICMP报文的格式图。前8个字节是类型、代码、校验和、和取决于类型部分。ICMP的数据部分（长度取决于类型），这里就是ICMP 差错报告报文类型的字节设置。取IP数据报首部+8字节内容。帮助理解。不应发送 ICMP 差错报告报文的几种情况：对 ICMP 差错报告报文不再发送 ICMP 差错报告报文。对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文。对具有多播地址的数据报都不发送 ICMP 差错报告报文。对具有特殊地址（如127.0.0.0 或 0.0.0.0）的数据报不发送 ICMP 差错报告报文。ICMP 询问报文有两种回送请求和回答报文时间戳请求和回答报文下面的几种 ICMP 报文不再使用：信息请求与回答报文掩码地址请求和回答报文路由器询问和通告报文源点抑制报文4.4.2ICMP 的应用举例PING (Packet InterNet Groper)PING 用来测试两个主机之间的连通性。PING 使用了 ICMP 回送请求与回送回答报文。PING 是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或UDP。Traceroute 的应用举例在 Windows 操作系统中这个命令是 tracert。用来跟踪一个分组从源点到终点的路径。它利用 IP 数据报中的 TTL 字段和 ICMP 时间超过差错报告报文实现对从源点到终点的路径的跟踪。4.5互联网的路由选择协议4.5.1有关路由选择协议的几个基本概念理想的路由算法算法必须是正确的和完整的。算法在计算上应简单。算法应能适应通信量和网络拓扑的变化，这就是说，要有自适应性。算法应具有稳定性。算法应是公平的。算法应是最佳的。关于“最佳路由”不存在一种绝对的最佳路由算法。所谓“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。实际的路由选择算法，应尽可能接近于理想的算法。 路由选择是个非常复杂的问题它是网络中的所有结点共同协调工作的结果。路由选择的环境往往是不断变化的，而这种变化有时无法事先知道。从路由算法的自适应性考虑静态路由选择策略——即非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。动态路由选择策略——即自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。分层次的路由选择协议互联网采用分层次的路由选择协议。这是因为：(1) 互联网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会使互联网的通信链路饱和。(2) 许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议（这属于本部门内部的事情），但同时还希望连接到互联网上。自治系统 AS (Autonomous System)自治系统 AS 的定义：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。现在对自治系统 AS 的定义是强调下面的事实：尽管一个 AS 使用了多种内部路由选择协议和度量，但重要的是一个 AS 对其他 AS 表现出的是一个单一的和一致的路由选择策略。互联网有两大类路由选择协议内部网关协议 IGP (Interior Gateway Protocol)在一个自治系统内部使用的路由选择协议。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。外部网关协议 EGP (External Gateway Protocol)若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。在外部网关协议中目前使用最多的是 BGP-4。互联网的早期 RFC 文档中未使用“路由器”而是使用“网关”这一名词。但是在新的 RFC 文档中又使用了“路由器”这一名词。应当把这两个术语当作同义词。IGP 和 EGP 是协议类别的名称。但 RFC 在使用 EGP 这个名词时出现了一点混乱，因为最早的一个外部网关协议的协议名字正好也是 EGP。因此在遇到名词 EGP 时，应弄清它是指旧的协议 EGP 还是指外部网关协议 EGP 这个类别。4.5.2 内部网关协议 RIP路由信息协议 RIP (Routing Information Protocol) 是内部网关协议 IGP 中最先得到广泛使用的协议。RIP 是一种分布式的、基于距离向量的路由选择协议。RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。“距离”的定义从一个路由器到直接连接的网络的距离定义为 1。从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 1。RIP 协议中的“距离”也称为“跳数”(hop count)，因为每经过一个路由器，跳数就加 1。这里的“距离”实际上指的是“最短距离”。RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短”。RIP 允许一条路径最多只能包含 15 个路由器。“距离”的最大值为 16 时即相当于不可达。可见 RIP 只适用于小型互联网。RIP 不能在两个网络之间同时使用多条路由。RIP 选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速(低时延)但路由器较多的路由。RIP 协议的三个特点仅和相邻路由器交换信息。交换的信息是当前本路由器所知道的全部信息，即自己的路由表。按固定的时间间隔交换路由信息，例如，每隔 30 秒。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。路由表的建立路由器在刚刚开始工作时，只知道到直接连接的网络的距离（此距离定义为 1）。它的路由表是空的。以后，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。经过若干次更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。RIP 协议的收敛 (convergence) 过程较快。“收敛”就是在自治系统中所有的结点都得到正确的路由选择信息的过程。距离向量算法RIP 协议让互联网中的所有路由器都和自己的相邻路由器不断交换路由信息，并不断更新其路由表，使得从每一个路由器到每一个目的网络的路由都是最短的（即跳数最少）虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然也应当是不同的 RIP2 协议的报文格式RIP2 报文由首部和路由部分组成。RIP2 报文中的路由部分由若干个路由信息组成。每个路由信息需要用 20 个字节。地址族标识符（又称为地址类别）字段用来标志所使用的地址协议。路由标记填入自治系统的号码，这是考虑使 RIP 有可能收到本自治系统以外的路由选择信息。再后面指出某个网络地址、该网络的子网掩码、下一跳路由器地址以及到此网络的距离。一个 RIP 报文最多可包括 25 个路由，因而 RIP 报文的最大长度是 4+20 x25=504 字节。如超过，必须再用一个 RIP 报文来传送。RIP2 具有简单的鉴别功能。若使用鉴别功能，则将原来写入第一个路由信息（20 个字节）的位置用作鉴别。在鉴别数据之后才写入路由信息，但这时最多只能再放入 24 个路由信息。RIP 协议特点：好消息传播得快，坏消息传播得慢。RIP 存在的一个问题：当网络出现故障时，要经过比较长的时间 (例如数分钟) 才能将此信息传送到所有的路由器。 这就是好消息传播得快，而坏消息传播得慢。网络出故障的传播时间往往需要较长的时间(例如数分钟)。这是 RIP 的一个主要缺点。RIP 协议的优缺点优点：实现简单，开销较小。缺点：RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。“坏消息传播得慢”，使更新过程的收敛时间过长4.5.3内部网关协议 OSPF开放最短路径优先 OSPF (Open Shortest Path First)是为克服 RIP 的缺点在 1989 年开发出来的。OSPF 的原理很简单，但实现起来却较复杂。“开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法 SPF采用分布式的链路状态协议 (link state protocol)。注意：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。三个要点向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。链路状态数据库由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（这称为链路状态数据库的同步）OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表OSPF 的更新过程收敛得快是其重要优点OSPF 的区域为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫做区域每一个区域都有一个 32 位的区域标识符（用点分十进制表示）区域也不能太大，在一个区域内的路由器最好不超过 200 个划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。OSPF 使用层次结构的区域划分。在上层的区域叫做主干区域 (backbone area)。主干区域的标识符规定为0.0.0.0。主干区域的作用是用来连通其他在下层的区域。主干路由器：R3、R4、R5、R6、R7区域边界路由器：R3、R4、R7OSPF 直接用 IP 数据报传送OSPF 不用 UDP 而是直接用 IP 数据报传送OSPF 构成的数据报很短。这样做可减少路由信息的通信量数据报很短的另一好处是可以不必将长的数据报分片传送但分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传OSPF 的其他特点OSPF 对不同的链路可根据 IP 分组的不同服务类型 TOS 而设置成不同的代价。因此，OSPF 对于不同类型的业务可计算出不同的路由。如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫做多路径间的负载平衡。所有在 OSPF 路由器之间交换的分组都具有鉴别的功能。支持可变长度的子网划分和无分类编址 CIDR。每一个链路状态都带上一个 32 位的序号，序号越大状态就越新。OSPF 的五种分组类型类型1，问候 (Hello) 分组。类型2，数据库描述 (Database Description) 分组。类型3，链路状态请求 (Link State Request) 分组。类型4，链路状态更新 (Link State Update) 分组，用洪泛法对全网更新链路状态。类型5，链路状态确认 (Link State Acknowledgment)分组。OSPF 的其他特点OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于 100 ms。指定的路由器多点接入的局域网采用了指定的路由器 (designated router) 的方法，使广播的信息量大大减少。指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。4.5.4 外部网关协议BGPBGP 是不同自治系统的路由器之间交换路由信息的协议BGP 较新版本是 2006 年 1 月发表的 BGP-4（BGP 第 4 个版本），即 RFC 4271 ~ 4278可以将 BGP-4 简写为 BGP互联网的规模太大，使得自治系统之间路由选择非常困难。对于自治系统之间的路由选择，要寻找最佳路由是很不现实的当一条路径通过几个不同 AS 时，要想对这样的路径计算出有意义的代价是不太可能的比较合理的做法是在 AS 之间交换“可达性”信息自治系统之间的路由选择必须考虑有关策略因此，边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由。BGP 发言人每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“ BGP 发言人” (BGP speaker)一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是 BGP 边界路由器，但也可以不是 BGP 边界路由器。BGP 交换路由信息一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 TCP 连接，然后在此连接上交换 BGP 报文以建立 BGP 会话(session)，利用 BGP 会话交换路由信息使用 TCP 连接能提供可靠的服务，也简化了路由选择协议使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的邻站(neighbor)或对等站(peer) BGP-4 共使用四种报文打开 (OPEN) 报文，用来与相邻的另一个BGP发言人建立关系更新 (UPDATE) 报文，用来发送某一路由的信息，以及列出要撤消的多条路由\保活 (KEEPALIVE) 报文，用来确认打开报文和周期性地证实邻站关系通知 (NOTIFICATION) 报文，用来发送检测到的差错三种协议的比较4.5.5 路由器的构成路由器是一种典型的网络层设备。路由器是互联网中的关键设备。路由器的主要作用是：连通不同的网络。选择信息传送的线路。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率，从而让网络系统发挥出更大的效益来。整个的路由器结构可划分为两大部分：路由选择部分分组转发部分路由选择部分也叫做控制部分，其核心构件是路由选择处理机。路由选择处理机的任务是根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表。分组转发部分由三部分组成交换结构 (switching fabric)：又称为交换组织，其作用是根据转发表 (forwarding table) 对分组进行处理。一组输入端口一组输出端口“转发”和“路由选择”的区别“转发”(forwarding) 就是路由器根据转发表将用户的 IP 数据报从合适的端口转发出去。“路由选择”(routing) 则是按照分布式算法，根据从各相邻路由器得到的关于网络拓扑的变化情况，动态地改变所选择的路由。路由表是根据路由选择算法得出的。而转发表是从路由表得出的。在讨论路由选择的原理时，往往不去区分转发表和路由表的区别。输入端口对线路上收到的分组的处理路由器的输入端口里面装有物理层、数据链路层和网络层的处理模块。数据链路层剥去帧首部和尾部后，将分组送到网络层的队列中排队等待处理。这会产生一定的时延。输入端口中的查找和转发功能在路由器的交换功能中是最重要的。输出端口将交换结构传送来的分组发送到线路输出端口里面装有物理层、数据链路层和网络层的处理模块。输出端口从交换结构接收分组，然后把它们发送到路由器外面的线路上。在网络层的处理模块中设有一个缓冲区（队列）。当交换结构传送过来的分组的速率超过输出链路的发送速率时，来不及发送的分组就必须暂时存放在这个队列中。数据链路层处理模块将分组加上链路层的首部和尾部，交给物理层后发送到外部线路。分组丢弃若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因。交换结构交换结构是路由器的关键构件。正是这个交换结构把分组从一个输入端口转移到某个合适的输出端口。实现交换有多种方法。常用交换方法有三种：(1) 通过存储器(2) 通过总线(3) 通过纵横交换结构 4.6 IPv6地址缩写：允许把数字前面的 0 省略。0000 中的前三个 0 省略，写成 1 个 0。一连串连续的零可以为一对冒号所取代。注意：在任一地址中只能使用一次零压缩。4.7 IP 多播4.7.1 IP 多播的基本概念IP 多播 (multicast，以前曾译为组播) 已成为互联网的一个热门课题。目的：更好地支持一对多通信。一对多通信：一个源点发送到许多个终点。例如，实时信息的交付（如新闻、股市行情等），软件更新，交互式会议及其他多媒体通信。 在互联网上进行多播就叫做 IP 多播。互联网范围的多播要靠路由器来实现。能够运行多播协议的路由器称为多播路由器(multicast router)。当然它也可以转发普通的单播IP数据报。IP 多播所传送的分组需要使用多播 IP 地址。在多播数据报的目的地址写入的是多播组的标识符。多播组的标识符就是 IP 地址中的 D 类地址（多播地址）。每一个 D 类地址标志一个多播组。多播地址只能用于目的地址，不能用于源地址。多播数据报和一般的 IP 数据报的区别就是它使用 D 类 IP 地址作为目的地址，并且首部中的协议字段值是 2，表明使用网际组管理协议 IGMP。多播数据报也是“尽最大努力交付”，不保证一定能够交付多播组内的所有成员。对多播数据报不产生 ICMP 差错报文。因此，若在 PING 命令后面键入多播地址，将永远不会收到响应。4.7.2 在局域网上进行硬件多播*D 类 IP 地址与以太网多播地址的映射关系 *互联网号码指派管理局 IANA 拥有的以太网地址块的高 24 位为 00-00-5E。因此 TCP/IP 协议使用的以太网地址块的范围是​ 从 00-00-5E-00-00-00​ 到 00-00-5E-FF-FF-FF不难看出，在每一个地址中，只有23位可用作多播。D 类 IP 地址可供分配的有 28 位，在这 28 位中的前 5 位不能用来构成以太网硬件地址。由于多播 IP 地址与以太网硬件地址的映射关系不是唯一的，因此收到多播数据报的主机，还要在 IP 层利用软件进行过滤，把不是本主机要接收的数据报丢弃。4.7.3 网际组管理协议 IGMP 和多播路由选择协议为了使路由器知道多播组成员的信息，需要利用网际组管理协议 IGMP (Internet Group Management Protocol)。连接在局域网上的多播路由器还必须和互联网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员。这就需要使用多播路由选择协议。IGMP 的使用范围IGMP 并非在互联网范围内对所有多播组成员进行管理的协议。IGMP 不知道 IP 多播组包含的成员数，也不知道这些成员都分布在哪些网络上。IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机（严格讲，是主机上的某个进程）参加或退出了某个多播组。多播路由选择协议更为复杂多播转发必须动态地适应多播组成员的变化（这时网络拓扑并未发生变化）。请注意，单播路由选择通常是在网络拓扑发生变化时才需要更新路由。多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地址，而是还要考虑这个多播数据报从什么地方来和要到什么地方去。多播数据报可以由没有加入多播组的主机发出，也可以通过没有组成员接入的网络。IGMP 是整个网际协议 IP 的一个组成部分和 ICMP 相似，IGMP 使用 IP 数据报传递其报文（即 IGMP 报文加上 IP 首部构成 IP 数据报），但它也向 IP 提供服务。因此，我们不把 IGMP 看成是一个单独的协议，而是属于整个网际协议 IP 的一个组成部分。IGMP 工作：略IGMP 采用的一些具体措施：略多播路由选择多播路由选择协议尚未标准化。一个多播组中的成员是动态变化的，随时会有主机加入或离开这个多播组。多播路由选择实际上就是要找出以源主机为根结点的多播转发树。在多播转发树上的路由器不会收到重复的多播数据报。对不同的多播组对应于不同的多播转发树。同一个多播组，对不同的源点也会有不同的多播转发树。多播路由选择协议在转发多播数据报时使用三种方法：(1) 洪泛与剪除(2) 隧道技术 (tunneling)(3) 基于核心的发现技术洪泛与剪除这种方法适合于较小的多播组，而所有的组成员接入的局域网也是相邻接的。一开始，路由器转发多播数据报使用洪泛的方法（这就是广播）。为了避免兜圈子，采用了叫做反向路径广播 RPB (Reverse Path Broadcasting) 的策略。RPB 的要点路由器收到多播数据报时，先检查它是否是从源点经最短路径传送来的。若是，就向所有其他方向转发刚才收到的多播数据报（但进入的方向除外），否则就丢弃而不转发。如果存在几条同样长度的最短路径，那么只能选择一条最短路径，选择的准则就是看这几条最短路径中的相邻路由器谁的 IP 地址最小。最后就得出了用来转发多播数据报的多播转发树，以后就按这个多播转发树转发多播数据报。避免了多播数据报的兜圈子，同时每一个路由器也不会接收重复的多播数据报。如果在多播转发树上的某个路由器发现它的下游树枝（即叶节点方向）已没有该多播组的成员，就应把它和下游的树枝一起剪除。当某个树枝有新增加的组成员时，可以再接入到多播转发树上。*隧道技术 (tunneling) *其实就是把多播数据转为单播数据直接传过去基于核心的发现技术这种方法对于多播组的大小在较大范围内变化时都适合。这种方法是对每一个多播组 G 指定一个核心(core) 路由器，给出它的 IP 单播地址。核心路由器按照前面讲过的方法创建出对应于多播组 G 的转发树。4.8虚拟专用网 VPN 和网络地址转换 NAT4.8.1 虚拟专用网 VPN由于 IP 地址的紧缺，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。考虑到互联网并不很安全，一个机构内也并不需要把所有的主机接入到外部的互联网。假定在一个机构内部的计算机通信也是采用 TCP/IP 协议，那么从原则上讲，对于这些仅在机构内部使用的计算机就可以由本机构自行分配其 IP 地址。本地地址——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。全球地址——全球唯一的 IP 地址，必须向互联网的管理机构申请。问题：在内部使用的本地地址就有可能和互联网中某个 IP 地址重合，这样就会出现地址的二义性问题。解决：RFC 1918 指明了一些专用地址 (private address)。专用地址只能用作本地地址而不能用作全球地址。在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发。采用这样的专用 IP 地址的互连网络称为专用互联网或本地互联网，或更简单些，就叫做专用网。因为这些专用地址仅在本机构内部使用。专用IP地址也叫做可重用地址 (reusable address)。利用公用的互联网作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网VPN (Virtual Private Network)。“专用网”是因为这种网络是为本机构的主机用于机构内部的通信，而不是用于和网络外非本机构的主机通信。“虚拟”表示“好像是”，但实际上并不是，因为现在并没有真正使用通信专线，而VPN只是在效果上和真正的专用网一样。如果专用网不同网点之间的通信必须经过公用的互联网，但又有保密的要求，那么所有通过互联网传送的数据都必须加密。一个机构要构建自己的 VPN 就必须为它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的 VPN 系统都知道其他场所的地址。 远程接入 VPN (remote access VPN)可以满足外部流动员工访问公司网络的需求。在外地工作的员工拨号接入互联网，而驻留在员工 PC 机中的 VPN 软件可在员工的 PC 机和公司的主机之间建立 VPN 隧道，因而外地员工与公司通信的内容是保密的，员工们感到好像就是使用公司内部的本地网络。4.8.2 网络地址转换 NAT问题：在专用网上使用专用地址的主机如何与互联网上的主机通信（并不需要加密）？解决：再申请一些全球 IP 地址。但这在很多情况下是不容易做到的。采用网络地址转换 NAT。这是目前使用得最多的方法。网络地址转换 NAT (Network Address Translation) 方法于1994年提出。需要在专用网连接到互联网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT路由器，它至少有一个有效的外部全球IP地址。所有使用本地地址的主机在和外界通信时，都要在 NAT 路由器上将其本地地址转换成全球 IP 地址，才能和互联网连接。PS：这才是我们家用路由器的真正内容。家用的是“虚假的路由器”，其实就是给你收发数据套上全球IP地址接入互联网。当 NAT 路由器具有 n 个全球 IP 地址时，专用网内最多可以同时有 n 台主机接入到互联网。这样就可以使专用网内较多数量的主机，轮流使用 NAT 路由器有限数量的全球 IP 地址。通过 NAT 路由器的通信必须由专用网内的主机发起。专用网内部的主机不能充当服务器用，因为互联网上的客户无法请求专用网内的服务器提供服务。为了更加有效地利用 NAT 路由器上的全球IP地址，现在常用的 NAT 转换表把运输层的端口号也利用上。这样，就可以使多个拥有本地地址的主机，共用一个 NAT 路由器上的全球 IP 地址，因而可以同时和互联网上的不同主机进行通信。使用端口号的 NAT 叫做网络地址与端口号转换NAPT (Network Address and Port Translation)，而不使用端口号的 NAT 就叫做传统的 NAT (traditional NAT)。4.9 多协议标记交换 MPLSIETF于1997年成立了 MPLS 工作组，开发出一种新的协议——多协议标记交换 MPLS (MultiProtocol Label Switching)。“多协议”表示在 MPLS 的上层可以采用多种协议，例如：IP，IPX；可以使用多种数据链路层协议，例如：PPP，以太网，ATM 等。“标记”是指每个分组被打上一个标记，根据该标记对分组进行转发。]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络【四】]]></title>
    <url>%2Fposts%2F1dd8e486%2F</url>
    <content type="text"><![CDATA[第四章 网络层4.1网络层提供的两种服务在计算机网络领域，网络层应该向运输层提供怎样的服务（“面向连接”还是“无连接”）曾引起了长期的争论。 争论焦点的实质就是：在计算机通信中，可靠交付应当由谁来负责？是网络还是端系统？4.1.1让网络负责可靠交付这种观点认为，应借助于电信网的成功经验，让网络负责可靠交付，计算机网络应模仿电信网络，使用面向连接的通信方式通信之前先建立虚电路 (Virtual Circuit)，以保证双方通信所需的一切网络资源如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点，不丢失、不重复补充：虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接请注意，电路交换的电话通信是先建立了一条真正的连接因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样4.2.2网络提供数据报服务互联网的先驱者提出了一种崭新的网络设计思路网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务网络在发送分组时不需要先建立连接每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）网络层不提供服务质量的承诺即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限补充：由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责可靠交付（包括差错处理、流量控制等）采用这种设计思路的好处是：网络的造价大大降低，运行方式灵活，能够适应多种应用4.2网际协议 IP4.2.1几大协议网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一与 IP 协议配套使用的还有三个协议：地址解析协议 ARP (Address Resolution Protocol)网际控制报文协议 ICMP (Internet Control Message Protocol)网际组管理协议 IGMP (Internet Group Management Protocol)4.2.2虚拟互连网络将网络互连并能够互相通信，会遇到许多问题需要解决，如：不同的寻址方案不同的最大分组长度不同的网络接入机制不同的超时控制不同的差错恢复方法不同的状态报告方法不同的路由选择技术不同的用户接入控制不同的服务（面向连接服务和无连接服务）不同的管理与控制方式等如何将异构的网络互相连接起来？各层连接需要的中转设备将网络互相连接起来要使用一些中间设备。 中间设备又称为中间系统或中继 (relay)系统。有以下五种不同的中间设备：物理层中继系统：转发器 (repeater)数据链路层中继系统：网桥 或 桥接器 (bridge)网络层中继系统：路由器 (router)网桥和路由器的混合物：桥路器 (brouter)网络层以上的中继系统：网关 (gateway)网关 (gateway)（可以理解为离主机最近的路由器）补充：当中继系统是转发器或网桥时，一般并不称之为网络互连，因为这仅仅是把一个网络扩大了，而这仍然是一个网络。（可理解为仍然是一个局域网，不是两个网的互联）网关由于比较复杂，目前使用得较少。网络互连都是指用路由器进行网络互连和路由选择。由于历史的原因，许多有关 TCP/IP 的文献将网络层使用的路由器称为网关。互连网络与虚拟互连网络谓虚拟互连网络也就是逻辑互连网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络从用户看起来好像是一个统一的网络。使用 IP 协议的虚拟互连网络可简称为 IP 网。使用虚拟互连网络的好处是：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体的网络异构细节。如果在这种覆盖全球的 IP 网的上层使用 TCP 协议，那么就是现在的互联网 (Internet)。如果我们只从网络层考虑问题，那么 IP 数据报就可以想象是在网络层中传送。==直接交付 :==直接交付时,分组的终点是一台与交付者链接在同一个网络上的主机.直接交付在生在两种情况下:(1)分组的元电荷终点在同一个物理网络上.(2)最后一个路由器与目的主机之间的交付. 发送方很容易判断交付是否是直接的.发送方可以提取终点的网络地址(通过掩码),然后与自己所连接的网络地址相比较.如果是同一个Uli网络,交付就是直接的.==间接交付==如果目的主机与交付者不在同一个网络上,分组就间接的交付.在间接交付时,分组经过了一个有一个路由器,最后到达与终点链接在同一个网络上的路由器.间接交付时,发送方通过分组的目的IP地址和路由表来查找该分组应当被交付的下一个路由器的IP地址,然后发送方再通过ARP协议找出下一个路由器的物理地址.直接交付是在终点的IP地址和终点的物理地址之间进行的地址映射,而间接交付是在下一个路由器的IP地址和下一个路由器的物理地址之间的地址映射.交付总是包括一个直接交付以及零个以上的间接交付,而且最后的交付总是直接交付.4.2.3分类的 IP 地址我们把整个互联网看成为一个单一的、抽象的网络。IP 地址就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符。IP 地址现在由互联网名字和数字分配机构ICANN (Internet Corporation for Assigned Names and Numbers)进行分配。IP 地址的编址方法分类的 IP 地址。这是最基本的编址方法，在1981年就通过了相应的标准协议。子网的划分。这是对最基本的编址方法的改进，其标准[RFC 950]在1985年通过。构成超网。这是比较新的无分类编址方法。1993年提出后很快就得到推广应用。分类 IP 地址将IP地址划分为若干个固定类每一类地址都由两个固定长度的字段组成，其中一个字段是网络号 net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号 host-id，它标志该主机（或路由器）主机号在它前面的网络号所指明的网络范围内必须是唯一的由此可见，一个 IP 地址在整个互联网范围内是唯一的 点分十进制记法==就是二进制转十进制，很简单==IP地址的指派范围ip地址有5种A类：1.0.0.0~126.255.255.255==二进制0开头====十进制1~126==B类：128.0.0.0~191.255.255.255==二进制10开头====十进制128~191==C类：192.0.0.0~223.255.255.255==二进制110开头====十进制192~223==D类：224.0.0.0~239.255.255.255==二进制1110开头====十进制224~239==E类：240.0.0.0~254.255.255.255==二进制1111开头====十进制239~254==其中127.0.0.0~127.255.255.255用于环回测试，D类地址用于组播，E类地址用于科研私有地址（可理解为一个网络内部使用，多个网络内部都能使用，不冲突的，因为不和外界网络交流，例如学校学院内网）A类10.0.0.0/8：10.0.0.0~10.255.255.255B类172.16.0.0/12：172.16.0.0~172.31.255.255C类192.168.0.0/16：192.168.0.0~192.168.255.255==记忆：====二进制：0开头，四个1结尾，中间都是0前面挨个增加一个1，然后对应ABCDE====十进制：128、192、224、239记住四个临界点，很容易判断出5个区间，ABCDE(只不过要注意A的0和127不能用)== 王道中关于那两个减1：192.0和224.0不认为是可分配的。有关B类和C类第一个可用网络号的问题==为什么A类最大可指派的网络数要减2（本来不应该是0~127吗问什么变成了1-126）？==网络段全0的IP地址是个保留地址，指“本网络”网络字号为127（01111111）保留作为本地软件的环回测试若主机发送一个目的地址为环回地址的IP数据报，则本主机中的协议软件就会处理数据报中的数据，不会发送到任何网络。（大家的测试数据要是都发，那网络得多拥挤啊？且没啥用浪费资源）换种说法：网络号为127的地址根本不是一个网络地址，它不会出现在任何网络上==为什么B、C类最大可指派的网络数不用减2？==因为该类的网络类别本身前缀就保证了不可能是全0或者全1==为什么最大主机数要减2？==主机段全0代表本网络，主机段全1代表本网络上的所有主机例如：IP地址为5.6.7.8所在的网络地址就是5.0.0.0128.7.255.255表示在网络128.7.0.0上的所有主机0.0.0.35则表示“在这个网络上主机号为35的主机”==注意网络段的全0全1和主机段的全0全1的区别！！== IP 地址的一些重要特点(1) IP 地址是一种分等级的地址结构。分两个等级的好处是：第一，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理第二，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间(2) 实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为多归属主机 (multihomed host)由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此一个路由器至少应当有两个不同的 IP 地址。(3) 用转发器或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号 net-id(4) 所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的4.2.4IP 地址与硬件地址IP 地址与硬件地址是不同的地址。从层次的角度看，硬件地址（或物理地址）是数据链路层和物理层使用的地址。IP 地址是网络层和以上各层使用的地址，是一种逻辑地址（称 IP 地址是逻辑地址是因为 IP 地址是用软件实现的）。==注意：MAC地址在IP地址外==在 IP 层抽象的互联网上只能看到 IP 数据报。图中的 IP1 → IP2 表示从源地址 IP1 到目的地址 IP2 。两个路由器的 IP 地址并不出现在 IP 数据报的首部中。 *路由器只根据目的站的 IP 地址的网络号进行路由选择。 在具体的物理网络的链路层只能看见 MAC 帧而看不见 IP 数据报 *IP 层抽象的互联网屏蔽了下层很复杂的细节。在抽象的网络层上讨论问题，就能够使用统一的、抽象的 IP 地址研究主机和主机或主机和路由器之间的通信 。 4.2.5地址解析协议 ARP(1) 什么是 ARP通信时使用了两个地址：IP 地址（网络层地址）MAC 地址（数据链路层地址）已经知道了一个机器（主机或路由器）的IP地址，如何找出其相应的硬件地址？地址解析协议 ARP 就是用来解决这样的问题的。ARP 作用：从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址。(2) 解析的过程不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。 每一个主机都设有一个 ARP 高速缓存 (ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表解析的过程：当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。如没有， ARP 进程在本局域网上广播发送一个 ARP 请求分组。收到 ARP 响应分组后，将得到的 IP 地址到硬件地址的映射写入 ARP 高速缓存。补充：ARP请求分组：包含发送方硬件地址 / 发送方 IP 地址 / 目标方硬件地址(未知时填 0) / 目标方 IP 地址本地广播 ARP 请求（路由器不转发ARP请求）ARP 响应分组：包含发送方硬件地址 / 发送方 IP地址 / 目标方硬件地址 / 目标方 IP 地址ARP 分组封装在物理网络的帧中传输(3) ARP 高速缓存的作用存放最近获得的 IP 地址到 MAC 地址的绑定，以减少 ARP 广播的数量为了减少网络上的通信量，主机 A 在发送其 ARP 请求分组时，就将自己的 IP 地址到硬件地址的映射写入 ARP 请求分组当主机 B 收到 A 的 ARP 请求分组时，就将主机 A 的这一地址映射写入主机 B 自己的 ARP 高速缓存中。这对主机 B 以后向 A 发送数据报时就更方便了(4) 应该注意的问题ARP 用于解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做从 IP 地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址(5) 使用 ARP 的四种典型情况发送方是主机，要把 IP 数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上另一个路由器的硬件地址。剩下的工作由这个路由器来完成==总之：下一个目的是本网络主机，则是主机MAC，下一个目的是另一个网络的主机，则是路由器的MAC==(6)不直接使用硬件地址进行通信由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此几乎是不可能的事IP 编址把这个复杂问题解决了。连接到互联网的主机只需各自拥有一个唯一的 IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便，因为上述的调用 ARP 的复杂过程都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的因此，在虚拟的 IP 网络上用 IP 地址进行通信给广大的计算机用户带来了很大的方便4.2.6IP 数据报的格式一个 IP 数据报由首部和数据两部分组成首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的在首部的固定部分的后面是一些可选字段，其长度是可变的(1) 固定部分(20 字节)版本——占 4 位，指 IP 协议的版本。目前的 IP 协议版本号为 4 (即 IPv4)首部长度——占 4 位，可表示的最大数值是 15 个单位(==一个单位为 4 字节==)，因此 IP 的首部长度的最大值是 60 字节==因为具有可变部分，所以为了告诉及其，真正的数据再哪儿，需要告诉首部有多长==区分服务——占 8 位，用来获得更好的服务。 在旧标准中叫做服务类型，但实际上一直未被使用过。 1998 年这个字段改名为区分服务。 只有在使用区分服务（DiffServ）时，这个字段才起作用。 在一般的情况下都不使用这个字段总长度——占 16 位，指首部和数据之和的长度，==单位为字节==，因此数据报的最大长度为 65535 字节。==总长度必须不超过最大传送单元 MTU。==标识(identification) ——占 16 位，它是一个计数器，用来产生 IP 数据报的标识。==加入一个报文太长，需要分片，我们需要标识那些是一个报文，值得注意的是，同样标识就代表是同一个报文的切片（至于顺序，由标志+片偏移配合描述）==标志(flag) ——占 3 位，==目前只有前两位有意义。标志字段的最低位是 MF (More Fragment)。MF = 1 表示后面“还有分片”。MF = 0 表示最后一个分片。标志字段中间的一位是 DF (Don’t Fragment) 。只有当 DF = 0 时才允许分片。==片偏移—— 占13 位，==指出：较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。====所以，计算片偏移，需要原数据报分片后，第一个字节数/8==生存时间——占8 位，记为 TTL (Time To Live)，指示数据报在网络中可通过的路由器数的最大值。==防止一些数据，不停地再网络中兜圈子，占用资源==协议——占8 位，指出此数据报携带的数据使用何种协议，以便目的主机的 IP 层将数据部分上交给那个处理过程首部检验和——占16 位，只检验数据报的首部，不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。从中可以看出，就是把首部，每十六个位进行反码算术运算求和再取反（这里的检验和置0），存到部检验和——占16 位发送出去，接受的时候也把首部每16位进行反码算术运算求和（这里的检验和字段就是之前计算过的数据），再取反，若为0则保留，否则丢弃。不过几乎不会考，太麻烦了。源地址和目的地址都各占 4 字节(2) 可变部分IP 首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施，内容很丰富选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目增加首部的可变部分是为了增加IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销实际上这些选项很少被使用【例4-1】 IP 数据报分片一数据报的总长度为 3820 字节，其数据部分的长度为 3800 字节（使用固定首部），需要分片为长度不超过 1420 字节的数据报片。因固定首部长度为 20 字节，因此每个数据报片的数据部分长度不能超过 1400 字节。于是分为 3 个数据报片，其数据部分的长度分别为 1400、1400 和 1000 字节。原始数据报首部被复制为各数据报片的首部，==但必须修改有关字段的值。== ==仔细理解MAC帧、IP数据报之间的关系！====数据部分+20字节固定（+可变部分）=MAC帧的数据部分====而根据MAC帧，我们知道最大不能超过1500字节，所以，数据部分+20字节固定（+可变部分）≤1500字节==4.2.7IP 层转发分组的流程分组转发是指在互联网络中路由器转发IP分组的物理传输过程与数据报转发机制。根据分组的目的IP地址与源IP地址是否属于同一个子网可分为直接转发和间接转发。大多数计算机网络都不能连续地传送任意长的数据，所以实际上网络系统把数据分割成小块，然后逐块地发送，这种小块就称作分组（packet）。也有些书籍把分组定义为网络层的协议数据单元。==直接交付 :==直接交付时,分组的终点是一台与交付者链接在同一个网络上的主机.直接交付在生在两种情况下:(1)分组的元电荷终点在同一个物理网络上.(2)最后一个路由器与目的主机之间的交付.发送方很容易判断交付是否是直接的.发送方可以提取终点的网络地址(通过掩码),然后与自己所连接的网络地址相比较.如果是同一个Uli网络,交付就是直接的.==间接交付==如果目的主机与交付者不在同一个网络上,分组就间接的交付.在间接交付时,分组经过了一个又一个路由器,最后到达与终点链接在同一个网络上的路由器.间接交付时,发送方通过分组的目的IP地址和路由表来查找该分组应当被交付的下一个路由器的IP地址,然后发送方再通过ARP协议找出下一个路由器的物理地址.直接交付是在终点的IP地址和终点的物理地址之间进行的地址映射,而间接交付是在下一个路由器的IP地址和下一个路由器的物理地址之间的地址映射.交付总是包括一个直接交付以及零个以上的间接交付,而且最后的交付总是直接交付.(1)路由在路由表中，对每一条路由，最主要的是（目的网络地址，下一跳地址）因为这样才能通过目的网络地址选择向哪儿转发。假设：有四个 A 类网络通过三个路由器连接在一起。每一个网络上都可能有成千上万个主机。可以想象，若按目的主机号来制作路由表，每一个路由表就有 4 万个项目，即 4 万行（每一行对应于一台主机），则所得出的路由表就会过于庞大。但若按主机所在的网络地址来制作路由表，那么每一个路由器中的路由表就只包含 4 个项目（每一行对应于一个网络），这样就可使路由表大大简化。个人理解：==一个网络可以链接多个路由器====一个路由器可以链接多个网络（一个路由器可以有多个IP地址，(其实主机也能)）====例如：R1的出口20.0.0.7和R2的出口20.0.0.9（接口0）都在网络20.0.0.0中==接口0出去，是直接交付，APR协议找出目的主机的物理地址，发出去。而发送给路由器，除了查路由表找到路由的IP地址，还需要APR协议找出该路由器的物理地址，再发给路由器。==注：一个路由器可以有多个IP地址，路由器的一个接口就能有一个IP地址。==查找路由表根据目的网络地址就能确定下一跳路由器，这样做的结果是：IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）。只有到达最后一个路由器时，才试图向目的主机进行直接交付。特定主机路由虽然互联网所有的分组转发都是基于目的主机所在的网络，但在大多数情况下都允许有这样的特例，即为特定的目的主机指明一个路由。采用特定主机路由可使网络管理人员能更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。默认路由 (default route)路由器还可采用默认路由以减少路由表所占用的空间和搜索路由表所用的时间。这种转发方式在一个网络只有很少的对外连接时是很有用的。默认路由在主机发送 IP 数据报时往往更能显示出它的好处。如果一个主机连接在一个小网络上，而这个网络只用一个路由器和互联网连接，那么在这种情况下使用默认路由是非常合适的。(2)关于路由表路由表没有给分组指明到某个网络的完整路径。路由表指出，到某个网络应当先到某个路由器（即下一跳路由器）。在到达下一跳路由器后，再继续查找其路由表，知道再下一步应当到哪一个路由器。这样一步一步地查找下去，直到最后到达目的网络。(3)一些强调IP 数据报的首部中没有地方可以用来指明“下一跳路由器的 IP 地址”。当路由器收到待转发的数据报，不是将下一跳路由器的 IP 地址填入 IP 数据报，而是送交下层的网络接口软件。网络接口软件使用 ARP 负责将下一跳路由器的 IP 地址转换成硬件地址，并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。==值得注意的是，上述介绍说明了，IP数据报本身是保持不变的，转发是通过MAC来做到的，也就是数据链路层（个人认为）==(4)路由器分组转发算法从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行 (3)。若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行 (4)。特定主机路由:这种路由是为特定的目的主机指明一个路由。之前介绍过。若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行 (5)。若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行 (6)。报告转发分组出错。==可看出，优先级：本网络就是目的&gt;特定主机路由&gt;到达目的主机所在网络的路由&gt;默认路由==4.3划分子网和构造超网4.3.1从两级 IP 地址到三级 IP 地址在 ARPANET 的早期，IP 地址的设计确实不够合理：(1) IP 地址空间的利用率有时很低。(2) 给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。(3) 两级的 IP 地址不够灵活。想申请个网络，但是考虑以后发展C类太少，A类B类太多，怎么办？你有急事，想现在就用上一个网络，怎么办？从 1985 年起在 IP 地址中又增加了一个“子网号字段”，使两级的 IP 地址变成为三级的 IP 地址。 这种做法叫做划分子网 (subnetting) 。 划分子网已成为互联网的正式标准协议。(1)划分子网的基本思路划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。从主机号借用若干个位作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个位。IP地址 ::= {&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;}凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号 net-id，先找到连接在本单位网络上的路由器。然后此路由器在收到 IP 数据报后，再按目的网络号 net-id 和子网号 subnet-id 找到目的子网。最后就将 IP 数据报直接交付目的主机。 充分体现：划分子网纯属一个单位内部的事情，对外部网络透明，对外仍然表现为没有划分子网的一个网络。(2)子网掩码从一个 IP 数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分。使用子网掩码 (subnet mask) 可以找出 IP 地址中的子网部分。子网掩码是一个网络或一个子网的重要属性。路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。规则：子网掩码长度 ＝ 32 位子网掩码左边部分的一连串 1，对应于网络号和子网号子网掩码右边部分的一连串 0，对应于主机号==(IP 地址) AND (子网掩码) =网络地址====注意AND运算特性：====遇到1不变，遇到0变0。==再看子网掩码：从某位，左侧全是1右侧全是0。通过可网络地址的and运算，主机号段变成0代表本网络，其它位不变，直接说明是那个子网！对于A、B、C类网络的默认子网掩码：(3)子网掩码的划分方法有固定长度子网和变长子网两种子网划分方法。在采用固定长度子网时，所划分的所有子网的子网掩码都是相同的。虽然根据已成为互联网标准协议的 RFC 950 文档，子网号不能为全 1 或全 0，但随着无分类域间路由选择 CIDR 的广泛使用，现在全 1 和全 0 的子网号也可以使用了，但一定要谨慎使用，确认你的路由器所用的路由选择软件是否支持全 0 或全 1 的子网号这种较新的用法。划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。为什么表中的“子网号的位数”中没有 0, 1, 15 和 16 这四种情况，因为这没有意义？当子网号位数为0时： 相当于没有划分子网。当子网号位数为16时：相当于主机所占位数全部用于划分子网，只有子网号，却没有主机号了。（即每个子网中的有效主机数为0）当子网号位数为15时：相当于主机号剩余一位，即有两种取值（0,1）。当取值为0时，实际为该子网的网络地址，取值为1时实际为该子网的广播地址。这两个取值都不能作为有效的主机号标识，所以也没有意义。当子网号位数为1时：相当于子网号位一位，即有两种取值（0,1）。这两个取值也就是含子网号全0全1与父网络网络地址和广播地址重名冲突的两种情况（对路由器来说具有二义性，会发生错误）。选定的子网掩码将创建多少个子网?2^x^个，其中x是子网掩码借用的主机位数。每个子网可包含多少台主机?2^y^-2台，其中y是没被借用的主机位的位数。（就是子网掩码二进制下0位数）-2是因为，主机位全为0的部分是这个子网的网段号（Net_id），全为1的部分是这个网段的广播地址。==但是要注意：随着无分类域间路由选择CIDR的广泛使用，是可以让子网号全为1或者全为0的，这样就不用减2了。但一定要谨慎使用，要弄清你的路由器所用的路由选择软件是否支持全0或全1的子网号这种较新的用法。== ==不规则子网划分的方法总结（个人经验）：====从大到小划分。====先找主机数，确定主机号、网络号的数量。====根据网络号的数量选择没有用过的网络号码。（注意选择前缀）====网络号从从最小那个位置开始改变确认网络号==树状图？我没试过。4.3.2使用子网时分组的转发在不划分子网的两级 IP 地址下，从 IP 地址得出网络地址是个很简单的事但在划分子网的情况下，从 IP 地址却不能唯一地得出网络地址来，这是因为网络地址取决于那个网络所采用的子网掩码，但数据报的首部并没有提供子网掩码的信息因此分组转发的算法也必须做相应的改动(1) 从收到的分组的首部提取目的 IP 地址 D(2) 先用各网络的子网掩码和 D 逐位相“与”，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行 (3)(3) 若路由表中有目的地址为 D 的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行(4) 对路由表中的每一行，将子网掩码和 D 逐位相“与”。若结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行 (5)(5) 若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器；否则，执行 (6)(6) 报告转发分组出错 ==注：====首先目的地址和路由器直接相连的网络的子网掩码计算，看看目的地址是不是在直连网络，若是则直接交付。否则交给路由器。====按照特定主机路由、普通路由、默认路由的优先级，依次检查。====检查就是用目的地址和相应子网掩码计算，和前面的目的网络地址比较，一致则交付给该路由器。==4.3.3 无分类编址 CIDRCIDR划分子网在一定程度上缓解了互联网在发展中遇到的困难。然而在 1992 年互联网仍然面临三个必须尽早解决的问题：B 类地址在 1992 年已分配了近一半，眼看就要在 1994 年 3 月全部分配完毕！互联网主干网上的路由表中的项目数急剧增长（从几千个增长到几万个）。整个 IPv4 的地址空间最终将全部耗尽。CIDR干了什么：CIDR消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。CIDR使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号。IP 地址从三级编址（使用子网掩码）又回到了两级编址。IP地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;}CIDR 使用“斜线记法”(slash notation)，它又称为 CIDR 记法，即在 IP 地址面加上一个斜线“/”，然后写上网络前缀所占的位数（这个数值对应于三级编址中子网掩码中 1 的个数）。例如： 220.78.168.0/24CIDR 把网络前缀都相同的连续的 IP 地址组成“CIDR 地址块”。 128.14.32.0/20 表示的地址块共有 2^12^个地址（因为斜线后面的 20 是网络前缀的位数，所以这个地址的主机号是 12 位）这个地址块的起始地址是 128.14.32.0在不需要指出地址块的起始地址时，也可将这样的地址块简称为“/20 地址块”128.14.32.0/20 地址块的最小地址：128.14.32.0128.14.32.0/20 地址块的最大地址：128.14.47.255全 0 和全 1 的主机号地址一般不使用路由聚合一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由路由聚合有利于减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能路由聚合也称为构成超网 (supernetting)CIDR 虽然不使用子网了，但仍然使用“掩码”这一名词（但不叫子网掩码）对于 /20 地址块，它的掩码是 20 个连续的 1。 斜线记法中的数字就是掩码中1的个数。CIDR 记法的其他形式10.0.0.0/10 可简写为 10/10，也就是把点分十进制中低位连续的 0 省略。10.0.0.0/10 隐含地指出 IP 地址 10.0.0.0 的掩码是 255.192.0.0。此掩码可表示为：网络前缀的后面加一个星号 * 的表示方法，如 00001010 00，*在星号 * 之前是网络前缀，而星号 * 表示 IP 地址中的主机号，可以是任意值。**==如果发现平均划分子网不能满足要求，或者认为过于浪费，那么可以根据需要划分子网。很多时候上图中这种比较直接的划分可以看出一些规律基本上都是一个子网后推一位，最后的两个前缀位数一样（23、24、25、26、26）==这个 ISP 共有 64 个 C 类网络。如果不采用 CIDR 技术，则在与该 ISP 的路由器交换路由信息的每一个路由器的路由表中，就需要有 64 个项目。但采用地址聚合后，只需用路由聚合后的 1 个项目 206.0.64.0/18 就能找到该 ISP。最长前缀匹配使用 CIDR 时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成。在查找路由表时可能会得到不止一个匹配结果应当从匹配结果中选择具有最长网络前缀的路由：最长前缀匹配 (longest-prefix matching)网络前缀越长，其地址块就越小，因而路由就越具体 (more specific)最长前缀匹配又称为最长匹配或最佳匹配收到的分组的目的地址 D = 206.0.71.130路由表中的项目：206.0.68.0/22 1​ 206.0.71.128/25 2==选择两个匹配的地址中更具体的一个，即选择最长前缀的地址。==使用二叉线索查找路由表当路由表的项目数很大时，怎样设法减小路由表的查找时间就成为一个非常重要的问题为了进行更加有效的查找，通常是将无分类编址的路由表存放在一种层次的数据结构中，然后自上而下地按层次进行查找。这里最常用的就是二叉线索 (binary trie)IP 地址中从左到右的比特值决定了从根结点逐层向下层延伸的路径，而二叉线索中的各个路径就代表路由表中存放的各个地址为了提高二叉线索的查找速度，广泛使用了各种压缩技术==将路由表中每个IP地址的唯一前缀，构造二叉线索====进行查找时，只要能够和唯一前缀匹配上，就认为查找成功==]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络【三】]]></title>
    <url>%2Fposts%2Faaf5fde3%2F</url>
    <content type="text"><![CDATA[第三章 数据链路层3.1 使用点对点信道的数据链路层数据链路层属于计算机网络的低层，数据链路层使用的信道主要有以下两种类型：点对点信道。这种信道使用一对一的点对点通信方式。广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。当我们专心研究数据链路层找那个的问题的时候，在许多情况下我们可以只关心在协议栈中水平方向的各数据链路层，于是当主机 H1 向主机 H2 发送数据的时候，我们可以想象数据就是在数据链路层中从左向右沿着水平方法传送的3.1.1 数据链路和帧链路(link): 从一个节点到相邻节点的一段物理线路(有线或者无线)，中间没有任何其他的交换结点。进行数据通信时，两个计算机之间的通路往往是由许多的链路串接而成的。一条链路只是一条通路的一个组成部分。数据链路(data link)： 除了物理线路外，还必须有通信协议来控制这些数据的传输。把实现这些协议的硬件和软件加到链路上，就构成了数据链路。常用方法是用适配器（即网卡）（通过硬件或者软件）来实现相关协议。适配器是一个电路板（或者一个PCMCIA卡），通常包括RAM、DSP芯片、主机总线接口和链路接口。 适配器通常也称为网络接口卡（network interface card, NIC）。链路层协议的主要部分在适配器中实现，适配器通常包括数据链路层和物理层这两层功能。早期数据通信协议曾经叫做通信规程，所以在数据链路层中，规程和协议是同义语帧：数据链路层传送的是帧。我们知道在物理层之间传送的是比特流，而在传输媒体上传送的是信号，但有时为了方便，常说，“在某条链路上传送数据帧”。其实这隐含地假定是在数据链路层上来观察问题。传输过程传输节点的网络层将网络层数据报传递到适配器。该适配器在一个帧内封装数据报，并将该帧传输到通信链路。在另一端，接收适配器收到整个帧，提取出网络层数据报，传递给网络层。如果链路层协议提供差错检测，发送适配器设置差错检测比特，接收适配器完成差错检测。如果链路层协议提供可靠交付，那么可靠交付的机制（例如序号、定时器、确认）在适配器中实现。如果链路层协议提供随机访问，随机访问协议在适配器中实现。3.1.2 三个基本问题(1)封装成帧封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。首部和尾部的一个重要作用就是进行帧定界。用控制字符进行帧定界的方法举例数据在传输中出现差错时，帧定界符的作用更加明显。ASCII 码是7位编码，一共可以组成128个不同的 ASCII 码，其中可打印的有95个，不可打印的有33个，请注意，SOH 和 EOT 都是控制字符的名称，他们的十六进制编码分别为 01（二进制是 00000001）和 04（00000100）SOH（或 EOT） 并不是 S，O，H （或 E，O，T）三个字符(2)透明传输如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地“找到帧的边界”。解决方法：字节填充 (byte stuffing) 或字符填充 (character stuffing)发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”（其十六进制编码是1B）接收端的数据链路层在将数据送往网络层之前删除插入的转义字符如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个(3)差错控制在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER (Bit Error Rate)。 误码率与信噪比有很大的关系。 为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC 的检错技术。在发送端，先把数据划分为组。假定每组 k 个比特在每组 M（待传送数据） 后面再添加供差错检测用的 n 位冗余码，然后一起发送出去冗余码如何计算：用二进制的模 2 运算进行 2^n 乘 M 的运算，这相当于在 M 后面添加 n 个 0得到的 (k + n) 位的数除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q 而余数是 R，余数 R 除数 P 少 1 位，即 R 是 n 位将余数 R 作为冗余码拼接在数据 M 后面，一起发送出去接收端对收到的每一帧进行 CRC 检验(1) 若得出的余数 R = 0，则判定这个帧没有差错，就接受 (accept)。(2) 若余数 R ≠ 0，则判定这个帧有差错，就丢弃。但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。 只要经过严格的挑选，并使用位数足够多的除数 P，那么出现检测不到的差错的概率就很小很小。举例：现在 k = 6, M = 101001设 n = 3, 除数 P = 1101被除数是 2^n^M = 101001000模 2 运算的结果是：商 Q = 110101，余数 R = 001把余数 R 作为冗余码添加在数据 M 的后面发送出去。发送的数据是：2^n^M + R，即：101001001，共 (k + n) 位 模2除法，实际上就是异或，每一位除的结果不影响其它位，即不借位。模2除法的步骤：1、用被除数最高几位对除数做模2减，没有借位。2、够除数位数就商1否则就商03、一直做到余数的位数小于除数，该余数就是最终结果。（不够n位前面补0）PS运算中，余数第一位是0可省略，如上。在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)循环冗余检验 CRC 和帧检验序列 FCS 并不等同CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法实际中，每个r位的FCS都会对应一个规定好的除数。这也是为什么接收方知道用啥除的原因。注意：仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受 (accept)“无差错接受”是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”也就是说：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受） 单纯使用 CRC 差错检测技术不能实现“无差错传输”或“可靠传输”应当明确，“无比特差错”与“无传输差错”是不同的概念在数据链路层使用 CRC 检验，能够实现无比特差错的传输，但这还不是可靠传输(例如：中途整个帧丢失了怎么办？)要做到“无差错传输”（即发送什么就收到什么）就必须再加上确认和重传机制这一篇中介绍的数据链路层协议都不是可靠传输的协议3.2 点对点协议PPP对于点对点的链路，目前使用得最广泛的数据链路层协议是点对点协议 PPP (Point-to-Point Protocol)3.2.1PPP 协议的特点PPP 协议应满足的需求简单 —— 这是首要的要求封装成帧 —— 必须规定特殊的字符作为帧定界符透明性 —— 必须保证数据传输的透明性多种网络层协议 —— 能够在同一条物理链路上同时支持多种网络层协议多种类型链路 —— 能够在多种类型的链路上运行差错检测 —— 能够对接收端收到的帧进行检测，并立即丢弃有差错的帧检测连接状态 —— 能够及时自动检测出链路是否处于正常工作状态最大传送单元 —— 必须对每一种类型的点对点链路设置最大传送单元 MTU 的标准默认值，促进各种实现之间的互操作性网络层地址协商 —— 必须提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址数据压缩协商 —— 必须提供一种方法来协商使用数据压缩算法PPP 协议不需要的功能纠错流量控制序号多点线路半双工或单工链路PPP 协议的组成PPP 协议有三个组成部分：一个将 IP 数据报封装到串行链路的方法在PPP帧中封装数据、识别帧的开始和结束以及检测帧中差错的方法。链路控制协议 LCP (Link Control Protocol)建立、配置、测试数据链路；在链路上协调互连的两端设备每个选项的设置值（如：封帧的格式，分组的大小），还可进行链路质量管理。网络控制协议 NCP (Network Control Protocol)PPP允许同时使用多个网络层协议，对于所支持的每一个网络层协议都有一个不同的网络控制协议（NCP），用来建立和配置不同的网络层协议。3.2.2 PPP 协议的帧格式PPP 帧的首部和尾部分别为 4 个字段和 2 个字段标志字段 F = 0x7E （符号“0x”表示后面的字符是用十六进制表示。十六进制的 7E 的二进制表示是 01111110）地址字段 A 只置为 0xFF。地址字段实际上并不起作用控制字段 C 通常置为 0x03PP 是面向字节的，所有的 PPP 帧的长度都是整数字节PPP 有一个 2 个字节的协议字段，其值：若为 0x0021，则信息字段就是 IP 数据报。若为 0x8021，则信息字段是网络控制数据。若为 0xC021，则信息字段是 PPP 链路控制数据。若为 0xC023，则信息字段是鉴别数据。(1)PPP 协议解决透明传输的问题当 PPP 用在同步传输链路时，协议规定采用硬件来完成比特填充（和 HDLC 的做法一样）当 PPP 用在异步传输时，就使用一种特殊的字符填充法字符填充将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列 (0x7D, 0x5E)若信息字段中出现一个 0x7D 的字节(即出现了和转义字符一样的比特组合), 则将其转变成为 2 字节序列 (0x7D, 0x5D)若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变零比特填充PPP 协议用在 SONET/SDH 链路时，使用同步传输（一连串的比特连续传送）。这时 PPP 协议采用零比特填充方法来实现透明传输在发送端，只要发现有 5 个连续 1，则立即填入一个 0接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除理解字节填充和零比特填充不提供使用序号和确认的可靠传输PPP 协议之所以不使用序号和确认机制是出于以下的考虑：在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理在因特网环境下，PPP 的信息字段放入的数据是 IP 数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的帧检验序列 FCS 字段可保证无差错接受3.2.3PPP协议的工作状态当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）这些分组及其响应选择一些 PPP 参数，并进行网络层配置，NCP 给新接入的 PC 机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接可见，PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容3.3 使用广播信道的数据链路层本章研究的是在一个局域网内，分组怎样从一台主机传送到另一台主机（不经过路由器），这属于数据链路层的范畴。3.3.1局域网的数据链路层局域网最主要的特点是：网络为一个单位所拥有地理范围和站点数目均有限局域网具有如下主要优点：具有广播功能，从一个站点可很方便地访问全网，局域网上的主机可共享连接在局域网上的各种硬件和软件资源便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变提高了系统的可靠性、可用性和残存性(1)媒体共享技术静态划分信道–频分复用–时分复用–波分复用–码分复用动态媒体接入控制（多点接入）–受控接入 ，用户不能随机发送信息，如令牌环局域网。–随机接入：所有用户可随机发送信息，可能存在冲突问题，如以太网。(2)以太网的两个标准DIX Ethernet V2 是世界上第一个局域网产品（以太网）的规约IEEE 802.3 是第一个 IEEE 的以太网标准DIX Ethernet V2 标准与 IEEE 的 802.3 标准只有很小的差别，因此可以将 802.3 局域网简称为“以太网”严格说来，“以太网”应当是指符合 DIX Ethernet V2 标准的局域网(3)数据链路层的两个子层为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成两个子层：逻辑链路控制 LLC (Logical Link Control)子层媒体接入控制 MAC (Medium Access Control)子层与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关不管采用何种协议的局域网，对 LLC 子层来说都是透明的由于 TCP/IP 体系经常使用的局域网是 DIX Ethernet V2 ，因此现在 802 委员会制定的逻辑链路控制子层 LLC（即 802.2 标准）作用已经不大。很多厂商生产的适配器上仅装有 MAC 协议而没有 LLC 协议。(4)适配器的作用网络接口板又称为通信适配器 (adapter) 或网络接口卡 NIC (Network Interface Card)，或“网卡”适配器的重要功能：进行串行/并行转换对数据进行缓存在计算机的操作系统安装设备驱动程序实现以太网协议3.3.2CSMA/CD协议(1)以太网的广播方式发送最初的以太网是将许多计算机都连接到一根总线上。总线的特点：当一台计算机发送数据时，总线上的所有计算机都能检测到这个数据。即：广播通信方式。但大多数情况，并不希望进行一对多的广播通信，而是在总线上实现一对一的通信。方法：每一台计算机的适配器都拥有一个与其他适配器不同的地址，在发送数据帧时，在帧的首部写明接收方的地址。总线也有缺点。若多台计算机或多个站点同时发送时，会产生发送碰撞或冲突，导致发送失败。(2)以太网采取两种重要的措施(一)① 采用较为灵活的无连接的工作方式不必先建立连接就可以直接发送数据对发送的数据帧不进行编号，也不要求对方发回确认这样做的理由是局域网信道的质量很好，因信道质量产生差错的概率是很小的以太网提供的服务:以太网提供的服务是不可靠的交付，即尽最大努力的交付。当目的站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。② 以太网发送的数据都使用曼彻斯特 (Manchester) 编码曼彻斯特编码缺点是：它所占的频带宽度比原始的基带信号增加了一倍以太网提供的服务:CSMA/CD 表示 Carrier Sense Multiple Access with Collision Detection。“多点接入”指许多计算机以多点接入的方式连接在一根总线上，表明这是总线型网络。“载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机发送的数据信号，即:是否有其他计算机在发送数据 。如果有的话，则暂时不要发送数据，以免发生碰撞。总线上并没有什么“载波”。因此， “载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。(3)碰撞检测由于电磁波在总线上的传播速率是有限的，当某个站监听到总线是空闲时，也可能总线并非真正是空闲的A 向 B 发出的信息，要经过一定的时间后才能传送到 BB 若在 A 发送的信息到达 B 之前发送自己的帧 (因为这时 B 的载波监听检测不到 A 所发送的信息)，则必然要在某个时间和 A 发送的帧发生碰撞碰撞的结果是两个帧都变得无用所以需要在发送期间进行碰撞检测，以检测冲突“碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。 当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信），因为了碰撞了帧就无效了。当发送数据的站一旦发现发生了碰撞时：(1) 立即停止发送数据；(2) 再继续发送若干比特的人为干扰信号 (jamming signal)，以便让所有用户都知道现在已经发生了碰撞。争用期2τ-δ的来源入上，（τ-δ/2）乘二倍。最先发送数据帧的站，在发送数据帧后至多经过时间 2τ（两倍的端到端单程时延）就可知道发送的数据帧是否遭受了碰撞。以太网的端到端往返时延 2τ 称为争用期，或碰撞窗口。经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。截断二进制指数退避算法 (truncated binary exponential type)如果检测到碰撞了就直接重发，就会导致重新造成碰撞。发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。 争用期的长度和最小帧长以太网取 51.2 μs 为争用期的长度。对于 10 Mb/s 以太网，在争用期内可发送512 bit，即 64 字节。以太网在发送数据时，若前 64 字节没有发生冲突，则后续的数据就不会发生冲突。最小帧长=数据传输速率×2τ如果发生冲突，就一定是在发送的前 64 字节之内。 由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于 64 字节。以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧。强化碰撞当发送数据的站一旦发现发生了碰撞： 立即停止发送数据；继续发送32比特或者48比特的人为干扰信号(jamming signal)；jamming signal的目的：强化碰撞，使冲突的时间足够长，以便让所有用户都知道现在已经发生了碰撞。使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。(4)CSMA/CD协议的要点3.3.3使用集线器的星形拓扑传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做集线器 (hub)传统以太网使用同轴电缆，采用总线形拓扑结构 集线器是使用电子器件来模拟实际电缆线的工作，因此整个系统仍然像一个传统的以太网那样运行使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是 CSMA/CD 协议，并共享逻辑上的总线集线器很像一个多接口的转发器，工作在物理层集线器采用了专门的芯片，进行自适应串音回波抵消，减少了近端串音转发器并非简单地放大信号（放大信号的同时，也会放大噪声），而是将电信号解释为0和1，接着重新生成新的强信号发送到其他电缆。转发器并不解释比特的含义，只是查看并重新生成电信号，所以工作在物理层。3.3.4以太网的信道利用率(1)参数 a多个站在以太网上同时工作就可能会发生碰撞当发生碰撞时，信道资源实际上是被浪费了。因此，当扣除碰撞所造成的信道损失后，以太网总的信道利用率并不能达到 100%假设 τ是以太网单程端到端传播时延。则争用期长度为 2τ ，即端到端传播时延的两倍。检测到碰撞后不发送干扰信号设帧长为 L (bit)，数据发送速率为 C (bit/s)，则帧的发送时间为 T0 = L/C (s)一个站在发送帧时出现了碰撞。经过一个争用期 2τ 后，可能又出现了碰撞。这样经过若干个争用期后，一个站发送成功了。假定发送帧需要的时间是 T0注意到，成功发送一个帧需要占用信道的时间是 T0 + τ ，比这个帧的发送时间要多一个单程端到端时延 τ这是因为当一个站发送完最后一个比特时，这个比特还要在以太网上传播在最极端的情况下，发送站在传输媒体的一端，而比特在媒体上传输到另一端所需的时间是 τ要提以太网的信道利用率，就必须减小 τ 与 T0 之比在以太网中定义了参数 a ，它是以太网单程端到端时延 τ 与帧的发送时间 T0 之比：为提高利用率，以太网的参数 a 的值应当尽可能小些对以太网参数 a 的要求是：当数据率一定时，以太网的连线的长度受到限制，否则 τ 的数值会太大以太网的帧长不能太短，否则 T0 的值会太小，使 a 值太大(2)信道利用率的最大值 Smax在理想化的情况下，以太网上的各站发送数据都不会产生碰撞（这显然已经不是 CSMA/CD，而是需要使用一种特殊的调度方法），即总线一旦空闲就有某一个站立即发送数据发送一帧占用线路的时间是 T0 + τ ，而帧本身的发送时间是 T0。于是，我们可计算出理想情况下的极限信道利用率 Smax 为：只有当参数 a 远小于 1 才能得到尽可能高的极限信道利用率据统计，当以太网的利用率达到 30% 时就已经处于重载的情况。很多的网络容量被网上的碰撞消耗掉了3.3.5以太网的 MAC 层在局域网中，硬件地址又称为物理地址，或 MAC 地址。 802 标准所说的“地址”严格地讲应当是每一个站的“名字”或标识符。(1)MAC地址组成IEEE 802 标准规定 MAC 地址字段可采用 6 字节 ( 48位) 或 2 字节 ( 16 位) 这两种中的一种IEEE 的注册管理机构 RA 负责向厂家分配地址字段 6 个字节中的前三个字节 (即高位 24 位)，称为组织唯一标识符地址字段 6 个字节中的后三个字节 (即低位 24 位) 由厂家自行指派，称为扩展唯一标识符，必须保证生产出的适配器没有重复地址生产适配器时，6 字节的 MAC 地址已被固化在适配器的 ROM，因此，MAC 地址也叫做硬件地址 (hardware address) 或物理地址。单站地址，组地址，广播地址全球管理与本地管理适配器检查MAC所有的适配器都至少能够识别前两种帧，即能够识别单播地址和广播地址以混杂方式 (promiscuous mode) 工作的以太网适配器只要“听到”有帧在以太网上传输就都接收下来(2)MAC 帧的格式格式​ 常用的以太网 MAC 帧格式有两种标准：DIX Ethernet V2 标准（常用）IEEE 的 802.3 标准最常用的 MAC 帧是以太网 V2 的格式。 无效的 MAC 帧数据字段的长度与长度字段的值不一致帧的长度不是整数个字节用收到的帧检验序列 FCS 查出有差错数据字段的长度不在 46 ~ 1500 字节之间有效的 MAC 帧长度为 64 ~ 1518 字节之间对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。帧间最小间隔帧间最小间隔为9.6 μs ，相当于96比特时间。一个站在检测到总线开始空闲后，还要等待 9.6 μs 才能再次发送数据。目的：使刚刚收到数据帧的站来得及清理接收缓存，做好接收下一帧的准备。3.4 扩展的以太网3.4.1在物理层扩展以太网使用光纤扩展主机使用光纤（通常是一对光纤）和一对光纤调制解调器连接到集线器。很容易使主机和几公里以外的集线器相连接使用集线器扩展：将多个以太网段连成更大的、多级星形结构的以太网优点使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信扩大了以太网覆盖的地理范围缺点碰撞域增大了，但总的吞吐量并未提高如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来补充碰撞域（collision domain）又称为冲突域，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络碰撞域越大，发生碰撞的概率越高3.4.2在数据链路层扩展以太网扩展以太网更常用的方法是在数据链路层进行早期使用网桥，现在使用以太网交换机网桥工作在数据链路层它根据 MAC 帧的目的地址对收到的帧进行转发和过滤==当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃==以太交换机的特点以太网交换机实质上就是一个多接口的网桥通常都有十几个或更多的接口每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在全双工方式以太网交换机具有并行性能同时连通多对接口，使多对主机能同时通信独占传输媒体的带宽对于传统的 10 Mb/s 的共享式以太网，若共有 N 个用户，则每个用户占有的平均带宽只有总带宽(10 Mb/s)的 N 分之一。使用以太网交换机时，虽然在每个接口到主机的带宽还是 10 Mb/s，但由于一个用户在通信时是独占而不是和其他网络用户共享传输媒体的带宽，因此对于拥有 N 个接口的交换机的总容量为 N10 Mb/s。这正是交换机的最大优点。总线以太网使用CSMA/CD协议，以半双工方式工作。但以太网交换机不使用共享总线，没有碰撞问题。因此不使用CSMA/CD协议，而是以全双工方式工作。那交换式以太网为什么还叫以太网呢？因为帧结构不变，仍然采用以太网帧结构。以太网交换机的优点从共享总线以太网转到交换式以太网时，所有接入设备的软件和硬件、适配器等都不需要做任何改动。以太网交换机一般都具有多种速率的接口，方便了各种不同情况的用户。交换机的交换方式存储转发方式把整个数据帧先缓存后再进行处理。直通 (cut-through) 方式接收数据帧的同时就立即按数据帧的目的 MAC 地址决定该帧的转发接口，因而提高了帧的转发速度。缺点是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。交换机的自学习算法 处理收到的帧和建立转发表 在交换机的转发表中写入的信息除了地址和接口外，还有帧进入该交换机的时间。因为以太网的拓扑可能经常会发生变化，站点也可能会更换适配器（即改变了站点的地址）。把每个帧到达交换机的时间登记下来，就可以在转发表中只保留网络拓扑的最新状态信息。这样就使得交换机中的转发表能反映当前网络的最新拓扑状态。以太网交换机实质上就是一个多接口的网桥这里我们是以以太网交换机为例，若以网桥为基础开始介绍，则接口只有1、2，不同的网桥,自左到右为1 2 1 2 1 2若不同网桥有不同的机器，通过不同的网桥传达信息，若表中无此信息，则会通过广播传送给各个网桥（只要本网桥中找不到目的地址，就会广播，而网桥接口很少，广播次数会很多。）总结：以太网交换机运行自学习算法自动维护交换表交换机收到一帧后先进行自学习。查找交换表中与收到帧的源地址有无相匹配的项目。如没有，就在交换表中增加一个项目（源地址、进入的接口和有效时间）。如有，则把原有的项目进行更新（进入的接口或有效时间）。转发帧。查找交换表中与收到帧的目的地址有无相匹配的项目。如没有，则向所有其他接口（进入的接口除外）转发。如有，则按交换表中给出的接口进行转发。若交换表中给出的接口就是该帧进入交换机的接口，则应丢弃这个帧（因为这时不需要经过交换机进行转发）。以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。回路和生成树算法在网络拓扑图中，你能找到一个回路，比如多个交换机用网线连成一个圈，这样数据可以从原始交换机出发后，还能被转发回原始交换机。互连在一起的交换机在进行彼此通信后，就能找出原来的网络拓扑的一个子集。在这个子集里，整个连通的网络中不存在回路，即在任何两个站之间只有一条路径。为了避免产生转发的帧在网络中不断地兜圈子，我们使用生成树算法（Kruskal(克鲁斯卡尔)算法等）3.4.3虚拟局域网网桥和交换机只能分割冲突域，不能分割广播域。虚拟局域网 VLAN技术可以分割广播域。 利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN)IEEE 802.1Q 对虚拟局域网 VLAN 的定义：虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同- 的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源10 台计算机划分为三个虚拟局域网： VLAN1, VLAN2 和 VLAN3每个虚拟局域网是一个广播域，VLAN1, VLAN2 和 VLAN3 是三个不同的广播域当 B1 向 VLAN2 工作组内成员发送数据时，工作站 B2 和 B3 将会收到其广播的信息B1 发送数据时，VLAN1 和 VLAN3 中的工作站 A1，A2 和 C1 等都不会收到 B1 发出的广播信息虚拟局域网限制了接收广播信息的工作站数，使得网络不会因传播过多的广播信息 (即“广播风暴”) 而引起性能恶化。虚拟局域网使用的以太网帧格式虚拟局域网协议允许在以太网的帧格式中插入一个 4 字节的标识符，称为 VLAN 标记(tag)，用来指明发送该帧的工作站属于哪一个虚拟局域网。虚拟局域网（VLAN）技术具有以下主要优点：改善了性能简化了管理降低了成本改善了安全性3.5 高速以太网100BASE-T 以太网速率达到或超过 100 Mb/s 的以太网称高速以太网。100BASE-T 是在双绞线上传送 100 Mb/s 基带信号的星型拓扑以太网又称为快速以太网( Fast Ethernet )。IEEE802.3u吉比特以太网允许在 1 Gb/s 下全双工和半双工两种方式工作。在半双工方式下使用 CSMA/CD 协议（全双工方式不需要使用 CSMA/CD 协议）。使用 802.3 协议规定的帧格式。与 10BASE-T 和 100BASE-T 技术向后兼容。]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络【二】]]></title>
    <url>%2Fposts%2Fe7eb5eb1%2F</url>
    <content type="text"><![CDATA[第二章、物理层2.1 物理层的基本概念物理层是指通过传输介质，以及相关的通信协议、标准建立起来的物理线路。(1)主要功能物理层主要功能：提供透明的比特流传输封装好的数据以 “0”、”1” 比特流的形式进行传递，从一个地方搬到另一个地方。物理层上的传输，从不关心比特流里面携带的信息，只关心比特流的正确搬运。(2)主要任务可以将物理层的主要任务描述为确定与传输媒体到接口有关的一些特性：(1) 机械特性：接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等(2) 电气特性：接口电路的各条线上出现的电压范围(3) 功能特性：某条线上出现某一电平电压的意义(4) 过程特性：对于不同功能的各种可能事件的出现顺序电气特性和功能特性：电气特性一般含有数字功能特性一般不含数字2.2 数据通信的基础知识(1)数据通信系统的模型首先可以看到一个数据通讯系统可以划分为三大部分：① 源系统、② 传输系统、③ 目的系统(1) 源系统包括源点：源点设备产生要传输的数据发送器：源点生成的数字比特流要通过发送器编码后才能在传输系统中传输，例如调制器(2) 目的系统包括接收器：结束传输系统发送来的信号，并转换成能被目的设备处理的信息，如解调器终点：终点设备从接收器获取传送来的数字比特流，然后把信息输出(3)常用术语消息：通信的目的是传送消息，如语音、文字、图像、视频等数据 (data) —— 运送消息的实体。通常是有意义的符号序列。数据通信指在不同计算机之间传输表示信息的二进制数0、1序列的过程。信号 (signal) —— 数据的电气的或电磁的表现。模拟信号 (analogous signal)，或连续信号—— 代表消息的参数的取值是连续的。数字信号 (digital signal)，或离散信号 —— 代表消息的参数的取值是离散的。码元 (code) —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。一个电信号称为一个码元，二进制两种码元：0/1码元的信息量由表示的数据有效状态值个数决定(2)有关信道的几个基本概念信源：产生和发送数据的源头。信宿：接收数据的终点。信道 —— 一般用来表示向某一个方向传送信息的媒体。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。（具有方向性）三种数据通信方式单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息。串行传输和并行传输实现同步的传输/通信方式同步和异步通信同步通信，就是送快递的面对面给交你，交互完成即完在，但双方都需要在同一时间内反应，否则会造成另一方阻塞等待。异步通信，就是送快递的放在门卫或快递箱，你自己去取，中间不是同步完成的。同步传输就是发送方和接收方的时钟要同步，且每次发送的是帧（一串字符，包含起始位和结束位）。打个比方就像双方约好了发送方每过一个小时就发送一次打包好的数据（帧）给接收方，接收方也每过一个小时接收一次数据（帧）。但是接收方不明白这一串数据得有多长，不能说传过来的数据收了一半就算完成了，所以得有起始位和结束位方便识别接受到的数据是否完整。异步传输是发送方和接收方没有时钟同步，且每次发送的是一个字符（包含起始位和结束位）。发送方想什么时候发就什么时候发，但是每次只能发一个字符，并且这个字符（8位）里还要包含一个起始位和一个结束位。码元码元是指用一个固定时长的信号波形（数字脉冲），代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，而该时长称为码元宽度。当码元的离散状态有M个时（M大于2），此时码元为M进制码元。例如：它只有两种波形，则为2进制码元。那个小横杠就是码元，每个小波形的长度（那个横杠的长度）成为码元宽度。1码元可以携带多个比特的信息量。例如，在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。而4进制码元则可以携带2b信息量。因为有四种高低不同的电平，分别可代表00、01、10、11同理：16进制码元：1码元4bit数据数字通信系统数据传输速率的两种表示方法结合上面的一码元携带的比特数据量理解。调制和编码复习：信道 —— 一般用来表示向某一个方向传送信息的媒体。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。（具有方向性）频带信号=带通信号载波=载频=载波频率在通信技术上，载波（carrier wave, carrier signal或carrier）是由振荡器产生并在通讯信道上传输的电波，被调制后用来传送语音或其它信息。载波和调制波：一个是渡船，一个是乘客。载波是固定频率的波形发出去无意义，只有将信息加载到载波上变成调制波才有意义基带Baseband：信源（信息源，也称发射端）发出的没有经过调制（进行频谱搬移和变换）的原始电信号所固有的频带（频率带宽），称为基本频带，简称基带。基带和频带相对应频带：对基带信号调制后所占用的频率带宽（一个信号所占有的从最低的频率到最高的频率之差)。基带信号（即基本频带信号）—— 来自信源的信号。基带信号就是发出的直接表达了要传输的信息的信号，如声波、文字或图像文件的数据信号其特点是频率较低，信号频谱从零频附近开始，具有低通形式。在传输距离较近时，计算机网络都采用基带传输方式，大多数的局域网使用基带传输频带信号(带通信号)在通信中，由于基带信号具有频率很低的频谱分量,出于抗干扰和提高传输率考虑一般不宜直接传输,需要把基带信号变换成其频带适合在信道中传输的信号，变换后的信号就是频带信号（如果一个信号只包含了一种频率的交流成份或者有限几种频率的交流成份，我们就称这种信号叫做频带信号）。其主要用于网络电视和有线电视的视频广播。基带传输：在信道中直接传送基带信号时，称为基带传输。频带传输：在信道中直接传送频带信号时，称为频带传输。宽带传输：是相对一般说的频带传输而言的宽频带传输。==模拟信号：形状连续，可以设想形如sin(x)的形状====数字信号：不连续==在链路上传输的信号分成两种：基带信号，宽带信号==基带信号（对应数字信号）==：将数字信号0和1直接用两种不同的电压表示，然后传到数字信道上传输，这种传输叫做基带传输，通常用于局域网。频带信号：它也是一种模拟信号，用数字信号对特定频率的载波进行调制，将其变成适合于传送的信号在传输（远距离传输 或 无线传输），不过频带传输和宽带传输有细微不同，宽带传输的子信道比频带传输的子信道更多。==宽带信号（对应模拟信号）==：借助频带传输，将链路容量分解为两个或多个信道，每个信道可以携带不同的信号 宽带中所有的信道可以同时互不干扰的发送信号。将基带信号调制后形成模拟信号，并在模拟信道上传输，而这种传输叫做宽带传输。数字数据通过编码可以变成数字信号，方式有：非归零码，曼彻斯特编码，差分曼彻斯特编码数字数据通过调制可以变成模拟信号，方式有：幅移键控(ASK)，频移键控(FSK)，相移键控(PSK)，正交振幅调制(QAM)模拟数据通过编码可以变成数字信号，步骤为：抽样、量化、编码==总之====目的是数字信号：编码====目的是模拟信号：调制==调制——为了解决“基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。”的问题。必须对基带信号进行调制。调制分为两大类，即基带调制和带通调制。基带调制：仅对基带信号的波形进行变换，过程称为编码。使它能够与信道特性相适应。变换后的信号仍然是基带信号。带通调制：使用载波进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道） 。带通信号 ：经过载波调制后的信号。信源发出的数字信号，进入电话网络传播需要转为模拟信号，因为电话网络只支持模拟信号传播。基带调制(数字数据编码为数字信号)常用编码方式：不归零制：正电平代表 1，负电平代表 0。问题：发送连续的1或者0会很难识别，需要规定时钟信号。双方难以保持同步周期内不跳变画图：周期内，高1低0反向不归零编码：边界处信号电平翻转表示0，信号电平不变表示1。问题：发送全0容易判断（不断反转）发送全1也会出现双方难以保持同步的问题。周期内不跳变画图：为0则周期前端画竖线，最后从给出的起始连起来。归零制：正脉冲代表 1，负脉冲代表 0。可理解为后半段始终归零，前半段高电平就是1否则就是0归零码是信号电平在一个码元之内都要恢复到零的编码方式问题：处于低电平的时间比较多，信道相当于没怎么使用。画图：一个周期分两半，后半个恒为0，若1则前半个高电平，若0则前半个低电平，再连起来。曼彻斯特编码：每一个码元的中间出现电平跳变，位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。但也可反过来定义。该编码的特点是在每一个码元的中间出现电平跳变，位中间的跳变既作时钟信号（可用于同步），又作数据信号，但它所占的频带宽度是原始的基带宽度的两倍。每一个码元都被调成两个电平，所以数据传输速率只有调制速率（码元传输速率）的1/2。码元传输速率：别名码元速率、波形速率、调制速率、符号速率等显然，对于曼彻斯特编码，它的一个码元需要两个跳变，或者说两个码元表示一个数据。(中间和边缘)画图：一个周期分两半，高跳低为1.低跳高位0（或者反过来），再连起来。差分曼彻斯特编码(同 1 异 0)：在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1。画图：周期中间都画竖线，为0则周期前端再画竖线，最后从给出的起始连起来。 带通调制(数字数据调制为模拟信号)调幅(AM)：载波的振幅随基带数字信号而变化。调频(FM)：载波的频率随基带数字信号而变化。调相(PM) ：载波的初始相位随基带数字信号而变化。可理解为给0和1编制余弦波正弦波。模拟数据编码为数字信号 ==为什么是采样频率≥信号的最高频率？==信号可能是又一系列波叠加而成，它们由y=asin(ωt+φ)组成，对于a和φ两个未知数，我们需要两个样本点就能确定这个波。(至于为啥ω知道我也不清楚。)，而为了保证每一种用于叠加的波都被确定，需要取信号的最高频率，例如图中取a的频率，显然a也是跳变快的那个，若我们取的周期长了，或者说频率小了，则不能保证取到a周期中的两个样本点。模拟数据调制为模拟信号为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用技术，充分利用带宽资源。在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式；模拟的声音数据是加载到模拟的载波信号中传输的。(3)信道的极限容量带宽在不同背景下的表达1.==模拟信号系统中==：当输入的信号频率高或低到一定程度，使得系统的输出功率成为输入功率的一半时(即-3dB)，最高频率和最低频率间的差值就代表了系统的通频带宽，其单位为赫兹(Hz)。2.==数字设备中==：表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”/单位时间内通过链路的数量，常用来表示网络的通信线路所能传输数据的能力。 单位是比特每秒(bps)。拥有更宽的带宽，也就是有更大的信息运送能力！失真信号的传播会受到干扰而失真。有时有失真但可识别，有时失真大无法识别。影响失真程度的因素： 1.码元传输速率 2.信号传输距离 3.噪声干扰4.传输媒体质量失真的一种现象——码间串扰码间串扰：接收端收到的信号波形失去了码元之间清晰界限的现象。码间串扰：信号中高频分类受到衰减，在接收端收到的波形前沿和后沿不那么陡峭，每个码元所占时间界限不明确，接收端收到的信号波形失去了码元间的清晰界限的现象信源发出的数字信号，进入电话网络传播需要转为模拟信号，因为电话网络只支持模拟信号传播。这里指模拟信号系统中的带宽。即最高频率和最低频率间的差值==从这里我们也可以理解，两种带宽其实都能表达数据的传输速率。因为数字信号转化为模拟信号是一一对应的，信道的带宽高，其实也就说明数字信号的传输速率高。==也显然，传输过快或者过慢，就越难分辨码元之间的界限。奈氏准则奈氏准则：在任何信道，码元传输的速率是有上限的，超过上限就会出现严重的码间串扰，使接收端对码元无法识别（对码元的判决成为不可能）在理想低通（无噪声，带宽受限）条件下，==为了避免码间串扰，极限码元传输速率为 2W Baud，W是信道带宽，单位是Hz。==根据上面码元传输速率和信息传输速率的关系，我们有奈氏准则下的极限数据传输速率：奈奎斯特定理说明：信噪比任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰,码元传输速率越高，或信号传输距离越远，或者传输媒介差，在信道的输出端的波形的失真就越严重。限制码元在信道传输的两个因素：能够通过的频率范围；信噪比噪音是存在所有电子设备和通信通道中，因为噪声是随机产生的，所以它的瞬时值有时候会很大，因此噪声会使接收端对码元的判决产生错误（1 误判为 0，0 误判为 1），但是噪声的影响是相对的，信号越强，那么噪声的影响就相对较小，因此信噪比十分重要定义：信号的平均功率和噪声的平均功率之比，记作S/N，且常用分贝（dB）作为度量单位==公式：信噪比(dB) = 10 log10(S/N)(dB)==例子：当 S/N = 10 时，信噪比为 10 dB，而当 S/N = 1000时，信噪比为 30 dB定义和计算看似不等，其实和分贝的定义有关。分贝是较常用的计量单位。可表示为：表示功率量之比的一种单位，等于功率强度之比的常用对数的10倍。表示场量之比的一种单位，等于场强幅值之比的常用对数的20倍。3.声压级的单位，大约等于人耳通常可觉察响度差别的最小分度值。分贝最初来源于长途电讯的计测，后被广泛应用在电工、无线电、力学、冲击振动、机械功率和声学等领域。分贝最初是用来描述声音音量的大小的，因为声音的大小差别很大，如果用线性表示音量大小，无法将所有的声音归到同一个坐标系，因此用分贝表示。后来开始用在电学领域。分贝最重要的目的就是将很小的值和很大的值放在同一个坐标系中，同时将乘法运算变成加法运算。可表示的数值范围大。10000和0.0001换成对数终于可以画在一个坐标轴下了。乘法变加法，计算容易。放大100倍固然好算，但是放大73倍，我表示我得找计算器或计算尺。不用区分什么电压放大倍数和功率放大倍数了。香农公式香农定理：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。信道的极限数据传输速率 = Wlog₂(1+S/N)W：信道带宽（Hx）S/N：信噪比【无单位】如果信噪比单位为dB 需要使用 信噪比 = 10log₁₀(S/N)求出S/N香农公式的结论和意义：信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高只要信息传输速率低于信道的极限速率，就一定存在某种方法来实现无差错的传输对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。但是实际信道上的信息传输速率比香农极限传输速率低从香农定理可以看出，若信道带宽W或信噪比S/N没有上限（不可能），那么信道的极限信息传输速率也就没有上限。若信噪比不能再提高了，且码元传输速率也达到了了上限值，还可以使用编码的方法让每一个码元携带更多比特的信息量如：将信号中的每3个比特编为一个组101 011 000 110 111 010奈氏准则和香农公式的比较==一般来说，给出信噪比我们就用香农定理，不给，我们就用奈氏准则。====都给了，我们就都算算求最小值。==2.3物理层下的传输媒体传输媒体：是数据传输系统中在发送器和接收器之间的物理通路引导型：电磁波被引导沿着固体媒体（铜线或光纤）传播双绞线、同轴电缆、光纤非引导型：指自由空间，电磁波的传输常被称为无线传输(1)导引型传输媒体双绞线由按螺旋结构排列的两根绝缘线构成，铜线.两条线扭绞，可减少对邻近线对的电气干扰。价格在有线介质中最低，容易安装维护。双绞线分为屏蔽双绞线STP和无屏蔽双绞线 UTP 。屏蔽双绞线STP（Shielded Twisted Pair）外层由铝泊包裹, 以减小幅射,但不能完全消除。主要是IBM的设备用。无屏蔽双绞线UTP（Unshielded Twisted Pair）用于以太网 LAN。是令牌环网络安装指定要用的布线结构双绞线标准双绞线的色标和排列方法有统一的国际标准EIA/TIA-568：商用建筑物电信布线标准现在常用的是EIA/TIA-568-B普通网线用于接HUB,网卡,路由, 网络接口等，两个水晶头排列方式EIA/TIA-568-B。双机器互连网线用于接两台机器的网卡一端用568B标准，另外一端用568A标准，反线、交叉线。双绞线连接器交叉线：用于连接两种相同的设备平行线(直通线)：用于连接两种不同的设备同轴电缆同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据同轴电缆的带宽取决于电缆的质量按直径和特性阻抗不同分为粗缆和细缆粗缆直径10mm，特性阻抗为75 Ω ，传输模拟信号，传输距离几十公里，宽带同轴电缆LAN / 数字传输常用细缆直径5mm，特性阻抗为50 Ω ，传送没有载波的基带信号，称为基带同轴电缆有线电视 / 模拟传输常用光缆光纤是光纤通信的传输媒体由于可见光的频率非常高，约为 108 MHz 的量级，因此一个光纤通信系统的传输带宽远远大于目前其他各种传输媒体的带宽只要从纤芯中射到纤芯表面的光线的入射角大于某个临界角度，就可产生全反射光纤分为多模光纤和单模光纤。多模光纤——可以存在多条不同角度入射的光线在一条光纤中传输。单模光纤——若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。光纤的优点：(1) 通信容量非常大(2) 传输损耗小，中继距离长(2) 抗雷电和电磁干扰性能好(3) 无串音干扰，保密性好(4) 体积小，重量轻(2)非引导型传输媒体非导引型传输媒体：自由空间传统的微波通信主要有两种方式，即地面微波通信和卫星通信。短波通信（即高频通信）主要是靠电离层的反射，但短波信道的通信质量较差，传输速率低微波在空间主要是直线传播2.4 信道复用技术复用是通信技术中的基本概念。它允许用户使用一个共享信道进行通信，降低成本，提高利用率。(1)频分复用、时分复用和统计时分复用 frequency time statistic最基本的复用就是频分复用FDM和时分复用TDM。频分复用的所有用户在同样的时间占用不同的带宽资源。时分复用的所以用户是在不同样的时间占用同样的频带宽度。将时间划分为一段段等长的时分复用帧,用户在TDM 帧中占用固定序号的时隙，时隙周期性地出现，即TDM 帧的长度。TDM 信号也称为等时信号。 时分复用可能会造成线路资源的浪费使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的统计时分复用STDM原理：使用STDM帧来传送复用的数据，每一个STDM帧中的时隙数小于连接在集中器上的用户数，各用户有数据就发往集中器的输入缓存，集中器按顺序依次扫描输入缓存，把缓存中的输入数据放入STDM帧中，没有数据的缓存就跳过，当一个帧放满即发送，因此STDM帧不是固定分配时隙，而是按需动态分配时隙某用户占用的时隙不是周期性出现的，因此统计时分复用又称为异步时分复用，而时分复用又称为同步时分复用(2)波分复用WDM wave原理：就是光的频分复用，使用同一根光纤同时传输多个光载波信号波分多路复用就是光的频分多路复用(3)码分复用CDM code码分多址(CDMA)码分复用是一种共享信道方法，更常用的名词是码分多址(CDMA)，各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰，有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现在CDMA中，每一个比特时间再划分为m个短的间隔，称为码片；每一个站被指派一个唯一的m bit码片序列（一般为64bit/128bit）若发送1，则发送自己的m bit码片若发送0，则发送该码片的二进制反码例如，S 站的 8 bit 码片序列是 00011011，发送1发送00011011，发送0发送11100100S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1)CDMA 的重要特点每个站分配的码片序列不仅必须各不相同，并且还必须互相正交。在实用的系统中是使用伪随机码序列正交：码片向量 S 和T 的规格化内积为0正交关系的重要特征：任何码片与自己自身的规格化内积为1，与自己自身反码的规格化内积为-1正是基于正交关系的重要特征。我们为每个站点按照正交、不同的规则分配好各自的码片后，发送时完全可以加。待接收方用每个站点的特定码片和复合信号相乘进行检验即可，若为1则该站点发了信号1.若为-1则该准点发了信号0，若为0则该站点没发信号。为何不怕复合产生干扰？仔细理解正交公式A·A=1 A·B=0复合：(A+B)检验：A·(A+B)=A·A+A·B=1同理，多个叠加也是如此。2.5 数字传输系统(1)早期数字传输系统在早期电话网中，从市话局到用户电话机的用户线是采用最廉价的双绞线电缆，而长途干线采用的是频分复用 FDM 的模拟传输方式与模拟通信相比，数字通信无论是在传输质量上还是经济上都有明显的优势目前，长途干线大都采用时分复用 PCM 的数字传输方式脉码调制 PCM 体制最初是为了在电话局之间的中继线上传送多路的电话(2)早期数字传输系统的缺点早期数字传输系统的缺点：速率标准不统一：多路复用的速率体系有两个互不兼容的国际标准，北美和日本的T1速率（1.544Mbit/s）和欧洲的E1速率（2.048Mbit/s）不是同步传输1988年美国首先推出了一个数字传输标准，叫做同步光纤网(SONET)。同步光纤网(SONET)：各级时钟都来自一个非常精确的主时钟，为光纤传输系统定义了同步传输的线路速率等级结构ITU-T以美国标准SONET为基础，制定出国际标准同步数字系列(SDH)同步数字系列(SDH)：由sonet为基础发展的国际标准2.6 宽带接入技术(1)ADSL技术ADSL技术：非对称数字用户线，将原有的模拟电话线进行改造，使其能够承载宽带业务将0-4k的低端频谱留给电话使用，将剩余部分给宽带使用，其中上行带宽小于下行带宽传输距离：与数据率和用户线的线径（粗细）有关传输速度：与实际用户线的信噪比密切相关数据率：采用自适应调制技术使用户线能够传输尽可能多的数据，受环境和线路条件影响较大特点：上行和下行带宽不对称、需要在用户线两端各安装一个调制解调器(2)第二代ADSL第二代ADSL：得到更高的数据率，采用无缝速率自适应技术，可在运营中不中断通信和不产生误码的情况下，自适应的调整数据率光纤同轴混合网（HFC）：是目前覆盖面较广的有线电视网，采用模拟技术，频分复用，主干部分使用光纤，入户部分使用同轴电缆(3)FTTx技术FTTx技术：是一种实现宽带居民接入网的方案，代表多种宽带光纤接入方式无源光网络PON：为有效利用光纤资源，在光纤干线和用户之间使用无源光网络PON。无源光网络无须配备电源，长期运行和管理成本低。最流行的无源光网络是以太网无源光网络EPON和吉比特无源光网络GPON数据交换方式正常的话两两连接需要n(n-1)/2条线路，显然不现实。我们需要一个交换设备减少线路的复杂。例如：局域网：交换机广域网：路由器交换是通过某些交换中心将数据进行集中和传送。传输线路为各个用户共用，从而大大节省通信线路，降低系统费用。数据报就是我们讲的分组交换。它是无连接的方式。虚电路是模拟电路交换，但是它是逻辑上的电路，不是物理上真的连接了。过程和电路交换一样，三部分建立连接、数据传输、释放连接。它是有连接的方式。物理层设备(1)中继器诞生原因：由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，因此会导致接收错误。中继器的功能： 对信号进行再生和还原，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。==注意，是数字信号，且原理是再生。==中继器的两端：两端的网络部分是网段(A类、B类、C类、D类)，而不是子网，适用于完全相同的两类网络的互连，且两个网段速率要相同。两端可连相同媒体，也可连不同媒体。中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据。中继器两端的网段一定要是同一个协议。（中继器不会存储转发，傻）5-4-3规则：网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障。最多5个网段5个网段内最多4个物理层设备最多三个段可以连接计算机。与放大器对比 放大器放大的是模拟信号放大器原理是将衰减信号放大而不是再生(2)集线器（多口中继器）因为它是广播方式的，所以连接在集线器上的主机在一个冲突域内。==连在集线器上的工作主机平分带宽==]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络【一】]]></title>
    <url>%2Fposts%2Fd7fdb269%2F</url>
    <content type="text"><![CDATA[第一章、概述1.1绪论网络分类电信网络：提供电话、电报及传真等服务有线电视网络： 向用户传送各种电视节目计算机网络：使用户能在计算机之间传送数据文件计算机网络最重要的功能连通性：上网用户之间可以相互交换信息资源共享：信息共享、软件共享、硬件共享网络的网络网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（因特网 Internet）是全球范围的互连网。因特网发展的三个阶段第一阶段：从单个网络 ARPANET 向互联网发展的过程。1983 年 TCP/IP 协议成为 ARPANET 上的标准协议。第二阶段：建成三级结构的因特网：主干网、地区网和校园网（或企业网）。第三阶段：形成多层次的ISP（Internet Service Provider 因特网服务提供者）结构的因特网互联网、因特网、万维网互连网：能彼此通信的设备组成的网络因特网：安装了 TCP/IP协议、拥有一个公网地址万维网：应用层使用HTTP协议互联网的组成边缘部分：有所有连接在因特网上的主机组成。这部分由用户直接使用，用来进行通信和资源共享。核心部分 : 由大量的网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。处于边缘部分的用户通信方式计算机之间通信：主机A的某个进程和主机B上的另一个进程进行通信客户服务器方式（C/S方式）：即Client/Server方式。（客户是服务的请求方，服务器是服务的提供方）对等方式（P2P方式）：即Peer-to-Peer方式。（对等连接中的每一个主机既是客户又同时是服务器）p2p下载核心部分的交换技术电路交换 的三个阶段：建立连接——通话——释放连接 在通话时，两用户之间占用端到端的资源，而由于绝大部分时间线路都是空闲的，所以线路的传输速率往往很低。N 部电话机两两相连，需N(N-1)/2对电线电路交换的电话网很适合于电话通信正在通信的电路中有一个交换机或有一条链路被炸毁，则整个通信电路就要中断改用其他迂回电路，必须重新拨号建立连接由于计算机数据的突发性，使用电路交换传送计算机数据效率低分组交换 在发送端，先把较长的报文划分成较短的、固定长度的数据段。每一个数据段前面添加上首部(包头)构成分组(包) 分组交换网以“分组”作为数据传输单元依次把各分组发送到接收端每一个分组的首部都含有地址等控制信息。分组交换网中的结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机。利用这种存储转发方式，最后分组到达最终目的地。接收端收到分组后剥去首部还原成数据段。最后，在接收端把数据段恢复成为原来的报文。假定分组在传输过程中没有出现差错，在转发时也没有被丢弃。路由器把收到的分组先放入缓存（暂时存储）检查首部，查找转发表，找出到某个目的地址应从哪个端口转发。把分组送到适当的端口转发出去在路由器中的输入和输出端口之间没有直接连线分组交换的优点高效：动态分配传输带宽，对通信链路是逐段占用灵活：以分组为传送单位来查找路由迅速：不必先建立连接就能向其他主机发送分组可靠：保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性报文交换 报文交换的单位是报文，报文携带有目标地址，源地址等信息，报文交换在交换节点采用的是存储转发的传输方式。简单的理解就是：整个报文会先传到相邻的节点，全部存储下来再查找转发报文交换的时延较长，从几分钟到几小时不等 现在报文交换已经很少有人使用了若要连续传送大量的数据，且其传送时间远大于连接建立时间，则电路交换的传输速率较快报文交换和分组交换不需要预先分配传输带宽，在传送突发数据时可提高整个网络的信道利用率由于一个分组的长度往往远小于整个报文的长度，因此分组交换比报文交换的时延小，同时也具有更好的灵活性1.2计算机网络的类别计算机网络最简单的定义：计算机网络是一些互相连接的、自治的计算机的集合因特网(Internet)是“网络的网络”(1) 按网路的作用范围划分广域网 WAN (Wide Area Network)：作用范围通常为几十到几千公里城域网 MAN (Metropolitan Area Network)：作用距离约为 5 ~ 50 千米，例如一般跨越几个截取甚至整个城市局域网 LAN (Local Area Network) ：局限在较小的范围（如 1 公里左右），例如一般比如学校或者工厂企业，相对较小的范围个人区域网 PAN (Personal Area Network) ：范围很小，大约在 10 米左右(2) 按照网络的使用者进行分类公用网：共用网是电信公司出资建造的大型网络，公用的意思就是所有愿意按电信公司规定缴纳费用的人都可以使用这种网络，也可以称为公众网专用网：这是某个部门为了满足本单位特殊业务工作的需要而建造的网络，这种网络不向本单位以外的人提供服务，例如军队，银行，电力等等(3) 补充接入网的概念接入网 AN (Access Network)，它又称为本地接入网或居民接入网它并不属于互联网的核心部分，也不属于互联网的边缘部分接入网是从某个用户端系统到互联网中的第一个路由器（也称为边缘路由器）之间的一种网络接入网只是起到让用户能够与互联网连接的“桥梁”作用。很多接入网还是属于局域网1.3计算机网络的性能(1)计算机网络的性能指标速率：指连接在计算机网络上的主机在数字信道上传送数据的速率。b/s（bps） 如100M以太网，实际是指100Mb/s。往往是指额定速率或标称速率。通常把最高数据传输速率成为带宽带宽：数字信道所能传送的最高速率。b/s（bps）在电子学领域里，带宽是用来描述频带宽度的。(Hz)但是在数字传输方面，也常用带宽来衡量传输数据的能力。(b/s)用它来表示单位时间内（一般以“秒”为单位）传输数据容量的大小，表示吞吐数据的能力。这也意味着，宽的带宽每秒钟可以传输更多的数据。宽带是运营商给你提供的一条接入互联网的通道带宽是运营商给你提供通道的理论最大速度我认为。速率和带宽：就像是先介绍物理量速度，然后告诉你你骑车的速度为XXX有人认为，速率就是设备发出数据的速率，带宽就是线路上跑的数据在单位时间上的数量。有人认为，如果将带宽就相当于马路的宽度，传输速率相当于汽车所能达到的速度的话，网速是设备的网络通讯速度。王道计算机的解释（1）“带宽”原本指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz）。（2）计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。==一般就是指网络设备所支持的最高速度，在线路上都是以电磁波形式传输，就是光速。==吞吐量：单位时间内通过某个网络（或信道、接口）的实际数据量。其绝对上限值等于带宽。包含全部上传和下载的流量。上图中，计算机A同时浏览网页、在线看电影、向FTP上传文件。A计算机的吞吐量就是全部上传和下载速率的总和，即30+40+20=90（Kb/s）。时延：数据（一个报文或分组、甚至比特）从网络（或链路）的一段传送到另一端的时间，也称延迟。①发送时延：主机或路由器发送数据帧所需的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。也成传输时延。发送时延 = 数据帧长度（b） / 信道带宽（b/s）②传播时延：电磁波在信道中传输一定距离所需划分的时间。传播时间 = 信道长度（m） / 传输速率（m/s）电磁波在自由空间的传输速度是光速，即3.0X10^ 5km/s。电磁波在网络中的传输速度比在自由空间中低一些：在铜线中传播速率约为2.3X10^ 5km/s，在光纤中的传播速率约为2X10^5km/s。电磁波在指定介质的传播速率是固定的，从公式看出，信道长度固定了，传播时延也就固定了，我们没有办法改变。③ 处理时延：主机或路由器处理收到的分组所花费的时间。路由器或主机在收到数据包时，要花费一定时间进行处理，例如分析数据包的首部、进行首部差错检验，查找路由表为数据包选定准发接口，这就产生了处理时延。④ 排队时延：分组在输入队列中等待处理的时间加上其在输出队列中等待转发的时间。分组在经过网络传输时，要经过很多的路由器。但分组在进入路由器后要先在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发，这就产生了排队时延。排队时延的长短往往却决于网络当时的通信量，当网络的通信量很大时会发生排队溢出，是分组丢失。综上：总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延。注：对于高速网络链路，提高的是发送速率而不是传播速率。时延带宽积：传播时延 * 带宽。表示链路的容量。也是第一个比特到达终点的时候，发送端发了多少比特。往返时间RTT：从发送方发送数据开始，到发送发收到接收方的确认为止，所花费的时间。往返传播时延=传播时延 * 2PS，往返时间RTT它不管发送时延末端处理时间利用率：某信道有百分之几是被利用的（有数据通过）。而信道或网络利用率过高会产生非常大的时延。当前时延=空闲时时延/（1-利用率）U使网络利用率，D表示网络当前延时，D。表示空闲时的时延。当网络的利用率接近最大值1时，网络的时延趋于无穷大。一般在计算机领域，K、G、T这种都是1024进制。而通信领域都是1000进制计算机网络的性能指标https://www.cnblogs.com/yangmingxianshen/p/7789121.html计算机网络中，传输速率，带宽，信道容量有何区别和联系？：https://www.zhihu.com/question/285840051/answer/452538077传输速率这个词，顾名思义，以某个东西作为单位，来描述单位时间内传输某个东西的数量。比如下载软件上面，常常显示的 5.5MB/s，就是以字节(Byte) 单位表示的传输速率。计算机里以Byte作为存储的最小单位，所以下载时顺势就用了这个单位，显得直观。一般而言，我们用bit来描述，传输时携带的信息量。另一常见，且容易搞混的，是波特率这个词。bit率是指，单位时间内传输过来的信息量。baud率则是指单位时间内传输过来的符号量。这里有个弯要绕过来，因为常识层面大多数的信息都是以01两种符号来传输，所以两者在数值层面常常是相等的，相等自然弄混。实际上符号量 可以不等于信息量。举个例子，评价里常常有 优 良 中 差 4个选项，每个字相当于1个符号。用一个字就可以表达。但如果换成0跟1两种符号来表示，那么优良中差是4种状态，只能表示成00，01，10，11 ，那么每种状态，都用了两个位置来表示。这种情况下，1个字 = 2bit。带宽带宽常常作为bit率的同义词，常说的百兆带宽，就是 100Mbit/s。但为啥会有这么一个不明觉厉的称呼呢？假设有一个东西，它跑的越快，身材就越宽。宽到比跑道的宽度还要大，那么就跑不了了。常识里没有这种东西。但是在通讯的领域是有的。我们通信最常用的就是用高低电平来表示0和1，那么实际上传输的就是类似长城形状的锯齿纹路。由傅里叶变换的结论，能够推出，你传的越快，相当于，那个矩形纹路越窄，那么在频域中，你这个占用的频谱就会越宽。一旦你的频谱超过了容许你使用的最大频带，那么你的数据速度就不能再往上加了。这个频带的宽度，就被称为带宽。然而在常见的有线网络中，这个线为线头的AB两端所独享，整条线的可用宽度都是你的，自然是海阔凭鱼跃，天高任鸟飞，那么你速度多少，开的带宽自然就是多少，两者混起来也是自然。把城市的道路看成网络，道路有双车道、四车道也许是八车道，人们驾车从出发点到目的地，途中可能经过双车道、四车道也许是单车道。在这里，车道的数量好比是带宽，车辆的数目就好比是网络中传输的信息量。我们再用城市的供水网来比喻，供水管道的直径可以衡量运水的能力，主水管直径可能有2m，而到家庭的可能只有2cm。在这个比喻中，水管的直径好比是带宽，水就好比是信息量。使用粗管子就意味着拥有更宽的带宽，也就是有更大的信息运送能力。这个涉及到频谱效率的问题。频谱效率是指最大的传输速率除以系统频带宽度，单位为bps/Hz。频谱效率是一个0到1之间的数。最大为1，也就是说，最大的传输速率，即你所谓的带宽为系统所占的频带宽度。对于二进制，波特率等于比特率。但是在无线通信中，由于传输信道不理想，频谱效率不可能为1。为了对抗传输中造成的干扰和衰落，通常要对信号进行编码和调制，这样在提高通信可靠性的同时就会降低频谱效率，所以实际的信息传输速率要远小于系统频带宽度。频带宽度与通信带宽的关系？https://www.zhihu.com/question/51949948/answer/128291990终于明白带宽和频率的关系https://www.cnblogs.com/licha/p/11309272.html信号频率也叫频率信号。通常是由于信号的带宽而起的作用。信号带宽是信号频谱的宽度，也就是信号的最高频率分量与最低频率分量之差，譬如，一个由数个正弦波叠加成的方波信号，其最低频率分量是其基频，假定为f=2kHz，其最高频率分量是其7次谐波频率，即7f =7×2=14kHz，因此该信号带宽为7f - f =14-2=12kHz。信道带宽则限定了允许通过该信道的信号下限频率和上限频率，也就是限定了一个频率通带。比如一个信道允许的通带为1.5kHz至15kHz，其带宽为13.5kHz，上面这个方波信号的所有频率成分当然能从该信道通过，如果不考虑衰减、时延以及噪声等因素，通过此信道的该信号会毫不失真。然而，如果一个基频为1kHz的方波，通过该信道肯定失真会很严重；方波信号若基频为2kHz，但最高谐波频率为18kHz，带宽超出了信道带宽，其高次谐波会被信道滤除，通过该信道接收到的方波没有发送的质量好；那么，如果方波信号基频为500Hz，最高频率分量是11次谐波的频率为5.5kHz，其带宽只需要5kHz，远小于信道带宽，是否就能很好地通过该信道呢？其实，该信号在信道上传输时，基频被滤掉了，仅各次谐波能够通过，信号波形一定是不堪入目的。”带宽”来表示信道的数据传输速率编辑因此通信信道最大传输速率与信道带宽之间存在着明确的关系，所以人们可以用“带宽”去取代“速率”。例如，人们常把网络的“高数据传输速率”用网络的“高带宽”去表述。因此“带宽”与“速率”在网络技术的讨论中几乎成了同义词。信号频率也叫频率信号。通常是由于信号的带宽而起的作用。由信号频谱图可以观察到一个信号所包含的频率成分。把一个信号所包含谐波的最高频率与最低频率之差，即该信号所拥有的频率范围，定义为该信号的带宽。因此可以说，信号的频率变化范围越大，信号的带宽就越宽。==总结：====速率：信道上的传输速率。====带宽：理想状态下新到传输的最高速率。====吞吐量：某主机所有信道上的传输速率之和====时延：总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延。====发送时延 = 数据帧长度（b） / 信道带宽（b/s）====传播时间 = 信道长度（m） / 传输速率（m/s）====处理时延 + 排队时延一般忽略====注：对于高速网络链路，提高的是发送速率而不是传播速率。一般都是电磁波传输，光速没法提高。====时延带宽积：传播时延 * 带宽。表示链路的容量。也是第一个比特到达终点的时候，发送端发了多少比特。====往返时间RTT：从发送方发送数据开始，到发送发收到接收方的确认为止，所花费的时间。====往返传播时延=传播时延 * 2====PS，往返时间RTT它不管发送时延====末端处理时间====利用率：某信道有百分之几是被利用的（有数据通过）。而信道或网络利用率过高会产生非常大的时延。====有数据通过的时间/总时间====当前时延=空闲时时延/（1-利用率）==(2)计算机网络的非性能指标费用质量标准化可靠性可扩展性与可升级性易于管理和维护1.4计算机网络的体系结构相互通信的两个计算机系统必须高度协调工作才行，而这种“协调”是相当复杂的，“分层”可将庞大而复杂的问题，转化为若干较小的局部问题，更易于研究和处理。法律上的国际标准 OSI 并没有得到市场的认可，非国际标准 TCP/IP 现在获得了最广泛的应用。TCP/IP 常被称为事实上的国际标准(1)协议和划分层次网络协议简称协议(protocol) ，为进行网络中的数据交换而建立的规则、标准或约定。是通信双方必须严格遵守的规则，协议精确地规定在网络通信中使用的各种控制信息、数据格式以及同步问题网络协议的组成要素语法：数据与控制信息的结构或格式语义：需要发出何种控制信息，完成何种动作以及做出何种响应同步：事件实现顺序的详细说明网络需要多少协议呢？一个显然不够.网络中采用的方法是把各种通信相关的问题划成多个子问题，然后为每个子问题设计不同的协议.对于非常复杂的计算机网络协议，结构应该是层次式的各个层次之间的关系下层为上层提供服务； 下层向上层屏蔽工作细节； 相邻层次之间通过接口相互衔接； 当某一层的功能发生变化时，只要接口不变，便不会影响到其他层的正常工作 ； 纵向真实的传输；协议和服务关系1、协议的实现保证了能够向上一层提供服务。本层的服务用户只能看见服务而无法看见下面的协议。下面的协议对上面的服务用户是透明的。2、协议是“水平的”，即协议是控制两个对等实体进行通信的规则。但服务是“垂直的”，即服务是由下层通过层间接口向上层提供的。(2)几种网络协议体系结构首先要提的是 OSI 七层协议体系结构，其概念是比较完整的，但是它即复杂又不使用接着就是 TCP/IP 体系结构，它现在却得到了非常广泛的应用但是从实质上将， TCP/IP 只有最上面的一层，是因为下面的网络接口层并没与什么具体内容所以在下面我们采用一种折中的方式，那就是综合 OSI 和 TCP/IP 的优点采用一种只有五层协议的体系结构简单说明一下这五层结构中，每一层大概是做什么的，其每一部分都会花费一章的篇幅来进行详细的解释，这里有个印象就可以了，下面我们从上层到底层来说(1) 应用层应用层是体系结构中的最高层。应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。这里的进程就是主机中正在运行的程序。对于不同的网络应用需要不有不同的应用层协议。在互联网的应用层协议很多，如域名 DNS，支持万维网应用的HTTP 协议，支持电子邮件的 SMTP 协议，等等。我们把应用层的数据单元称为报文(messgae)。(2) 运输层运输层的任务就是负责向两台主机中进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。所谓通用的，是指并不针对某个特定网路应用，而是多种应用可以使用同一个运输层服务。由于一台主机可以同时运行多个进程，因此运输层有复用和分用的功能。复用就是多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付给上面应用层的相关进程。运输层主要有下面两种协议：传输控制协议TCP（Transmission Control Protocol）——提供面向连接的、可靠的数据传输服务，其数据传输的单位是报文段(segment)。用户数据报协议 UDP（User Datagram Protocol）——提供无连接的尽最大努力（best-effort）的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是用户数据报(3) 网络层网络层负责为分组交换网上的不同主机提供通信服务。 在发送数据时，网络层把运输层产生的报文段或者用户数据报封装成分组或者包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫作IP数据报，或简称数据报。 请注意：不要将运输层的 “用户数据报 UDP” 和网络层的 “IP数据报” 弄混，此外，无论哪一层传输的数据单元，都可以笼统的用”分组”来表示。 网络层的另一个任务就是选择合适的路由，是源主机运输层所传下来的分组，能够通过网络中的路由器来找到目的主机。互联网是有大量的异构（heterogeneous）网络来通过路由器（Router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议IP（Internet Protocol）和许多路由选择协议, 因此互联网的网络层也叫作网际层或IP层。(4) 数据链路层数据链路层通常简称为链路层。我们知道，两台主机之间的数据传输，总是在一段一段的链路上传送的, 这就需要使用专门的链路层的协议。在两个相邻结点之间传送数据时，数据链路层量网络层交下来的IP数据报封装成帧(frameing)，在两个相邻节点间的链路上传送帧，每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错信息等）在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始到哪个比特结束，这样数据链路层在收到一个帧后，就可从中提取数据部分，上交到网络层。控制信息还能使接收端能够检测到所收到的帧中有无差错。如发现有差错，数据链路层就简单的丢弃了这个出了差错的帧，以免继续在网络传输下去白白的浪费资源。如果需要改正数据在数据链路层传输时出现的差错(这就是说,数据链路层不仅要检错,还要纠错)， 那么就可以采用可靠数据传输协议来纠正出现的差错。这种方法会使数据链路层的协议复杂些。(5) 物理层在物理层上所传数据的单位是比特(bit)。发送方发送1或者0时，接收方应该接收相同的1或者0，因此物理层要考虑用多大的电压代表”1”或者”0”， 以及接收方如何识别发送方所发出的比特。物理层还要确定连接电缆的插头应当有多少根引脚以及各引脚如何连接。当然解释比特代表的意思，就不是物理层的任务。请注意，传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆、无线信道等，并不是物理层协议之内而是在物理层协议的下面。因此也有人把物理层当做第0层。在互联网所使用的的各种协议中，最重要的和最著名的就是TCP和IP两个协议。现在人们经常提到的TCP/IP并不一定是单指TCP和IP两个具体的协议，而往往是表示互联网所使用的的整个TCP/IP协议族(Protocol suite)。(6) 补充：① OSI 参考模型把对等层次之间传送的数据单位称为该层的协议数据单元 PDUPDU (Protocol Data Unit)：协议数据单元，是一个数据单位② OSI 把层与层之间交换的数据的单位称为服务数据单元 SDU (Service Data Unit)③ 各层协议实际上就是在各个对等层之间传递数据时的各项规定④ 协议是 “水平的”，即协议是控制对等实体之间通信的规则⑤ 服务是 “垂直的”，即服务是由下层向上层通过层间接口提供的(7)实体、协议、服务和服务访问点实体(entity) 表示任何可发送或接收信息的硬件或软件进程协议是控制两个对等实体进行通信的规则的集合在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务要实现本层协议，还需要使用下层所提供的服务下面的协议对上面的服务用户是透明的协议是“水平的”，即协议是控制对等实体之间通信的规则服务是“垂直的”，即服务是由下层向上层通过层间接口提供的同一系统相邻两层的实体进行交互的地方，称为服务访问点 SAP【计算机网络】学习笔记，第一篇：概述（谢希仁版）]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统概念]]></title>
    <url>%2Fposts%2F531663ae%2F</url>
    <content type="text"><![CDATA[什么是操作系统?操作系统是系统软件，是一组控制和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序集合。什么是死锁？死锁（Deadlock）,是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种状态时，若无外力作用，它们都将无法再向前推进。即：如果一组进程中，每个进程都无限等待被该组进程中另一进程所占有的资源，因而永远无法得到的资源，这种现象称为进程死锁，这一组进程就称为死锁进程。操作系统的基本特征？并发、共享、虚拟和异步并行性：两个或多个事件在同一时刻发生并发性：两个或多个事件在同一时间间隔内发生操作系统的功能？处理机管理功能存储器管理功能设备管理功能文件管理功能用户接口(1)处理机管理功能①进程控制：为作业创建进程、撤销已结束的进程，以及控制进程在运行过程中的状态转换②进程同步：为多个进程(含线程)的运行进行协调协调方式：互斥和同步③进程通信：用来实现在相互合作的进程之间的信息交换；④进程调度：作业和进程的状态切换，包括作业调度和进程调度(2)存储器管理功能①内存分配：为每道程序分配内存空间，提高存储器的利用率，允许正在运行的程序申请附加的内存空间；②存储保护：确保每道用户程序都只在自己的内存空间中运行，彼此互不干扰；③地址映射(变换)：进程的逻辑地址到内存物理地址的映射。④内存扩充：用虚拟存储技术解决内存容量不足的问题；(3)设备管理功能①缓冲管理：在 I/O 和 CPU 之间引入缓冲，匹配CPU和外设的速度，提高两者的利用率和并行操作程度；缓冲区机制包括：单缓冲机制、双缓冲机制、公用缓冲池机制②设备分配：根据用户请求的设备类型和采用的分配算法，对设备进行分配③设备处理：实现 CPU 与设备控制器之间的通信。(4)文件管理功能①文件存储空间的管理：为文件分配外存空间,提高外存的利用率，并能有助于提高文件系统的运行速度;②目录管理：为文件建立一个目录项,并对众多的目录项加以有效组织，实现方便的按名存取，能实现文件共享，提供快速的目录查询手段。③文件读写管理和保护：对外存中的文件进行读写，提供防护(5)用户接口①命令接口（用户直接使用）：联机用户接口、脱机用户接口联机用户接口：由一组磁盘操作命令和命令解释程序组成脱机用户接口：由一组作业控制语言JCL组成②程序接口（用户通过程序间接使用）：让用户程序在执行中访问系统资源，是用户程序取得 OS 服务的唯一途径，有时候也叫做系统调用③图形用户接口死锁产生的原因？==1、竞争不可抢占性资源引起死锁====2、竞争消耗性资源资源引起死锁====3、进程间推进顺序非法==产生死锁的必要条件？==互斥条件 :====请求和保持条件:====不可剥夺条件:====环路等待条件==死锁的解决方法？1、预防死锁2、避免死锁3、检测死锁4、 解除死锁同步应该遵循的规则?==空闲让进====忙则等待====有限等待====让权等待==程序并发执行时的特征==间断性====失去封闭性====不可再现性==程序顺序执行时的特征(1) 顺序性(2) 封闭性(3) 可再现性进程进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。进程同步的主要任务：使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性。结构性(结构特征)：进程实体=程序段+进程控制块(PCB)+相关的数据段动态性进程：进程实体的一次执行过程，有生命周期。程序：程序是一组有序指令的集合，是静态的概念。动态性是进程最基本的特性并发性多个进程实体同存于内存中，在一段时间内同时运行，可以并发。程序不能并发执行。独立性：进程实体是一个能独立运行、独立分配资源和独立接受调度的基本单位，而程序则不是。异步性：进程按各自独立的、不可预知的速度向前推进。 引起创建进程的事件如下① 用户登录。② 作业调度。③ 提供服务。④ 应用请求。虚拟存储技术定义：所谓虚拟存储器，是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统，其逻辑容量由内存容量和外存容量之和决定，其运行速度接近内存，成本接近外存。（1）==多次性==（2）==对换性==（3) ==虚拟性==SPOOLing技术事实上，当系统中引入了多道程序技术后，可以利用其中的一道程序，来模拟脱机输入时的外围控制机的功能，把低速I/O设备上的数据传送到高速磁盘上，再利用另一道程序来模拟脱机输出时外围控制机的功能，把数据从磁盘上传送到低速输出设备上，这样，便可在主机的直接控制下，实现脱机输入、输出的功能。此时的外围操作与CPU对数据的处理同时进行，我们把这种在联机情况下实现的同时外围操作称为SPOOLing（Simultaneaus Periphernal Operations On-Line），或称为假脱机操作。SPOOLing系统的组成：① 输入井和输出井，这是在磁盘上开辟的两个大存储空间。输入井是模拟脱机输入时的磁盘设备，用于暂存I/O设备输入的数据，输出井是模拟脱机输出时的磁盘，用于暂存用户程序和输出数据。② 输入缓冲区和输出缓冲区，缓和CPU与磁盘之间速度不匹配，在内存中开辟的两个缓冲区，输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井，输出缓冲区用于暂存从输出井送来的数据，以后再传送给输出设备。③ 输入进程SPi和输出进程SPo，利用两个进程来模拟脱机I/O时的外围控制机，其中，进程SPi模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲区再送到输入井，当CPU需要输入数据时，直接从输入井读入内存；进程SPo模拟脱机输出时的外围控制机，把用户要求输出的数据先从内存送到输出井，待输出设备空闲时，再将输出井中的数据经过输出缓冲区送到输出设备上。SPOOLing系统主要有如下的特点① 提高了I/O速度，对数据所进行的I/O操作，已从对低速的I/O设备进行I/O操作，演变为对输入井或输出井中数据的存取，如同脱机输入输出一样，提高了I/O速度，缓和了CPU与低速I/O设备之间速度不匹配。② 将独占设备改造为共享设备，因为在SPOOLing系统中，实际上并没有任何进程分配设备，而只是在输入井或输出井中为进程分配一个存储区和建立一张I/O请求表，这样，便把独占设备改造为共享设备。③ 实现了虚拟设备功能，宏观上，虽然是多个进程在同时使用一台独占设备，而对于每个进程而言，他们都会认为自己是独占了一个设备，当然，只是逻辑上的设备，SPOOLing系统实现了将独占设备变换为若干个对应的逻辑设备的功能。利用SPOOLing技术，可以将独占设备打印机改造为一台供多个用户共享的设备，从而提高设备的利用率，也方便了用户。当用户进程请求打印输出时 ，SPOOLing系统统一为它打印输出，但是并不真正立即把打印机分配给该用户进程，而只为它做两件事。① 由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据送入其中。② 输出进程再为用户进程申请一张空白的用户请求打印表，并将该用户的打印要求填入其中，再将该表挂到请求打印队列上。如果还有进程要求打印输出，系统仍可以接受该请求，也同样为该进程做上述两件事情。如果打印机空闲，输出进程将从请求打印队列的队首取出一张请求打印表，根据表中的要求打印数据，从输出井传送到内存缓冲区，再由打印机进行打印。打印完后，输出进程再查看请求打印队列中是否还有等待打印的请求表，若有，又取出队列中的第一张表，继续打印，直至请求打印队列为空，输出进程才将自己阻塞起来，仅当下次再有打印请求时，输出进程才被唤醒。进程调度进程调度是控制、协调进程对CPU的竞争,即按一定的调度算法从就绪队列中选中一个进程，把CPU的使用权交给被选中的进程一个作业，从进入系统并驻留在外存的后备队列上开始，直至作业运行完毕，可能要经历下面三级调度高级调度(High Scheduling，作业调度)作业调度也即高级调度，这个阶段可以看作是准备阶段。主要任务是按照一定的规则从外存上处于后备队列的作业中挑选一个或多个作业，为其分配内存，建立 PCB（进程） 等，使它们具备竞争处理机的能力。这个阶段进程的状态变化是：无 –&gt; 创建态 –&gt; 就绪态中级调度(Intermediate-Level Scheduling，提高内存使用率)内存调度也即中级调度，这个阶段可以看作是优化阶段。主要任务是将暂时不能运行的进程对换到外存中，使它们挂起；而当挂起的进程具备运行条件时，它们会被重新对换回内存，得到激活。这个阶段的主要目的是提高内存利用率和系统吞吐量。这个阶段进程的状态变化是： 静止就绪态 –&gt; 活动就绪态，静止阻塞态 –&gt; 活动阻塞态低级调度(Low Level Scheduling，进程调度)进程调度即低级调度，这个阶段让进程真正运行起来。主要任务是按照某种算法，从就绪队列中选取一个进程，分配处理机给它。进程调度是最基本、次数最频繁的阶段。这个阶段进程的状态变化是： 就绪态 –&gt; 活动态线程（1）线程的引入首先回忆一下为什么会有进程 —— 在以前，程序是串行执行的，为了让多道程序并发执行，引入了进程。进程虽然显著提高了资源利用率和系统吞吐量，满足了并发的需求，但是这种并发能不能做得更好呢？事实上，进程既是一个携带资源的独立单位，也是独立调度的基本单位，因此，在进程的创建、撤销和切换时，系统必须为之付出较大的时间空间开销（没办法“轻装上阵”）。鉴于此，系统不宜设置过多的进程，也不宜频繁地切换进程，这对于并发来说是一种限制。如何解决这个问题呢？可以把进程看作是管理初创公司的老板，一开始人手不足，老板既要管理公司，也要四处奔跑沟通业务；但是一旦人手充足，那么老板仍然可以管理公司，只是沟通业务的工作就可以交给手下人去执行了。同理，我们可以考虑依然让进程作为拥有资源的独立单位，但是独立调度的基本单位则不再是进程，而是新引入的线程了。它将进程的两个基本属性分开，==作为调度和分派的基本单位==，==不同时作为拥有资源的单位==，以“轻装上阵”；对于拥有资源的基本单位，又不对之进行频繁切换。在多线程OS中，通常一个进程包括多个线程，每个线程是利用CPU的基本单位，是花费最小开销的实体。（2）进程和线程的比较进程是指在系统中正在运行的一个应用程序每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内比如同时打开QQ、Xcode，系统就会分别启动2个进程1个进程要想执行任务，必须得有线程（每1个进程至少要有1条线程）==线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行==比如使用酷狗播放音乐、使用迅雷下载电影，都需要在线程中执行1个进程中可以开启多个线程，每个线程可以并行（同时）执行不同的任务：进程 -&gt;车间，线程-&gt;车间工人 多线程技术可以提高程序的执行效率 比如同时开启3条线程分别下载3个文件（分别是文件A、文件B、文件C）同一时间，CPU只能处理1个线程，只有1个线程在工作（执行）多线程并发（同时）执行，其实是CPU快速地在多个线程之间调度（切换）如果CPU调度线程的时间足够快，就造成了多线程并行执行的假象。如果线程非常非常多,CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源每条线程被调度执行的频次会降低总结调度的基本单位引入线程后，调度的基本单位不再是进程，而是线程。线程能够独立运行，且切换的时候，代价远远小于进程切换的代价。同一进程不同线程的切换，不会引起进程的切换。执行的基本单位通常认为进程不再作为可执行的实体。也即，可以说进程处于“执行”状态，但其实指的是该进程的某个线程正在执行；**可以说进程处于“挂起”状态，但其实指的是该进程的所有线程都被挂起。其他同理。**并发性进程间仍然能够并发，不仅如此，一个进程中的多个线程间也能并发，不同进程中的线程也能够并发，大大提高了 OS 的并发性。资源资源依然掌握在进程手中。为了性能考虑，线程仅占有一点必不可少的资源（比如 TCB，程序计数器等）。那么如何访问其它资源呢？事实上，同一进程的线程共享该进程所拥有的资源。另外，这些线程还共享同一片内存地址空间，所以也可以方便地进行通信。独立性同一进程中的线程间独立性要比不同进程间独立性低很多。前者独立性高，因为要防止进程之间彼此干扰和破坏；后者独立性低，因为同一进程的多个线程通常需要协作完成任务，互相之间可访问程度相对来说会比较高。系统开销在创建和撤销进程时，系统需要分配或者回收 PCB，分配或者回收资源，所以需要付出一定的时空开销；但是线程的创建和撤销的时空开销则明显小很多，尤其是在同一进程内的线程创建和撤销，这种开销会更加地小。支持多处理机系统传统的单线程进程，即使处理机再多，一个进程也只能运行在一个处理机上；但是引入了线程后，一个进程的多个线程可以分配到多个处理机上、并行执行。访存页/段式==访问内存两次==，第一次是访问内存中的页表，从中找到指定页的物理块号，再将块号与页内偏移量W拼接，以形成物理地址，第二次访问时，才是从第一次所得的地址中获得所需数据分段存储方式的第一次访存是访问内存中的段表，第二次是访问内存中的目标单元。它也可以引入快表，若引入快表，则第一次访存有可能因为命中而得到避免在段页式系统中，为了获得一条指令或数据，需要==访问内存三次==，第一次访问时访问内存中的段表，从中取得页表始址，第二次访问是访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址，第三次访问才是真正的从第二次访问所得的地址中，取出指令或数据。设备独立性设备独立性（Device Independence）的概念——应用程序独立于具体使用的物理设备。算法英文调度算法FCFS 算法长作业有利、对短作业不利CPU 繁忙型作业有利，对 I/O 繁忙型作业不利短作业(进程)优先调度算法SJ(P)FSJF 算法的优点在于，它拥有“最短的”平均等待时间和平均周转时间对长作业是不利的。产生“饥饿”甚至“饿死”现象。高优先权优先（HPF，Highest Priority First）调度算法问题：用户将优先权设的较高，对其他进程不利！！短进程优先对长进程不利！！高响应比优先调度算法（HRF）等待时间相同的作业，则要求服务的时间愈短，其优先权愈高，——对短作业有利要求服务的时间相同的作业，则等待时间愈长，其优先权愈高， ——是先来先服务长作业，优先权随等待时间的增加而提高，其等待时间足够长时，其优先权便可升到很高， 从而也可获得处理机,——对长作业有利是一种折衷，既照顾了短作业，又考虑了作业到达的先后次序，又不会使长作业长期得不到服务。简单的时间片轮转法(RR—Round Robin)优点：公平。保证就绪队列中所有进程在一给定的时间内，均能获得一时间片的处理机执行时间缺点：紧迫任务响应慢。UNIX中采用：时间片+优先权==注意：先放入新到的进程，在放入时间片完的进程==多级反馈队列调度算法I.基于顺序搜索的动态分区分配算法首次适应算法（First Fit）循环首次适应算法（Next Fit）最佳适应算法（Best Fit）II.基于索引搜索的动态分区分配算法1.快速适应算法（分类搜索法） （Quick Fit）2.伙伴系统（buddy system）3.哈希算法页面调入算法==最佳置换算法OPT==先进先出FIFO置换算法==最近最久未使用（LRU）置换算法====最少使用置换算法LFU====CLOCK置换算法【NRU（Not Recently Used）算法】==磁盘调度① 先来先服务（FCFS, First Come First Service）② 最短寻道时间优先（SSTF，Shortest Seek Time First）③ 扫描（SCAN）算法④ 循环扫描（CSCAN）算法⑤ NStepSCAN算法⑥ FSCAN算法文件目录管理的基本要求是什么？文件目录管理的基本要求是：(1) 实现“按名存取”。这是目录管理的最基本的功能，也是文件系统向用户提供的最基本的服务。(2) 提高对目录的检索速度。通过合理组织目录结构的方法，可加快对目录的检索速度，从而提高对文件的存取速度。(3) 文件共享。在多用户系统中，允许多个用户共享一个文件，在外存中保留一份该文件的副本，供不同用户使用，以节省大量的存储空间。(4) 允许文件重名。系统应允许不同用户对不同文件采用相同的名字，以方便用换照自己的习惯给文件命名和使用文件。进程队列个数如果系统中有n个进程，运行队列中进程的个数最多为1个就绪队列中进程的个数最多为n-1个阻塞队列中进程的个数最多为n个全部在等待外部条件，无法执行进程通信进程通信指的是进程之间的信息的传播和交换。低级通信：进程之间的互斥和同步。信号量机制作为通信工具的缺点：(1)效率低 ；(2)通信对用户不透明。高级进程：通信是指用户可直接利用操作系所提供的一组通信命令，高效地传送大量数据的一种通信方式。特点：（1）使用方便操作系统隐藏了进程通信的细节，对用户透明，减少了通信程序编制上的复杂性。（2）高效的传送大量数据，利用通信原语实现。1. 共享存储进程 A 无法直接访问进程 B 的地址空间，反之亦然，所以提供一块可以供 AB 访问的共享空间。这块共享空间属于互斥的临界资源。1.1 基于数据结构各个进程共用某些数据结构，借以实现进程间的信息交换。比如共用一个长度为 10 的数组。这种共享速度慢、限制多，属于低级通信方式。1.2 基于存储区在内存中划出一块共享存储区，各个进程通过对这个共享区的读写交换信息、实现通信。数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，属于高级通信方式。2. 消息传递进程通过操作系统提供的“发送消息/接受消息”两个原语进行数据交换，而数据交换的基本单位是一个格式化的消息，该消息包括消息头和消息体。消息头包括：发送进程 ID，接受进程 ID，消息类型，消息长度等格式化的信息。2.1 直接通信方式发送进程发送消息之前，首先申请一个缓冲区，之后把消息复制到缓冲区，再通过发送原语把缓冲区发送给接受进程，缓冲区首先到达接受进程的消息缓冲队列队尾。接受进程通过接受原语读取队列消息，并复制到本地变量。2.2 间接通信方式也叫做信箱通信。发送进程发送的消息首先到达一个消息容器，接受进程再从消息容器中接受消息。3. 管道通信管道又名 pipe 文件，其实就是在内存中开辟一个大小固定的缓冲区。它采用的是半双工通信，一个时间段内只能实现单向的传输。另外，管道也是互斥的临界资源。管道写满的时候，写进程会被阻塞，直到读进程把数据读走；而管道空的时候，读进程会被阻塞，直到写进程把数据读入。这里要注意，管道与我们之前说过的生产者、消费者使用的缓冲区不同。写会一次性写完，读会一次性读完，不存在写一下、读一下的情况。进程通信，是指进程之间的信息交换，进程的互斥和同步，由于只能交换很少量的信息而被归结为低级通信，目前的高级通信机制可归结为三大类==① 共享存储器系统==相互通信的进程共享某些数据结构或共享存储区，进程之间能够通过这些空间进行通信，基于此，又可以分为如下两种类型：基于共享数据结构的通信方式，在这种通信中，要求诸进程共用某些数据结构，借此实现进程间的信息交换。基于共享存储区的通信方式，为了传输大量数据，在存储器中划出一块共享存储区，诸进程可通过对共享存储区中的数据的读或写来实现通信。==② 消息传递系统==进程间的数据交换是以格式化的消息为单位，程序员直接利用操作系统提供的一组通信命令（原语），不仅能实现大量数据的传递，而且还隐藏了通信的实现细节，使通信过程对用户是透明的，从而大幅减少通信程序编制的复杂性。==③ 管道通信系统==连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件，向管道（共享文件）提供输入的发送进程，以字符流形式将大量的数据送入管道；而接受管道输出的接受进程，则从管道中接受数据，由于发送和接受进程是利用管道进行通信的，因此叫做管道通信。管道通信需要具有三方面的协调能力：互斥（当一个进程正在对pipe执行读/写时，其他进程必须等待），同步（当写进程把一定数量的数据写入pipe，便去睡眠等待，到读进程取走数据后，再把它唤醒，当读进程读一个空pipe时，也应该睡眠等待，直到有数据写入管道，才将其唤醒），确定对方是否存在，只有确定了对方已存在时，才能进行通信。装入① 绝对装入方式如果在编译时知道程序驻留在内存的什么位置，那么，==编译程序将产生绝对地址的目标代码==，绝对装入方式按照装入模块中的地址，将程序和数据装入内存，装入模块被装入内存后，由于程序中的逻辑地址与实际内存地址完全相同，故不需要对程序和数据的地址进行修改。② 可重定位装入方式由于绝对装入方式只能将目标模块装入到内存中事先指定的位置，在多道程序环境下，编译程序不可能事先知道所编译的目标模块应放在内存的何处，因此，绝对装入方式只适用于单道程序环境，在多道程序环境下，所得到的目标模块的起始地址通常都是以0开始的，程序中的其他地址也都是相对于起始地址计算的，此时应采用可重定位装入方式，根据内存的当前情况，将装入模块装入到内存的适当位置。该方式会使装入模块中的所有逻辑地址与实际装入内存的物理地址不同，需要对数据地址和指令地址进行修改，通常把再装入时对目标程序中指令和数据的修改过程称为重定位，又因为地址变换通常是在装入时（第三步）一次完成的，以后不再变化，故称为静态重定位。第一步第二步，只是绝地地址，第三步进行转换映射。③ 动态运行时装入方式可重定位装入方式允许将装入模块装入到内存中任何允许的位置，故可用多道程序环境，但这种方式并不允许程序运行时在内存中移动位置，因为，程序在内存中的移动，意味着它的物理位置发生了变化，这就必须对程序和数据的地址进行修改后方能运行。然而，在运行过程中它在内存中的位置可能经常要改变，此时就应该采用动态运行时装入方式。动态运行时的装入程序在把装入程序装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址都仍是相对地址，为了使地址转换不影响指令的执行速度，需要重定位寄存器的支持。**重定位寄存器用于记录和更新装入模块当前的物理起始地址，逻辑地址只需要和这个物理起始地址相加即可得到物理地IO设备类型IO设备分配的数据结构① 设备控制表（DCT，Device Control Table）② 控制器控制表（COCT，Controller control table)③ 通道控制表（CHCT， Channel Control Table）④ 系统设备表（SDT，System device table）SDT查DCT，申请设备DCT查COCT，分配控制器COCT查CHCT，分配通道文件结构① 文件的逻辑结构，这是从用户观点出发所观察到的文件组织形式，是用户可以直接处理的数据及其结构，独立于文件的物理特性，又称为文件组织。② 文件的物理结构，又称为文件的存储结构，是指文件在外存上的存储组织形式，不仅与存储介质有关，还与外存分配方式有关。文件的物理结构和外存组织方法有关。在采用不同的分配方式时将形成不同的文件物理结构。连续分配方式对应顺序式文件结构；链接分配方式形成链接式文件结构；索引分配方式形成索引式文件结构。页表进程和程序比较（1）动态性是进程最基本的特征。这一方面在于进程是进程实体的执行过程，另一方面还表现在“它由创建而产生，由调度而执行，因得不到资源而暂停执行，以及由撤销而消亡”，即进程具有一定的生命周期。而程序只是一组有序指令的集合，并存放在某种介质上，本身并无运动的含义，故为静态实体。（2）并发性是进程的重要特征，同在内存中的多个进程实体能在同一时间内同时运行；而单单基于程序的概念和实体是不能实现并发执行的。（3）进程实体是一个能独立运行的基本单位，同时也是系统中独立获得资源和独立调度的基本单位。凡未建立进程的程序，都不能作为一个独立的单位参加运行。进程和线程比较（1）调度。传统的操作系统中，拥有资源和独立调度的基本单位都是进程；在引入线程的操作系统中，则把线程作为调度和分派的基本单位，并把进程作为资源拥有的基本单位，从而把传统进程的两个属性分开，使线程能够轻装上阵。（2）并发性。传统的操作系统只能在进程之间实现并发执行；引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程的多个线程之间亦可并发执行，从而提高了系统并发程度，并可更有效地使用系统资源和提高系统吞吐量。（3）拥有资源。不论是传统的操作系统，还是引入线程的操作系统，进程都是拥有资源的一个独立单位，它可以拥有自己的资源。一般来说，线程除拥有一点在运行中必不可少的资源（如程序计数器、一组寄存器和栈）外，其自身基本不拥有系统资源，而与同属同一进程的其它线程共享所属进程的代码段、数据段及系统资源。（4）系统开销。由于在创建或撤消进程时，系统均需为其分配或回收资源（如内存空间、I/O设备），所以操作系统所付出的开销将显著大于在创建或撤消线程时的开销。类似地，进程切换牵涉到整个当前进程CPU环境的保存及新被调度运行的进程的CPU环境的设置，而线程切换只需保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作，所以进程切换的开销也远大于线程切换的开销。此外，由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。特别地，对于只支持用户级线程的系统，线程的切换、同步及通信都无须操作系统内核的干预。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统【十四】]]></title>
    <url>%2Fposts%2F84ea5def%2F</url>
    <content type="text"><![CDATA[八、磁盘存储器的管理1、外存分配方式磁盘具有可随机访问的特性，故当利用磁盘存放文件时，具有很大的灵活性。在为文件分配外存空间时所要考虑的主要问题是：怎样才能有效的利用外存空间， 如何提高对文件的访问速度， 提高磁盘系统的可靠性。文件的物理结构和外存组织方法有关。在采用不同的分配方式时将形成不同的文件物理结构。连续分配方式对应顺序式文件结构；链接分配方式形成链接式文件结构；索引分配方式形成索引式文件结构。(1)连续分配连续分配要求为每个文件分配一组相邻接的盘块，一组盘块地址定义了磁盘上的一段线性地址。采用连续分配方式时，可把逻辑文件中的记录顺序地存储到邻接的各物理盘块中，这样所形成的文件结构称为顺序文件结构，这种分配方式保证了逻辑文件中的记录顺序与存储器中文件占用盘块的顺序的一致性。下图为连续分配方式（假设记录与盘块一样大）。如同动态分配分区分配一样，随着文件建立时空间的分配和文件删除时的空间回收，将使磁盘空间被分割成许多小块，这些小块的连续去已难以存储文件，此即外存的碎片，同样，可以使用紧凑的方法，将盘上所有的文件紧靠在一起，把所有的碎片拼成一大片连续的存储空间。连续分配的优点如下① 顺序访问容易，访问一个占有连续空间的文件非常容易。② 顺序访问速度快，因为由连续分配所装入的文件，其所占用的盘块可能是位于一条或几条相邻的磁道上，这是，磁头移动距离最少，这种对文件访问的速度使几种存储空间分配方式中最高的一种。连续分配的缺点如下① 要求又连续的存储空间，要为每个文件分配一段连续的存储空间，这样，便会产生许多外部碎片，严重地降低了外存空间利用率，定期紧凑会花费大量的机器时间。② 必须实现知道文件的长度，事先知道文件的长度，然后根据其大小，在存储空间中找出一块其大小足够的存储区，将文件装入，对于动态增长的文件非常低效。(2)链接分配如果将一个逻辑文件存储到外存上，并不要求为整个文件分配一块连续的空间，而是可以将文件装到多个离散的盘块中，这样就可以消除连续分配的缺点。采用链接分配方式时，可通过在每个盘块上的链接指针，将同属于一个文件的多个离散盘块链接成一个链表，把这样形成的物理文件称为链接文件。链接分配采取离散分配方式，消除了外部碎片，故而显著地提高了外存空间的利用率，并且对文件的增、删、改、查十分方便。链接方式可分为隐式链接和显示链接两种形式。链接结构的特点是每个物理块的最后一个字节中不能存放文件的信息，而是用来存放物理块之间的链接指针文件信息占用的第一块的物理地址登记在文件目录中，链接结构中每个物理块中的链接指针指出了文件信息存放的下一个物理块的地址。当某物理块中链接指针为“0”时，表示文件信息至本块结束。① 隐式链接， 在文件目录的每个目录项中，都须含有指向链接文件第一个盘块和最后一个盘块的指针。说明：第9个盘块指向第16个盘块，第16个盘块指向第1个盘块，第1个盘块指向第10个盘块，第10个盘块指向第25个盘块（结束块）。隐式链接分配的主要问题在于：其只适合于顺序访问，对随机访问的效率及其低效。此外，其可靠性较差，任何一个指针出现问题，都会导致整个链的断开。可以将几个盘块组成一个簇，然后以簇为单位进行分配，会减少查找指定块的时间，但是会增加内部碎片。② 显示链接，把用于链接文件各物理块的指针，显式的放在内存的一张链接表中该表称为文件分配表FAT(File Allocation Table)，该表在整个磁盘仅设置一张。说明：表的序号从0开始，直至N-1，N为盘块总数，在每个表项中存放链接指针，即下一个盘块号，在该表中，凡是属于某一文件的第一个盘块号，或者说是每一条链的链首指针所对应的盘块号，均作为文件地址被填入相应的文件的FCB(File Control Block)的物理地址字段中，由于查找记录的过程是在内存中进行的，因而提高了检索速度，减少了访问磁盘的次数，由于分配给文件的所有盘块号都在该表中，故把该表称为文件分配表FAT（File Allocation Table）。链接分配的问题如下：不能支持高效的直接存储（要对一个较大的文件进行直接存取，须首先在FAT中顺序地查找很多盘块号）；FAT需要占用较大的内存空间（由于一个文件所占用的盘块的盘块号是随机地分布在FAT中的，因而只有将整个FAT调入内存，才能保证FAT中找到一个文件的所有盘块号，当磁盘容量较大时，FAT占用的容量更大）FAT 的计算 ​①FAT技术在微软公司的早期MS-DOS中，所使用的就是12位的FAT12文件系统，后来为16位的FAT16文件系统 在Windows95和Windows98系统中，升级为32位的FAT32文件系统 Windows NT、 Windows 2000和Windows XP系统中又进一步发展为NTFS文件系统 这些文件系统都属于显式链接方法。早期MS-DOS系统的FAT系统中，引入了“卷”的概念，支持将一个物理磁盘分为四个逻辑磁盘，每个逻辑磁盘就是一个卷（或称为分区）每个卷都是一个能够被单独格式化和使用的逻辑单元一个卷中包含文件系统信息、一组文件和空闲空间每个卷都专门划出一个单独区域来存放自己的文件目录和FAT表，以及自己的逻辑驱动器字母。Ⅰ.FAT12以盘块为基本分配单位.在FAT的每个表项中存放下一个盘块号，它实际上是用于盘块之间的链接的指针，通过它可以将一个文件的所有盘块链接起来。每个文件的第一个盘块号放在自己的FCB中。整个系统有一张文件分配表FAT。在FAT的每个表项中存放下一个盘块号。对于1.2MB的软盘，每个盘块大小为512B，在每个FAT中共含有2.4K个表项，若每个FAT表项占12位，则FAT表共占有3.6KB的存储空间由于每个FAT表项为12位，因此FAT表中最多允许有4096（212=4K）个表项若每个盘块大小为512字节，则每个磁盘分区的容量最多为4096512B=2MB如果一个物理磁盘支持4个逻辑分区，则磁盘最大容量为8MB。*为了适应磁盘容量的不断增加的需求，进行磁盘分配时，不再以盘块为单位，而是以“簇”为基本单位。**簇是一组连续的扇区，大小一般是2^n个盘块，一个簇包含扇区的数量与磁盘容量的大小直接有关一个簇仅有一个扇区时，磁盘最大容量为8MB；一个簇有2个扇区时，磁盘最大容量为16MB；一个簇有8个扇区时，磁盘最大容量为64MB。FAT12存在的问题最主要的问题是：对所允许的磁盘容量存在着严重的限制，通常只有数十兆字节，虽然通过增加簇的大小来提高最大磁盘容量，但相应的簇内碎片也将随之成倍的增加Ⅱ.FAT16解决方法FAT12的问题是增加FAT表的表项数量，即增加FAT表的宽度，将其宽度增加至16位，则表项数增至2^ 16=64K=65536个。把具有16位表宽的FAT表称为FAT16如果FAT16的每个簇有64个盘块，则最大分区空间为64k×64×512=2^31=2GBⅢ.FAT32FAT32是FAT系统文件系统的最后一个产品。 FAT32表可以有2^32=4 294 967 296个表项，若每个簇为8个盘块（即4KB），FAT32分区可以管理的最大磁盘空间为2TB。 FAT32比FAT16支持更小的簇和更大的磁盘容量，大大减少了磁盘空间的浪费。 FAT32主要应用与Windows 98及后续的Windows系统，也支持长文件名。FAT32的不足之处：由于分配表的扩大，运行速度比FAT16格式要慢FAT32有最小管理空间的限制，FAT32不支持容量小于512MB的分区，因此小分区还是需要使用FAT16或FAT12系统Ⅳ.NTFS组织方式NTFS新特征:NTFS是一个专门为Windows NT开发的全新的文件系统。 NTFS具有许多新特征： 使用64位磁盘地址，理论上可以264字节磁盘分区 支持长文件名 具有系统容错功能 提供了数据的一致性 提供了文件加密、文件压缩等功能磁盘组织:NTFS也是以簇为磁盘分配和回收的基本单位，通过簇来间接管理磁盘，可以不需要知道盘块的大小，使NTFS具有了与磁盘物理扇区大小无关的独立性。 NTFS系统中，将簇大小称为“卷因子”，也是物理磁盘扇区的整数倍。 对于簇的定位， NTFS采用逻辑簇号LCN和虚拟簇号VCN进行的。 卷因子与LCN的乘积，可以得到文件数据所在的物理磁盘地址。文件的组织：在NTFS中，以卷为单位，将一个卷中所有的文件信息、目录信息以及可以的未分配空间信息，都以文件记录的方式记录在一张主控文件表MFT中。卷中每个文件作为一条记录，在MFT表中占有一行，大小为1KB，称为该行所对应文件的元数据，或文件控制字。对于一个文件的真正数据，即文件的DATA属性，如果很小，就直接存储在MFT表中对应的与数据中，这样对文件数据的访问仅需对MFT表进行即可。 这样减少了磁盘访问次数，提高了对文件的存取效率。 如果文件较大，则文件的真正数据往往保存在其它簇中，此时通过访问元数据（文件控制字）中指向文件DATA属性的队列指针，就可以方便的 查找到数据簇，完成对文件数据的访问(3)索引分配事实上，在打开某个文件时，只需要把该文件占用的盘块号的编号调入内存即可，完全没有必要把整个FAT调入内存，为此，应该将每个文件所对应的盘块号集中地放在一起，索引分配方式就是基于这种想法所形成的一种分配方式。其为每个文件分配一个索引块（表），再把分配给该文件的所有盘块号都记录在该索引块中，因而该索引块就是一个含有许多磁盘块号的数组。在建立一个文件时，只需要在位为之建立的目录项中填上指向该索引块的指针（单级索引）。说明：索引方式支持直接访问，可在索引块中找到第i个盘块，索引方式也不会产生外部碎片，当文件较大时，索引分配方式要优于链接分配方式。其主要问题在于：可能需要花费较多的外存空间，每当建立一个文件时，便须为之分配一个索引块，将分配给该文件的所有盘块号记录其中。对于小文件而言，索引块的利用率非常低。当OS为一个大文件分配磁盘空间时，如果所分配的盘块的盘块号已经装满一个索引块时，OS便为该文件分配另一个索引块，用于将以后继续为之分配的盘块号记录于其中，以此类推，然后再通过链指针将各索引块按序链接起来，当文件太大时，索引块太多，效率是低效的。此时，应该为这些索引块再建立一级索引，称为第一级索引，还可再建立索引，称为第二级索引等等。称为多级索引分配。说明：在二级索引分配方式下，若每个盘块的大小为1KB，每个盘块号占4个字节，则在一个索引块可以存放256个盘块号，这样，在两级索引时，最多可以包括存放文件的盘块号总数为64K(256 * 256)个盘块号，所允许文件最大长度为64MB，若盘块号为4KB，则一级索引的最大文件大小为4MB，二级索引的最大文件大小为4GB。 (4)混合索引分配方式将多种索引分配方式相结合而形成的一种分配方式，如直接地址（在索引结点中设置10个直接地址项，每项中所存放的是该文件数据所在盘块的盘块号，假如每个盘块大小为4KB，当文件不大于40KB时，可以直接从索引结点中读出该文件的全部盘号），一次间接地址（利用索引结点中的地址项来提供一次间接地址，其实质就是一级索引分配方式，在一次简直快中可存放1K个盘块号，允许最大文件为4MB），多次间接地址（当文件大于4MB + 40KB时，系统采用二次间址分配方式，其实质是两级索引分配方式，采用二次间址的最大文件大小为4GB，同理，可采用三次间接地址，允许文件最大大小为4TB）。索引结构优缺点优点：保持了链接结构的优点，又解决了其缺点：即能顺序存取，又能随机存取，满足了文件动态增长、插入删除的要求，也能充分利用外存空间缺点：较多的寻道次数和寻道时间，索引表本身带来了系统开销，如：内外存空间，存取时间2、文件存储空间管理(1)空闲表法空闲表法属于连续分配方式，它与内存的动态分配方式雷同，它为每个文件分配一块连续的存储空间，即系统也为外存上所有空闲区建立一张空闲表，每个空闲区对应于一个空闲表项，其中包括表项序号、该空闲区的第一个盘块号、该区的空闲盘块号等信息，再将所有空闲区按其起始盘块号递增排列。空闲盘区的分配与内存的动态分配类似，同样采用首次适应算法，循环首次适应算法等。系统在对用户所释放的存储空间进行回收时，也采取类似于内存回收的方法，即考虑回收区是否与空闲表中插入点的前区和后区相邻接，对相邻接者应该予以合并。当文件较小时，采用连续分配方式，当文件较大时，可采用离散分配方式。(2) 空闲链表法空闲链表法是将所有空闲盘区拉成一条空闲链。把链表分成两种形式，空闲盘块链和空闲盘区链。① 空闲盘块链，这是将磁盘上的所有空闲空间，以盘块为单位拉成一条链，当用户因创建文件而请求分配存储空间时，系统从链首开始，依次摘下适当数目的空闲盘块分配给用户，当删除文件而释放空间时，系统将回收的盘块依次插入空闲盘块链的末尾，其优点是用于分配和回收一个盘块的过程简单，但在为文件分配盘块时，可能要重复操作多次。② 空闲盘区链，这是将磁盘上的所有空闲盘区（每个盘区可包含若干个盘块）拉成一条链，在每个盘区上除了含有只是下一个空闲盘区的指针外，还应有能指明本盘区大小（盘块数）的信息。盘区分配与内存的动态分配类似，可采用首次适应算法，在回收盘区时，同样也要将回收区和相邻接的空闲盘区相合并，在采用首次适应算法时，可以采用显式链接法提高检索速度，在内存中为空闲盘区建立一张链表。(3)位示图法利用二进制的一位表示磁盘中的一个盘块的使用情况，当其值为0时，表示对应的盘块空闲，为1时，表示已经分配，磁盘上的所有盘块都有一个二进制位与之对应，这样，由所有盘块所对应的位构成一个集合，称为位示图，通常可用m * n个位数来构成位示图，并使m * n等于磁盘的总块数。对于盘块的分配分为如下三步① 顺序扫描位示图，从中找出一个或一组值为0的二进制位。② 将所找到的一个或一组二进制位转换成与之赌赢的盘块号。③ 修改位示图。对于盘块的回收分为如下两步① 将回收盘块的盘块号转换成位示图中的行号和列号。② 修改位示图。此方法的优点在于从位示图中很容易找到一个或一组相邻接的空闲盘块，此外，由于位示图很小，占用空间少，因而可将其保存在内存中，进而使在每次进行盘区分配时，无需首先把盘区分配表读入内存，节省磁盘启动时间。详解位示图法==设行号i 列号j 盘块号B 一行的位数为n==1.行列号从0开始，盘块号从0开始b = i * n+ ji = b/nj =b%n2.行列号从0开始，盘块号从1开始相对于第一种情况，盘块号多了1分配时，相对于第一种情况，计算后盘块号再加一b =i ∗ n + j + 1回收时，相对于第一种情况，计算前盘块号先减一i = (b− 1) / nj = (b − 1) % n3.行列号从1开始，盘块号从0开始相对于第一种情况，行列号多了1分配时，相对于第一种情况，计算前行列号先减一b =(i− 1) * n + j− 1回收时，相对于第一种情况，计算后行列号再加一i=b /n + 1j=b % n + 14.行列号从1开始，盘块号从1开始相对于第一种情况，盘块号、行列号都多了1分配时，相对于第一种情况，计算前行列号先减一，计算后盘块号再加一b = (i − 1) * n + (j− 1) + 1即：b= (i − 1) * n+ j回收时，相对于第一种情况，计算前盘块号先减一，计算后行列号再加一i =(b − 1) /n + 1j =(b− 1) %n + 1 (4)成组链接法空闲表法和空闲链表法都不适用于大型系统，因为这会使空闲表或空闲链表很长，在UNIX采用的成组链接法，结合上述两种方法。① 空盘块的组织，空闲盘块栈用来存放当前可用的一组空闲盘块的盘块号（最多含100个号），以及栈中尚有的空闲盘块号数N，顺便指出，N兼做栈顶指针使用，栈是临界资源，系统设置一把锁供进程互斥访问。其中，S.free(0)是栈底，栈满时栈顶为S.free(99)。② 文件区中的所有空闲盘块被分成若干个组，如每100个盘块作为一组。③ 将每一组含有的盘块总数N和该组所有的盘块号记入其前一组的第一个盘块S.free(0)~S.free(99)中，这样，由各组的第一个盘块可链接成一条链。④ 将第一组的盘块总数和所有的盘块号记入空闲盘块号栈中，作为当前可供分配的空闲盘块号。⑤ 最末一组只有99个盘块，其盘块号分别记入其前一组的S.free(1)~S.free(99)中，而在S.free(0)中则存放0，作为空闲盘块链的结束。当系统要为用户分配文件所需的盘块时，须调用盘块分配过程来完成。该过程首先检查空闲盘块号栈是否上锁，如未上锁，便从 栈顶取出一空闲盘块号，将与之对应的盘块分配给用户，然后将栈顶指针下移一格。若该盘块号已是栈底，即S.free(0)，这是当前栈中最后一个可分配的 盘块号。由于在该盘块号所对应的盘块中记有下一组可用的盘块号，因此，须调用磁盘读过程，将栈底盘块号所对应盘块的内容读入栈中，作为新的盘块号栈的内 容，并把原栈底对应的盘块分配出去(其中的有用数据已读入栈中)。然后，再分配一相应的缓冲区(作为该盘块的缓冲区)。最后，把栈中的空闲盘块数减1并返回。在系统回收空闲盘块时，须调用盘块回收过程进行回收。它是将回收盘块的盘块号记入空闲盘块号栈的顶部，并执行空闲盘块数加1操作。当栈中空闲盘块号数目已达100时，表示栈已满，便将现有栈中的100个盘块号，记入新回收的盘块中，再将其盘块号作为新栈底。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统【十三】]]></title>
    <url>%2Fposts%2F33c7448a%2F</url>
    <content type="text"><![CDATA[七、文件管理1、文件管理功能文件管理的功能有：文件存储空间的管理：为每个文件分配必要的外存空间，提高外存的利用率，并能有助于提高文件系统的运行速度;目录管理: 为每个文件建立其目录项，并对众多的目录项加以有效组织，实现方便的按名存取，能实现文件共享，提供快速的目录查询手段。文件的读写管理和保护：文件的读写管理：根据用户请求，从外存中读取数据，或将数据写入外存。文件保护2、文件和文件系统(1)文件系统==在操作系统中，文件系统的主要目的是“实现对文件的按名存取”==现代OS几乎都是通过文件系统来组织和管理在计算机中所存储的大量程序和数据的。文件系统的管理功能是通过把它所管理的程序和数据组织成一系列文件的方法来实现的。而文件则是指具有文件名的若干相关元素的集合。元素通常是记录，而记录是一组有意义的数据项的集合。可以把数据组成分为数据项、记录、文件。① 数据项，数据项是最低级数据组织形式。分为基本数据项（用于描述一个对象某种属性的字符集，是数据组织中可以明明的最小逻辑数据单位，即原子数据，又称为数据元素或字段）和组合数据项（由若干个基本数据项组成）② 记录，是一组相关数据项的集合，用于描述一个对象在某方面的属性，为了能够唯一标识一个记录，需要在记录中确定一个或几个数据项，把他们的集合称为关键字，关键字是能够唯一标识一个记录的数据项。③ 文件，文件是具有文件名的一组相关元素的集合，分为有结构文件和无结构文件。有结构文件由若干个相关记录组成，无结构文件则被看成一个字符流。文件是文件系统的最大数据单位。它描述了一个对象集。文件应该具有自己的属性，包括文件类型（如源文件、目标文件、可执行文件等），文件长度（文件的当前长度，也可能是最大允许长度），文件的物理位置（指示文件在哪一个设备上及在该设备的哪个位置的指针），文件的建立时间（文件最后一次修改时间）。一个文件可对应若干个记录，一个记录可对应若干个数据项。文件系统管理的对象有：文件（作为文件管理的直接对象），目录（为了方便用户对文件的存取和检索，在文件系统中配置目录，每个目录项中，必须含有文件名及该文件所在的物理地址，对目录的组织和管理是方便和提高对文件存取速度的关键），磁盘（磁盘）存储空间（文件和目录必定占用存储空间，对这部分空间的有效管理，不仅能提高外存的利用率，而且能提高对文件的存取速度）。对对象操纵和管理的软件集合：是文件管理的核心部分。实现了文件系统的大部分功能：对文件存储空间 的管理、对文件目录的管理、实现文件的地址转换机制、对文件读写管理以及对文件的共享和保护文件系统的接口：命令接口（用户与文件系统）和程序接口（用户程序和文件系统）。(2)文件操作① 创建文件，在创建一个新文件时，系统首先要为新文件分配必要的外存空间，并在文件系统的目录中，为之建立一个目录项，目录项中应该记录新文件的文件名及其在外存的地址等属性。② 删除文件，当已不再需要某文件时，可将其从文件系统中删除，在删除时，系统应先从目录中找到要删除文件的目录项，使之成为空项，然后回收该文件所占用的存储空间。③ 读文件，读文件时，须在相应系统调用中给出文件名和应读入的内存目标地址。此时，系统要查找目录，找到指定目录项，从中得到被读文件在外存中的位置。在目录项中，还有一个指针用于对文件进行读/写。④ 写文件，写文件时，须在相应系统调用中给出文件名和其在内存源地址。此时，系统要查找目录，找到指定目录项，从再利用目录中的写指针进行写操作。⑤ 截断文件，如果一个文件的内容已经陈旧而需要全部更新时，一种方法是将此文件删除，再重新创建一个新文件，但如果文件名和属性均无改变，则可采取截断文件的方法，其将原有的文件长度设置为0，放弃原有文件的内容。⑥ 设置文件的读/写位置，用于设置文件读/写指针的位置，以便每次读/写文件时，不需要从始端开始而是从所设置的位置开始操作。可以改顺序存取为随机存取。但对于一个实际的OS，为了方便用户使用文件而提供了更多地对文件的操作，如打开和关闭一个文件及改变文件名等操作。当前OS所提供的大多数对文件的操作，其过程大致都是这样两步：首先，检索文件目录来找到指定文件的属性及其在外存上的位置；然后，对文件实施相应的操作，如读/写文件等，当用户要求对一个文件实施多次读/写或其他操作时，每次都要从检索目录开始，为了避免多次重复地检索目录，在大多数OS中都引入了打开这一文件系统调用，当用户第一次请求对某文件系统进行操作时，先利用open系统调用将该文件打开。打开是指系统将指名文件的属性（包括该文件在外存上的物理位置）从外存拷贝到内存打开文件表的一个表目中，并将该表目的编号（索引号）返回给用户，以后，当用户再要求对该文件进行操作时，便可利用系统所返回的索引号向系统提出操作请求，系统便可直接利用该索引号到打开文件表中去查找，从而避免了对该文件的再次检索，如果用户不再需要对该文件实施操作，可利用关闭系统调用来关闭此文件，OS将会把该文件从打开文件表中的表目上删除掉。3、文件的逻辑结构对任何的文件，都存在以下两种形式的结构① 文件的逻辑结构，这是从用户观点出发所观察到的文件组织形式，是用户可以直接处理的数据及其结构，独立于文件的物理特性，又称为文件组织。② 文件的物理结构，又称为文件的存储结构，是指文件在外存上的存储组织形式，不仅与存储介质有关，还与外存分配方式有关。(1)文件逻辑结构的类型文件的逻辑结构可分为两大类，一类是有结构文件，这是指由一个以上的记录构成的文件，故把他称为记录式文件，另一类是无结构文件，这是指由字符流构成的文件，又称为流式文件。① 有结构文件，每个记录都用于描述实体集中的一个实体，各记录有着相同或不同数目的数据项，记录分为定长记录（文件中所有记录的长度都是相同的，所有记录中的各数据项都处在记录中相同的位置，具有相同的顺序和长度）和变长记录（文件中个记录的长度不相同，可能由于一个记录中所包含的数据项目并不相同）。根据用户和系统的需要，可采用多种方式来组织这些记录，如顺序文件（记录按照某种顺序排列所形成的文件，记录通常是定长的，能较快查找到文件中的记录），索引文件（记录为可变长度时，通常建立一张索引表，并为每个记录设置一个表项，加快对记录检索的速度），索引顺序文件（为文件建立一张索引表，为每一组记录中的第一个记录设置一个表项）。② 无结构文件，对于源程序、可执行文件、库函数等通常采用的是无结构文件形式，即流式文件，其长度以字节为单位。(2)顺序文件文件是记录的集合，文件中的记录可以是任意顺序的，因此，它可以按照各种不同的顺序进行排列，一般地，可归纳为以下两种情况。① 串结构，个记录之间的顺序与关键字无关，通常按照时间先后排序，最先存入的记录作为第一个记录，其次，为第二个记录，以此类推。② 顺序结构，文件中所有记录按照关键字排列，可以按照关键词长度从大到小排列。顺序结构的检索效率更高。顺序文件的最佳应用场合是在对诸记录进行批量存取时，即每次要读或写一大批记录时，此时，对顺序文件的存取效率是所有逻辑文件中最高的，此外，只有顺序文件才能存储在磁带上，并能有效工作。但是想要增加或删除一个文件比较困难。(3) 索引文件对于定长记录文件，可以方便的实现顺序存取和直接存取，然而，对于变长记录就很难实现。为了解决变长记录检索问题，可为变长记录文件建立一张索引表，对主文件中的每个记录，在索引表中设有一个相应的表项，用于记录该记录的长度L及指向该记录的指针（指向该记录在逻辑地址空间的首址），由于索引表示按记录键排序的，因此，索引表本身是一个定长记录的顺序文件。从而可以方便实现直接存取。在对索引文件进行检索时，首先根据用户（程序）提供的关键字，并利用折半查找检索索引表，从中找到相应的表项，再利用该表项给出的指向记录的指针值，去访问所需的记录。每当要向索引文件中增加一个新纪录时，便须对索引表进行修改。索引表的问题在于除了有主文件外，还需要配置一张索引表，每个记录需要有一个索引项，因此提高了存储费用。(4)索引顺序文件其有效克服了变长记录不便于直接存取的缺点，而且所付出的代价也不算太大，它是顺序文件和索引文件相结合的产物，它将顺序文件中的所有记录分为若干个组，为顺序文件建立一张索引表，在索引表中为每组中的第一个记录建立一个索引项，其中含有该记录的键值和指向记录的指针。在对索引顺序文件进行检索时，首先利用用户（程序）所提供的关键字及某种查找算法去检索索引表，找到该记录组中的第一个记录的表项，从中得到该记录组第一个记录在主文件中的位置，然后，再利用顺序查找法去查找主文件，从中找出所要求的记录。(5)直接文件对于直接文件，则根据给定的记录键值，直接获得指定记录的物理地址，换言之，记录键值本身就决定了记录的物理地址，这种由记录键值到记录物理地址的转换被称为键值转换。(6)哈希（Hash）文件利用Hash函数可将记录键值转换为相应记录的地址，为了能实现文件存储空间的动态分配，通常由Hash函数所求得的并非是相应记录的地址，而是指向一目录表相应表目的指针，该表目的内容指向相应记录所在的物理块。4、目录管理为了能够对文件实施有效的管理，必须对它们加以妥善组织，这主要是通过文件目录实现的，文件目录也是一种数据结构，用于标识系统中的文件及其物理地址，供检索时使用，对目录的管理要求如下① 实现按名存取，即用户只须向系统提供所需访问的文件的名字，便能够快速准确地找到指定文件在外存上的存储位置，这是目录管理中最基本的功能。② 提高对目录检索速度，通过合理地组织目录结构的方法，可加快对目录的检索速度，从而提高对文件的存取速度。③ 文件共享，在多用户系统中，应该允许用户共享一个文件。④ 允许文件重名，系统应允许不同用户对不同文件采用相同的名字，以便用户按照自己的习惯给文件命名和使用文件。(1)文件控制块为了能对文件进行正确的存取，必须为文件设置用于描述和控制文件的数据结构，称之为文件控制块FCB，文件管理程序可借助于文件控制块中的信息，对文件施加各种操作，文件与文件控制块一一对应，而人们把文件控制块的有序集合称为文件目录，一个文件控制块就是一个文件目录项。通常，一个文件目录也可被看成是一个文件，称为目录文件。文件控制块包含基本信息、存取控制信息、使用信息。① 基本信息，包括文件名（标识一个文件的符号名，在每个系统中，每个文件都有唯一的名字，用户利用该名字进行存取）；文件物理位置（指文件在外存上的存储位置，包括存放文件的设备名、文件在外村上的起始盘块号、指示文件所占用的盘块数或字节数的文件长度）；文件逻辑结构（指示文件是流式文件还是记录式文件、记录数，文件是定长还是变长记录）；文件物理结构（指示文件是顺序文件、链式文件还是索引文件）② 存取控制信息，包括文件主的存取权限、核准用户的存取权限及一般用户的存取权限。③ 使用信息，包括文件的建立日期和时间、文件上一次修改的日期和时间及当前使用信息（这项信息包括当前已打开该文件的进程数、是否被其他进程锁住、文件在内存中是否已被修改但尚未拷贝到盘上）(2)索引结点文件目录通常是存放在磁盘上的，当文件很多时，文件目录可能要占用大量的盘块，检索目录文件的时候，先将存放目录文件的第一个盘块中的目录调入内存，然后把用户所给定的文件名和目录项中的文件名逐一对比。若未找到指定文件，则再将下一个盘块中的目录项调入内存。在检索目录文件时，只用到了文件名，仅当找到一个目录项（即其中的文件名与指定要查找的文件名相匹配）时，才需要从该目录项中读出该文件的物理地址，而其他一些对该文件进行描述的信息，在检索目录时一概不用，显然，这些信息在检索目录时不需要调入内存。为此，在有的系统中，如UNIX系统，便采用了把文件名和文件描述信息分开的方法，亦即，使文件描述信息单独形成一个称为索引结点的数据结构，简称为i结点，在文件目录中的每个目录项由文件名和指向该文件所对应的i结点的指针所构成。每个文件都有唯一的磁盘索引结点（磁盘索引结点信息与文件名等信息一起构成了FCB），其主要包括内容如下① 文件主标识符，即拥有该文件的个人或小组的标识符。② 文件类型，包括正规文件、目录文件或特别文件。③ 文件存取权限，指各类用户对该文件的存取权限。④ 文件物理地址，每个索引结点中含有13个地址项（混合索引方式），他们以直接或间接的方式给出数据文件所在的盘块的编号。⑤ 文件长度，指以字节为单位的文件长度。⑥ 文件连接计数，表明在本文件系统中所有指向该文件名的指针计数。⑦ 文件存取时间，指本文件最近被进程存取的时间、最近被修改的时间及索引结点最近被修改的时间。当文件被打开时，要将磁盘索引结点拷贝到内存索引结点中，便于以后使用，在内存索引结点中又增加了一下内容。① 索引结点编号，用于标识内存索引结点。② 状态，指示i结点是否上锁或被修改。③ 访问计数，每当有进程要访问此i结点时，将访问计数加1，访问完再减1。④ 文件所属文件系统的逻辑设备号。⑤ 链接指针，设置有分别指向空闲链表和散列队列的指针。(3)目录结构目录结构的组织，关系到文件系统的存取速度，也关系到文件的共享性和安全性，目前常用的目录结构形式有单级目录、两级目录、多级目录。①单级目录结构在整个系统中只建立一张目录表，每个文件占一个目录项，目录项中含文件名、文件扩展名、文件长度、文件类型、文件物理地址、状态位（表示目录项是否空闲）等。每当要建立一个新文件时，必须先检查所有的目录项，以保证新文件名在目录中是唯一的，然后再从目录表中找到一个空白目录项，填入新文件的文件名及其他说明信息，并置状态为1，删除文件时，先从目录中找到该文件的目录项，回收该文件所占用的存储空间，然后再清除该目录项。单级目录的有点是简单并且能够实现目录管理的基本功能-按名存取，但是查找速度慢（查找一个目录项要花费较多的时间），不允许重名（在一个目录表中的所有文件，都不能与另一个文件有相同的名字，这是难以避免的），不便于实现文件共享（每一个用户都有自己的名字空间或命名习惯，因此，应该允许不同用户使用不同的文件名来访问同一个文件）②两级目录结构为每个用户建立一个单独的用户文件目录UFD（User File Directory），这些文件目录具有相似的结构，由用户所有文件的文件控制块组成。此外，系统中还有一个主文件目录MFD（Master File Directory），在主文件目录中，每个用户目录文件都占有一个目录项，其目录项包括用户名和指向用户目录文件的指针。两级目录结构客服了单级目录的缺点，具有如下优点：提高了检索目录的速度（如果在主目录中有n个子目录，每个用户目录最多为m个目录项，则为查找一指定的目录项，最多只需要检索n+m个目录项）。在不同的用户目录中，可以使用相同的文件名（只要在用户自己的UFD中，每个文件名都是唯一的，不同用户可以有文件名相同的文件）。不同用户还可使用不同的文件名来访问系统中同一个共享文件。但在多个用户需要合作完成一个大任务时，不便于用户之间共享文件。实现了对目录管理的四个要求③多级目录结构对于大型文件系统，通常采用三级或三级以上的目录结构，以提高对目录的检索速度和文件系统的性能。多级目录结构又称为树形目录结构，主目录被称为根目录，把数据文件称为树叶，其他的目录均作为树的结点。说明：方框代表目录文件，圆圈代表数据文件，主目录中有是哪个用户总目录A、B、C，在B用户的总目录B中，又包括三个分目录F、E、D，其中每个分目录中又包含多个文件，为提高系统的灵活性，应该允许在一个目录文件中的目录项既是作为目录文件的FCB，又是数据文件的FCB，这一信息可用目录项中的一位来指示。如用户A总目录中，目录项A是目录文件FCB，而目录项B和D则是数据文件的FCB。在树形目录结构中，从根目录到任何数据文件，都只有一条唯一的通路，在该路径上从树的根开始，把全部目录文件名和数据文件名依次用”/“连接起来，即构成该数据文件的路径名。系统中的每个文件都有唯一的路径名。例如，用户B访问文件J，则使用路径名/B/F/J来访问。当一个文件系统含有很多级时，每访问一个文件，都要使用从树根开始直到树叶（数据文件）为止的、包含各中间节点（目录）的全路径名，这非常麻烦，可为每个进程设置一个当前目录，又称为工作目录，进程对各文件的访问都相对于当前目录而进行的。把从当前目录开始值得数据文件为止所构成的路径名称为相对路径名，而把从树根开始的路径名称为绝对路径名。④ 增加和删除目录，在树形目录结构中，用户可为自己建立UFD，并可再创建子目录，在用户要创建一个新文件时，只需要查看自己的UFD及其子目录中有无与新建文件相同的文件名，若无，便可在UFD或其某个子目录中增加一个新目录项。在树形目录中，如何删除一个目录，应该视情况而定，若要删除的目录为空，则简单地将其删除，使它在其上一级目录中所对应的目录项为空，若不为空，可采用如下方法：不删除非空目录（当目录不为空时，为了删除一个非空目录，必须先删除目录中所有的文件，使之称为空目录，然后再删除，如果目录中包含有子目录，则应该递归调用方式删除），可删除非空目录（将目录中的所有文件和子目录同时删除）。5、目录查询技术当用户要访问一个已存在的文件时，系统首先利用用户提供的文件名对目录进行查询，找出该文件的文件控制块或对应索引结点，然后，根据FCB或索引结点中所记录的文件物理地址（盘块号），换算出文件在磁盘上的物理位置，最后，再通过磁盘驱动程序，将所需文件读入内存。目前常用的方式有线性检索法和Hash方法。(1)线性检索法又称为顺序检索法，在树形目录中，用户提供的文件名是由多个文件分量名组成的路径名，此时须对多级目录进行查找，假定用户给定的文件路径名为/usr/ast/mbox，则查找过程如下。说明：首先，系统应先读入第一个文件分量名usr，用它与根目录文件（或当前目录文件）中各目录项中的文件名顺序地进行比较，从中找到匹配者，并得到匹配项的索引结点号是6，再从6号索引结点中得到usr目录文件放在132号盘块中，将该盘块内容读入内存。接着，系统再将路径名中的第二个分量名ast读入，用它与放在132号盘块中的第二级目录文件中各目录项的文件名顺序进行比较，又找到匹配项，从中得到ast的目录文件放在26号索引结点中，再从26号索引结点中得知/usr/ast是存放在496号盘块中，再读入496号盘块。然后，将文件的第三个分量名mbox读入，用它与第三季目录文件/usr/ast中各目录项的文件名进行比较，最后得到/usr/ast/mbox的索引结点号为60，即在60号索引结点中存放了指定文件的物理地址，目录查询操作到此结束，如果在顺序查找过程中发现有一个文件分量名没有找到，则停止查找，并返回文件未找到信息。(2)Hash方法系统利用用户提供的文件名并将它转换为文件目录的索引值，再利用该索引值到目录中去查找，这将提高检索速度。6、文件共享(1)基于有向无循环图实现文件共享在严格的树形结构目录中，每个文件只允许有一个父目录，父目录可以有效地拥有该文件，其它用户要想访问它，必须经过其属主目录来访问该文件。这就是说，对文件的共享是不对称的，或者说，树形结构目录是不适合文件共享的。如果允许一个文件可以有多个父目录，即有多个属于不同用户的多个目录，同时指向同一个文件，这样虽会破坏树的特性，但这些用户可用对称的方式实现文件共享，而不必再通过其属主目录来访问。(2)利用索引结点为了解决上述问题，可以引用索引结点，即诸如文件的物理地址及其它的文件属性等信息，不再是放在目录项中，而是放在索引结点中。在文件目录中只设置文件名及指向相应索引结点的指针，如图 所示(3)利用符号链实现文件共享为使用户B能共享用户C的一个文件F，可以由系统创建一个LINK类型的新文件，也取名为F，并将F写入用户B的目录中，已实现B的目录与文件F的链接。在新文件中只包含被链接文件F的路径名。这样的链接方法被称为符号链接。新文件中的路径名，则被看作是符号链，当用户B要访问被链接的文件F且正要读LINK类新文件时，将被OS截获，OS根据新文件中的路径名去读该文件，于是就实现了B对文件F的共享。建立一种特殊的文件在这文件中只包含被链接文件F8的路径和名字。这样的链接方法被称为符号链接。优点在利用符号链方式实现文件共享时，只是文件主才拥有指向其索引结点的指针；而共享该文件的其他用户则只有该文件的路径名，并不拥有指向其索引结点的指针这样，也就不会发生在文件主删除一共享文件后留下一悬空指针的情况。当文件的拥有者把一个共享文件删除后，如果其他用户又试图通过符号链去访问一个已被删除的共享文件，则会因系统找不到该文件而使访问失败，于是再将符号链删除，此时不会产生任何影响。利用符号链的共享方式也存在着一些问题：当其他用户去读共享文件时，系统是根据给定的文件路径名逐个分量(名)地去查找目录，直至找到该文件的索引结点。因此，在每次访问共享文件时，都可能要多次地读盘。这使每次访问文件的开销甚大，且增加了启动磁盘的频率。因为要为每个共享用户建立一条符号链，而由于链本身实际上是一个文件，尽管该文件非常简单，却仍要为它配置一个索引结点，这也要耗费一定的磁盘空间。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统【十二】]]></title>
    <url>%2Fposts%2F7ed9e7d8%2F</url>
    <content type="text"><![CDATA[6、缓冲管理为了缓和CPU和I/O设备速度不匹配的矛盾，提高CPU和I/O设备的并行性，在现代OS中，几乎所有的I/O设备与处理机交换数据时，都用了缓冲区。引入缓冲区的原因有很多，可归结为以下几点：(1) 缓和CPU与I/O设备间速度不匹配的矛盾。(2) 减少对CPU的中断频率，放宽对CPU中断响应时间的限制。(3) 解决数据粒度不匹配的问题。(4) 提高CPU和I/O设备之间的并行性。(1)单缓冲每当用户进程发出一个I/O请求时，操作系统便在主存中为之分配一个缓冲区，假定从磁盘把一块数据输入到缓冲区的时间为T，操作系统将该缓冲区中的数据传送到用户区的时间为M，而CPU对这一块数据处理（计算）的时间为C，由于T和C是可以并行的，当T&gt;C时，系统对每一块数据的处理时间为M+T，反之，为M+C，系统对每一块数据的处理时间为Max(C，T) + M。在字符设备输入时，缓冲区用于暂存用户输入的一行数据，在输入期间，用户进程被挂起以等待数据输入完毕，在输出时，用户进程将一行数据输入到缓冲区后，继续进行处理，当用户进程已有第二行数据输出时，如果第一行数据尚未被提取完毕，则此时用户进程应该阻塞。(2)双缓冲为了加快输入和输出的速度，提高设备利用率，人们又引入了双缓冲区机制，称为缓冲对换，在设备输入时，先将数据送入第一个缓冲区，装满后便转向第二个缓冲区，此时操作系统可以从第一缓冲区中移出数据，并送入用户进程，接着由CPU对数据进行计算，在双缓冲时，系统处理一块数据的时间可以粗略地认为是Max(C，T)，如果C&lt;T，可使块设备连续输入，如果C&gt;T，则可使CPU不必等待设备输入。对于字符设备，若采用行输入方式，则采用双缓冲通常能消除用户的等待时间，即用户在输入完第一行后，在CPU执行第一行中的命令时，用户可继续向第二缓冲区输入下一行数据。双机通讯时缓冲区的设置§若我们在实现两台机器之间的通信时，仅为它们配置了单缓冲，那么它们之间任意时刻都只能实现单方向的数据传输，而绝不允许双方同时向对方发送数据。§为了实现双向数据传输，必须在两台机器中都设置两个缓冲区，一个用作发送缓冲区，另一个用作接收缓冲区。(3)循环缓冲当输入与输出或生产者与消费者的速度基本相匹配时，采用双缓冲能获得较好的效果，可使生产者和消费者基本上能并行操作，但若两者速度相差甚远，双缓冲的效果则不够理想，因此，引入了多缓冲机制，可将多个缓冲组织成循环缓冲形式。对于用作输入的循环缓冲，通常是提供给输入进程或计算进程使用，输入进程不断向空缓冲去输入数据，而计算进程则从中提取数据进行计算。循环缓冲区的组成如下① 多个缓冲区，在循环缓冲区中包括多个缓冲区，每个缓冲区的大小相同，作为输入的多缓冲区可分为三种类型，用于装输入数据的空缓冲区R、已装满数据的缓冲区G以及计算进程正在使用的先行工作缓冲区C② 多个指针，作为输入的缓冲区可设置三个指针，用于指示计算进程下一个可用缓冲区G的指针Nextg、指示输入进程下次可用的空缓冲区R的指针Nexti、以及用于指示计算进程正在使用的缓冲区C的指针Current。计算进程和输入进程可以利用下述两个过程来使用循环缓冲区（循环缓冲的使用）。① Getbuf过程，当计算进程要使用缓冲区中的数据时，可调用Getbuf过程，该过程将由指针Nextg所指示的缓冲区提供给进程使用，相应的，须把它改为现行工作缓冲区，并将Current指针指向该缓冲区的第一个单元，同时将Nextg移向下一个G缓冲区，类似地，当输入进程要使用空缓冲区来装入数据时，调用Getbuf过程，由该过程将指针Nexti所指示的缓冲区提供给输入进程使用，同时将Nexti指针移向下一个R缓冲区。② Releasebuf过程，当计算进程把C缓冲区中的数据提取完毕时，便调用Releasebuf过程，将缓冲区C释放，此时，把该缓冲区由当前（现行）工作缓冲区C改为空缓冲区R，类似地，当输入进程把缓冲区装满时，也应该调用Releasebuf过程，将该缓冲区释放，并改为G缓冲区。使用输入循环缓冲，可使输入进程和计算进程并行执行（进程同步），相应地，指针Nexti和指针Nextg将不断地沿着顺时针方向移动，这样就会出现如下两种情况。① Nexti指针追赶上Nextg指针，这意味着输入进程的速度大于计算进程处理数据的速度，已把全部可用的空缓冲区装满，再无缓冲区可用，此时，输入进程应该阻塞，直到计算进程把某个缓冲区中的数据全部提取完，使之成为空缓冲区R，并调用Releasebuf过程将它释放时，才将输入进程唤醒，这种情况称为系统受计算限制。② Nextg指针追赶上Nexti指针，这意味着输入数据的速度低于计算进程处理数据的速度，使全部装有输入数据的缓冲区都被抽空，再无装有数据的缓冲区供计算进程提取数据，这时，计算进程应该阻塞，直至输入进程又装满某个缓冲区，并调用Releasebuf过程将它释放时，才去唤醒计算进程，这种情况称为系统受I/O限制。(4)缓冲池上述的缓冲区仅适用于某特定的I/O进程和计算进程，因而它们属于专用缓冲，当系统较大时，将会有许多这样的循环缓冲，这样会消耗大量的内存空间，而且利用率不高，为了提高缓冲区的利用率，引入缓冲池，在池中设置了多个可供若干个进程共享的缓冲区。缓冲池中的各缓冲区是系统的公共资源，可供各进程共享，并由操作系统统一分配和管理。对于既可以用于输出的共用缓冲池，其中至少包含有一下三种类型的缓冲区。① 空（闲）缓冲区。② 装满输入数据的缓冲区。③ 装满输出数据的缓冲区。为了管理方便，将相同类型的缓冲区链成一个队列，形成了空缓冲队列emq、输入队列inq、输出队列outq。还具有四种工作缓冲区：用于收容输入数据的工作缓冲区用于提取输入数据的工作缓冲区用于收容输出数据的工作缓冲区用于提取输出数据的工作缓冲区。缓冲区可以工作在收容输入、提取输入、收容输出、提取输出四种工作方式下。① 收容输入，在输入进程需要输入数据时，便调用Getbuf(emp)过程，从空缓冲队列的队首取出一个空缓冲区，把它作为收容输入工作缓冲hin，然后，把数据输入其中，装满后再调用Putbuf(inq,hin)过程，将该缓冲区挂在输入队列上。② 提取输入，当计算进程需要输入数据时，调用Getbuf(inq)过程，从输入队列队首取出一个缓冲区，作为提取输入工作缓冲区sin，计算进程从中提取数据，计算进程用完该数据后，再调用Putbuf(emq,sin)过程，将该缓冲区挂到空缓冲队列emq上。③ 收容输出，当计算进程需要输出时，调用Getbuf(emq)过程从空缓冲区队列emq的队首取出一个空缓冲区，作为收容输出工作缓冲区hout，当其中装满输出数据后，又调用Putbuf(outq,hout)过程，将该缓冲区挂在outq末尾。④ 提取输出，由输出进程调用Getbuf(outq)过程，从输出队列队首取出一个装满输出数据的缓冲区，作为提取输出工作缓冲区sout，在数据提取完后，再调用Putbuf(emq,sout)过程，将该缓冲区挂在空缓冲队列末尾。7、磁盘存储器的管理(1)磁盘性能简述磁盘设备包括一个或多个物理盘片，每个盘片分一个或两个存储面，每个磁盘面被组织成若干个同心环，这种环称为磁道，各磁道之间留有必要的缝隙。每条磁道上可存储相同数目的二进制位，这样，磁盘密度即每英寸中所存储的位数，显然是内层磁道密度较外层磁道的密度高，每条磁道又被逻辑上划分成若干个扇区，一个扇区称为一个盘块（数据块）或称为磁盘扇区。一个物理记录存储在一个扇区上，磁盘上存储的物理记录块数目是由扇区数、磁道数以及盘面数决定的。磁盘可以从不同的角度进行分类：硬盘和软盘、单片盘和多片盘、固定头磁盘和活动头磁盘等。固定头磁盘：每条磁道都有一个读/写磁头，可对磁道并行读/写，I/O速度快，适用于大容量磁盘。移动头磁盘：每个盘面一个磁头，该磁头能移动以进行寻道。只能进行串行读/写， I/O速度较慢，但结构简单，曾经广泛用于中、小型磁盘设备中。寻道时间Ts：是把磁臂从当前位置移动到指定磁道上所经历的时间。该时间是启动磁臂的时间s与磁头移动n条磁道所花费的时间之和， 即Ts=m×n+s旋转延迟时间Tr：是指定扇区移动到磁头下面所经历的时间。Tr=1/2rr为磁盘每秒钟的转数如：硬盘转速为15000r/min (15000转/分钟） 每转=60000ms/15000r=4ms，平均延迟2 ms传输时间Tt：指数据从磁盘读出，或向磁盘写入数据所经历的时间。Tt = b/rN每次所读/写的字节数b；r为磁盘每秒钟的转数；N为一条磁道上的字节数则访问时间Ta =Ts + Tτ+ TtTa = Ts + b/rN + 1/2r其中Ts=m×n+s在访问时间中，寻道时间和旋转延迟时间，基本上都与所读/写数据的多少无关，而且它通常是占据了访问时间的大头，尤其是寻道时间。因而，适当地集中数据（不要太零散）传输，将有利于提高传输效率。(2)磁盘调度磁盘是多个进程共享的设备，当有多个进程都要求访问磁盘时，应采用一种最佳的调度算法，使各进程对磁盘的平均访问时间最小。由于在访问磁盘中，主要是寻道时间，因此，磁盘调度的目标是使磁盘的平均寻道时间最少。目前常用的磁盘调度算法有先来先服务、最短寻道时间优先及扫描等算法。① 先来先服务（FCFS, First Come First Service），这是一种最简单的磁盘调度算法，其根据进程请求访问磁盘的先后顺序进行调度.优点：公平、简单，每个进程的请求都能得到依次处理，不会出现某个进程的请求长期得不到满足的情况。缺点：未对寻道进行优化，致使平均寻道时间可能较长。仅适用于请求磁盘I/O的进程数目较少的场合② 最短寻道时间优先（SSTF，Shortest Seek Time First），要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短。但这种算法不能保证平均寻道时间最短。优点：使每次寻道时间最短缺点：不能保证平均寻道时间最短；可能导致距离远的进程总也得不到服务③ 扫描（SCAN）算法，SSTF算法虽然能获得较好的寻道性能，但可能会导致某个进程发生饥饿现象，因为只要有新进程的请求到达，且其所要访问的磁道与磁头当前所在磁道的距离较近，这种新进程的I/O请求必然先满足，对SSTF算法修改后形成SCAN算法，可防止老进程出现饥饿现象。该算法不仅考虑到欲访问的磁盘与当前磁道之间的距离，更优先考虑的是磁头当前的移动方向。例如，当磁头正在自里向外移动时，SCAN算法所考虑的下一个访问对象，应是其欲访问的磁道既在当前磁道之外，又是距离最近的。其类似电梯的运行，也称为电梯调度算法。缺点：刚移过的磁道的等待时间长④ 循环扫描（CSCAN）算法，SCAN算法既能够获得较好的寻道性能，又能防止饥饿现象，但是，当磁头刚从里向外移动而越过了某个磁道时，恰好又有一进程请求访问此磁道，这时，该进程必须等待，待磁头继续从里向外，然后再从外向里扫描完所有要访问的磁道后，才处理该进程的请求，致使该进程的请求被大大地推迟。为了减少这种延迟，CSCAN算法规定磁头单向移动，例如，致使自里向外移动，当磁头移到最外的磁道访问后，磁头立即返回最里的欲访问的磁道，即将最小的磁道号紧接着最大的磁道号构成循环，进行循环扫描。⑤ NStepSCAN算法，在SSTF、SCAN、CSCAN几种调度算法中，都可能会出现磁臂停留在某处不动的情况，例如，有一个或几个进程对某个磁道具有较高的访问频率，即这些进程反复请求对某一磁道的I/O操作，从而垄断了整个磁盘设备，这一现象称为磁臂粘着。NStepSCAN算法将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法一次处理这些子队列，当正在处理某子队列时，如果又出现了新的磁盘请求，便将新的请求进程放入其他队列，这样就避免了出现粘着现象。当N很大时，会使N步扫描算法性能接近于SCAN算法，当N=1时，退化为FCFS算法。⑥ FSCAN算法，其是NStepSCAN的简化，即FSCAN只将磁盘请求队列分成两个子队列，一个是由当前所有请求磁盘I/O的进程所形成的队列，由磁盘调度按SCAN算法进行处理，在扫描期间，将新出现的请求磁盘I/O的进程放入另一个等待处理的请求队列。这样，所有的新请求都被推迟到下一次扫描时处理。(3)磁盘高速缓存利用内存中的存储空间来暂存从磁盘上读出的一系列盘块中的信息，这里的高速缓存是一组在逻辑上属于磁盘，物理上是驻留在内存中的盘块，高速缓存在内存中可以分成两种形式，第一种是在内存中开辟一个单独的存储空间来作为磁盘高速缓存，其大小是固定的，不会受到应用程序的影响。第二种是把所有未利用的内存空间变为一个缓冲池，供请求分页系统和磁盘I/O时（作为磁盘高速缓存）共享。此时的高速缓存大小不再固定。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统【十一】]]></title>
    <url>%2Fposts%2F4ecf0b00%2F</url>
    <content type="text"><![CDATA[六、设备管理1、IO系统(1)IO硬件计算机系统的一个重要组成部分是I/O系统。在该系统中包括：用于实现信息输入、输出和存储功能的设备和相应的设备控制器，在有的大中型机中，还有I/O通道或I/O处理机。设备管理的对象主要是I/O设备，还可能要涉及到设备控制器和I/O通道。设备管理的基本任务是完成用户提出的I/O请求，提高I/O速率以及改善I/O设备的利用率。设备管理的主要功能：设备分配设备驱动（设备处理）缓冲区管理虚拟设备实现设备独立性IO设备发展历程：详见计算机组成原理分散连接——&gt;总线连接—&gt;DMA方式—&gt;通道-&gt;IO处理机(2)IO软件IO软件：（1）用户层I/O软件实现与用户交互的接口，用户可直接调用该层所提供的与I/O有关的的库函数对设备进行操作；（2）设备独立性软件，实现与用户程序与设备驱动器的统一接口，设备命名 ，保护及设备的分配与释放等;（3）设备驱动程序；（4）中断处理程序。2、I/O设备的类型(1)IO设备类型I/O设备类型繁多，在OS观点看，设备使用特性、数据传输速率、数据的传输单位、设备共享属性等都是重要的性能指标。可以按照不同角度对他们进行分类① 按设备的使用特性分类，可把设备分为两类，第一类是存储设备，也称为外存活后备存储器、辅助存储器，是计算机系统用于存储信息的主要设备，该设备速度慢，容量大，价格便宜。第二类是输入/输出设备，可分为输入设备、输出设备和交互式设备，如键盘，鼠标，扫描仪，打印机，显示器等。② 按传输速率分类，可将I/O设备分为三类，第一类是低速设备，其传输速率仅为每秒钟几个字节至几百个字节的设备，如键盘、鼠标等。第二类是中速设备，其传输速率为每秒数千个字节至十万个字节的设备，如行式打印机、激光打印机等。第三类是高速设备，其传输速率在数百个千字节至千兆字节的设备，如磁带机、磁盘机、光盘机等。③ 按信息交换的单位分类，可把I/O设备分为两类，第一类为块设备，这类设备用于存储信息，信息以数据块为单位，如磁盘，每个盘块512B~4KB，传输速率较高，通常每秒钟几兆位，另一特征是可寻址，即对它可随机地读/写任一块，磁盘设备的I/O常采用DMA方式。第二类是字符设备，用于数据的输入和输出，其基本单位是字符，属于无结构类型，如打印机等，其传输速率较低，通常为几个字节至数千个字节，另一特征是不可寻址，即输入/出时不能指定数据的输入源地址及输出的目标地址，此外，常采用中断驱动方式。④ 按设备的共享属性分类，可以分为三类，独占设备，在一段时间内只允许一个用户（进程）访问的设备，即临界资源。共享设备，在一段时间内允许多个进程同时访问的设备，当然，每一时刻仍然只允许一个进程访问，如磁盘（可寻址和可随机访问）。虚拟设备，通过虚拟技术将一台设备变换为若干台逻辑设备，供若干个用户（进程）同时使用。通常，设备并不是直接与CPU进行通信，而是与设备控制器通信，因此，在I/O设备中应该含有与设备控制器之间的接口，在该接口有三种类型的信号，各对应一条信号线。① 数据信号线，用于在设备控制器之间传送数据信号，对于输入设备而言，由外界输入的信号经转换器转换后所形成的数据，通常先送入缓冲器中，当数量达到一定的比特（字符）数后，再从缓冲器通过一组信号线传送给设备控制器。对输出设备而言，则先将从设备控制器经过数据信号线传送来的一批数据先暂存于缓冲器中，经转换器做适当转换后，再逐个字符地输出。② 控制信号线，作为由设备控制器向I/O设备发送控制信号时的通路，该信号规定了设备将要执行的操作，如读操作（指由设备向控制器传送数据）或写操作（由控制器接受数据），或执行磁头移动等操作。③ 状态信号线，用于传送设备当前状态的信号，设备的当前状态有正在读（或写）；设备已读（写）完成，并准备好新的数据传送。(2)设备控制器设备控制器是计算机中的一个实体，其主要职责是控制一个或多个I/O设备，以实现I/O设备和计算机之间的数据交换，它是CPU与I/O设备之间的接口，它接收从CPU发来的命令，并去控制I/O设备工作，以使处理从繁杂的设备控制事务中解脱出来。其是一个可编址的设备，当它仅控制一个设备时，它只有一个唯一的设备地址，若控制器可连接多个设备时，则应该含有多个设备地址，并使每个设备地址对应一个设备。设备控制器可以分为用于控制字符设备的控制器和用于控制块设备的控制器。设备控制器的基本功能如下① 接收和识别命令，CPU可以向控制器发送多种不同的命令，设备控制器应能够接收并识别这些命令，为此，控制器中应具有相应的控制寄存器，用来存放接收的命令和参数，并对所接收的命令进行译码，相应的，在磁盘控制器中有多个寄存器和命令译码器。② 数据交换，实现CPU与控制器之间、控制器与设备之间的数据交换，对于前者，通过数据总线，由CPU并行地将数据写入控制器，或从控制器中并行地读出数据，对于后者，是是被将数据输入到控制器，或从控制器传送给设备，为此，在控制器中必须设置一个数据寄存器。③ 标识和报告设备的状态，控制器应该几下设备的状态供CPU了解，在控制器中设置一状态寄存器，用其中的每一位来反映设备的某一种状态，当CPU将该寄存器的内存读入后，便可了解该设备的状态。④ 地址识别，系统中的每一个设备都有一个地址，而设备控制器又必须能够识别它所控制的每个设备的地址，此外，为使CPU能向（或从）寄存器中写入（或读出）数据，这些寄存器都应该具有唯一的地址，如硬盘控制器中各寄存器的地址分别为320~32F之一，控制器应该能正确识别这些地址，为此，需要在控制器中配置地址译码器。⑤ 数据缓冲，由于I/O设备的速率较低而CPU和内存速率很高，故在控制器中必须设置一个缓冲器，在输出时，用此缓冲器暂存由主机高速传来的数据，然后才以I/O设备所具有的速率将缓冲器的数据传送给I/O设备，在输入时，缓冲器则用于暂存从I/O设备送来的数据，待接收一批数据后，再将缓冲器中的数据高速地传送至主机。⑥ 差错控制，设备控制器监管对I/O设备传送来的数据进行差错检测，若发现传送中出现了错误，则向CPU报告，于是CPU将本次传送的数据作废，并重新传送一次，这样便可以确保数据输入的正确性。由于设备控制器位于CPU与设备之间，既要与CPU通信，又要与设备通信，还应具有按照CPU所发来的命令去控制设备工作的功能，因此，现有的大多数控制器都是由如下的三部分组成。① 设备控制器与处理机的接口，该接口用于实现CPU与设备控制器之间的通信，共有三类信号线，数据线、地址线、控制线，数据线与两类寄存器相连接，第一类是数据寄存器，第二类是控制/状态寄存器。② 设备控制器与设备的接口，设备控制器可以连接一个或多个设备，相应地，在控制器中便有一个或多个设备接口，一个接口连接一台设备，在每个接口中都存在数据、控制和状态三种类型的信号，控制器中的I/O逻辑根据处理机发来的地址信号去选择一个设备接口。③ I/O逻辑，用于实现对设备的控制，通过一组控制线与处理机交互，处理机利用该逻辑向控制器发送I/O命令，I/O逻辑对收到的命令进行译码，每当CPU要启动一个设备时，一方面将启动命令发送给控制器，另一方面又同时通过地址线把地址发送给控制器，由控制器的I/O逻辑对收到的地址进行译码，再根据所译出的命令对所选设备进行控制。(3)IO通道虽然在CPU与I/O设备之间增加了设备控制器后，可以大大减少CPU对I/O的干预，但是当主机所配置的外设很多时，CPU的负担仍然很重，因此，在CPU和设备控制器之间又增设了通道。其主要目的是为了建立独立的I/O操作，不仅使数据的传送能独立于CPU，而且也希望有关对I/O操作的组织、管理及其结束处理尽量独立，以保证CPU有更多的时间去进行数据处理。在设置了通道后，CPU只需要向通道发送一条I/O指令，通道在收到该指令后，便从内存中取出本次要执行的通道程序，然后执行该通道程序，仅当通道完成了规定的I/O任务后，才向CPU发中断信号。I/O通道是一种特殊的处理机，具有执行I/O指令的能力，并通过执行通道（I/O）程序来控制I/O操作，但I/O通道与一般的处理机不同，因为其指令类型单一同时没有自己的内存，与CPU共享主内存。通道用于控制外围设备（包括字符设备和块设备），由于外围设备的类型较多，传输速率相差甚大，因为使通道具有多种类型，根据信息交换方式的不同，将通道分为以下三种。① 字节多路通道，这是一种按照字节交叉方式工作的通道，通常都含有许多非分配型子通道，其数量可以几十到数百个，每个子通道连接一台I/O设备，并控制该设备的I/O操作，这些子通道按照时间片轮转方式共享主通道。② 数组选择通道，字节多路通道不适合连接高速设备，数组选择通道按数组进行数据传送，其通常只含有一个分配型子通道，在一段时间内只能执行一道通道程序，控制一台设备进行数据传送，致使当某台设备占用了该通道后，便一直由它独占，即使是它无数据传送，通道被闲置，也不允许其他设备使用该通道，直至该设备传送完毕释放该通道，其利用率很低。③ 数组多路通道，由于数组选择通道每次只允许一个设备传送数据，数组多路通道是将数组选择通道传输速率高和字节多路通道能使各子通道（设备）分时并行操作的优点相结合而形成的一种新通道，其含有多个非分配型子通道，具有很高的数据传输速率，其数据传输是按数组方式进行的。由于通道价格昂贵，计算所设置的通道较少，提高通道的利用率的一种很有效的方法是增加设备到主机间的通路而不增加通道。3、I/O控制方式(1)中断控制方式在早起计算机系统中，由于无中断机构，处理机对I/O设备的控制采取程序I/O方式，或称为忙-等待方式，即在处理机向控制器发出一条I/O指令启动输入设备输入数据时，要同时把状态寄存器中的忙/闲标志busy设置为1，然后便不断地循环测试busy，只有当其为0时，表示输入已经送入控制器的数据寄存器中，于是处理机将数据寄存器中的数据取出，送入内存指定单元中，这样便完成了一个字（符）的I/O。在程序I/O方式中，由于CPU的高速性和I/O设备的低速性，致使CPU的绝大部分时间都处于等待I/O设备完成数据I/O的循环测试中，造成对CPU的极大浪费。(2)中断驱动I/O控制方式当某进程要启动某个I/O设备工作时，便由CPU向相应的设备控制器发出一条I/O命令，然后立即返回继续执行原来的任务，设备控制器于是按照该命令的要求去控制指定I/O设备，此时，CPU与I/O设备并行操作。一旦数据进入数据寄存器，控制器便通过控制线向CPU发送一个中断信号，由CPU检查输入过程中是否出错，若无错，便由控制器发送取走数据的信号，再通过控制器及数据线将数据写入内存指定单元中。在I/O设备输入每个数据的过程中，由于无需CPU干预，因而可使CPU与I/O设备并行工作，仅当完成一个数据输入时，才需CPU花费极短的时间去做一些中断处理。(3)直接存储器访问（DMA）I/O控制方式虽然中断驱动I/O比程序I/O方式更有效，但是，它仍是以字（节）为单位进行I/O的，每当完成一个字（节）的I/O时，控制器便要向CPU请求一次中断，换言之，采用中断驱动I/O方式时的CPU是以字（节）为单位进行干预的，将这种方式用于块设备的I/O是非常低效的，例如，为了从磁盘读取1KB的数据块，需要中断CPU1K次，为了进一步减少CPU对I/O的干预而引入了直接存储器访问方式，该方式的特点如下① 数据传输的基本单位是数据块，即在CPU与I/O设备之间，每次传送至少一个数据块。② 所传送的数据是从设备直接送入内存的，或者相反。③ 仅在传送一个或多个数据块的开始和结束时，需要CPU干预，整块数据的传送是在控制器的控制下完成的。详见计算机组成原理DMA控制方式(4)I/O通道控制方式虽然DMA方式比起中断方式已经显著地减少CPU的干预，即已由以字（节）为单位的干预减少到了以数据块为单位进行干预，但CPU没发出一条I/O指令，也只能去读（或写）一个连续的数据块，而当我们需要一次去读多个数据块且将他们分别传送到不同的内存区域，或者相反时，则须由CPU分别发出多条I/O指令及进行多次中断才能完成。I/O通道方式是DMA的发展，它可以进一步减少CPU的干预，即把一个数据块的读（或写）为单位的干预减少为对一组数据块的读（或写）及有关的控制和管理为单位的干预。同时，可以实现CPU、通道、I/O设备的并行操作，提高资源利用率。具有通道的机器一般是大、中型计算机，数据流通量很大。与DMA的区别 ：DMA借助硬件完成数据传送 通道利用一组通道命令与硬件一起完成数据传送;DMA控制器只能控制一台或几台同类设备, 而一个通道可 同时控制多台同类或不同类的设备。通道是通过执行通道程序，并与设备控制器共同实现对I/O设备的控制的，通道程序是由一系列通道指令（或称为通道命令）所构成的，通道指令与一般的机器指令不同，它的每条指令都包含下列的信息。① 操作码，操作码规定了指令所执行的操作，如读、写、控制等操作。② 内存地址，内存地址标明字符送入内存（读操作）和从内存取出（写操作）时的内存首址。③ 计数，该信息表示本条指令所要读（或写）数据的字节数。④ 通道程序结束位P，该位用于表示通道程序是否结束，P=1表示本条指令是通道程序的最后一条指令。⑤ 记录结束标志R，R=0表示本通道指令与下一条指令所处理的数据是同属于一个记录，R=1表示这是处理某记录的最后一条指令。下面给出了一个由六条通道指令所构成的简单通道程序，该程序的功能是将内存中不同地址的数据携程多个记录，其中，前三条指令是分别将813-892单元中的80个字符和1034-1173单元中的140个字符及5830-5889单元的60个字符携程一个记录，第四条指令是单独写一个具有300个字符的记录，第五、六条指令共写含500个字符的记录。4、IO软件(1)设备驱动程序设备驱动程序，又称为设备处理程序，是所有与该设备的硬件相关和设备相关的代码的集合，是I/O进程与设备控制器之间的通信程序。设备驱动程序在功能是上属于核心，但代码通常由设备制造厂家编写（遵循该操作系统的驱动程序与核心间的接口标准），是在核心之外的一个或多个文件。主要任务：接收上层软件发来的抽象要求，转换为具体要求后，发送给设备控制器，启动设备去执行；将设备控制器发来的信号传送给上层软件。驱动程序与硬件密切相关，应为每一类设备配置一种驱动程序；或为非常类似的两类设备配置一个驱动程序。(2)与设备无关的I/O软件(主要是设备独立性软件)设备独立性（Device Independence）的概念——应用程序独立于具体使用的物理设备。鉴于驱动程序是一个与硬件（或设备）紧密相关的软件，必须在驱动程序之上设置一层软件，称为设备独立性软件，以执行所有设备的公有操作、完成逻辑设备名到物理设备名的转换（为此应设置一张逻辑设备表）并向用户层（或文件层）软件提供统一接口，从而实现设备的独立性。物理设备和逻辑设备：类似于物理地址和逻辑地址的概念。使用逻辑设备名称来请求使用某类设备；系统实际执行时，必须使用物理设备名称。在实现了设备独立性功能后，可带来以下好处。① 设备分配时的灵活性，当应用程序（进程）以物理名称来请求使用指定的某台设备时，如果该设备已经分配给其他进程或正在检修，而此时尽管还有几台其他的相同设备正在空闲，该进程仍然阻塞，但若进程能够以逻辑设备名称来请求某类设备时，系统可立即将该类设备中的任一台分配给进程，仅当所有此类设备全部分配完毕时，进程才会阻塞。② 易于实现I/O重定向，用于I/O操作的设备可以更换，而不必改变应用程序。逻辑设备名到物理设备名映射的实现① 逻辑设备表，为了实现设备的独立性，系统必须设置一张逻辑设备表LUT(Logical Unit Table)，用于将应用程序中所使用的逻辑设备名映射为物理设备名，该表的每个表目中包含了三项，逻辑设备名、物理设备名、设备驱动程序的入口地址。通过逻辑设备名，系统可以查找LUT，便可找到物理设备和驱动程序。② LUT的设置问题，LUT的设置可以采用两种方式：在整个系统中设置一张LUT（由于系统中所有进程的设备分配情况都记录在同一张LUT中，因而不允许在LUT中具有相同的逻辑设备名，这就要求所有用户都不能使用相同的逻辑设备名，多用户下难以做到，单用户很好实现）。为每个用户设置一张LUT（每当用户登录时，便为该用户建立一个进程，同时建立一张LUT，并将该表放入进程的PCB中）5、设备分配(1)设备分配中的数据结构在进行设备分配时，通常都需要借助于一些表格的帮助，在表格中记录了相应设备或控制器的状态及对设备或控制器进行控制所需的信息，在进行设备分配时所需要的数据结构有设备控制表、控制器控制表、通道控制表和系统设备表等。① 设备控制表（DCT，Device Control Table）系统为每个设备都配置了一张设备控制表，用于记录本设备的情况。说明：设备队列队首指针（凡因为请求本设备而未得到满足的进程，其PCB都应按照一定的策略排成一个队，称该队列为设备请求队列或简称设备队列，其队首指针指向队首PCB），设备状态（当设备处于使用状态时，应该设备设置为忙/闲标志置为1），与设备连接的控制器表指针（该指针指向该设备所连接的控制器的控制表），重复执行次数（由于外部设备在传送数据时，较容易发生数据传送错误，因而在许多系统中，如果发生传送错误，并不立即认为传送失败，而是令它重传，并由系统规定设备在工作中发生错误时应重复执行的次数）② 控制器控制表（COCT，Controller control table)系统为每个控制器都设置了一张用于记录本控制器情况的控制器控制表。③ 通道控制表（CHCT ，Channel Control Table）每个通道都配有一张通道控制表。④ 系统设备表（SDT，System device table）系统范围的数据结构，记录了系统中全部设备的情况，每个设备占用一个表目，其中包括有设备类型、设备标识符、设备控制表及设备驱动程序的入口等。SDT查DCT，申请设备DCT查COCT，分配控制器COCT查CHCT，分配通道(2)设备分配时应考虑的因素为使系统有条不紊的工作，系统在分配设备时，应考虑这样几个因素：①设备的固有属性设备的固有属性可分为三种：独占性、共享性和虚拟性设备。独占设备在一段时间内只能由一个进程使用。共享设备允许多个进程共享。虚拟设备是经过某种处理由独占设备变为虚拟设备。②设备分配算法与进程调度类似，一般使用以下两种：先来先服务。根据请求的先后次序排成一个队列，设备总是分配给队首进程。优先级高者优先。利用该算法形成队列时，将优先权高的进程安排在设备队列前面，优先级相同的先来先服务。③设备分配中的安全性安全分配方式。每当进程发出I/O请求后便阻塞，直到I/O完成后被唤醒。避免了死锁中“请求和保持”条件，虽安全但缓慢。不安全分配方式。不断发出I/O请求，直到所请求的设备已经被另一进程占用才阻塞。一个进程可以同时操作多个设备，使进程迅速推进。但可能具备“请求和保持”条件而发生死锁，虽迅速但不安全。可以通过增加安全性检测算法避免死锁发生。④设备独立性(3)独占设备的分配程序1、分配设备：根据物理设备名在系统设备表SDT中找出该设备的设备控制表DCT，若设备忙，便将请求I/O的进程PCB挂在设备队列上；否则，便按照一定的算法来计算本次设备分配的安全性，若不会导致系统进入不安全状态，便将设备分配给请求进程；否则，仍将其PCB插入设备队列。2、分配控制器：分配设备给进程后，再到其设备控制表DCT中找出与该设备连接的控制器的COCT。若控制器忙，便将请求I/O进程的PCB挂在该控制器的等待队列上；否则，将该控制器分配给进程。3、分配通道：分配控制器后，再在控制器控制表COCT中找到与该控制器连接的通道的CHCT。若通道忙，便将请求I/O的进程挂在该通道的等待队列上；否则，将该通道分配给进程。只有在设备、控制器和通道三者都分配成功时，这次的设备分配才算成功之后便可启动该I/O设备进行数据传送。上述基本的设备分配程序中，有以下特点：① 进程以物理设备名提出I/O请求的；② 采用的是单通路的I/O系统结构，容易产生“瓶颈”现象。为使独占设备的分配程序具有更大的灵活性和提高分配的成功率，应从两方面对基本的设备分配程序加以改进：增加设备的独立性：为获得设备独立性，进程应用逻辑设备名请求I/O。系统先从SDT中找出第一个该类设备的DCT。如该设备忙，再找第二个，若所有该类设备部忙则把进程挂在该类设备的等待队列上；而只要有一个该类设备可用，系统就可进一步计算分配该设备的安全性。考虑多通路情况：分配控制器和通道时，若设备（控制器）所连接的第一个控制器（通道）忙时，应查看其所连接的第二个控制器（通道），仅当所有的控制器（通道）都忙时，此次的控制器（通道）分配才算失败，才把进程挂在控制器（通道）的等待队列上；而只要有一个控制器（通道）可用，系统便可将它分配给进程。(4)SPOOLing技术通过SPOOLing技术可将一台物理I/O设备虚拟为多台逻辑I/O设备，允许多个用户共享一台物理I/O设备。以空间换取时间的技术为了缓和CPU的高速性和I/O设备的低速性间的矛盾而引入的脱机输入、脱机输出技术，该技术是利用专门的外围控制机，将低速I/O设备上的数据传送到高速磁盘上，或者相反。事实上，当系统中引入了多道程序技术后，可以利用其中的一道程序，来模拟脱机输入时的外围控制机的功能，把低速I/O设备上的数据传送到高速磁盘上，再利用另一道程序来模拟脱机输出时外围控制机的功能，把数据从磁盘上传送到低速输出设备上，这样，便可在主机的直接控制下，实现脱机输入、输出的功能。此时的外围操作与CPU对数据的处理同时进行，我们把这种在联机情况下实现的同时外围操作称为SPOOLing（Simultaneaus Periphernal Operations On-Line），或称为假脱机操作。注意：与真脱机的区别在于设备与主机是否连接，目标设备的I/O过程是否在主机控制下进行。SPOOLing只适用可以从程序过程中分离出来的I/O，如打印。SPOOLing系统的组成：① 输入井和输出井，这是在磁盘上开辟的两个大存储空间。输入井是模拟脱机输入时的磁盘设备，用于暂存I/O设备输入的数据，输出井是模拟脱机输出时的磁盘，用于暂存用户程序和输出数据。② 输入缓冲区和输出缓冲区，缓和CPU与磁盘之间速度不匹配，在内存中开辟的两个缓冲区，输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井，输出缓冲区用于暂存从输出井送来的数据，以后再传送给输出设备。③ 输入进程SPi和输出进程SPo，利用两个进程来模拟脱机I/O时的外围控制机，其中，进程SPi模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲区再送到输入井，当CPU需要输入数据时，直接从输入井读入内存；进程SPo模拟脱机输出时的外围控制机，把用户要求输出的数据先从内存送到输出井，待输出设备空闲时，再将输出井中的数据经过输出缓冲区送到输出设备上。注意：处于磁盘中的井才是中介输入:外部输入到内存的输入缓冲区，写入磁盘中的输入井.CPU再从输入井中读数据输出:内存中运算产生的数据送往输出井，输出井送到缓冲区，在送给输出设备。SPOOLing系统主要有如下的特点① 提高了I/O速度，对数据所进行的I/O操作，已从对低速的I/O设备进行I/O操作，演变为对输入井或输出井中数据的存取，如同脱机输入输出一样，提高了I/O速度，缓和了CPU与低速I/O设备之间速度不匹配。② 将独占设备改造为共享设备，因为在SPOOLing系统中，实际上并没有任何进程分配设备，而只是在输入井或输出井中为进程分配一个存储区和建立一张I/O请求表，这样，便把独占设备改造为共享设备。③ 实现了虚拟设备功能，宏观上，虽然是多个进程在同时使用一台独占设备，而对于每个进程而言，他们都会认为自己是独占了一个设备，当然，只是逻辑上的设备，SPOOLing系统实现了将独占设备变换为若干个对应的逻辑设备的功能。利用SPOOLing技术，可以将独占设备打印机改造为一台供多个用户共享的设备，从而提高设备的利用率，也方便了用户。当用户进程请求打印输出时 ，SPOOLing系统统一为它打印输出，但是并不真正立即把打印机分配给该用户进程，而只为它做两件事。① 由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据送入其中。② 输出进程再为用户进程申请一张空白的用户请求打印表，并将该用户的打印要求填入其中，再将该表挂到请求打印队列上。如果还有进程要求打印输出，系统仍可以接受该请求，也同样为该进程做上述两件事情。如果打印机空闲，输出进程将从请求打印队列的队首取出一张请求打印表，根据表中的要求打印数据，从输出井传送到内存缓冲区，再由打印机进行打印。打印完后，输出进程再查看请求打印队列中是否还有等待打印的请求表，若有，又取出队列中的第一张表，继续打印，直至请求打印队列为空，输出进程才将自己阻塞起来，仅当下次再有打印请求时，输出进程才被唤醒。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统【十】]]></title>
    <url>%2Fposts%2Fa0eb5617%2F</url>
    <content type="text"><![CDATA[五、虚拟存储器1、虚拟存储器概述前面所介绍的存储器管理方式都有一个共同的特点，即他们都要求将一个作业全部装入内存后方能运行，于是，出现了下面两种情况① 有的作业很大，其所要求的内存空间超过了内存总容量，作业不能全部被装入内存，致使该作业无法运行。② 做大量作业要求运行，但由于内存容量不足以容纳所有这些作业，只能将少数作业装入内存让他们先运行，而将其他大量作业留在外存上等待。为了解决上述问题，可以增加物理内存，但是其不太现实，另外是从逻辑上扩充内存容量。基于程序的局部性原理（时间局限性和空闲局限性），程序在运行之前，没有必要全部装入内存，仅需将那些当前要运行的少数页面或段先装入内存便可运行。其余部分暂留在磁盘上，程序运行时，如果它所要访问的页（段）已经调入内存，便可继续执行下去，但如果程序所要访问的页（段）尚未调入内存（缺页或缺段），此时程序应利用OS的请求调页（段）功能，将它们调入内存，以使进程继续执行下去。如果此时内存已满，无法再装入新的页（段），则还需利用页（段）的置换功能，将内存中暂时不用的页（段）调至磁盘上，再将要访问的页（段）调入内存，使程序继续执行。这样，可以使很大的用户程序在较小的内存空间中运行。从用户的调入看，该系统具有很大的内存容量，但是，用户看到的大容量只是一种感觉，这种存储器被称为虚拟存储器。2、虚拟存储器定义和特征定义：所谓虚拟存储器，是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统，其逻辑容量由内存容量和外存容量之和决定，其运行速度接近内存，成本接近外存。可见，虚拟存储技术是一种性能非常优越的存储器管理技术，虚拟存储器的实现都是建立在离散分配的存储管理方式的基础上！（1）==多次性==：一个作业被分成多次调入内存运行（2）==对换性==：允许在作业的运行过程中进行换进、换出。（3) ==虚拟性==：能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。虚拟性以多次性和对换性为基础；多次性和对换性又必须建立在离散分配的基础上。3、虚拟存储器的实现方法(1)请求分页系统在分页系统的基础上，增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。它允许只装入部分页面的程序(及数据)，便启动运行。以后再通过调页功能及页面置换功能， 再将要运行的页面调入内存，同时把暂不运行的页面换出到外存上，置换时以页面为单位。为实现请求调页和置换功能，系统必须提供必要的支持：①请求分页的页表机制（它是在纯分页的页表机制上增加若干项而形成的，作为请求分页的数据结构）②缺页中断机构（每当用户程序要访问的页面尚未调入内存时，便产生一缺页中断，请求OS将所缺的页调入内存）、③地址变换机构（在纯分页的基础上发展形成）软件支持：实现请求调页的软件和实现页面置换的软件请求分页系统是建立在基本分页基础上的，增加了请求调页功能和页面置换功能。换入和换出的基本单位都是长度固定的页面，因而在实现上比请求分段系统简单。①硬件支持I.页表基本作用仍是将用户地址空间中的逻辑地址变换为内存空间中的物理地址。由于只将程序的一部分装入内存，还有一部分在外存中，因此须在页表中增加若干项，供程序或数据在换进、换出时参考。(1) 状态位P ：指示该页是否已调入内存。供程序访问时参考；供程序访问时参考；(2) 访问字段A ：用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问。供选择换出页面时参考；(3) 修改位M ：表示该页在调入内存后是否被修改过。供置换页面时参考；(4) 外存地址：用于指出该页在外存上的地址。供调入该页时参考。II. 缺页中断机构当要访问的页面不在内存时，产生一个缺页中断，请求OS将缺的页面调入内存，缺页作为中断，也需要经过保护CPU现场、分析中断原因、转入中断处理程序进行处理、恢复CPU环境等。但是，其与一般中断相比有一些不同，主要在于：在指令执行期间产生和处理中断信号（通常CPU都是在一条指令执行完后，才检查是否有中断请求到达，若有，则响应，否则，继续执行下一条指令，然而，缺页中断是在指令执行期间，发现所要访问的指令或数据不再内存时所产生和处理的）一条指令在执行期间，可能产生多次缺页中断。III. 地址变换机构请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，为实现虚拟存储器增加了处理缺页中断，以及从内存中换出一页的功能实现的。注意，最终置换的是内存中的页，所以页表中只需要修改逻辑页号，因为是吧之前逻辑页号映射的物理块号中的内容置换了。②请求分页中的内存分配I.最小物理块数的确定最小物理块数，是指能保证进程正常运行所需的最小物理块数。当系统为进程分配的物理块数少于此值时，进程将无法运行。进程应获得的最小物理块数与计算机的硬件结构有关，取决于指令的格式、功能和寻址方式。对于某些简单机器，若是单地址指令且采用直接寻址方式，最小物理块数应为2，如果该机器允许间接寻址，则至少要求3个物理块。对于某些功能较强的机器，指令长度可能是两个或两个以上字节，至少要为进程分配6个物理块。II. 物理块的分配策略在请求分页系统中，可采取两种内存分配策略，固定和可变分配策略，在进行置换时，也可采用全局置换和局部置换，可组合出如下三种适用的策略。固定分配局部置换为每个进程分配一定数目的物理块，整个运行期不再改变，如果进程在运行中发现缺页，则只能从该进程在内存的n个页面中选出一页换出，然后再调入一页，以保证分配给该进程的内存空间不变，若开始为进程分配的物理块数太少，则会频繁缺页，降低系统吞吐量，若太多，则使内存中驻留的进程数目减少，进而造成CPU空闲或其他资源空闲的情况。困难：应为每个进程分配多少个物理块难以确定。可变分配全局置换先为系统中的每个进程分配一定数目的物理块，而OS自身也保持一个空闲物理块队列，当某进程发现缺页时，由系统从空闲物理块队列中取出一个物理块分配给该进程，并将欲调入的缺页装入其中，仅当空闲物理队列的物理块用完时，OS才能从内存中选择一页调出，该页可能是系统中任一进程的页，这样，会是那个进程的物理块减少，进而使缺页率增加可变分配局部置换为每个进程分配一定数目的物理块，当进程缺页时，只允许从该进程在内存中的页面中选出一页换出，这样不会影响其他进程的运行，如果该进程频繁发生缺页，则系统需要再为该进程分配若干附加的物理块，直至该进程的缺页率减少到适当程度为止，反之，若一个进程正在运行过程中的缺页率特别低，则此时可适当减少分配给该进程的物理块数，但不应该引起缺页率明显增加III. 物理块分配算法平均分配算法（将系统中所有可供分配的物理块平均分配给各个进程）按比例分配（根据进程的大小按比例分配物理块）考虑优先权的分配算法（将重要的，紧迫的作业分配较多的内存空间，可将系统的物理块分成两部分，一部分按比例分配给各进程，另一部分则根据进程的优先权适当地增加相应份额后，分配给进程）③实现请求调页的软件和实现页面置换的软件I.页面调入策略1.何时调入页面预调页策略采用以预测为基础的预调页策略，将那些预计在不久之后便会被访问的页面，预先调入内存，目前预调页的成功率仅为50%。主要用于进程的首次调入时.(毕竟预测实在是太难了)请求调页策略当程序在运行中需要访问某部分程序和数据时，若发现其所在的页面不在内存，便立即提出请求，由OS将其所需要的页面调入内存。优点：由请求调页策略所调入的页，一定会被访问且较易实现。缺点：每次仅调入一页，需花费较大的系统开销，增加了磁盘I/O的启动频率。2.从何处调入页面在请求分页系统中的外存分为文件区和对换区。每当发生缺页时，系统应从何处将缺页调入内存，可分成三种情况：系统拥有足够的对换区空间：可以全部从对换区调入所需页面，以提高调页速度。系统缺少足够的对换区空间：凡不会被修改的文件，直接从文件区调入；换出时不用换，再调入时仍从文件区调入。可能被修改的部分，换出时需调到对换区，换入时从对换区调入。UNIX方式：与进程有关的文件放在文件区，故未运行的页面应从文件区调入。曾经运行但又被换出的页面被放在对换区，下次调入应从对换区调入。进程请求的共享页面可能已被其它进程调入，无需再从对换区调入。II.页面调入过程3.是如何进行调入的(1)每当程序所要访问的页面未在内存时，便向CPU发出一缺页中断，中断处理程序首先保留CPU环境，分析中断原因后，转入缺页中断处理程序。(2)缺页中断处理程序通过查找页表，得到该页在外存上的物理块后，如果此时内存能容纳新页，则启动磁盘I/O将所缺之页调入内存，然后修改页表。(3)如果内存已满，则需按照某种置换算法从内存中选出一页准备换出；如果该页未被修改过，可不必写回磁盘；但如果此页已被修改，则必须将它写回磁盘，然后把所缺的页调入内存，并修改页表中的相应表项，置其存在位为“1”，并将此页表项写入快表。(4)在缺页调入内存后，利用修改后的页表，形成所要访问的物理地址，再去访问内存数据。4.缺页率缺页率 受以下几个因素的影响:(1)页面大小。页面划分较大，则f较低，反之f较高；(2)进程所分配的物理块数目。所分配的物理块数目多，则f较低，反之f较高；(3)页面置换算法。算法的优劣决定了进程执行过程中的缺页中断次数，因此f是衡量页面置换算法的重要指标；(4)程序固有特性。局部性越高，则f 越低。III. 页面调入算法把选择换出页面的算法称为页面置换算法，其好坏直接影响系统的性能。一个好的置换算法应具有较低的页面更换频率。从理论上讲，应将那些以后不会再访问的页面换出，或者把那些在较长时间内不会再访问的页面换出。如果选用了一个不合适的调度算法就会出现这样的现象：刚被调出的页又立即要用，因而又要把它调入；而调入不久又被调出；调出不久又再次被调入。如此反复，使调度非常频繁，以至于使大部分时间都花费在页面置换上，这种现象称为抖动，又称颠簸。因而应该选择一种好的调度算法，有较低的页面更换频率，以减少和避免抖动现象。==最佳置换算法OPT==是一种理论上的算法，所选择的被淘汰页面将是以后用不使用的，或者是在最长时间内不再被访问的，采用最佳置换算法，可以保证获得最低的缺页率，由于无法预知一个进程在内存的若干个页面中，哪个页面是未来最长时间内不再被访问的，因而该算法无法实现，但可以以此评价其他算法。假设系统为某进程分配了三个物理块，并考虑如下的页面号引用串：7， 0 ，1， 2， 0， 3， 0， 4， 2， 3， 0， 3， 2， 1， 2， 0， 1， 7， 0， 1。在进程运行后的置换如下图。缺页次数：9置换次数：6缺页率：9/20=45%==先进先出FIFO置换算法==该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰，该算法实现简单，只需要把一个进程已调入内存的页面，按照先后次序链接成一个队列，并设置一个指针，称为替换指针，使之指向最老的页面，但该算法与进程实际运行的规律不相适应，因为在进程中，有些页面经常被访问，FIFO算法并不能保证这些页面不被淘汰。缺页次数：15置换次数：12缺页率：15/20=75%先进先出算法的另一个缺点是它有一种异常现象。一般来说，对于任一作业或进程，如果给它分配的内存页面数越接近于它所要求的页面数，则发生缺页的次数会越少。但是，使用FIFO算法时，有时会出现分配的页面数增多，缺页次数反而增加的奇怪现象。这种现象称为Belady现象。先进先出算法产生Belady现象的原因在于它基于CPU按线性顺序访问地址空间这个假设，根本没有考虑程序执行的动态特征。==最近最久未使用（LRU）置换算法==该算法根据页面调入内存后的使用情况来进行决策，由于无法预测各页面将来的使用情况，LRU只能使用”最近的过去”代替”最近的将来”，因此，LRU置换算法是选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次访问以来所经历的时间t，当需要淘汰一个页面时，选择现有页面中其t值最大的，即最近最久未使用的页面予以淘汰。选择最后一次访问时间距离当前时间最长的一页并淘汰之。缺页次数：12置换次数：9缺页率：12/20=60%把LRU算法作为页面置换算法是比较好的，它对于各种类型的程序都能适用，但实现起来有相当大的难度，因为它要求系统具有较多的支持硬件。所要解决的问题有：一个进程在内存中的各个页面各有多久时间未被进程访问；如何快速地知道哪一页最近最久未使用的页面。为此，须利用以下两类支持硬件：1．移位寄存器：定时右移为每个在内存中的页面配置一个移位寄存器，用来记录某进程在内存中各页的使用情况。移位寄存器表示为R=Rn-1Rn-2Rn-3…R2R1R0当进程访问某物理块时，要将相应寄存器的Rn-1位置成1。此时，定时信号将每隔一定时间将寄存器右移一位。如果把n位寄存器的数看作一个整数，那么具有最小数值的寄存器所对应的页面，就是最近最久未使用的页面。其实本质上就是把访问过的页刷新为最大，每一次clock寄存器自动右移，代表除以2同步减少，最小的就是最长时间没使用的2．栈：当进程访问某页时，将其移出压入“栈顶”，“栈底”换出。利用一个特殊的栈来保存当前使用的各个页面的页面号。每当进程访问某页面时，便将该页面的页面号从栈中移出，将它压入栈顶。因此，栈顶始终是最新被访问页面的编号，而栈底则是最近最久未使用页面的页面号。==最少使用置换算法LFU==为内存中的每个页面设置一个移位寄存器，用来记录该页面被访问的频率该算法选择在最近时期使用最少的页面作为淘汰页。这种算法并不能真正反映出页面的使用情况，因在每一时间 间隔内, 只是用寄存器的一位来记录页的使用情况，因此在 每一时间间隔内访问1次和10000次是等效的LFU与LRU的区别LRU是最近最少使用页面置换算法(Least Recently Used),也就是首先淘汰最长时间未被使用的页面!LFU是最近最不常用页面置换算法(Least Frequently Used),也就是淘汰一定时期内被访问次数最少的页!比如,第二种方法的时间T为10分钟,如果每分钟进行一次调页,主存块为3,若所需页面走向为2 1 2 1 2 3 4 注意,当调页面4时会发生缺页中断若按LRU算法,应换页面1(1页面最久未被使用)但按LFU算法应换页面3(十分钟内,页面3只使用了一次)可见LRU关键是看页面最后一次被使用到发生调度的时间长短而LFU关键是看一定时间段内页面被使用的频率!==CLOCK置换算法【NRU（Not Recently Used）算法】==为每一页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列，当某页被访问时，其访问位置为1，置换算法在选择一页淘汰时，只需要检查页的访问位，如果是0，就选择该页换出；若为1，则重新置为0，暂不换出，给该页第二次驻留内存的机会，再按照FIFO算法检查下一页面。当检查到队列中的最后一个页面时，若其访问位仍然是1，则再返回到队首去检查第一个页面，该算法只有一位访问位，只能用它表示该页是否已经使用过，而置换时是将未使用过的页面置换出去，故又把该算法称为最近未用算法NRU(Not Recently Used)在将一个页面换出时，如果该页已经被修改过，便需要将该页重新写回到磁盘上，但如果没有被修改过，则不必将它拷回磁盘，在改进的Clock算法中，增加了一个置换代价的因素，这样，选择页面换出时，既要是未使用过的页面，又是要未被修改过的页面，把同时满足这两个条件的页面作为首选淘汰页面。由访问位A和修改位M可以组合如下四种类型的页面① （A = 0, M = 0），表示该页最近既未被访问，又未被修改，是最佳淘汰页面。② （A = 0, M = 1），表示该页最近未被访问，但已被修改，并不是很好的淘汰页面。③ （A = 1, M = 0），表示该页最近已被访问，但未被修改，该页可能被再次访问。④ （A = 1, M = 1），表示该页最近已被访问且被修改，该页可能再被访问。对于置换而言，执行如下几步。① 从指针所指示的当前位置开始，扫描循环队列，寻找A = 0 且 M = 0的第一类页面，将所遇到的第一个页面作为所选中的淘汰页，在第一次扫描期间不改变访问位A。② 如果第一步失败，即查找一周后未遇到第一类页面，则开始第二轮扫描，寻找A = 0 且 M = 1的第二类页面，将所遇到的第一个这类页面作为淘汰页。在第二轮扫描期间，将所有扫描过的页面的访问位A置为0。③ 如果第二步也失败，即未找到第二类页面，则将指针返回到开始位置，并将所有的访问位复为0，然后重复第一步，如果仍然失败，则重复第二步，则一定能够找到被淘汰的页。请求分页系统性能优越，是目前最常用的一种存储管理方式。但缺页情况影响着程序运行的速度及系统的性能；而缺页率的高低又直接与每个进程所占用的物理块数目有关。（1）页面置换算法（2）写回磁盘的频率（3）读入内存的频率IV.页面缓冲算法PBA虽然LRU和Clock置换算法都比FIFO算法好，但都需要硬件支持，页面缓冲算法则既可改善分页系统的性能，又可采用一种较简单的置换策略。页面缓冲算法采用了可变分配和局部置换方式,页面缓冲算法中，设置了两个链表（队列）存放被淘汰的页：空闲页链表（实际上就是空闲物理块链表）和已修改页面链表。（都用来存放被淘汰的页，只不过进入的标准不一样。）当需要读入一个页面时，便利用空闲物理块链表中的第一个物理块来装入。当有一个未被修改的页要换出时，并不将它换出内存，而是直接把它所在的物理块挂在空闲页链表的末尾。换出一个已修改的页面时，则将其所在的物理块挂在修改页面链表的末尾。注意：换出页面时，页面在内存并不做物理上的移动，只是将页表中的表项移到上述两个链表之一中。这种方式可使已被修改的页面和未被修改的页面，都仍留在内存中。当进程以后再次访问这些页面时，就有可能只须花费较小的开销。只有当被修改页面达到一定数量，例如64个页面时，再将它们一起写回到磁盘，从而显著地减少了磁盘I/O的操作次数。④访问内存的有效时间注意：快表是一种寄存器，非内存中的部分分区。λ：查找快表的时间t：存储器的访问时间ε：是缺页中断处理时间a：命中率f：缺页率请求分页系统中不发生缺页情况， 且对应的页表项在快表中（EAT)＝ λ+tλ+t：查找块表+内存取数据被访问页在内存中且对应的页表项在不快表中EAT＝ λ+t +λ+t=2（λ+t）第一个λ+t：查找快表+访问存储器的页表第二个λ+t：存入快表+访问存储器中数据被访问页不在内存EAT＝ λ+t +ε+λ+t=ε+2（λ+t）第一个λ+t：查找快表+访问存储器的页表ε：缺页中断处理。第二个λ+t：存入快表+访问存储器中数据考虑快表的命中率及缺页率EAT＝λ+a×t+(1-a)×[t+f×(ε+λ+t)+(1-f)(λ+t)]λ：访问页表a×t：访问页表命中则访问内存取数据(1-a)：访问快表未命中t：未命中则取访问页表f×(ε+λ+t)：缺页，发生中断处理将数据调入内存，地址存入快表，取数据(1-f)(λ+t)：不缺页，则地址存入快表，取数据不考虑快表的命中率只考虑缺页率EAT＝t+f×(ε+t)+(1-f)×t即a=λ=0⑤抖动与工作集I.抖动在多道程序环境下，适当提高多道程序度（在内存中并发执行的程序数目），可以提高系统的吞吐量。否则将会出现“抖动”现象，反而使系统吞吐量下降。在虚存中，页面在内存与外存之间频繁调度，以至于调度页面所需时间比进程实际运行的时间还多，此时系统效率急剧下降，甚至导致系统崩溃。这种现象称为颠簸或抖动原因：分配给进程的物理块数太少（根本原因）页面淘汰算法不合理II.工作集所谓工作集是指，在某段时间间隔△里，进程实际要访问的页面的集合。程序在什么时刻将访问哪些页面无法预知，只能利用程序过去某段时间内的行为，作为程序在将来某段时间内的行为的近似。把某进程在时间t 的工作集记为w(t, △)，把变量△称为工作集“窗口尺寸”。下图显示了进程访问页面的序列及当窗口尺寸分别为3、4、5时的工作集。其实就是把过去使用过的页存起来。满了就把最先放进去的顶出去。据前表可以看出：工作集与时间t有关：不同时间t 的工作集的大小不同，所包含的页面数也不相同；工作集与窗口尺寸△有关：△选择得很大，以致能将一个进程的整个地址空间全部装入内存，存储器不会得以充分地利用，从而失去了虚拟存储器的意义。选择得过小，不能将进程所需的工作集全部装入内存，则会频繁地产生缺页中断，降低系统的吞吐率。因此，工作集的大小应选择适中，使拐点附近的缺页率保持在适当合理的水平上。III.抖动的预防方法通过调节多道程序度可以防止抖动现象的产生和扩展，具体方法有：采取局部置换策略系统采取可变分配、局部置换。这样，即使有某个进程发生“抖动”，也不致引起其它进程也产生抖动，从而把抖动局限于较小的范围内。这种方法不能从根本上防止抖动的发生；而且发生抖动的进程还会长期地处于磁盘I/O的等待队列中，使其它进程缺页中断的处理时间增长，延长了有效的访问时间。在CPU调度程序中引入工作集算法当调度程序发现CPU利用率低时，自动地从外存调入一新作业进入内存。在调度程序从外存调入作业前，必须检查每个进程在内存的驻留集是否足够大，仅当每个进程在内存中有足够大的驻留集时，才再从外存上调入新的作业，以防新作业的调入而导致缺页率增加。L=S准则当产生缺页的平均时间L等于系统处理进程缺页的平均时间S时，CPU利用率最高，以此原则调整多道程序度。挂起若干进程挂起某些进程，腾出内存分配给抖动的进程。被挂起的进程通常是优先权最低或较低的、不很重要但较大的进程（当内存非常拥挤时）、或者是具有最多剩余执行时间的进程。思考题1、在一个采用分页式虚拟存储管理的系统中，有一用户作业，它依次要访问的字节地址序列是：115，228，120，88，446，102，321，432，260，167。 若分配给作业可使用的主存空间共300个字节，作业的页面大小为100个字节，且第0页已经装人主存，请回答下列问题：（1）按FIFO页面调度算法将产生多少次缺页中断？写出依次淘汰的页号。（2）按LRU页面调度算法将产生多少次缺页中断？写出依次淘汰的页号。答（过程略）（1）FIFO页面调度算法将产生5次缺页中断，依次淘汰的页号：0、1、2（2）按LRU页面调度算法将产生6次缺页中断，依次淘汰的页号：2、0、1、3(2)请求分段存储管理方式只需先调入若干个分段便可启动运行，当所访问的段不在内存中时，可请求OS将所缺的段调入内存。也同样需要硬件的支持。①请求分段中的硬件支持为了快速完成请求分段功能，需要支持的硬件有段表机制、缺段中断机制、地址变换机构。I.段表① 段表机制，由于只有一部分段装入内存，其余段仍留在外存上，需要再段表中增加若干项，以供程序调进、调出时参考。存取方式 ：用于标识本分段的存取属性,只执行\只读或允许读/写。访问字段A ：用于记录本段被访问的频繁程度。修改位M：表示该页在进入内存后是否已被修改过，供置换时参考）存在位P：表示本段是否已调入内存，供程序访问时参考增补位：用于表示本段在运行过程中是否做过动态增长外存始址：本段在外存中的起始地址，即起始盘块号。II.缺页中断机构，进程运行时发现所需的段尚未调入内存，便由缺段中断机构产生一个缺段中断信号，进入OS后由缺段中断处理程序将所需要的段调入内存。需要在一条指令的执行期间，产生和处理中断，以及一条指令执行期间，可能会产生多次缺段中断。缺段中断同样需要在一条指令的执行期间，产生和处理中断，以及在一条指令执行期间，可能产生多次缺段中断。但不会出现一条指令被分割在两个分段中或一组信息被分割在两个分段中的情况。对缺段中断的处理要比对缺页中断的处理复杂，因为段是不定长的。III.地址变换机构其在分段系统地址变换机构基础上形成，增加了缺段中断的请求和处理功能。②分段的共享和保护为了实现共享，可在内存中配置一张共享段表，所有各共享段都在共享段表中占有一表项。除了段表再设置一个共享段表(1) 共享计数count：共享段为多个进程所需要，当某进程不再需要它而释放它时，系统并不回收该段所占内存区，仅当所有共享该段的进程全都不再需要它时，才由系统回收该段所占内存区。设置count用于记录有多少个进程需要(2) 存取控制字段：对于一个共享段，应给不同的进程以不同的存取权限。(3) 段号：对于一个共享段，不同的进程可以各用不同的段号去共享该段。分配与回收为共享段分配内存时，对第一个请求使用该共享段的进程，由系统为该共享段分配一物理区，再把共享段调入该区，同时将该区的始址填入请求进程的段表的相应项中，还须在共享段表中增加一表项，填写有关数据，把count置为1；之后，当又有其他进程需要调用该共享段时，无需再为该段分配内存，只需在调用进程的段表中，增加一表项，填写该共享段的物理地址；在共享段的段表中，填上调用进程的进程名、存取控制等，再执行count:=count+1操作。当共享该段的进程不再需要该段时，应将该段释放，包括撤消在该进程段表中共享段所对应的表项，以及执行count:=count-1操作。如果结果为0，则需由系统回收该共享段的物理内存，以及取消在共享段表中该段所对应的表项，否则只取消调用者进程在共享段表中的有关记录。分段保护越界检查段表寄存器存放了段表长度；段表中存放了每个段的段长。在进行存储访问时，将段号与段表长度比较，段内地址与段长比较。存取控制检查段表中的每个表项都设置了“存取控制”字段，用于规定该段的访问方式。只读只执行读/写环保护机构规定：低编号的环具有高优先权一个程序可以访问驻留在相同环或较低特权环中的数据。一个程序可以调用驻留在相同环或较高特权环中的服务。4、四、五章节存储器管理总结页式方法会产生少量内部碎片。段没有内部碎片，解决内部碎片最好的就是段式，但是会造成外部碎片。碎片 一般默认是外部碎片。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统【九】]]></title>
    <url>%2Fposts%2F25d973d3%2F</url>
    <content type="text"><![CDATA[6、分段存储管理方式从固定分区到动态分区分配，再到分页存储管理方式，其主要动力为提高内存利用率，引入分段存储管理的目的在于满足用户在编程和使用上多方面的要求。如① 方便编程，用户可以把自己的作业按照逻辑关系划分为若干段，每个段都是从0开始编址，并有自己的名字和长度。② 信息共享，在实现对程序和数据的共享时，是以信息的逻辑单位为基础的，比如共享某个函数。③ 信息保护，信息保护同样是对信息的逻辑单位进行保护。④ 动态增长，在实际应用中，数据段在使用过程中往往会不断增长，而实现无法确切知道数据段会增长到多大，分段可以较好的解决这个问题。⑤ 动态链接，再运行时，先将主程序所对应的目标程序装入内存并启动运行，当运行过程中有需要调用某段时，才将该段调入内存并进行链接。(1)分段系统的基本原理在分段管理中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息，如有主程序段MAIN，子程序段X，数据段D及栈段S，每个段都有自己的名字，每个段从0开始编址，并采用一段连续的地址空间，段的长度由相应的逻辑信息组的长度决定，因而各段长度不等，整个作业的地址空间由于是分成多个段，因而是二维的，即其逻辑地址由段号和段内地址构成。如下图，进程 A 按照逻辑功能被划分为三个段，每个段大小不一，最后再被分配到内存中不连续的各个空间中：由于引入了分段存储管理，所以可以将程序按照逻辑功能模块进行划分，程序员在编写程序的时候也会更加方便，程序的可读性会更高，比如：12LOAD 1，[D]|&lt;A&gt;STORE 1，[X]|&lt;B&gt;分别表示：将分段 D 中 A 单元内的值读入寄存器 1，以及将寄存器 1 的值存入分段 X 的 B 单元中。很显然，逻辑上是非常清晰的。这里的分段 D 和 X 都是段名，程序员在编程的时候只需要使用段名，而在编译的时候，段名会转化为对应的短号，同理，A、B 单元表示的其实是地址，编译的时候也会转化为对应的地址。在引入分段存储管理后，逻辑地址的含义也不同了。假设仍然是用 32 位二进制数表示逻辑地址，此时，地址的前 16 位将表示段号，后 16 位表示段内偏移量：由于段号是 16 位二进制数，也就是说段号有 2^16^ 种取值，即每个进程最多最多可以被分为 2^16^ 个段；由于段内偏移量也是 16 位二进制数，也就是说在一个段内，段内地址可能有 2^16^ 种取值，所以一个段的最大长度为 2^16^(2)段表在分段存储管理中，程序被分为大小不等的多个段，我们没办法像之前一样只需要块号即可推导出块的初始地址，为了准确地找出段存放在内存中的位置，我们要将段号、段长、基址 这三者作为段表的三列。这样，根据段号可以在段表中找到对应段在内存中的初始地址（基址），再结合段长，可以知道这个段具体占用了哪里的空间。在分段式存储管理系统中，为每个分段分配一个连续的分区，而进程中的各个段可以离散地移入内存中不同的分区，为了使程序正常运行，能够物理内存中找出每个逻辑段所对应的位置，应该为每个进程建立一张段映射表，称为段表，每个段在表中有一个表项，其中记录了该段在内存中的起始地址和段的长度。段表可以存放在一组寄存器中，这样有利于提高地址转换速度，但通常将段表放在内存中。段表用于实现从逻辑段到物理内存区的映射。为了实现从进程的逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址和段表长度(TL)，在进行地址变换时，系统将逻辑地址中的段号与段表长度TL进行比较，若S&gt;TL，表示段号太大，访问越界，产生越界中断信号，若未越界，则根据段表的始址和该段的段号，计算该段对应段表项的位置，从中读出该段在内存中的起始地址，然后，再检查段内地址d是否超过该段的段长SL，若超过，同样发出越界中断信号（因为你表项里明明是这么长A，而你想偏移B，且B》A，必然会越界。），若未越界，则将该段的基址与段内地址d相加，即得到要访问的内存物理地址。另一个图，同样意思展示段表的使用流程。在需要将逻辑地址转换为物理地址的时候，首先会将逻辑地址分为段号和段内偏移量两个部分，段表寄存器中的段表长度代表了程序总共被分为多少个段，因此段号不应该超过段表长度，若超过则发生了越界中断，若不超过，进入下一步根据段号、段表初始地址以及段表项的大小，找到段号对应的段表项。比较段表项中的段长 C 和逻辑地址中的段内偏移量 W，若 W&gt;=C，说明越界了；反之则进入下一步（注意这里要与分页存储相区分）（因为你表项里明明是这么长A，而你想偏移B，且B》A，必然会越界。）在段表项中找到段号对应的基址，将该基址与段内偏移量拼接，得到物理地址根据物理地址来到内存中访问相关的目标单元为什么会有一个偏移量呢？因为段长+基址知识只是我们找到对应段。我们本来的不低是想找到某个地址内的内容，需要在这个段内进行偏移才能找到它。就像你想在一页书中找到一行文字。(3)分段和分页的比较可以看到，分页与分段存在很大的相似性，如都采用离散分配方式，都需要通过地址映射机构实现地址变换，但两者的主要区别如下。① 页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率，或者说，分页仅仅是由于系统管理的需要而不是用户的需要，段则是信息的逻辑单位，它含有一组意义相对完整的信息，分段的目的是为了能更好地满足用户的需要。② 页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，一个系统中，只存在一种大小的页面，段的长度则不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。③ 分页的作业的地址空间是一维的，即单一的线性的地址空间，程序员只利用一个记忆符即可表示一个地址，而分段的作业地址空间是二维的，程序员在标识一个地址是，需要给出段名和段内地址。另一个图，表达的对比。(4)信息的共享和保护在分段存储方式中，更容易实现信息共享和保护：在分页存储方式中，则很难：其实原因很简单，就是因为段表是认为的逻辑划分，这个段能重复利用就是能重复利用。而分页是系统根据大小分的。一个能重复利用的代码段很可能被分成两个或多个页中，或者分到一个页中，但这个页还包含其他内容。都不容易设定。(5)访存次数关于访存次数，两者都是一样的：在不引入快表的情况下，分页存储方式的第一次访存是访问内存中的页表，第二次是访问内存中的目标单元；若引入快表，则第一次访存有可能因为命中而得到避免分段存储方式的第一次访存是访问内存中的段表，第二次是访问内存中的目标单元。它也可以引入快表，若引入快表，则第一次访存有可能因为命中而得到避免7、段页式存储管理采用分页存储管理，内存利用率高，不会产生外部碎片，仅会产生少量内部碎片；但是不方便按照逻辑模块实现信息的共享和保护采用分段存储管理，很方便按照逻辑模块实现信息的共享和保护，但是若逻辑过多则会导致段过长，另外，这种方式也会产生外部碎片分页系统能够有效的提高内存利用率（但是会存在页内碎片），分段系统则能够很好地满足用户需要。若能将两种方式结合起来，既具有分段系统的便于实现、分段可共享、易于保护、可动态链接等优点，又能像分页系统那样很好地解决内存的外部碎片问题，基于此，提出了段页式系统。段页式系统先将用户程序分成若干个段，再把段分为若干个页，并为每一个段赋予一个段名。段页式系统中，地址结构由段号、段内页号、页内地址三部分构成。在段页式系统中，为了获得一条指令或数据，需要==访问内存三次==，第一次访问时访问内存中的段表，从中取得页表始址，第二次访问是访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址，第三次访问才是真正的从第二次访问所得的地址中，取出指令或数据。同样，也可以增设高速缓冲寄存器用于加快访问速度。若检索到（命中），则无需经历第一次和第二次访存，可直接拿到块号并和偏移量进行拼接，得到物理地址，之后只需要访存一次即可。也就是说，引入快表后，省下了两次访存。在需要将逻辑地址转换为物理地址的时候，首先会将逻辑地址分为段号、页号和页内偏移量三个部分，段表寄存器中的段表长度仍然代表了程序总共被分为多少个段，因此段号不应该超过段表长度，若超过则发生了越界中断，若不超过，进入下一步根据段号、段表初始地址以及段表项的大小，找到段号对应的段表项。这个段表项记录了段号对应段的页表的相关信息。注意这里，同样要比较段表项中的页表长度和逻辑地址中的页号 P，若页号大于等于页表长度，说明越界了；反之则进入下一步我们已经找到了段表项，也就找到了段的页表所在块的块号。根据这个块号，在内存中找到这个块，再从块中找到页表根据逻辑地址中的页号，在页表中找到页号对应的块号，将块号和逻辑地址中的页内偏移量拼接，得到物理地址根据物理地址，再次来到内存中访问相关的目标单元思考题块！不是段!。这是页式存储。内存-&gt;块，程序-&gt;页1、假定某采用页式存储管理的系统中，主存容量为1M，被分成256块，块号为0，1，2，……255。现有一个共4页（页号为0，1，2，3）的作业被依次装人到主存的第2，4，1，5块中。请回答：（1）主存地址应该用多少位来表示？20位（2）作业每一页的长度为多少字节？逻辑地址中的页内地址部分应占用多少位？4K 12位（3）把作业中每一页占用的主存块起始地址填入下表。页号起始地址08K116K24K320K（4）若作业执行中要从第0页的第75单元和第3页的第548单元读信息，那么，实际应从主存的哪两个单元读信息？（ 请把应访问的主存绝对地址用二进制编码的十六进制数表示。）若作业执行中要从第0页的第75单元，对应的物理地址是： 8*1024+75=8267，二进制：0010 0000 0100 1011十六进制：204B第3页的第548单元，对应的物理地址是： 20*1024+548=21028，二进制：0101 0010 0010 0100十六进制：52248、内存的扩充(1)覆盖技术(2)对换技术所谓“对换”，是指把内存中暂时不能运行的进程或者暂时不用的程序和数据，调到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程和进程所需要的程序和数据，调入内存。整体对换(或进程对换)：以整个进程为单位页面对换或分段对换：以页或段为单位对换整个作业—-用于单道系统（单道模拟多道）对换整个进程—-用于连续分区存储管理（进程挂起、激活，中程调度）对换（置换）页面/段—-请求分页、请求分段存储管理虚拟存储技术）(3)虚拟技术详见第五章。在页式存储管理中，分页是由硬件_完成的。在页式存储管理中，分页是由程序员_完成的。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统【八】]]></title>
    <url>%2Fposts%2F5f14528c%2F</url>
    <content type="text"><![CDATA[4、对换在多道程序环境下，一方面，在内存中的某些进程由于某事件尚未发生而被阻塞运行，但它却占用了大量的内存空间，甚至有时可能出现在内存中所有进程都被阻塞而迫使CPU停止下来等待的情况，另一方面，却有很多作业在外存上等待，因无内存而无法进入内存运行的情况，这是对系统资源的浪费，为了解决这个问题，增设了对换设施，对换是把内存中暂时不能运行的进程或者暂时不用的程序和数据调出到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或者进程所需要的程序和数据调入内存。对换是提高内存利用率的有效措施。如果对换的单位是进程，便称为整体对换或进程对换，为了实现进程对换，系统必须实现对换空间的管理、进程的换出、进程的换入。① 对换空间的管理，在具有对换功能的OS中，通常把外存分为文件区和对换区，前者用于存放文件，后者用于存放从内存换出的进程。由于文件通常是较长久的驻留在外存上，文件区的管理主要目标是提高存储空间的利用率，采取离散分配方式，进程通常在对换区中驻留的时间较短暂，对换操作较频繁，故对对换空间管理的主要目标是提高进程换入和换出的速度，采取的是连续分配的方式，较少考虑外存中的碎片问题。② 进程的换出，每当进程由于创建子进程而需要更多的内存空间，但又无足够的内存空间情况时，系统应将某进程换出，首先，系统首先选择处于阻塞状态且优先级最低的进程作为换出进程，然后启动磁盘，将该进程的程序和数据传送到磁盘的对换区上，若传送过程没有错误，则可回收该进程所占用的内存空间，并对该进程的进程控制块做相应的修改。③ 进程的换入，系统定时地查看所有进程的状态，从中找出就绪状态但已换出的进程，将其中换出时间最久的进程作为换入进程，将其换入，直至无换入的进程或无可换出的进程为止。对换空间的分配与回收，与动态分区方式时的内存分配与回收雷同。5、基本分页存储管理方式连续分配，包括固定分区分配和动态分区分配。但前者容易产生内部碎片，后者容易产生外部碎片（虽然可以用紧凑技术解决，但是有一定的成本），都不是理想的解决方案。果允许一个进程直接分散地装入到许多不相邻接的分区中，则无须进行紧凑操作，基于这一思想产生了离散分配方式，如果离散分配的基本单位是页，则称为分页存储管理方式，若为段，则为分段存储管理方式。通俗：在连续分配中，一个进程不可被分割，只能整体放入一块连续的内存空间中；但在基本分页存储管理中，允许把一个进程按照固定大小 X 分割为多个部分，同时把内存也按照固定大小 X 分割为多个部分，并把前者对应地放到后者中（不要求连续存放）。通常来说，一个进程的最后一部分会小于 X，这部分若放到内存的某个 X 空间中，则仍然会产生碎片（这种碎片称为页内碎片），要让这种碎片尽可能小，X 也必须尽可能小。(1)页面与页表①页面、页框（块）将用户程序的地址空间分为若干个大小固定的页，对应的内存空间分为与页面 大小相同的块（block）或页框（frame ）分页存储管理是将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并为各页进行编号，从0开始。相应地，把内存空间分成与页面相同大小的若干个存储块，称为（物理）块或者页框，也同样为它们编号，如0#块，1#块等。在未进程分配内存时，以块为单位将进程的若干个页分别装入到多个可以不相邻接的物理块中，由于进程的最后一页经常装不满一块而形成不可利用的碎片，称之为页内碎片。==进程：页面====内存：块、页框==在分页系统中的页面其大小应适中，页面若太大，一方面可以是内存碎片减少，有利于提供内存利用率，但是，每一个进程占用的页面较多，导致页表过长，占用太多内存，会降低页面换进换出的效率。页面若太大，可减少页表的长度，提供页面换进换出的速度，但是，内存碎片会增大，所以，也页面大小应适中，通常为512B~8K。分页地址中的地址结构如下说明：前一部分为页号P，后一部分为位移量W（或称为页内地址），总共32位，其中0-11位为页内地址，每页大小4KB，12-31位为页号，地址空间最多允许1M页。②页表为了能够保证在内存中找到每个页面所对应的物理块，系统为每个进程建立了一张页面映射表，简称为页表。页表项纪录了相应页在内存中对应的物理块号，在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号，页表实现了从页号到物理块号的地址映像。③地址转换1、十进制地址左边进程按照 50b 的大小分为 4 个页面，右边内存按照 50b 的大小分为若干个页框：在程序执行到指令 1 的时候，需要访问地址 80，这是一个逻辑地址，需要转换成对应的物理地址。转换步骤如下：计算逻辑地址的页号根据页号找到页号对应页面在内存中的起始地址计算逻辑地址在当前页面内的偏移量物理地址 = 起始地址 + 页内偏移量从左图可以看出，逻辑地址 80 在 1号页面内，而 1 号页面对应的是右图中的红色页框，起始地址为 450；逻辑地址 80 在 1号页面内的偏移量为 30；所以物理地址 = 450 + 30 = 480也可以用计算的方法，在已知逻辑地址的情况下：==页号 = 逻辑地址/页面长度，即 80/50 = 1（取整数部分）；====页内偏移量 = 逻辑地址%页面长度，即 80%50 = 30；==2、二进制地址当然，地址实际上是用 32 位二进制数表示的。这时候计算页号和页内偏移量实际上更加简单，因为地址本身已经包含了这两者。以页面/页框大小 4kb 为例：一个页面 4kb 大小，也即 2^12^b = 4096b 大小。那么，0 号页、1 号页、2 号页的表示就是：这里会发现，地址的前 20 位（红色部分）表示页号：全是 0 表示 0 号页，末尾 1 表示 1 号页，末尾 10 表示 2 号页……以此类推；地址的剩余（黑色）部分表示页内偏移量。所以说地址本身其实已经包含了这两者的信息。若页面/页框大小位 1kb，也即 2^10^b =1024b 大小，那么同样可以发现，地址的前 22 位表示页号，地址的剩余部分表示页内偏移量：总结下来，规律就是：如果页面/页框大小为 2^k^ b，那么前面部分表示页号，末尾 k 位表示页内偏移量。在页面/页框大小为 2 的整数幂的时候，就可以直接从地址看出页号和页内偏移量，因此建议将页面/页框大小设置为为 2 的整数幂。(2)地址变换机构①基本地址变换机构为了能够将用户地址空间中的逻辑地址变换为内存空间中的物理地址，在系统中必须设置地址变换机构，该机构的基本任务是实现从逻辑地址到物理地址的转换，由于页内地址与物里块内的地址一一对应，无须再进行转换，因此，地址变换机构的任务实际上只是将逻辑地址中的页号转换为内存中的物理块号。又因为页面映射表的的作用就是用于实现从页号到物理块号的变换，因此，地址变换任务是借助页表来完成的。页表的功能可以由一组专门的寄存器来实现，一个页表项用一个寄存器，由于寄存器具有较高的访问速度，因而有利于提高地址变换的速度，但成本较高，且页表项一般会很多，都使用寄存器实现不太现实，因此，页表大多驻留在内存。在系统中只设置一个页表寄存器PTR(Page-Table Register)，用于存放页表在内存的始址和页表的长度，平时，进程执行时，页表的始址和页表长度存放在本进程的PCB中，当调度程序调度到某进程时，将这两个数据装入页表寄存器，因此，在单处理机环境下，虽然系统中可以运行多个进程，但只需要一个页表寄存器。当进程要访问某个逻辑地址中的数据时，分页地址变换机构会自动地将有效地址（相对地址）分为页号和页内地址两部分，再以页号为索引去检索页表，查找操作由硬件执行，在执行检索前，先将页号与页表长度进行比较，若页号大于或等于页表长度，则表示本次访问的地址超越了进程的地址空间，这一错误将被系统发现并产生一个地址越界中断。若未出现错误，则将页表始址加上页号与页表项长度的乘积，便得到该表项在页表中的位置，于是可从中得到该页的物理块号，将之装入物理地址寄存器，与此同时，再将有效地址寄存器中的页内地址送入物理地址寄存器的块内地址字段中，这样，便完成了逻辑地址到物理地址的转换。在程序未执行的时候，PCB 中存放程序对应页表的初始地址 F 以及页表长度 M（页表项个数）。程序一旦开始执行，F 和 M 会被送到页表寄存器中。在需要访问地址的时候，基本地址变换机构开始运行：首先将逻辑地址 A 拆分为页号和页内偏移量两个部分，然后将页号与页表寄存器中的页表长度作比较。页表长度即页表项个数，即页面个数，因此页号是不能大于等于（不能等于，是因为页号从 0 开始计算，类似于数组）页表长度的，否则就说明页号越界了，此时就会发生越界中断。若不越界，来到下一步由于页表中每个页表项的大小是一样的（假设为 size），且已经知道了页表初始地址（假设为 X），所以很容易知道页号 P 对应的页表项的地址，它等于 X + size*P，找到这个地址就意味着找到了页号对应的块号将块号与偏移量（注意这两个都是二进制）拼接，就得到了物理地址根据物理地址，就可以访问到目标==在上面例子中，由于涉及到的都是二进制数，所以要计算物理地址，只需要将块号二进制数与偏移量二进制数拼接即可，这是比较方便的==，如果例子给出的是十进制数，那么可以用 块起始地址 + 页内偏移量 进行计算，计算结果可以再转化为二进制数，结果其实也是一样的。比如：若给定的是十进制：页面大小 1kb，块号 2，偏移量 1023。那么块起始地址等于 2*1kb = 2*1024b=2048b，又偏移量 1023，所以物理地址等于 2048+1023=3071，转化为 32 位二进制数，就是 0000000000000000000010,1111111111若给定的是二进制：页面大小 1kb，块号 2，偏移量 1111111111。那么块号 2 转化为 22 位二进制数就是 0000000000000000000010，与偏移量拼接，就得到 0000000000000000000010,1111111111，可以看出与上面的结果是一样的。1、若逻辑地址以十六进制、八进制、二进制的形式给出的，则计算方法如下：==将逻辑地址转换成二进制的数====按页的大小分离出页号和位移量（低位部分是位移量，高位部分是页号）====根据题意查找页表====将位移量直接复制到内存地址寄存器的低位部分====以页号查页表，得到对应页装入内存的块号，并将块号转换成二进制数填入地址寄存器的高位部分，从而形成内存地址。==2、逻辑地址以十进制数给出，则==页号P=INT[虚地址/页面大小]====位移量d=虚地址 % 页面大小====根据页号查页表，得到对应的块号 内存地址=块号*页面大小+位移量== ②具有快表的地址变换机构上述操作中，每次存取一个数据时，都会==访问内存两次==，第一次是访问内存中的页表，从中找到指定页的物理块号，再将块号与页内偏移量W拼接，以形成物理地址，第二次访问时，才是从第一次所得的地址中获得所需数据，因此，这种方式会使计算机的处理速度降低一半，为了提高地址变换速度，可以在地址变换机构中增设一个具有并行查询能力的特殊高速缓冲寄存器，又称为联想寄存器或快表，用以存放当前访问的那些页表项。第二次访存肯定是不能避免的，但是第一次访存其实可以想办法避免。若多条指令涉及到的逻辑地址的页号都相同，则每次都得经历第一次访存，找到该页号对应的块号上面这两个问题可以通过引入快表来解决。快表又叫做联想寄存器，它是一种访问速度比内存快很多的高速缓冲存储器，用以存放访问过的页表项的副本，从而加快地址转换的过程 —— 也就是说，引入快表后，地址转换可以不需要经历第一次访存，而是直接从快表中拿到需要的页表项。与之对应的，内存中原本的页表，叫做慢表。==其实应用的是局部性原理==此时，地址变换机构的运行过程和之前还是差不多的，只是多了一个快表的处理过程：在程序未执行的时候，PCB 中存放程序对应页表的初始地址 F 以及页表长度 M（页表项个数）。程序一旦开始执行，F 和 M 会被送到页表寄存器中。在需要访问地址的时候，地址变换机构开始运行：首先将地址拆分为页号和页内偏移量两个部分，然后将页号与页表寄存器中的页表长度作比较。若越界，则发生越界中断。若不越界，来到下一步该页号被送往快表，并与其中的页表项一一比较，寻找是否有配对的页号，因为这里我们是第一次查询，所以是没有的，即未命中，此时来到下一步经历第一次访存，在内存的页表中找到页号对应的页表项的地址，找到这个地址就意味着找到了页号对应的块号将该页表项拷贝一份副本放到快表中将块号与偏移量（注意这两个都是二进制）拼接，就得到了物理地址根据物理地址，就可以访问到目标假设又一次地，我们需要访问某个地址，并且这个地址与前次访问的地址的页号一样：首先将地址拆分为页号和页内偏移量两个部分，然后将页号与页表寄存器中的页表长度作比较。若越界，则发生越界中断。若不越界，来到下一步该页号被送往快表，并与其中的页表项一一比较，寻找是否有配对的页号，因为之前我们已经在快表中存放了一份页表项的副本，所以找到了配对的页号，即命中，此时来到下一步从快表中读出该页号对应的块号，并与偏移量拼接，就得到了物理地址根据物理地址，就可以访问到目标这里可以注意到，由于第一次查询到页号对应的块号后，我们将页表项拷贝了一份副本放到快表中，所以以后再涉及到相同的页号时，只需要先来到快表查找即可，找到了就直接拼接得到物理地址，无需再到内存中去访问页表，寻找页号对应的块号。当然，由于成本的关系，快表不会做得很大，但对于中小型作业来说也已经足够，只是对于大型作业来说，不太可能把全部页表项都存放到快表中。I.访问内存的有效时间（Effective Access Time,EAT)从进程发出指定逻辑地址的访问请求，经过地址变换到在内存中找到对应的实际物理地址单元取出数据所花费的总时间 。分页存储管理方式==EAT=2t(t为访问一次内存所需时间）==引入快表分页存储管理方式==EAT= a×λ+(t+λ)(1-a)+t=2t+λ-at==a×λ+(t+λ)(1-a)为使用块表的平均查询时间t为不可避免的访存时间λ为查找快表所需时间 ，a为命中率某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。假设访问一次快表耗时 1us，访问一次内存耗时 100us，快表的命中率为 90%。若未引入快表，则访问一个逻辑地址耗时 100 + 100 = 200us若引入快表，则访问一个逻辑地址耗时 (1+100) * 0.9 + (1+100+100) * 0.1= 111 us若引入快表，且该系统支持同时查询快表和慢表，则访问一个逻辑地址耗时 (1+100) * 0.9 + (100+100) * 0.1 = 110.9us显然，引入快表后，访问一个逻辑地址的速度快多了。II.页表项的大小假设某系统物理内存大小为 4GB，页面大小为 4KB，则每个页表项至少应该为多少字节？4GB=2^32^ b， 4KB=2^12^b，因此 4GB 的内存总共会被分为 2^32^/2^12^ = 2^20^ 个内存块，因此内存块号的范围应该是 0～2^20^-1。因此对于单个页表项，它至少要用一个 20 位二进制数才能表示这样的一个内存块号，而一个字节 8 位，所以至少要三个字节才可以表示这样的一个内存块号。又由于实际不知道哪个页表项存放哪个内存块号，所以所有的页表项统一得用到至少三个字节。但是一个页表项用三个字节其实会出现一些问题。类似于进程被拆分为多个页面存储在内存中一样，页表也是被拆分为多个页表项存储在内存中的。假设页面/页框大小为 4kb，也即 4096b，由于一个页表项 3b，所以一个页框至多可以放 4096/3=1365 个页表项，并且这个页框剩余 1b 的空间。由于 1b 不足以再存放一个页表项，所以第 1366 个页表项（1365 号页表项）只能放在下一个页框中了。这就会导致，前面 1365 个页表项的地址依然可以采用 X + 3*P 的方式计算，但是第 1366 个页表项，它的地址却应该是 X + 3*P + 1，也就是说，我们无法以一个通用的式子去计算页表项的地址。为此，建议一个页表项大小应为 4b 而不是 3b（选取 2 的整数幂）。因为如果页表项大小为 4b，那么一个页框就刚好可以放 4096/4=1024 个页表项，不会有剩余空间，而余下的页表项也可以依次放在下一个页框中。这样的话，涉及到页表项地址的计算，都可以用通用的式子 X + 4*P 来计算，就无需考虑由于页框无法得到完全利用而带来的查询麻烦的问题了。当然，为了这个式子能够通用，页表通常也应该连续地存放在内存块中，中间不出现断节。③两级页表和多级页表I.两级页表现代计算机系统中，可以支持非常大的逻辑地址空间（2^32^~2^64^），这样，页表就变得非常大，要占用非常大的内存空间，如，具有32位逻辑地址空间的分页系统，规定页面大小为4KB，则在每个进程页表中的页表项可达1M(2^20^)个，又因为每个页表项占用一个字节，故每个进程仅仅页表就要占用1MB的内存空间，而且要求连续，这显然是不现实的，可以通过如下两个方法解决该问题。采用离散方式只将当前所需页表项调入内存对于要求连续的内存空间来存放页表的问题，可利用将页表进行分页，并离散地将各个页面分别存放在不同的物理块中的办法来解决，同样的，也要为离散分配在页表再建立一张页表，称为外层页表。在每个页表项中记录了页表页面的物理块号，以32位逻辑地址空间为例进行说明。说明：外层页号P1为10位，可以表示1024个物理块，外层页表中的外层页内地址P2为10位，可以表示1024个物理块，页内地址为12位，表示页面大小为4K。在需要进行地址转换的时候：首先将逻辑地址分为三个部分：一级页号、二级页号、页内偏移量然后从 PCB 中读出页目录表的初始地址，结合一级页号以及每个页表项的大小，找到一级页号对应页表项的地址，即找到了对应页表项，也就找到了一级页号对应的内存块号根据内存块号到内存中找到对应的那个二级页表（原页表的某个子页表）在二级页表中，根据二级页号找到对应的块号块号与偏移量结合，得到物理地址为了实现地址变换，在地址变换机构中需要增设一个外层页表寄存器，用于存放外层页表的始址，并利用逻辑地址中的外层页号，作为外层页表的索引，从中找到指定页表分页的始址，在利用P2作为指定页表分页的索引，找到指定的页表项，其中即含有该页在内存的物理块号，用该块号和页内地址d即可构成访问的内存物理地址。II.多级页表页面大小为4KB即212B，还剩52位，按物理块大小2^12位来划分页表，则剩余40位用于外层页号，此时外层页表可能有1024G个页表项，要占用的连续存储空间太大。解决方法：采用多级页表，将外层页表再进行分页。==注意:到现在为止，我们只是在解决连续分布问题，没有解决页表大的问题。无论你分几层，只不过是打散，并没有减少。==④*反置页表(Inverted Page Table)分页系统中，为每个进程配置了一张页表，进程逻辑地址空间中的每一页，在页表中都对应有一个页表项。在现代计算机系统中，通常允许一个进程的逻辑地址空间非常大，因此就需要有许多的页表项，而因此也会占用大量的内存空间。反置页表：为每个物理块设置一个页表项，并将它们按物理块编号排序，其内容为页号及所在的进程ID.在利用反置页表进行地址变换时，是根据进程标识符和页号去检索反置页表。如果检索到与之匹配的页表项，则该页表项(中)的序号i便是该页所在的物理块号，可用该块号与页内地址一起构成物理地址送内存地址寄存器。若检索了整个反置页表仍未找到匹配的页表项，则表明此页尚未装入内存。对于不具有请求调页功能的存储器管理系统，此时则表示地址出错。对于具有请求调页功能的存储器管理系统，此时应产生请求调页中断，系统将把此页调入内存。当内存容量很大时，反置页表表项也会很多，如何检索？I.内存块的管理方法：位示图法位示图法是利用二进制的一位来表示主存中一个块的使用情况。 当其值为0时表示对应的块空闲，为1时表示已分配 。 主存上的所有盘块都有一个二进制位与之对应，这样由所有盘块所对应的位构成一个集合，称为位示图。 通常可用m*n个位数来构成位示图，并使m*n等于主存的总块数。④虚拟存储技术上述方法用离散分配空间解决了大页表无需大片存储空间的问题，但并未减少页表所占的内存空间。解决方法是把当前需要的一批页表项调入内存，以后再根据需要陆续调入（虚存）。在采用两级页表结构的情况下，对于正在运行的进程，必须将其外层页表调入内存，而对页表则只需要调入一页或者几页，为了表征某页的页表是否已经调入内存，还应在外层页表项中增设一个状态位S，其值若为0，表示该页表分页尚未调入内存，否则，说明已经在内存，进程运行时，地址变换机构根据逻辑地址P1，去查找外层页表，若所找到的页表项中的状态位为0，则产生一中断信号，请求OS将该页表分页调入内存。具体的知识后面再进行讲解。习题最后，可以做一些题目来巩固一下。1.若系统采用两级分页存储方式，物理内存 64mb，页面大小 1kb，页表项大小 2b，则顶级页表有多少个页表项？这里我们可以参考之前求页表项大小的思路。物理内存 64mb，即 2^26^b，所以逻辑地址一共 26 位。这 26 位中，一部分表示一级页号，一部分表示二级页号，剩下的表示页内偏移量。因为页面大小 1kb，也即 2^10^b，所以页内偏移量一共需要 10 位来表示。一个页面大小 2^10^b，一个页表项 2b，所以一个页面可以最多可以放 2^9^ 个页表项，又由于各级页表不能超过一个页面，所以各级页表不能超过 2^9^ 个页表项。在逻辑地址余下的 16 位中，可以用其中 9 位去表示二级页表的页号（此时该页表的页表项个数取到了最大值），剩下的 7 位表示另一个 —— 顶级页表的页号。因为顶级页表页号有 7 位，所以顶级页表可以包含 2^7^ 个页表项，即包含 128 个页表项。2.若系统采用分页存储方式，物理内存 256mb，页面大小 1kb，页表如下：页号 0，1，2，3，4，5，6，7，8，9，10 分别对应块号 15，16，20，28，29，30，31，32，36，38，39则逻辑地址 1A68（16进制）对应的物理地址是多少？为了方便计算，我们先统一用十进制计算，得到十进制的物理地址后再转换为十六进制。1A68 按权展开转化为对应的十进制数字是 6760，对于逻辑地址 6760，可以计算它的页号和页内偏移量：页号 = 6760/1024 = 6（取整数部分）页内偏移量 = 6760%1024 = 616根据页号 6 找到块号 31，根据块号 31 计算块初始地址为 31*1024 = 31744，偏移量和初始地址相加得到的物理地址为 31744+616 = 32360。32360 是十进制的物理地址，转化为对应的十六进制物理地址就是 7E68。3.若系统采用分页存储方式，物理内存 1mb，共有 32 个页面，一个页面 2kb，则逻辑地址一共多少位？因为物理内存 1mb，也即 2^20^b，所以逻辑地址 20 位。根据上面习题的经验，我们可能会这么做，但是注意这是错误的做法。上面的习题都没有告诉我们程序具体被划分为多少个页面，所以我们认为物理地址需要多少位时（20），逻辑地址也需要多少位（20）；但是这道题已经告诉了我们程序具体被划分为多少个页面（32）—— 显然，页面仅仅被划分为 32 个，是不需要 20 这么多位的逻辑地址的。由于逻辑地址包括两部分，一个是页号，一个是页内偏移量，我们不妨分别考虑这两者所占的位数：考虑页内偏移量位数。由于一个页面 2kb，也即 2^11^b，所以页内偏移量占 11 位（注意这点是不变的）；考虑页号位数。由于页面仅仅被划分为 32 个，也即 2^5^ 个，所以页号只需要 5 位11 + 5 =16，所以逻辑地址一共 16 位。PS：当题目明确给出分页个数的时候，按照页号位数+偏移量位数计算逻辑地址总位数。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统【七】]]></title>
    <url>%2Fposts%2Fa87f7acf%2F</url>
    <content type="text"><![CDATA[四、存储器管理【操作系统】存储器管理（四）存储器管理功能有：内存分配：为每道程序分配内存空间，提高存储器的利用率，允许正在运行的程序申请附加的内存空间；存储保护：确保每道用户程序都只在自己的内存空间中运行，彼此互不干扰；地址映射(变换)：进程的逻辑地址到内存物理地址的映射。内存扩充：用虚拟存储技术解决内存容量不足的问题；1、存储器的层次结构存储器的层次结构（缓存、内存、外存）主存储器与寄存器主存储器：用于保存进程运行时的程序和数据。寄存器：寄存器访问速度最快，与CPU协调工作。高速缓存与磁盘缓存高速缓存：CPU对高速缓存的访问，其速度比访问主存快，比访问寄存器慢。磁盘缓存：内存中一块存储区，对应于某固定磁盘，临时存储磁盘数据（如，数据预取）。磁盘的IO速度远低于对主存的访问速度，因此将频繁使用的一部分磁盘数据和信息暂时存放在磁盘缓存中，可减少访问磁盘的次数，磁盘缓存本身并不是一种实际存在的存储介质，它依托于固定磁盘，提供对主存储器空间的扩充，即利用主存中的存储空间，来暂存从磁盘中读出或写入的信息，主存可以看做是辅存的高速缓存，因为，辅存中的数据必须复制到主存方能使用，反之，数据也必须先存在主存中，才能输出到辅存。2、程序的装入和链接为了使程序能够运行，必须先为之创建进程，而创建进程的第一件事，就是将程序和数据装入内存，如何将一个用户源程序变为一个可在内存中执行的程序，通常要经过如下几步：首先是编译（由编译程序将用户源代码编译成若干个目标模块）其次是链接（由链接程序将编译后形成的一组目标模块，以及它们所需要的库函数链接在一起，形成一个完整的装入模块）最后是装入（由装入程序将装入模块装入内存）一些基本概念逻辑地址： 用户的程序经过汇编或编译后形成目标代码，目标代码通常采用相对地址的形式，其首地址为0，其余指令中的地址都相对于首地址而编址。物理地址：内存中存储单元的地址，可直接寻址名空间：一个用高级语言编制的源程序，我们说它存在于由程序员建立的符号名字空间地址空间：程序用来访问信息所用地址单元的集合，是逻辑（相对）地址的集合，由编译程序生成。存储空间：主存中物理单元的集合。外部碎片指的是尚未分配出去、由于太小而无法分配出去的内存空间内部碎片指的是已经分配出去、但没有完全得到利用的内存空间(1)程序装入的方式在装入一个模块到内存时，有绝对装入方式，可重定位装入方式，动态运行时装入方式。① 绝对装入方式如果在编译时知道程序驻留在内存的什么位置，那么，==编译程序将产生绝对地址的目标代码==，绝对装入方式按照装入模块中的地址，将程序和数据装入内存，装入模块被装入内存后，由于程序中的逻辑地址与实际内存地址完全相同，故不需要对程序和数据的地址进行修改。② 可重定位装入方式由于绝对装入方式只能将目标模块装入到内存中事先指定的位置，在多道程序环境下，编译程序不可能事先知道所编译的目标模块应放在内存的何处，因此，绝对装入方式只适用于单道程序环境，在多道程序环境下，所得到的目标模块的起始地址通常都是以0开始的，程序中的其他地址也都是相对于起始地址计算的，此时应采用可重定位装入方式，根据内存的当前情况，将装入模块装入到内存的适当位置。该方式会使装入模块中的所有逻辑地址与实际装入内存的物理地址不同，需要对数据地址和指令地址进行修改，通常把再装入时对目标程序中指令和数据的修改过程称为重定位，又因为地址变换通常是在装入时（第三步）一次完成的，以后不再变化，故称为静态重定位。第一步第二步，只是绝地地址，第三步进行转换映射。③ 动态运行时装入方式可重定位装入方式允许将装入模块装入到内存中任何允许的位置，故可用多道程序环境，但这种方式并不允许程序运行时在内存中移动位置，因为，程序在内存中的移动，意味着它的物理位置发生了变化，这就必须对程序和数据的地址进行修改后方能运行。然而，在运行过程中它在内存中的位置可能经常要改变，此时就应该采用动态运行时装入方式。动态运行时的装入程序在把装入程序装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址都仍是相对地址，为了使地址转换不影响指令的执行速度，需要重定位寄存器的支持。重定位寄存器用于记录和更新装入模块当前的物理起始地址，逻辑地址只需要和这个物理起始地址相加即可得到物理地址。(2)程序链接的方式源程序经过编译后，可得到一组目标模块，再利用链接程序把这组目标模块链接，形成装入模块，根据链接时间的不同，可把链接分为静态链接（在程序运行之前，先将各目标模块及他们所需的库函数，链接成一个完整的装配模块，以后不再拆开）装入时动态链接（将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式）运行时动态链接（对某些目标模块的链接，是在程序执行中需要盖模块时，才对它进行链接）。① 静态链接在将目标模块装配成一个装入模块时，需要对相对地址进行修改（由于编译程序产生的所有目标模块中，使用的都是相对地址，其起始地址都为0，每个模块中的地址都是相对于起始地址计算的）。也需要变换外部调用符号（将每个模块中所用的外部调用符号都变换为相对地址），这种先进行链接所形成的一个完整的装入模块，又称为可执行文件，通常都不再拆开它，要运行时可直接将它装入内存，这种事先进行链接，以后不再拆开的链接方式，称为静态链接方式。② 装入时动态链接用户源程序经编译后所得是目标模块，是在装入内存时边装入边链接的，即在装入一个目标模块时，若发生一个外部模块调用事件，将引起装入程序去找出相应的外部目标模块，并将它装入内存，装入时动态链接有如下优点便于修改和更新（各目标模块是分开的存放的，所以要修改或更新各目标模块非常容易），便于实现对目标模块的共享（很容易将一个目标模块链接到几个应用模块上，实现多个应用程序对该模块的共享）③ 运行时动态链接将某些模块的链接推迟到程序执行时才进行链接，即在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS去找到该模块并将之装入内存，把它链接到调用者模块上，凡在执行过程中未被调用到的模块，都不会被调入内存和被链接到装入模块上，这样不仅加快程序的装入过程，同时也节省了大量的内存空间。3、连续分配方式连续分配方式，是指为一个用户程序分配一个连续的内存空间.可以将连续分配方式分为单一连续分配固定分区分配动态分区分配动态重定位分区分配(1)单一连续分配单一连续分配。这是一种最简单的存储管理方式，但只能在单用户、单任务的操作系统中，将内存分为系统区和用户区，系统区供OS使用，通常放在内存的低地址，用户区是指除系统区以外的全部内存空间，提供给用户使用。(2)固定分区分配是一种最简单的可运行多道程序的存储管理方式，将内存用户空间划分为若干个固定大小的区域，在每个分区只装入一道作业，这样，便允许多道作业并发执行，当有空闲分区时，便可以再从外存的后备作业队列中选择一个适当大小的作业装入该分区，当该作业结束时，又可再从后备作业队列中找出另一作业调入该分区。对于内存的用户空间的划分，有如下两种方法。分区大小相等，即所有的内存分区大小相等。缺点是缺乏灵活性，即当程序太小时，会造成内存资源的浪费，程序太大时，一个分区由不足以装入该程序，只是该程序无法运行。分区大小不等，把内存区划分成含有多个较小的分区、适量中等分配和少量大分区，这样，便可根据程序的大小为之分配适当的分区。为了便于内存分配，将分区按大小进行排队，并为之简历一张分区使用表，其中各表项包括每个分区的起始地址、大小、状态（是否已分配），当有一个程序需要装入时，由内存分配程序检索该表，从中找出一个能满足要求的，尚未分配的分区，将之分配给该程序，然后将该表项中的状态设置为已分配，若未找到大小足够的分区，则拒绝为该用户分配内存。​ (图中起止改为起址，因为有大小了只需要起始地址就可以。)(3)动态分区分配动态分区存储管理不是预先把主存储器中的用户区域划成分区，而是在作业要求装入主存储器时，根据作业需要的主存空间大小和当时主存空间使用情况来决定是否为作业分配一个分区。在实现可变分区分配时，将涉及到分区分配中所用的数据结构、分区分配算法、分区的分配和回收等。操作系统只管理空闲的，分配出去了就不再管理，就相当于没有这块内存注意会合并连续的空闲分区。①分区分配中的数据结构为了实现分区分配，胸中必须配置相应的数据结构，用来描述空闲分区和已分配分区的情况，为分配提供依据，常用的数据结构有如下两种形式：空闲分区表（在系统中设置一张空闲分区表，用于记录每个空闲分区的情况，每个空闲分区占一个表目，表目中包括分区序号、分区始址、分区大小等，在前面已有介绍）空闲分区链（为了实现对空闲分区的分配和链接，在每个分区的起始部分，设置一些用于控制分区分配的信息，以及用于链接各分区所用的向前指针；在分区尾部设置一向后指针，这样，可以将空闲分区链接成一个双向链），为了检索方便，在分区尾部重复设置状态为和分区大小表目，当分区被分配出去以后，把状态为从0改成1，此时前后指针都失去意义（已经不再空闲链表中）。②分区分配算法I.基于顺序搜索的动态分区分配算法首次适应算法（First Fit）以空闲分区链为例进行说明，FF算法要求空闲分区链以地址递增的次序链接，在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止，然后再按照作业的大小，从该分区划出一块内存空间分配给请求者，余下的空闲分区仍留在空闲链中，若从链首直至链尾都不能找到一个能满足要求的分区，则此次内存分配失败，返回。优点：优先利用内存低址部分的内存空间缺点：低址部分不断划分，产生小碎片；每次查找从低址部分开始，增加了查找的开销循环首次适应算法（Next Fit）由首次适应算法演变而来，在未进程分配内存空间时，不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区，从中划分出一块与请求大小相等的内存空间分配给作业。进行空闲分区分配时，会采用循环查找方式，即如果最后一个（链尾）空闲分区的大小仍不能满足要求，则返回第一个空闲分区。优点：使内存空闲分区分布均匀，减少查找的开销缺点：缺乏大的空闲分区最佳适应算法（Best Fit）该算法总是能把满足要求、又是最小的空闲分区分配给作业，避免大材小用，为了加速寻找，该算法要求把所有的空闲分区按其容量以从小到大的顺序形成一个空闲分区链，这样，第一次就能找到满足要求的空闲区，必然是最佳的，孤立地看，最佳适应算法似乎是最佳的，然而宏观上却不一定，因为每次分配后所切割下来的剩余部分总是最小的，会留下很多难以使用的小空闲区。缺点：产生许多难以利用的小空闲区(内存零头，内存碎片）最坏适应算法（Worst Fit）所谓“最坏”是指每次为作业分配内存时， 要扫描整个空闲分区表或链表总是挑选一个 最大的空闲分区分配给作业。要求将所有的空闲分区按其容量以从大到小的顺序形成一空闲分区链,查找时只要看第一个分区是否满足要求。优点：产生碎片的几率最小缺点：使存储器缺乏大的存储空间 。总结==由于动态分区分配不是事先划分好区域，而是“按需分配”，所以不会出现区域划分出去后无法完全得到利用的情况，也即不会产生内部碎片；但是可能出现内存空间太小而无法被分配出去的情况，也即可能产生外部碎片。==II.基于索引搜索的动态分区分配算法1.快速适应算法（分类搜索法） （Quick Fit）该算法又称为分类搜索法，是将空闲分区容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这些，系统中存在多个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。该算法的优点是查找效率高，仅需根据进程的长度，寻找到能容纳它的最小空闲区链表，并取下第一块进行分配即可。该算法在进行空闲分区分配时，不会对任何分区产生分割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。但是在分区归还主存时算法复杂，系统开销大。优点：查找效率高，根据进程的长度查找,不分割分区，因而不会产生新的碎片缺点：1、分区归还存储器时算法复杂，2、会造成空间的浪费。是典型的以空间换时间的做法。2.伙伴系统（buddy system）伙伴系统（buddy system） 是Linux Kernel 进行物理内存页管理的一个子系统伙伴系统的特点：无论是占用块或空闲块，其大小均为2的k次幂（k为某个正整数）。伙伴：是指由同一个大的空闲块分裂成的两个大小相等的存储区，这两个由同一大块分裂出来的小块就称之“互为伙伴”。伙伴系统规定，无论已分配分区还是空闲分区，其大小均为2的k次幂，k为整数，1&lt;= k &lt;= m，其中，2^1^表示分配的最小分区的大小，2^m^表示分配的最大分区的大小，通常2^m^是整个可分配内存的大小。假设系统开始时的初始容量为2^m^个字，由于不断切分，可能会形成若干个不连续的空闲分区，将这些空闲分区根据分区的大小进行分类，对于每一类具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表。这样，不同大小的空闲分区形成了k个空闲分区链表。当需要为进程分配一个长度为n的存储空间时，首先计算一个i值，使2^i^-1 &lt; n &lt;= 2^i^，然后，在空闲分区大小为2^i^的空闲分区链表中查找，若找到，即把该空闲分区分配给进程，否则，表明2^i^的空闲分区已经耗尽，在大小为2^i+1^的空闲分区链表中查找，若存在，则将该空闲分区分为两个大小为2^i^的分区，一个用于分配，一个加入到大小为2^i^的空闲分区链表中，若还是不存在，则继续在大小为2^i^+2的空闲分区链表中查找，若存在，则将空闲分区进行两次分割，一次分割为两个大小为2^i^+1的空闲分区，一个加入到大小为2^i^+1的空闲分区链表中，另外一个继续进行分割，分成两个大小2^i^的空闲块，一个用于分配，另外一个加入到大小为2^i^的空闲分区链表中，以此类推。在最坏的情况下，可能需要对2^k^的空闲分区进行k此分割才能得到所需分区。当回收空闲分区时，也需要经过多次合并，如回收大小为2^i^的空闲分区时，若事先已经存在2^i^的空闲分区，则应将其与伙伴分区合并为一个大小为2^i^+1的空闲分区，若事先已存在2^i^+1的空闲分区，则再次进行合并，合并为2^i^+2的分区，以此类推。为了更直观地理解，这里用一个例子来说明。假设系统总的内存为 512 kb，现有进程活动如下：进程 A 请求 100kb，进程 B 请求 50kb，进程 C 请求 100kb进程 A 释放 100kb进程 D 请求 20kb进程 D 释放 20kb进程 B 释放 50kb按照伙伴系统的算法，内存的分配和回收是怎么进行的呢？首先，一开始肯定是整片空的内存空间：进程 A 请求 100kb，因为 64&lt;100&lt;128，即 2^6^&lt;100&lt;2^7^，所以寻找是否有 2^7^=128 的空闲分区，当然是没有的（目前只有 512kb），所以寻找是否有 2^8^=256 的空闲分区，也没有，所以寻找是否有 2^9^=512 的空闲分区，找到了，此时就把 512kb 一分为二：一半的 256kb 加入到对应的空闲分区链表，一半的 256kb 用于分配，对这一半继续一分为二：一半的 128kb 加入到对应的空闲分区链表，一半的 128kb 用于分配，这一半对进程 A 来说足够了，于是占用它：进程 B 请求 50kb，因为 32&lt;50&lt;64，即 2^5^&lt;100&lt;2^6^，所以寻找是否有 2^6^=64 的空闲分区，当然是没有的，所以寻找是否有 2^7^=128，找到了，此时就把 128kb 一分为二：一半的 64kb 加入到对应的空闲分区链表，一半的 64kb 用于分配，这一半对进程 B 来说足够了，于是占用它：进程 C 请求 100kb，因为 64&lt;100&lt;128，即 2^6^&lt;100&lt;2^7^，所以寻找是否有 2^7^=128 的空闲分区，当然是没有的，所以寻找是否有 2^8^=256 的空闲分区，找到了，此时就把 256kb 一分为二：一半的 128kb 加入到对应的空闲分区链表，一半的 128kb 用于分配，这一半对进程 C 来说足够了，于是占用它：进程 A 释放 100kb：进程 D 请求 20kb，因为 16&lt;20&lt;32，即 2^4^&lt;100&lt;2^5^，所以寻找是否有 2^5^=32 的空闲分区，当然是没有的，所以寻找是否有 2^6^=64 的空闲分区，找到了，此时就把 64kb 一分为二：一半的 32kb 加入到对应的空闲分区链表，一半的 32kb 用于分配，这一半对进程 D 来说足够了，于是占用它：进程 D 释放 20kb，回收 32kb，由于事先已经有一个 32kb，所以此时两个互为伙伴的 32kb 进行合并：进程 B 释放 50kb，回收 64kb，由于事先已经有一个 64kb，所以此时两个互为伙伴的 64kb 进行合并，形成 128kb，由于事先已经有一个 128kb，所以此时两个互为伙伴的 128kb 进行合并，形成 256kb：回收空闲块时，首先判别其伙伴是否为空闲块，若否，则只要将释放的空闲块简单插入在相应子表中即可；若是，则需在相应子表中找到其伙伴并删除之，然后再判别合并后的空闲块的伙伴是否是空闲块。依此重复，直到归并所得空闲块的伙伴不是空闲块时，再插入到相应的子表中去。最后补充一个计算伙伴地址的方法：对于给定的内存块，若它的大小为 2^k^，起始地址为 x，那么它的伙伴地址：如果 x/2^k 为奇数，则伙伴地址为 x - 2^k如果 x/2^k 为偶数，则伙伴地址为 x + 2^k与前面所述的多种方法相比较，由于该算法在回收空闲分区时，需要对空闲分区进行合并，所以其时间性能比前面所述的分类搜索算法差，但比顺序搜索算法好，而其空间性能则远优于前面所述的分类搜索法，比顺序搜索法略差。3.哈希算法前面的两种方法（快速适应和伙伴系统）都是将空闲分区按照大小进行分类，并为每一类建立一个独立的空闲分区链表，再用一个总的索引表进行记录。不过，如果分类过多，则索引表的表项也会过多，这时候搜索索引表的时间开销就会比较大。因此，哈希算法选择建立一张哈希表（而不是普通的索引表），这张哈希表以空闲分区大小作为关键字，每次需要进行分配的时候，会根据所需空闲分区的大小，通过哈希函数快速计算得到该空闲分区在表中的位置，从而得到对应的空闲分区链表。③分区分配操作I.内存分配利用某种分配算法，从空闲分区链(表)中找到所需大小的分区。设请求的分区大小为u.size，表中每个空闲分区的大小表示为m.size，若m.size- u.size≤size(规定的不再切割的分区大小)，将整个分区分配给请求者，否则从分区中按请求的大小划出一块内存空间分配出去，余下部分留在空闲链(表）中，将分配区首址返回给调用者。II.内存回收当进程运行完毕释放内存时，系统根据回收区的首址，从空闲区链（表）中找到相应的插入点，此时会出现如下四种情况之一：回收分区与插入点的前一个空闲区F1相邻接，此时不必为回收区分配新表项，只需将回收区与F1合并，修改F1的表项的分区大小回收分区与插入点的后以空闲分区F2相邻接，将回收区与F2合并，修改F2的表项的首址、分区大小回收区同时与插入点的前、后两个分区邻接，此时将三个分区合并，使用F1的表项和F1的首址，取消F2的表项，大小为三者之和。回收区既不与F1邻接，也不与F2邻接，这时为回收区单独建立一个新表项，填写回收区的首址和大小，并根据其首址插入到空闲链中的适当位置。(4)动态可重定位分区分配到目前为止，我们所讲的都是连续分配的方式，也就是说，为某个进程分配的必须是一块连续的空间 —— 若多个空闲分区不是相邻的，那么即便它们的大小相加后，已经足以满足进程的需求，也无济于事。为此，可以采用紧凑技术解决这个问题。紧凑技术可以把内存中各个进程进行移动，使得它们都相邻，从而把原先分开的各个空闲分区合并在一起，带来了更大的、可以充分利用的空闲分区：在每次紧凑之后，都必须对移动了的数据和程序进行重定向。假定我们先前采用的是静态重定位装入方式，那么在模块装入内存的时候，就已经把逻辑地址转换为物理地址了，就会导致在这里需要再进行一次地址的修改，更麻烦的是，之后每次发生紧凑，都要在程序上重新修改一次物理地址。相反，如果我们采用动态重定位装入方式，那么各个程序和数据的地址其实全程都是逻辑地址，在每次程序执行到需要访问地址的时候，无需修改程序上的地址，只需要将该逻辑地址与当前重定位寄存器里存放的物理起始地址进行相加即可。并且，每次发生紧凑的时候，也只需要用紧凑后的新起始地址去替换重定位寄存器里的旧起始地址。(因为初始大家个个块都是0开始的逻辑地址)动态可重定位分区分配算法与动态分区分配算法基本一致，区别仅在于，它在原有的基础上增加了紧凑功能。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaEE程序设计【十三】]]></title>
    <url>%2Fposts%2F58d5cacd%2F</url>
    <content type="text"><![CDATA[SSM框架整合1、流程分析0.需求分析1、构建数据库2、大体框架编写各种文件夹DAO层文件夹POJO类文件夹Service层文件夹Controller层文件夹JSP文件夹静态资源文件夹各种配置文件Spring配置文件SpringMVC配置文件mybatis配置文件web.xml数据库的propertieslog4j的properties3、配置文件填充pom.xml文件填充Spring配置文件填充SpringMVC配置文件填充mybatis配置文件填充4、实现DAO层实现全部POJO类构建POJO类的各个Mapper接口和Mapper配置文件1234&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace=""&gt;&lt;/mapper&gt;在mybatis配置文件中配置mapper 使用自动扫描则不需要配置了5、实现Service层6、实现Controller层7、实现view（前后端的交互）2、常用配置(1)pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.edu.ccc&lt;/groupId&gt; &lt;artifactId&gt;ch17&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;ch17 Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;spring.version&gt;5.1.6.RELEASE&lt;/spring.version&gt; &lt;mybatis.version&gt;3.5.0&lt;/mybatis.version&gt; &lt;mybatis.spring.version&gt;2.0.0&lt;/mybatis.spring.version&gt; &lt;commons-dbcp.version&gt;1.4&lt;/commons-dbcp.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;fastjson.version&gt;1.2.35&lt;/fastjson.version&gt; &lt;slf4j.version&gt;1.7.25&lt;/slf4j.version&gt; &lt;jackson.version&gt;2.9.8&lt;/jackson.version&gt; &lt;commons-fileupload.version&gt;1.3.3&lt;/commons-fileupload.version&gt; &lt;commons-io.version&gt;2.5&lt;/commons-io.version&gt; &lt;commons-codec.version&gt;1.10&lt;/commons-codec.version&gt; &lt;aspectjweaver.version&gt;1.8.10&lt;/aspectjweaver.version&gt; &lt;mysql.version&gt;5.1.48&lt;/mysql.version&gt; &lt;commons-dbcp.version&gt;2.7.0&lt;/commons-dbcp.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql数据库链接jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入dbcp2的jar包，用来在applicationContext.xml中配置数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-dbcp.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL标签类 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;$&#123;jstl.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志文件管理包 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 格式化对象，方便输出日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- json和bean之间相互转换 --&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 上传组件包 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-fileupload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-io.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-codec.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;$&#123;aspectjweaver.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;ch17&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt;(2)web.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1"&gt; &lt;!-- 配置加载Spring文件的监听器--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置Spring MVC前端核心控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置服务器启动后立即加载Spring MVC配置文件 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!--/:拦截所有请求（除了jsp）--&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt;(3)Spring配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 读取db.properties --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp2.BasicDataSource"&gt; &lt;!--数据库驱动 --&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;!--连接数据库的url --&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;!--连接数据库的用户名 --&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;!--连接数据库的密码 --&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;!--最大连接数 --&gt; &lt;property name="maxTotal" value="$&#123;jdbc.maxTotal&#125;" /&gt; &lt;!--最大空闲连接 --&gt; &lt;property name="maxIdle" value="$&#123;jdbc.maxIdle&#125;" /&gt; &lt;!--初始化连接数 --&gt; &lt;property name="initialSize" value="$&#123;jdbc.initialSize&#125;" /&gt; &lt;/bean&gt; &lt;!-- 事务管理器，依赖于数据源 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 开启事务注解 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt; &lt;!-- 配置MyBatis工厂SqlSessionFactory --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!--注入数据源 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!--指定核MyBatis心配置文件位置 --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml" /&gt; &lt;/bean&gt; &lt;!-- 配置mapper扫描器 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="cn.edu.ccc.ch17.dao" /&gt; &lt;/bean&gt; &lt;!-- 扫描Service --&gt; &lt;context:component-scan base-package="cn.edu.ccc" /&gt;&lt;/beans&gt;(4)SpringMVC配置文件12345678910111213141516171819202122&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置包扫描器，扫描@Controller注解的类 --&gt; &lt;context:component-scan base-package="cn.edu.ccc" /&gt; &lt;!-- 加载注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; &lt;/beans&gt;(5)Mybatis配置文件1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!-- 打开延迟加载的开关 --&gt; &lt;setting name="lazyLoadingEnabled" value="false" /&gt; &lt;!-- 将积极加载改为消息加载，即按需加载 --&gt; &lt;setting name="aggressiveLazyLoading" value="true" /&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true" /&gt; &lt;setting name="logImpl" value="STDOUT_LOGGING" /&gt; &lt;/settings&gt; &lt;!-- 别名定义 --&gt; &lt;typeAliases&gt; &lt;package name="cn.edu.ccc.ch17.dao" /&gt; &lt;/typeAliases&gt;&lt;/configuration&gt;(6)数据库properties1234567jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8jdbc.username=rootjdbc.password=mysqljdbc.maxTotal=30jdbc.maxIdle=10jdbc.initialSize=5(7)log4J的properties12345678# Global logging configurationlog4j.rootLogger=ERROR, stdout# MyBatis logging configuration...log4j.logger.com.itheima=DEBUG# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n]]></content>
      <categories>
        <category>JavaEE程序设计</category>
      </categories>
      <tags>
        <tag>JavaEE程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaEE程序设计【十二】]]></title>
    <url>%2Fposts%2F15cb699f%2F</url>
    <content type="text"><![CDATA[三、Json数据交互和Restful支持1、什么是JSON？JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：对象表示为键值对，数据由逗号分隔花括号保存对象方括号保存数组==注意:如果使用JSON存储单个数据(如”abc”),一定要使用数组的形式,不要使用 Object形式,因为 Object形式必须是”名称:值”的形式.==JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值：123&#123;&quot;name&quot;: &quot;QinJiang&quot;&#125;&#123;&quot;age&quot;: &quot;3&quot;&#125;&#123;&quot;sex&quot;: &quot;男&quot;&#125;很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解：JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。12var obj = &#123;a: 'Hello', b: 'World'&#125;; //这是一个对象，注意键名也是可以使用引号包裹的var json = '&#123;"a": "Hello", "b": "World"&#125;'; //这是一个 JSON 字符串，本质是一个字符串JSON 和 JavaScript 对象互转要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法：12var obj = JSON.parse('&#123;"a": "Hello", "b": "World"&#125;');//结果是 &#123;a: 'Hello', b: 'World'&#125;要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法：12var json = JSON.stringify(&#123;a: 'Hello', b: 'World'&#125;);//结果是 '&#123;"a": "Hello", "b": "World"&#125;'2、Spring的json数据交互Spring提供了一个 HttpMessage Converter&lt;T&gt;接口来实现浏览器与控制器类( Controller)之间的数据交互.MappingJackson2HttpMessageConverter：SpringMVC默认处理JSON格式请求响应的实现类。可以将Java对象转换为JSON对象和XML对象也可以将JSON对象和XML对象转换为Java对象3、注解开发只需要配置&lt;mvc:annotation-driven /&gt;使用@RequestBody和@ResponseBody使用实例：123456@RequestMapping("/testJson") @ResponseBody public User testJson(@RequestBody User user) &#123; System.out.println(user); return user; &#125;外部JSON—&gt;@RequestBody—&gt;转化为user —&gt;return user—&gt;@ResponseBody—&gt;转化为JSON4、显示开发(很少使用)5、静态资源处理三种方法：配置&lt;mvc:resources location=&quot;&quot; mapping=&quot;&quot; /&gt;(推荐)使用&lt;mvc:default-servlet-handler/&gt;(不推荐)配置web.XML使用Tomcat（或者其他web容器）实现 Spring MVC静态资源处理：&lt;mvc:resources /&gt;1&lt;mvc:resources location="/,classpath:/META-INF/publicResources/" mapping="/resources/**"/&gt;以上配置将Web根路径”/“及类路径下 /META-INF/publicResources/ 的目录映射为/resources路径。假设Web根路径下拥有images、js这两个资源目录,在images下面有bg.gif图片，在js下面有test.js文件，则可以通过 /resources/images/bg.gif 和 /resources/js/test.js 访问这二个静态资源。假设WebRoot还拥有images/bg1.gif 及 js/test1.js，则也可以在网页中通过 /resources/images/bg1.gif 及 /resources/js/test1.js 进行引用。6、RESTful支持==简单来说，RESTful风格就是把请求参数变成请求路径的一种风格。==Web应用程序最重要的REST原则是,客户端和服务器之间的交互在请求之间是无状态的从客户端到服务器的每个请求都必须包含理解请求所必需的信息.例如：购买商品，你给出商品信息，服务器给你小票，之前和之后不会再保留任何相关信息。动词也变成了名词==主要是使用@PathVariable==例子：12345678910111213@RequestMapping("/user/&#123;id&#125;")@ResponseBodypublic User findById(@PathVariable("id") String id) &#123; System.out.println(id); if("1".equals(id)) &#123; User user=new User(); user.setId(1); user.setUsername("123"); user.setPassword("aa"); return user; &#125; return null;&#125;四、拦截器和文件上传下载1、拦截器（1）什么是拦截器？Spring MVC中的拦截器（Interceptor）类似于Servlet中的过滤器（Filter），它主要用于拦截用户请求并作相应的处理。例如通过拦截器可以进行权限验证、记录请求信息的日志、判断用户是否登录等。拦截器与过滤器的比较相似都有优先处理请求的权利，都可以决定是否将请求转移到请求的实际处理的控制器处。都可以对请求或者会话当中的数据进行加工。不同拦截器可以做前置处理也可以做后置处理，还可以进行完成处理，控制的 更加细致，而过滤器只负责前面的过滤行为而已。拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的过滤器优先执行，还是拦截器优先呢？———-过滤器优先。过滤器是servlet规范里面的组件。任何java web工程都可以使用拦截器都是框架自己而外添加的组件。==三种拦截器的执行时间段：==preHandle：在控制器方法前执行，其返回值表示是否中断后续操作。当其返回值为true时，表示继续向下执行；当其返回值为false时，会中断后续的所有操作。postHandle：该方法会在控制器方法调用之后，且解析视图之前执行。可以通过此方法对请求域中的模型和视图做出进一步的修改。afterCompletion：该方法会在整个请求完成，即视图渲染结束之后执行。可以通过此方法实现一些资源清理、记录日志信息等工作。（2）如何实现？1、通常拦截器类可以通过两种方式来定义。通过实现HandlerInterceptor接口，或继承HandlerInterceptor接口的实现类（如HandlerInterceptorAdapter）来定义。通过实现WebRequestInterceptor接口，或继承WebRequestInterceptor接口的实现类来定义。2、在Spring MVC的配置文件中进行配置。1234567891011121314151617&lt;mvc:interceptors&gt; &lt;bean class="cn.edu.ccc.interceptor.CustomInterceptor"/&gt; &lt;!-- 全局拦截器，拦截所有请求 --&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**"/&gt; &lt;!-- /**配置，表示拦截所有路径 --&gt; &lt;mvc:exclude-mapping path=""/&gt; &lt;!-- 配置不需要拦截的路径 --&gt; &lt;bean class=" cn.edu.ccc.interceptor.Interceptor1" /&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/hello"/&gt; &lt;!-- /hello表示拦截所有以“/hello”结尾的路径 --&gt; &lt;bean class=" cn.edu.ccc.interceptor.Interceptor2" /&gt; &lt;/mvc:interceptor&gt; ... &lt;/mvc:interceptors&gt;注意：&lt;mvc:interceptor&gt;中的子元素必须按照上述代码的配置顺序进行编写，否则文件会报错。(3)单个和多个拦截器执行的流程 ==多个：pre顺序执行;post和after反序执行====注意：顺序是按照XML中配置的顺序。正序就是XML中的顺序，逆序就是XML中的反顺序==例如：123456789101112131415161718&lt;!-- 配置拦截器 --&gt; &lt;mvc:interceptors&gt; &lt;!-- 拦截器2 --&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/hello" /&gt; &lt;bean class="cn.edu.ccc.ch15.interceptor.Interceptor2" /&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!-- 配置拦截器作用的路径 --&gt; &lt;mvc:mapping path="/**" /&gt; &lt;!-- 定义在&lt;mvc:interceptor&gt;下面的表示匹配指定路径的请求才进行拦截的 --&gt; &lt;bean class="cn.edu.ccc.ch15.interceptor.Interceptor1" /&gt; &lt;/mvc:interceptor&gt; &lt;!--使用bean直接定义在&lt;mvc:interceptors&gt;下面的拦截器将拦截所有请求 --&gt; &lt;bean class="cn.edu.ccc.ch15.interceptor.CustomInterceptor" /&gt; &lt;/mvc:interceptors&gt;(4)应用：常用来登录验证若访问本站点下除了登录页面的其他页面则进行拦截判断是否登录。登录则继续访问否则转发到登录页面。123456789101112131415161718192021public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 获取请求的URL String url = request.getRequestURI(); System.out.println("uri:" + url); // URL:除了login.jsp是可以公开访问的，其它的URL都进行拦截控制 if (url.indexOf("/login") &gt;= 0) &#123; return true; &#125; // 获取Session HttpSession session = request.getSession(); User user = (User) session.getAttribute("USER_SESSION"); // 判断Session中是否有用户数据，如果有，则返回true,继续向下执行 if (user != null) &#123; return true; &#125; // 不符合条件的给出提示信息，并转发到登录页面 request.setAttribute("msg", "您还没有登录，请先登录！"); request.getRequestDispatcher("/WEB-INF/jsp/login.jsp").forward(request, response); return false; &#125;1234567&lt;!-- 配置拦截器 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**" /&gt; &lt;bean class="cn.edu.ujn.ch15.interceptor.LoginInterceptor" /&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;2、文件上传和下载(1)上传==1、前端配置==多数文件上传都是通过表单形式提交给后台服务器的，因此，要实现文件上传功能，就需要提供一个文件上传的表单，而该表单必须满足以下3个条件form表单的method属性设置为post；form表单的enctype属性设置为multipart/form-data；提供&lt;input type=&quot;file&quot; name=&quot;filename&quot; /&gt;的文件上传输入框。multiple属性是HTML5中新属性，可实现多文件上传。123&lt;form action="uploadUrl" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="filename" multiple="multiple" /&gt; &lt;input type="submit" value="文件上传" /&gt;application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。==2、导入jar包==12345&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt;==3、MultipartResolver配置==当form表单的enctype属性为multipart/form-data时，浏览器就会采用二进制流来处理表单数据，服务器端就会对文件上传的请求进行解析处理。Spring MVC通过MultipartResolver实现文件上传功能。MultipartResolver是一个接口对象，需要通过它的实现类CommonsMultipartResolver来完成文件上传工作。12345678&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="defaultEncoding" value="UTF-8" /&gt; &lt;!-- 设置请求编码格式，必须与JSP中的pageEncoding属性一致，默认为ISO-8859-1 --&gt; &lt;property name="maxUploadSize" value="2097152" /&gt; &lt;!-- 设置允许上传文件的最大值（2M），单位为字节 --&gt; ...&lt;/bean&gt;maxUploadSize：上传文件最大长度（以字节为单位）；maxInMemorySize：缓存中的最大尺寸；defaultEncoding：默认编码格式；resolveLazily：推迟文件解析，以便在Controller中捕获文件大小异常。注意：因为MultipartResolver接口的实现类CommonsMultipartResolver内部 是引用multipartResolver字符串获取该实现类对象并完成文件解析的，所以在配置CommonsMultipartResolver时必须指定该Bean的id为multipartResolver。==4、使用MultipartFile接受前段传来的数据流，使用其相应方法对数据进行操作==`12345678910111213141516171819202122232425262728293031323334353637383940@RequestMapping("/file") public String toUpload() &#123; return "fileUpload";//这里跳转的是jsp &#125; @RequestMapping("/fileUpload") public String handleFormUpload(@RequestParam("name") String name, @RequestParam("uploadfile") List&lt;MultipartFile&gt; uploadfile, HttpServletRequest request) &#123; // 判断所上传文件是否存在 if (!uploadfile.isEmpty() &amp;&amp; uploadfile.size() &gt; 0) &#123; //循环输出上传的文件 for (MultipartFile file : uploadfile) &#123; // 获取上传文件的原始名称 String originalFilename = file.getOriginalFilename(); // 设置上传文件的保存地址目录 String dirPath = request.getServletContext().getRealPath("/upload/"); File filePath = new File(dirPath); // 如果保存文件的地址不存在，就先创建目录 if (!filePath.exists()) &#123; filePath.mkdirs(); &#125; // 使用UUID重新命名上传的文件名称(上传人_uuid_原始文件名称) String newFilename = name+ "_"+UUID.randomUUID() + "_"+originalFilename; try &#123; // 使用MultipartFile接口的方法完成文件上传到指定位置 file.transferTo(new File(dirPath + newFilename)); System.out.println(dirPath); &#125; catch (Exception e) &#123; e.printStackTrace(); return"error"; &#125; &#125; // 跳转到成功页面 return "success"; &#125;else&#123; return"error"; &#125; &#125;(2)下载==1、前端设置==在客户端页面使用一个文件下载的超链接，该链接的href属性要指定后台文件下载的方法以及文件名（需要先在文件下载目录中添加了一个名称为“1.jpg”的文件）。前端JSPdownload.jsp：&lt;a href=&quot;${pageContext.request.contextPath }/download?filename=&lt;%=URLEncoder.encode(&quot;壁纸.jpg&quot;, &quot;UTF-8&quot;)%&gt;&quot;&gt;中文名称文件下载 &lt;/a&gt;==2、后端使用ResponseEntity处理==在后台使用Spring MVC提供的ResponseEntity类型对象完成文件下载，使用它可以很方便的定义返回的HttpHeaders对象和HttpStatus对象，通过对这两个对象的设置，即可完成下载文件时所需的配置信息。文件下载中的ResponseEntity对象有些类似前面章节中的@ResponseBody注解，它用于直接返回结果对象。响应头信息中的MediaType代表的是Interner Media Type（即互联网媒体类型），也叫做MIME类型，MediaType.APPLICATION_OCTET_STREAM的值为application/octet-stream，即表示以二进制流的形式下载数据；HttpStatus类型代表的是Http协议中的状态，示例中的HttpStatus.OK表示200，即服务器已成功处理了请求。123456789101112131415161718192021222324252627282930313233343536373839404142@RequestMapping("/down") public String toDownload() &#123; return "download";//这里跳转的是jsp &#125;@RequestMapping("/download") public ResponseEntity&lt;byte[]&gt; fileDownload(HttpServletRequest request, String filename) throws Exception&#123; // 指定要下载的文件所在路径 String path = request.getServletContext().getRealPath("/upload/"); // 创建该文件对象 File file = new File(path+File.separator+filename); // 对文件名编码，防止中文文件乱码 filename = this.getFilename(request, filename); // 设置响应头 HttpHeaders headers = new HttpHeaders(); // 通知浏览器以下载的方式打开文件 headers.setContentDispositionFormData("attachment", filename); // 定义以流的形式下载返回文件数据 headers.setContentType(MediaType.APPLICATION_OCTET_STREAM); // 使用Sring MVC框架的ResponseEntity对象封装返回下载数据 return new ResponseEntity&lt;byte[]&gt;(FileUtils.readFileToByteArray(file), headers,HttpStatus.OK); &#125;/** * 根据浏览器的不同进行编码设置，返回编码后的文件名 */ public String getFilename(HttpServletRequest request, String filename) throws Exception &#123; // IE不同版本User-Agent中出现的关键词 String[] IEBrowserKeyWords = &#123;"MSIE", "Trident", "Edge"&#125;; // 获取请求头代理信息 String userAgent = request.getHeader("User-Agent"); for (String keyWord : IEBrowserKeyWords) &#123; if (userAgent.contains(keyWord)) &#123; //IE内核浏览器，统一为UTF-8编码显示 return URLEncoder.encode(filename, "UTF-8"); &#125; &#125; //火狐等其它浏览器统一为ISO-8859-1编码显示 return new String(filename.getBytes("UTF-8"), "ISO-8859-1"); &#125;==3、中文名文件乱码问题解决==为了解决浏览器中文件下载时中文名称的乱码问题，可以在前端页面发送请求前先对中文名进行统一编码，然后在后台控制器类中对文件名称进行相应的转码。 12345678910111213141516171819202122232425262728293031323334353637@RequestMapping("/download") public ResponseEntity&lt;byte[]&gt; fileDownload(HttpServletRequest request, String filename) throws Exception&#123; // 指定要下载的文件所在路径 String path = request.getServletContext().getRealPath("/upload/"); // 创建该文件对象 File file = new File(path+File.separator+filename); // 对文件名编码，防止中文文件乱码 filename = this.getFilename(request, filename); // 设置响应头 HttpHeaders headers = new HttpHeaders(); // 通知浏览器以下载的方式打开文件 headers.setContentDispositionFormData("attachment", filename); // 定义以流的形式下载返回文件数据 headers.setContentType(MediaType.APPLICATION_OCTET_STREAM); // 使用Sring MVC框架的ResponseEntity对象封装返回下载数据 return new ResponseEntity&lt;byte[]&gt;(FileUtils.readFileToByteArray(file), headers,HttpStatus.OK); &#125;/** * 根据浏览器的不同进行编码设置，返回编码后的文件名 */ public String getFilename(HttpServletRequest request, String filename) throws Exception &#123; // IE不同版本User-Agent中出现的关键词 String[] IEBrowserKeyWords = &#123;"MSIE", "Trident", "Edge"&#125;; // 获取请求头代理信息 String userAgent = request.getHeader("User-Agent"); for (String keyWord : IEBrowserKeyWords) &#123; if (userAgent.contains(keyWord)) &#123; //IE内核浏览器，统一为UTF-8编码显示 return URLEncoder.encode(filename, "UTF-8"); &#125; &#125; //火狐等其它浏览器统一为ISO-8859-1编码显示 return new String(filename.getBytes("UTF-8"), "ISO-8859-1"); &#125;]]></content>
      <categories>
        <category>JavaEE程序设计</category>
      </categories>
      <tags>
        <tag>JavaEE程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaEE程序设计【十一】]]></title>
    <url>%2Fposts%2F25dd8547%2F</url>
    <content type="text"><![CDATA[一、初识SpringMVCSpringMVC框架是Spring 框架的一部分，可以方便的利用Spring所提供的其他功能。1、实现Controller接口和配置XML方式实现（用于理解，开发不用）1.在web.xml中，配置Spring MVC的前端控制器DispatcherServlet。1234567891011121314&lt;servlet&gt;&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;init-param&gt;&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;&lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt;&lt;/init-param&gt;&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;&lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;这里说明一下XML的配置，因为之前JSP使用注解，所以很少配置XML&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;“1”表示容器在启动时立即加载该Servlet&lt;init-param&gt;是给DispatcherServlet对象注入Spring配置文件。&lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; /* &lt;/ url-pattern &gt;会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。客户端请求—&gt;URL解析—&gt;XM使用&lt;url-pattern&gt;/&lt;/url-pattern&gt;配置了解到拦截所有的请求—&gt;根据&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;找到相应的servlet进行处理。123&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;由此可知，SpringMVC中所有的请求都被DispatcherServlet拦截处理。而在之前的JSP设计中，我们一个请求都需要一个Servlet进行处理，同时在web.XML中配置相应的拦截和映射处理，使得每个请求找到相应的servlet进行处理。==这里体现的就是SpringMVC的一个特点了，增加”一层DispatcherServlet”在servlet映射处理上，进行自动配置，减少我们的工作量。同时也是一个思想“没有什么是增加一个‘父层’解决不了的，有就行2层”==2.创建控制器类,并实现Controller接口。1234567891011public class FirstController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // TODO Auto-generated method stub ModelAndView modelAndView = new ModelAndView();/*创建ModelAndView对象*/ modelAndView.addObject("msg","第一个SpringMVC程序！");/*添加返回信息*/ modelAndView.setViewName("/WEB-INF/jsp/first.jsp"); /*设置逻辑视图名*/ return modelAndView; &#125;&#125;3.设置Spring配置文件,注册bean1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 处理器映射器，将处理器Handle的name作为url进行查找 --&gt;&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/&gt;&lt;!-- 处理器适配器，配置对处理器中handleRequest()方法的调用--&gt;&lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"/&gt; &lt;!-- 配置视图解析器--&gt;&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" /&gt;&lt;bean name="/first" class="cn.edu.ccc.ch11.c.FirstController"&gt;&lt;/bean&gt;&lt;/beans&gt;BeanNameUrlHandlerMapping（可换成其他的mapping这个是通过beanname查找匹配servlet）4.编写JSP页面123456789101112&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;%@page isELIgnored="false"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt;关于EL表达式：注意Servlet版本，如果是Servlet 2.x，需要设置isELIgnored &lt;%@page isELIgnored=&quot;false&quot; %&gt;EL 全名为Expression Language，在本程序中的作用：获取数据：${msg}、${user.address.city}EL表达式还有很多功能，可另查阅学习5.将ch11项目发布到Tomcat中，并启动Tomcat服务器。在浏览器中访问2、SpringMVC的工作流程==只有虚线是我们需要编写的部分，其他都由Spring自动完成==简要分析执行流程DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。我们假设请求的url为 : http://localhost:8080/SpringMVC/hello如上url拆分成三部分：http://localhost:8080服务器域名SpringMVC部署在服务器上的web站点(发布时容器不配置有可能为空。)hello表示控制器通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。Handler让具体的Controller执行。Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。视图解析器将解析的逻辑视图名传给DispatcherServlet。DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。最终视图呈现给用户。粗略：DispatcherServlet拦截所有的请求，自动寻找我们配置的controller，并运行，返回给DispatcherServlet，然后DispatcherServlet将controller中得到的数据和视图名交给ViewResolver进行渲染显示给用户。 这些都是Spring帮我们做，我们只需要①配置一次web.xml 配置DispatcherServlet拦截所有请求②配置spring配置文件，添加处理器映射器、处理器适配器、视图解析器（目前版本自动添加可忽略不配，若需要拼装只需要配置视图解析器）和我们的controller（使用注解则不用，而是开启扫描和其他配置之后讲）③ 专心进行我们的controller业务逻辑编写即可SpringMVC中HandlerMapping和HandlerAdapter详解（适配器模式）==关于HandlerMapping和HandlerAdapter，需要了解适配器模式。再来理解是为何。这里浅显知道是Spring用来自动为请求寻找相应的servlet即controller进行处理。之后再来深入学习====使用springMVC必须配置的三大件：====处理器映射器、处理器适配器、视图解析器====通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置(原来我们使用xml方法配置的话一个servlet就需要在xml中配置一个)==3、核心类(1)DispatcherServletDispatcherServlet的全名是org.springframework.web.servlet.DispatcherServlet，它在程序中充当着前端控制器的角色。在使用时，只需将其配置在项目的web.xml文件中，123456789&lt;servlet&gt;&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;init-param&gt;&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;&lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt;&lt;/init-param&gt;&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;如果没有通过&lt;init-param&gt;元素配置，则应用程序会默认去WEB-INF目录下寻找以servletName-servlet.xml方式命名的配置文件，这里的servletName指下面的springmvc如果&lt;init-param&gt;元素存在并且通过其子元素配置了Spring MVC配置文件的路径，则应用程序在启动时会加载配置路径下的配置文件(2)ViewResolverSpring MVC中的视图解析器负责解析视图。可以通过在配置文件中定义一个ViewResolver来配置视图解析器，配置示例如下：12345&lt;bean id="viewResolver"class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;&lt;property name="prefix" value="/WEB-INF/jsp/" /&gt;&lt;property name="suffix" value=".jsp" /&gt;&lt;/bean&gt;上述代码中，定义了一个视图解析器，并设置了视图的前缀和后缀属性。这样设置后，方法中所定义的view路径将可以简化。例如，入门案例中的逻辑视图名只需设置为“first”，相当于“/WEB-INF/jsp/first.jsp”，视图解析器会自动的增加前缀和后缀。(3)@Controllerorg.springframework.stereotype.Controller注解类型用于指示Spring类的实例是一个控制器，其注解形式为@Controller。该注解在使用时不需要再实现Controller接口，只需要将@Controller注解加入到控制器类上，然后通过Spring的扫描机制找到标注了该注解的控制器即可。1234567package cn.edu.ccc.ch12.controller;import org.springframework.stereotype.Controller;...@Controllerpublic class FirstController&#123;...&#125;在Spring MVC的配置文件中添加相应的扫描配置信息，一个完整的配置文件示例如下:123456789&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:context="http://www.springframework.org/schema/context"xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;context:component-scan base-package="cn.edu.ccc" /&gt;&lt;/beans&gt;(4)@RequestMappingSpring通过@Controller注解找到相应的控制器类后，还需要知道控制器内部对每一个请求是如何处理的，使用@RequestMapping注解类型，它用于映射一个请求或一个方法。使用时，可以标注在一个方法或一个类上。标注在方法上：123456@Controllerpublic class FirstController&#123;@RequestMapping(value="/firstController")public ModelAndView handleRequest(HttpServletRequest request,HttpServletResponse resp) &#123;......return mav;&#125;此时，可以通过地址：http://localhost:8080/ch12/firstController访问该方法标注在类上：该类中的所有方法都将映射为相对于类级别的请求，表示该控制器所处理的所有请求都被映射到value属性值所指定的路径下。123456789@Controller@RequestMapping(value="/hello")public class FirstController&#123;@RequestMapping(value="/firstController")public ModelAndView handleRequest(HttpServletRequest req, HttpServletResponse resp) &#123;...return mav;&#125;&#125;由于在类上添加了@RequestMapping 注解，并且其value 属性值为“/hello” ，所以上述代码方法的请求路径将变为：http://localhost:8080/ch12/hello/firstController。组合注解： 请求处理方法的参数和返回类型：==由于ModelAndView 类型未能实现数据与视图之间的解耦，所以在企业开发时，方法的返回类型通常都会使用String。String用来跳转视图，而其他的数据用model带回==String类型除了可以返回上述代码中的视图页面外，还可以进行重定向与请求转发：return &quot;redirect:queryUser&quot;;return &quot;forward:editUser&quot;;4、注解方式使用1、配置项目里的web.xml12345678910111213141516171819202122232425&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;!-- 配置前端过滤器 --&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;!-- 初始化时加载配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 表示容器在启动时立即加载Servlet PS:数字越小，启动越早--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt;2.修改编写SpringMVC的配置文件123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置处理器Handle，映射“/firstController”请求 --&gt; &lt;context:component-scan base-package="cn.edu.ccc" /&gt; &lt;bean id="viewResolver" class= "org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 设置前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;!-- 设置后缀 --&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt;&lt;/beans&gt;在类和方法上添加相应注解即可12345678910@Controller@RequestMapping(value="/hello")public class FirstController&#123;@RequestMapping(value="/firstController")public String handleRequest(HttpServletRequest request,HttpServletResponse response, Model model) throws Exception &#123;model.addAttribute("msg", "这是我的第一个Spring MVC程序");return "first";&#125;&#125;二、数据绑定在执行程序时, Spring MVC会根据客户端请求参数的不同,将请求消息中的信息以一定的方式转换并绑定到控制器类的方法参数中。这种将请求消息数据与后台方法参数建立连接的过程就是 Spring MVC中的数据绑定。其实就是如何将前端的数据传到后端Spring mvc是怎样完成的数据绑定?在数据绑定过程中, Spring MVC框架会通过数据绑定组件( Data Binder)先将请求参数串的内容进行类型转换然后将转换后的值赋给控制器类中方法的形参,这样后台方法就可以正确绑定并获取客户端请求携带的参数了.1、简单数据绑定(1)HttpServletRequest默认模式12345678910@Controllerpublic class UserController &#123; @RequestMapping("/selectUser") public String selectUser(HttpServletRequest request) &#123; String id = request.getParameter("id"); System.out.println(id); request.setAttribute("id", id); return "success"; &#125;&#125;1234567891011&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;结果页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;id&#125;&lt;/body&gt;&lt;/html&gt;使用http://localhost:8080/ch13/selectUser?id=1即可测试得到id。(2)Spring自动绑定基础数据类型12345@RequestMapping("/findUser") public String findUser(Integer id) &#123; System.out.println(id); return "success";&#125;使用http://localhost:8080/ch13/findUser?id=1也可以测试出，数据从前端传到了后端。注意：参数名和后台控制器类方法中的形参名要一样，若不一样，需要使用@RequestParam(“前端属性名”)进行标注。但是一般不会自找麻烦，写一样的就可以了。12345@RequestMapping("/findUser") public String findUser(@RequestParam("id")Integer text) &#123; System.out.println(id); return "success";&#125;(3)Spring自动绑定绑定POJO类123456public class User &#123; private Integer id; //用户id private String username; //用户 private Integer password;//用户密码 ……&#125;123456789@RequestMapping("/toRegister") public String toRegister() &#123; return "register"; &#125; @RequestMapping("/registerUser") public String registerUser(User user) &#123; System.out.println("注册的用户信息："+user); return "ok"; &#125;123456789101112131415&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;注册&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="registerUser" method="post"&gt; 用户名：&lt;input type="text" name="username" /&gt;&lt;br /&gt; 密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;input type="text" name="password" /&gt;&lt;br /&gt; &lt;input type="submit" value="注册"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;访问http://localhost:8080/ch13/toRegister即可测试。注意：前端属性名和POJO类中的属性名要一样！！(4)绑定包装POJO类12345678910111213141516public class Orders &#123; private Integer ordersId; // 订单编号 private User user; // 用户POJO，所属用户 public Integer getOrdersId() &#123; return ordersId; &#125; public void setOrdersId(Integer ordersId) &#123; this.ordersId = ordersId; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125;12345678910111213141516171819202122@Controllerpublic class OrdersController &#123; /** * 向订单查询页面跳转 */ @RequestMapping("/tofindOrdersWithUser") public String tofindOrdersWithUser( ) &#123; return "orders"; &#125; /** * 查询订单和用户信息 */ @RequestMapping("/findOrdersWithUser") public String findOrdersWithUser(Orders orders) &#123; Integer orderId = orders.getOrdersId(); User user = orders.getUser(); String username = user.getUsername(); System.out.println("orderId="+orderId); System.out.println("username="+username); return "success"; &#125;&#125;1234567891011121314151617&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;订单查询&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath &#125;/findOrdersWithUser" method="post"&gt; 订单编号：&lt;input type="text" name="ordersId" /&gt;&lt;br /&gt; 所属用户：&lt;input type="text" name="user.username" /&gt;&lt;br /&gt; &lt;input type="submit" value="查询" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;访问http://localhost:8080/ch13/tofindOrdersWithUser即可测试。注意：前端中POJO内部的属性需要使用后端对应【对象.属性】例如：user.username(5)其他一般情况下,使用基本数据类型和POJO类型的参数数据已经能够满足需求,然而有些特殊类型的参数是无法在后台进行直接转换的,但也有特殊数据类型无法直接进行数据绑定,必须先经过数据转换,例如日期数据。①使用Converter1.使用Converter进行数据转换，在src目录下创建一个cn.edu.ccc.ch13.convert包,在该包下创建日期转换类DateConverter：123456789101112131415public class DateConverter implements Converter&lt;String, Date&gt; &#123; // 定义日期格式 private String datePattern = "yyyy-MM-dd HH:mm:ss"; @Override public Date convert(String source) &#123; // 格式化日期 SimpleDateFormat sdf = new SimpleDateFormat(datePattern); try &#123; return sdf.parse(source); &#125; catch (ParseException e) &#123; throw new IllegalArgumentException( "无效的日期格式，请使用这种格式:"+datePattern); &#125; &#125;&#125;编写配置文件：12345678910111213......&lt;!-- 显示的装配自定义类型转换器 --&gt; &lt;mvc:annotation-driven conversion-service="conversionService" /&gt; &lt;!-- 自定义类型转换器配置 --&gt; &lt;bean id="conversionService" class= "org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;set&gt; &lt;bean class="cn.edu.ccc.ch13.convert.DateConverter" /&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;创建一个日期控制器类DateController1234567891011@Controllerpublic class DateController &#123; /** * 使用自定义类型数据绑定日期数据 */ @RequestMapping("/customDate") public String CustomDate(Date date) &#123; System.out.println("date="+date); return "success"; &#125;&#125;访问：访问http://localhost:8080/chapter13/customDate?date= 2020-04-12 15:55:55。进行测试②使用format12345678&lt;!-- 自定义类型格式化转换器配置 --&gt; &lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;property name="formatters"&gt; &lt;set&gt; &lt;bean class="cn.edu.ccc.ch13.convert.DateFormatter" /&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;2、复杂数据绑定实际开发中仍可能遇到一些比较复杂的数据绑定问题,比如数组的绑定、集合的绑定,这在实际开发中也是十分常见的(1)数组绑定在实际开发时,可能会遇到前端请求需要传递到后台一个或多个相同名称参数的情况(如批量删除),此种情况采用前面讲解的简单数据绑定的方式显然是不合适的.针对上述这种情况,如果将所有同种类型的请求参数封装到一个数组中,后台就可以进行绑定接收了.user.jsp：1234567891011121314151617181920212223242526272829303132&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;用户列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath &#125;/deleteUsers" method="post"&gt; &lt;table width="20%" border=1&gt; &lt;tr&gt; &lt;td&gt;选择&lt;/td&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input name="ids" value="1" type="checkbox"&gt;&lt;/td&gt; &lt;td&gt;tom&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input name="ids" value="2" type="checkbox"&gt;&lt;/td&gt; &lt;td&gt;jack&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input name="ids" value="3" type="checkbox"&gt;&lt;/td&gt; &lt;td&gt;lucy&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type="submit" value="删除"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;在UserController中，编写接收批量删除用户的方法：12345678910111213141516171819@RequestMapping("/toUser") public String selectUsers( ) &#123; return "user"; &#125; /** * 接收批量删除用户的方法 */ @RequestMapping("/deleteUsers") public String deleteUsers(Integer[] ids) &#123; if(ids !=null)&#123; for (Integer id : ids) &#123; // 使用输出语句模拟已经删除了用户 System.out.println("删除了id为"+id+"的用户！"); &#125; &#125;else&#123; System.out.println("ids=null"); &#125; return "success"; &#125;访问http://localhost:8080/ch13/toUser进行测试。(2)集合绑定但如果是批量修改用户操作的话,前端请求传递过来的数据可能就会批量包含各种类型的数据,如 Integer, String等.由于数组内容必须是一致的，所以针对上述这种情况,就可以使用集合数据绑定.即在包装类中定义一个包含用户信息类的集合,然后在接收方法中将参数类型定义为该包装类的集合.在src目录下创建一个cn.edu.ccc.ch13.vo包，创建包装类UserVo封装用户集合属性：123456789101112/** * 用户包装类 */public class UserVO &#123; private List&lt;User&gt; users; public List&lt;User&gt; getUsers() &#123; return users; &#125; public void setUsers(List&lt;User&gt; users) &#123; this.users = users; &#125;&#125;在UserController中，编写接收批量删除用户的方法：123456789101112131415161718192021222324/** * 向用户批量修改页面跳转 */ @RequestMapping("/toUserEdit") public String toUserEdit() &#123; return "user_edit"; &#125; /** * 接收批量修改用户的方法 */ @RequestMapping("/editUsers") public String editUsers(UserVO userList) &#123; // 将所有用户数据封装到集合中 List&lt;User&gt; users = userList.getUsers(); // 循环输出所有用户信息 for (User user : users) &#123; // 如果接收的用户id不为空，则表示对该用户进行了修改 if(user.getId() !=null)&#123; System.out.println("修改了id为"+user.getId()+ "的用户名为："+user.getUsername()); &#125; &#125; return "success"; &#125;user_edit.jsp：123456789101112131415161718192021&lt;form action="$&#123;pageContext.request.contextPath &#125;/editUsers" method="post" id='formid'&gt; &lt;table width="30%" border=1&gt; &lt;tr&gt;&lt;td&gt;选择&lt;/td&gt;&lt;td&gt;用户名&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input name="users[0].id" value="1" type="checkbox" /&gt; &lt;/td&gt; &lt;td&gt; &lt;input name="users[0].username" value="tome" type="text" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input name="users[1].id" value="2" type="checkbox" /&gt; &lt;/td&gt; &lt;td&gt; &lt;input name="users[1].username" value="jack" type="text" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type="submit" value="修改" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;3、解决中文乱码SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 .123456789101112&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;]]></content>
      <categories>
        <category>JavaEE程序设计</category>
      </categories>
      <tags>
        <tag>JavaEE程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaEE程序设计【十】]]></title>
    <url>%2Fposts%2F1dfd5395%2F</url>
    <content type="text"><![CDATA[9、关联映射MyBatis(五)：mybatis关联映射Mybatis关联映射(1)一对一在Mapper文件的&lt;resultMap&gt;元素中，包含了一个&lt;association&gt;子元素，MyBatis就是通过该元素来处理一对一关联关系的。property：指定映射到的实体类对象属性，与表字段一一对应column：指定表中对应的字段javaType：指定映射到实体对象属性的类型select：指定引入嵌套查询的子SQL语句，该属性用于关联映射中的嵌套查询fetchType：指定在关联查询时是否启用延迟加载。该属性有lazy和eager两个属性值，默认值为lazy（即默认关联映射延迟加载）MyBatis加载关联关系对象主要通过两种方式:嵌套查询和嵌套结果。嵌套查询的方式要执行多条SQL语句，这对于大型数据集合和列表展示不是很好，因为这样可能会导致成百上千条关联的SQL语句被执行，从而极大的消耗数据库性能并且会降低查询效率。MyBatis延迟加载的配置使用MyBatis的延迟加载在一定程度上可以降低运行消耗并提高查询效率。MyBatis默认没有开启延迟加载，需要在核心配置文件中的&lt;settings&gt;元素内进行配置，具体配置方式如下：123456&lt;settings&gt;&lt;setting name="lazyLoadingEnabled" value="true" /&gt; &lt;!-- 打开延迟加载的开关 --&gt;&lt;setting name="aggressiveLazyLoading" value="false"/&gt; &lt;!-- 将积极加载改为消息加载，即按需加载 --&gt;&lt;/settings&gt;不论默认值是什么,进行显性表示，防止版本更新带来默认值变化等。在映射文件中，&lt;association&gt;元素和&lt;collection&gt;元素中都已默认配置了延迟加载属性，即默认属性fetchType=”lazy”（属性fetchType=”eager”表示立即加载），所以在配置文件中开启延迟加载后，无需在映射文件中再做配置。,但是若全局配置懒加载想要在某个方法中关闭懒加载可以配置fetchType。方法1：嵌套查询PersonMapper.xml12345678910111213141516171819&lt;select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap"&gt; select &lt;include refid="Base_Column_List" /&gt; from person where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt;&lt;resultMap id="BaseResultMap" type="cn.edu.ccc.ch9.dao.Person"&gt; &lt;id column="id" jdbcType="INTEGER" property="id" /&gt; &lt;result column="name" jdbcType="VARCHAR" property="name" /&gt; &lt;result column="age" jdbcType="INTEGER" property="age" /&gt; &lt;result column="card_id" jdbcType="INTEGER" property="cardId" /&gt; &lt;association property="card" column="card_id" javaType="cn.edu.ccc.ch9.dao.IdCard" select="cn.edu.ccc.ch9.dao.IdCardMapper.selectByPrimaryKey"&gt; &lt;/association&gt; &lt;/resultMap&gt;IdCardMapper.xml123456&lt;select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap"&gt; select &lt;include refid="Base_Column_List" /&gt; from idcard where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt;==指的是将column中的对应表字段作为参数传入到Select中的查询语句，将查询结果传入property表示的类中的属性中====若传入多个参数，可使用column=”card_id”==方法2：嵌套结果PersonMapper.xml1234567891011121314151617181920 &lt;select id="selectByPrimaryKey2" parameterType="java.lang.Integer" resultMap="BaseResultMap2"&gt; select p.*,idcard.code from person p,idcard idcard where p.card_id=idcard.id and p.id=#&#123;id&#125; &lt;/select&gt;&lt;resultMap id="BaseResultMap2" type="cn.edu.ccc.ch9.dao.Person"&gt; &lt;id column="id" jdbcType="INTEGER" property="id" /&gt; &lt;result column="name" jdbcType="VARCHAR" property="name" /&gt; &lt;result column="age" jdbcType="INTEGER" property="age" /&gt; &lt;result column="card_id" jdbcType="INTEGER" property="cardId" /&gt; &lt;association property="card" javaType="cn.edu.ccc.ch9.dao.IdCard"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="code" property="code"/&gt; &lt;/association&gt; &lt;/resultMap&gt;mybatis 嵌套查询子查询column传多个参数描述12345678910111213141516171819202122232425262728293031323334&gt; &lt;resultMap id="blogResult" type="Blog"&gt;&gt; &gt; &lt;association property="author" column="&#123;id=author_id,likename=author_name&#125;" javaType="Author" select="selectAuthor"/&gt;&gt; &gt; &lt;/resultMap&gt;&gt; &gt; &gt; &gt; &lt;select id="selectBlog" resultMap="blogResult" parameterType="java.lang.String"&gt;&gt; &gt; SELECT author_id,author_name FROM BLOG WHERE ID = #&#123;id&#125; &gt; &gt; &lt;/select&gt;&gt; &gt; &gt; &gt; &lt;select id="selectAuthor" resultType="Author" parameterType="java.util.HashMap"&gt;&gt; &gt; SELECT * FROM AUTHOR WHERE 1=1&gt; &gt; &lt;if test="id != null and id != '' "&gt;&gt; &gt; and ID = #&#123;id&#125; &gt; &gt; &lt;/if&gt;&gt; &gt; &lt;if test="likename != null and likename != '' "&gt;&gt; &gt; and name like CONCAT('%',#&#123;likename&#125;,'%')&gt; &gt; &lt;/if&gt;&gt; &gt; &lt;/select&gt;&gt;==嵌套查询：方法—&gt;映射SQL语句—&gt;结果集—&gt;映射SQL语句—&gt;结果集====嵌套结果：方法—&gt;映射SQL语句—&gt;结果集==(2)一对多在Mapper文件的&lt;resultMap&gt;元素中，包含了一个&lt;collection&gt;子元素，MyBatis就是通过该元素来处理一对多关联关系的。&lt;collection&gt;子元素的属性大部分与&lt;association&gt;元素相同，但其还包含一个特殊属性——ofType.ofType属性与javaType属性对应，它用于指定实体对象中集合类属性所包含的元素类型。方法1：嵌套查询UserMapper.xml1234567891011121314151617&lt;select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap2"&gt; select &lt;include refid="Base_Column_List" /&gt; from user where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt;&lt;resultMap id="BaseResultMap2" type="cn.edu.ccc.ch9.dao.User"&gt; &lt;id column="id" jdbcType="INTEGER" property="id" /&gt; &lt;result column="name" jdbcType="VARCHAR" property="name" /&gt; &lt;result column="password" jdbcType="VARCHAR" property="password" /&gt; &lt;collection property="orderlist" column="id" ofType="cn.edu.ccc.ch9.Orders" select="cn.edu.ccc.ch9.dao.OrdersMapper.selectByUserid"&gt;&lt;/collection&gt; &lt;/resultMap&gt;OrdersMapper.xml123456&lt;select id="selectByUserid" parameterType="java.lang.Integer" resultMap="BaseResultMap"&gt; select &lt;include refid="Base_Column_List" /&gt; from orders where user_id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt;方法2：嵌套结果UserMapper.xml1234567891011121314151617181920&lt;resultMap id="BaseResultMap3" type="cn.edu.CCC.ch9.dao.User"&gt; &lt;id column="id" jdbcType="INTEGER" property="id" /&gt; &lt;result column="name" jdbcType="VARCHAR" property="name" /&gt; &lt;result column="password" jdbcType="VARCHAR" property="password" /&gt; &lt;collection property="orderList" ofType="cn.edu.CCC.ch9.dao.Orders"&gt; &lt;id column="id" jdbcType="INTEGER" property="id" /&gt; &lt;result column="number" jdbcType="VARCHAR" property="number" /&gt; &lt;result column="user_id" jdbcType="INTEGER" property="userId" /&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;select id="selectByPrimaryKey3" parameterType="java.lang.Integer" resultMap="BaseResultMap3"&gt; select user.id, name, password,number from user,orders where user.id = #&#123;id,jdbcType=INTEGER&#125; and user_id=user.id &lt;/select&gt;一般来说，运行正常，但是查询不出结果，大多数是SQL语句有错误，常常为多表中的字段只用简写产生歧义。例如user中的id和orders中的id。若不该为user.id和orders.id，是查不出来的。尤其是使用sql标签把查询的参数抽取出来的时候更容易出这样的错误(3)多对多在数据库中，多对多的关联关系通常使用一个中间表来维护，中间表中的订单id作为外键参照订单表的id，商品id作为外键参照商品表的id。多对多本质上就是两个一对多的设计10、mybatis和spring的整合Mybatis(六) Spring整合mybatismybatis-spring官方中文文档先回顾一下mybatis最基础的根基：mybatis，有两个配置文件全局配置文件SqlMapConfig.xml(配置数据源，全局变量，加载映射文件等东西)映射文件xxxMapper.xml，用来对输入参数输出参数，数据库语句做配置的。mybatis配置好之后的使用步骤1、获取sqlMapConfig.xml的位置然后进行加载2、通过sqlMapConfig.xml中的内容创建出sqlsessionFactory对象3、然后通过sqlsessionFactory对象创建出sqlsession对象4、有了sqlsession对象就可以进行相应的操作了。集成思路有了上面的一些知识回顾，那么就有思路让spring继承mabatis了。1、让spring来管理数据源信息，sqlMapConfig.xml中就不需要加载数据源了。交给spring管理2、让spring通过单例方式管理SqlSessionFactory，只需要一个SqlSessionFactory帮我们生成sqlsession即可。也就是需要sqlsession对象就让sqlsessionfactory生成。所以是单例方式。3、让spring创建sqlsession bean。也就是通过SqlSessionFactory创建SqlSession，4、如果是使用mapper代理开发的方式，那么持久层的mapper都需要由spring进行管理，spring和mybatis整合生成mapper代理对象。(1)环境准备Spring框架所需的JAR包12345678910111213/*AOP开发使用的JAR*/aopalliance-1.0.jaraspectjweaver-1.8.10.jarspring-aop-4.3.6.RELEASE.jarspring-aspects-4.3.6.RELEASE.jar/*4个核心模块JAR*/spring-beans-4.3.6.RELEASE.jarspring-context-4.3.6.RELEASE.jarspring-core-4.3.6.RELEASE.jarspring-expression-4.3.6.RELEASE.jar/*JDBC和事务的JAR*/spring-jdbc-4.3.6.RELEASE.jarspring-tx-4.3.6.RELEASE.jar注：核心容器依赖的commons-logging的JAR在MyBatis框架的lib包中已经包含！MyBatis框架所需的JAR包12345678910111213ant-1.9.6.jarant-launcher-1.9.6.jarasm-5.1.jarcglib-3.2.4.jarcommons-logging-1.2.jarjavassist-3.21.0-GA.jarlog4j-1.2.17.jarlog4j-api-2.3.jarlog4j-core-2.3.jarmybatis-3.4.2.jarognl-3.1.12.jarslf4j-api-1.7.22.jarslf4j-log4j12-1.7.22.jarMyBatis与Spring整合的中间JAR1mybatis-spring-1.3.1.jar数据库驱动JAR（MySQL）1mysql-connector-java-5.1.40-bin.jar数据源所需JAR（DBCP）12commons-dbcp2-2.1.1.jarcommons-pool2-2.4.2.jar==若使用MAVEN添加依赖：==注：提取properties方便修改版本。尤其是Spring相关，多个依赖的版本控制都是spring.version123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;spring.version&gt;5.2.5.RELEASE&lt;/spring.version&gt; &lt;mybatis.version&gt;3.5.4&lt;/mybatis.version&gt; &lt;mybatis.spring.version&gt;2.0.4&lt;/mybatis.spring.version&gt; &lt;mysql.version&gt;5.1.48&lt;/mysql.version&gt; &lt;commons-dbcp.version&gt;2.7.0&lt;/commons-dbcp.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-dbcp.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;(2)Dao方式使用采用传统DAO开发方式进行MyBatis与Spring框架的整合时，可以使用mybatis-spring包中所提供的SqlSessionTemplate类或SqlSessionDaoSupport类来实现。SqlSessionTemplate：是mybatis-spring的核心类，它负责管理MyBatis的SqlSession，调用MyBatis的SQL方法。当调用SQL方法时，SqlSessionTemplate将会保证使用的SqlSession和当前Spring的事务是相关的。它还管理SqlSession的生命周期，包含必要的关闭、提交和回滚操作。SqlSessionDaoSupport：是一个抽象支持类，它继承了DaoSupport类，主要是作为DAO的基类来使用。可以通过SqlSessionDaoSupport类的getSqlSession()方法来获取所需的SqlSession。1234567891011121314@Repositorypublic class CustomerDaoImpl extends SqlSessionDaoSupport implements ICustomerDao &#123; @Autowired public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) &#123; super.setSqlSessionFactory(sqlSessionFactory); &#125; public void add(Customer cc) &#123; CustomerMapper customerMapper = this.getSqlSession().getMapper(CustomerMapper.class); int count = customerMapper.insert(cc); System.out.println("添加了" + count + "行数据。"); int update = this.getSqlSession().update("cn.edu.ccc.ch10.dao.CustomerMapper.insert", cc); System.out.println("--添加了"+update);&#125;&#125;1234567891011121314@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = "classpath:spring-mybatis.xml")public class CustomerDaoTest &#123; @Autowired private ICustomerDao customerDaoImpl; @Test public void addTest() &#123; Customer cc = new Customer(); cc.setUsername("AAA"); …… customerDaoImpl.add(cc); System.out.println("添加成功"); &#125;&#125;(3)mybatis-spring整合映射文件方式使用①SqlSessionFactoryBean在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的。 而在 MyBatis-Spring 中，则使用 SqlSessionFactoryBean 来创建。要创建工厂 bean，将下面的代码放到 Spring 的 XML 配置文件中：123&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt;需要注意的是 SqlSessionFactoryBean 实现了 Spring 的 FactoryBean 接口（参见 Spring 官方文档 3.8 节 通过工厂 bean 自定义实例化逻辑）。==这意味着由 Spring 最终创建的 bean 并不是 SqlSessionFactoryBean 本身，而是工厂类（SqlSessionFactoryBean）的 getObject() 方法的返回结果。（和Spring的手动配置工厂来进行装配相关，这种模式日常中我们开发用得少）==这种情况下，Spring 将会在应用启动时为你创建 SqlSessionFactory，并使用 sqlSessionFactory 这个名字存储起来。MyBatis中SqlSessionFactoryBean的作用为什么返回的是SqlSessionFactory对象而不是SqlSessionFactoryBean首先spring在初始化的时候会将所有创建的单例以Map&lt;K,V&gt;的形式放入singletonObjects，同时调用FactoryBean的getObject()将返回的对象以Map&lt;K,V&gt;的形式放入factoryBeanObjectCache如{sqlSessionFactory=org.apache.ibatis.session.defaults.DefaultSqlSessionFactory@d997f9}然后getBean的时候，spring利用getSingleton从singletonObjects获取单例(这里是SqlSessionFactoryBean对象)，判断是否实现了FactoryBean接口，若实现了就从factoryBeanObjectCache利用beanname(这里是sqlSessionFactory)重新获取，若未实现则返回getSingleton获取的单例等效的 Java 代码如下：123456@Beanpublic SqlSessionFactory sqlSessionFactory() &#123; SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean(); factoryBean.setDataSource(dataSource()); return factoryBean.getObject();&#125;通常，在 MyBatis-Spring 中，你不需要直接使用 SqlSessionFactoryBean 或对应的 SqlSessionFactory。相反，session 的工厂 bean 将会被注入到 MapperFactoryBean 或其它继承于 SqlSessionDaoSupport 的 DAO（Data Access Object，数据访问对象）中。SqlSessionFactory 有一个唯一的必要属性：用于 JDBC 的 DataSource。这可以是任意的 DataSource 对象，它的配置方法和其它 Spring 数据库连接是一样的。一个常用的属性是 configLocation，它用来指定 MyBatis 的 XML 配置文件路径。它在需要修改 MyBatis 的基础配置非常有用。通常，基础配置指的是 &lt;settings&gt; 或 &lt;typeAliases&gt; 元素。需要注意的是，这个配置文件并不需要是一个完整的 MyBatis 配置。确切地说，任何环境配置（&lt;environments&gt;），数据源（&lt;DataSource&gt;）和 MyBatis 的事务管理器（&lt;transactionManager&gt;）都会被忽略。SqlSessionFactoryBean 会创建它自有的 MyBatis 环境配置（Environment），并按要求设置自定义环境的值。如果 MyBatis 在映射器类对应的路径下找不到与之相对应的映射器 XML 文件，那么也需要配置文件。这时有两种解决办法：第一种是手动在 MyBatis 的 XML 配置文件中的&lt;mappers&gt; 部分中指定 XML 文件的类路径；第二种是设置工厂 bean 的 mapperLocations 属性。mapperLocations 属性接受多个资源位置。这个属性可以用来指定 MyBatis 的映射器 XML 配置文件的位置。属性的值是一个 Ant 风格的字符串，可以指定加载一个目录中的所有文件，或者从一个目录开始递归搜索所有目录。比如:1234&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="mapperLocations" value="classpath*:sample/config/mappers/**/*.xml" /&gt;&lt;/bean&gt;这会从类路径下加载所有在 sample.config.mappers 包和它的子包中的 MyBatis 映射器 XML 配置文件。其他再查阅官方文档:https://mybatis.org/spring/zh/factorybean.html在 MyBatis 中，你可以使用 SqlSessionFactory 来创建 SqlSession。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。使用 MyBatis-Spring 之后，你不再需要直接使用 SqlSessionFactory 了，因为你的 bean 可以被注入一个线程安全的 SqlSession，它能基于 Spring 的事务配置来自动提交、回滚、关闭 session。②手动配置MapperFactoryBean方式（麻烦，很少用）MapperFactoryBean是MyBatis-Spring团队提供的一个用于根据Mapper接口生成Mapper对象的类，该类在Spring配置文件中使用时可以配置以下参数：mapperInterface：用于指定接口；SqlSessionFactory：用于指定SqlSessionFactory；SqlSessionTemplate：用于指定SqlSessionTemplate。如果与SqlSessionFactory同时设定，则只会启用SqlSessionTemplate。在实际的项目中，DAO层会包含很多接口，如果每一个接口都在Spring配置文件中配置，不但会增加工作量，还会使得Spring配置文件非常臃肿。③自动注入映射器(使用MapperScannerConfigurer方式)Mybatis MapperScannerConfigurer 自动扫描 将Mapper接口生成代理注入到Spring配置MapperScannerConfigurer获得符合Mapper映射器要求的对象(相当于调用SqlSession的getMapper()方法)。即在测试方法中的：UserMapper userMapper = sqlSession.getMapper(UserMapper.class);并且会将这些对象放到spring容器里面（默认的id是首字母小写之后的接口名比如Mapper映射器名为EmpDAO,则默认的id是empDAO,也可以使用@Repository来修改默认的id)即功能为：MapperScannerConfigurer可以为我们自动生成各个Mapper的实例化Bean用来装入basePackage：指定映射接口文件所在的包路径，当需要扫描多个包时可以使用分号或逗号作为分隔符。指定包路径后，会扫描该包及其子包中的所有文件。annotationClass：指定了要扫描的注解名称，只有被注解标识的类才会被配置为映射器。sqlSessionFactoryBeanName：指定在Spring中定义的SqlSessionFactory的Bean名称。sqlSessionTemplateBeanName：指定在Spring中定义的SqlSessionTemplate的Bean名称。如果定义此属性，则sqlSessionFactoryBeanName将不起作用。markerInterface：指定创建映射器的接口。使用下面的 Spring 配置：123&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="org.mybatis.spring.sample.mapper" /&gt;&lt;/bean&gt;如果你需要指定 sqlSessionFactory 或 sqlSessionTemplate，==那你应该要指定的是 bean 名而不是 bean 的引用，因此要使用 value 属性而不是通常的 ref 属性==：1&lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt;在mybatis-spring1.1.0以前，是通过&lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;将SqlSessionFactory对象注入到sqlSessionFactory，这样做可能会有一个问题，就是在初始化MyBatis时，jdbc.properties文件还没被加载进来，dataSource的属性值没有被替换，就开始构造sqlSessionFactory类，属性值就会加载失败。在1.1.0以后，MapperScannerConfigure提供了String类型的sqlSessionFactoryBeanName，这样将bean name注入到sqlSessionFactoryBeanName，这样就会等到spring初始化完成后，再构建sqlSessionFactory。关于SqlSessionFactoryBean、SqlSessionFactory、SqlSession：SqlSessionFactoryBean—&gt;SqlSessionFactory—&gt;获取SqlSession对象—&gt;获取Mapper对象—&gt;执行SQL对话。SqlSessionFactoryBean—&gt;SqlSessionFactory—&gt;获取SqlSession对象—&gt;执行SQL对话。因为：session.selectOne(&quot;cn.edu.ccc.ch9.dao.PersonMapper.selectByPrimaryKey&quot;, 1);和PersonMapper personMapper=session.getMapper(PersonMapper.class); personMapper.selectByPrimaryKey(1);是等效的SqlSessionFactoryBean实现了SqlSessionFactory接口。Spring和Mybatis配置文件整合后代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;context:component-scan base-package="cn.edu.ccc.ch10.service" /&gt; &lt;!--读取db.properties --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;!--数据库驱动 --&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;!--连接数据库的url --&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;!--连接数据库的用户名 --&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;!--连接数据库的密码 --&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/bean&gt; &lt;!-- 事务管理器，依赖于数据源 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!--开启事务注解 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt; &lt;!--配置MyBatis工厂 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!--注入数据源 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 自动扫描dao目录, 省掉mapper-resource里的手工配置 --&gt; &lt;property name="typeAliasesPackage" value="cn.edu.ccc.ch10.dao" /&gt; &lt;!--指定核心配置文件位置 --&gt; &lt;property name="mapperLocations" value="classpath:cn/edu/ccc/ch10/dao/*.xml" /&gt; &lt;/bean&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="cn.edu.ccc.ch10.dao" /&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;/bean&gt; &lt;/beans&gt;dataSource等数据传给SqlSessionFactoryBean，Spring构建Bean得到SqlSessionFactory，MapperScannerConfigurer使用SqlSessionFactory获取session，再获取Mapper对象作为Bean，为Spring之后在Service层的注入使用。注意：若配置了sqlSessionFactoryBeanName选项，则value需要和XML文件中的sqlSessionFactory的Id一致。否则找不到sqlSessionFactory报错。若不配置则会默认寻找12345678910111213@Servicepublic class CustomerServiceImpl implements ICustomerService &#123; @Autowired private CustomerMapper customerMapper; @Override public int insert(Customer customer) &#123; // TODO Auto-generated method stub customerMapper.insert(customer); return 0; &#125;&#125;11、拓展：连接池(1)Apache的dbcp2连接池1234567891011121314 &lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp2.BasicDataSource"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt;&lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt;&lt;property name="maxTotal" value="$&#123;jdbc.maxTotal&#125;" /&gt; &lt;!--最大活动连接数量:连接池在同一时间能够分配的最大活动连接的数量, 如果设置为负数则表示不限制 默认为8 --&gt;&lt;property name="maxIdle" value="$&#123;jdbc.maxIdle&#125;" /&gt; &lt;!--最大空闲连接:连接池中容许保持空闲状态的最大连接数量,超过的空闲连接将被释放,如果设置为负数表示不限制 默认为8 --&gt;&lt;property name="initialSize" value="$&#123;jdbc.initialSize&#125;" /&gt; &lt;!--初始化连接数量:连接池启动时创建的初始化连接数量 默认为0 --&gt; &lt;/bean&gt;1234567jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatisjdbc.username=rootjdbc.password=rootjdbc.maxTotal=30jdbc.maxIdle=10jdbc.initialSize=5(2)阿里巴巴Druid连接池12345678910111213&lt;bean name="dataSource“ class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close" &gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name="initialSize" value="0" /&gt; &lt;!-- 连接池最大使用连接数量 --&gt; &lt;property name="maxActive" value="20" /&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name="minIdle" value="0" /&gt; ……&lt;/bean&gt;12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.15&lt;/version&gt;&lt;/dependency&gt;12、其他1、关于Service层，本就是服务层，只是我们初学，才只有只调用Mapper即DAO层的方法12345public Orders selectByPrimaryKey(Integer id) &#123; // TODO Auto-generated method stub Orders selectByPrimaryKey = ordersMapper.selectByPrimaryKey(id); return selectByPrimaryKey; &#125;实际上Service层，具有其他逻辑，例如：123456789101112131415public int insert(Orders record) &#123; // TODO Auto-generated method stub int insert = ordersMapper.insert(record); if (insert &gt; 0) &#123; List&lt;Product&gt; productList = record.getProductList(); for (Product p : productList) &#123; Map orderItem = new HashMap(); orderItem.put("orders_id", record.getId()); orderItem.put("product_id", p.getId()); int addOrdersItem = ordersMapper.addOrdersItem(orderItem); System.out.println("插入成功(orderItem)：" + orderItem); &#125; &#125; return insert; &#125;这样应用层只需要调用即可。]]></content>
      <categories>
        <category>JavaEE程序设计</category>
      </categories>
      <tags>
        <tag>JavaEE程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统【六】]]></title>
    <url>%2Fposts%2F7a7f0d50%2F</url>
    <content type="text"><![CDATA[四、死锁1、什么是死锁死锁（Deadlock）,是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种状态时，若无外力作用，它们都将无法再向前推进。即：如果一组进程中，每个进程都无限等待被该组进程中另一进程所占有的资源，因而永远无法得到的资源，这种现象称为进程死锁，这一组进程就称为死锁进程。2、资源和死锁原因(1)资源可重用性资源和消耗性资源可再用资源：可以被多个进程多次使用可抢占资源：CPU不可抢占资源：打印机消耗性资源：只可使用一次的资源；即由一个进程产生，被另一进程使用后就再也无用的资源，也称为临时性资源如信号量,中断信号，同步信号等（临时性资源）“申请–分配–使用–释放”模式可抢占（剥夺）和 不可抢占（非剥夺性）资源系统有两类资源：可剥夺资源和非剥夺性资源。一类资源是可剥夺的，如处理机（高优先权的进程剥夺低优先权进程的处理机）和内存区（存储器管理程序可以把一个进程从一个存储区移至另一个存储区，甚至调出到外存上）。另一类资源是不可剥夺的，当系统把这类资源分配给某进程后．再不能强行收回，只能在进程用完后自动释放，如磁带机、打印机等。(2)死锁原因产生死锁的原因==1、竞争不可抢占性资源引起死锁====当系统中供多个进程所共享的资源，不足以同时满足它们的需要时，引起它们对资源的竞争而产生死锁。====2、竞争消耗性资源资源引起死锁====3、进程间推进顺序非法进程====在运行过程中，请求和释放资源的顺序不当，导致了进程死锁。==参与死锁的进程最少是两个参与死锁的进程至少有两个已经占有资源参与死锁的所有进程都在等待资源参与死锁的进程是当前系统中所有进程的子集(3)产生死锁的必要条件==互斥条件 :==进程对所分配到的资源进行排它性的使用==请求和保持条件:== 进程已经至少保持了一个资源，但又提出了新的资源请 求，而该资源又已被其他进程占有==不可剥夺条件:== 进程已获得的资源在未使用完之前不能被剥夺==环路等待条件 :== 在发生死锁时，必然存在一个进程–资源循环等待的环形链 即进程集合（P0，P1，…，Pn）中的P0正在等待一个P1占用的资源；Pl正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。3、处理死锁的基本方法1、预防死锁 通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止发生死锁。优点：容易实现，已被广泛使用；缺点：设置的限制条件往往太严格，有可能降低系统资源利用率和系统吞吐量。2、避免死锁 在资源动态分配过程中，用某种方法防止系统进入不安全状态，从而避免发生死锁，只需在事先加以较弱的限制条件。目前在较完善的系统中，常用此方法来避免发生死锁。3、检测死锁 允许系统在运行过程中发生死锁，及时检测出死锁的发生，采取措施将系统中的死锁清除。4、 解除死锁 常用的实施方法是撤消或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源利用率和系统吞吐量，但实现难度最大。4、预防死锁==预防死锁可以通过破坏除了互斥条件之外的其他条件==前面讲过预防死锁是通过破坏死锁的四个必要条件，所以就有四个预防死锁的方法吗？错！只有三种，因为互斥条件是必须的，不仅不能改变，还应该加以保证。因此只能破坏后三个条件。①破坏“请求和保持”条件 ：进程请求资源时，不能持有不可抢占资源。第一种协议（静态分配）:所有进程在开始运行之前必须一次性的申请整个运行过程所需的全部资源。进程在运行期间不会再申请资源了简单、易于实现、安全资源浪费严重进程经常会发生饥饿现象第二种协议:允许一个进程只获得运行初期所需的资源后便开始运行，在运行过程中再逐步释放已获得的且已用完的全部资源，然后再请求新的所需资源。（磁带机、磁盘机、打印机）破坏“不可抢占”条件 ：当一个已经保持了某些不可抢占资源的进程，提出新的资源请求不能得到满足时，必须释放已经保持的所有资源，待以后需要时再重新申请。进程逐个地申请所需资源当一个已经保持了某些资源的进程申请新资源而不能得到满足时，必须放弃所有已保持的资源。容易造成进程前一阶段工作的失效，即使不失效也会使进程前后两次运行的信息不连续。缺点：实现复杂、代价高昂。反复申请和释放资源会导致进程的执行被无限的推迟，不仅延长了进程的周转时间，还增加了系统开销，降低了系统的吞吐量。破坏“循环等待”条件：系统将所有资源按类型分配序号并排队所有进程申请资源必须按序号递增的顺序资源利用率和系统吞吐量较高但在资源管理和资源申请方面仍有问题存在问题：资源的需求顺序不等于序号，仍存在资源浪费。另外假入某进程已请求到一些序号较高的资源，又想申请序号低的资源时，必须先释放更高序号的资源后，才能申请序号低的资源。（1）资源所分配的序号，必须相对稳定，这就限制了新设备类型的增加。（2）进程使用各资源的顺序，与系统规定的顺序不同，造成对资源的浪费。（3）按规定次序申请资源的方法，必然会限制了用户简单、自主地编程。5、避免死锁避免死锁的核心在于，如果资源在分配给某个进程后会在将来导致死锁，那么就不同意资源请求，取消资源的分配。(1)安全状态在避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。 若此次分配不会导致系统进入不安全状态，则将资源分配给进程； 否则，令进程等待。所谓安全状态，是指系统能按某种进程顺序(P1, P2, …，Pn)为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。此时称（P1, P2, …, Pn）为安全序列。如果系统无法找到这样一个安全序列，则称系统处于不安全状态==P2—&gt;P1—&gt;P3的顺序可以使得进程顺利执行，所以为安全状态====没有序列使得三个进程能够顺利执行，为不安全状态。因为P2执行完毕后释放4个资源，而P1至少要5个P3只要要6个==(2)银行家算法假设系统中有 n 个进程，m 种资源，规定：每个进程在运行前先声明自己需要的最大资源数，用一个 n*m 的最大需求矩阵 Max 表示各个进程的需求情况，比如 Max[i][j]= K 就表示进程 i 需要 K 个 j 类型资源用一个 n*m 的分配矩阵 Allocation 表示各个进程的已分配资源情况用一个 n*m 的需求矩阵 Need 表示各个进程的最多还需要资源情况，Need = Max - Allocation用一个 m 长度的一维数组 Avaliable[k] 表示剩余K资源的数目用一个 m 长度的一维数组 Request_i[k] 表示某个进程 i 某次申请的资源K数目按照之前说过的流程图，银行家算法的工作过程是：请求资源数是否超过最大资源数？Request_i[j]&lt;=Need[i][j]，则到下一步；否则出错请求资源数是否超过剩余资源数？Request_i[j]&lt;=Available[j]，则到下一步；否则说明资源不够，进程等待尝试进行资源分配。剩余资源减少：Available = Available - Request已分配资源增加：Allocation[i][j] = Allocation[i][j] + Request_i[j]需求资源减少：Need[i][j] = Need[i][j] - Request_i[j]对分配后的状态通过安全性算法进行预判：安全状态：不会发生死锁，可以分配资源不安全状态：可能发生死锁，不分配资源安全性算法==其实本质上就进行假设运行计算，看看能否成功分配资源==(1) 设置两个向量：① 工作向量Work: 它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work := Available;② Finish: 它表示系统是否有足够的资源分配给进程，使之运行完成。 开始时先做Finish[i] := false; 当有足够资源分配给进程时， 再令Finish[i] := true。(2) 从进程集合中找到一个能满足下述条件的进程： ① Finish[i] = false; ② Need[i,j] ≤ Work[j]； 若找到， 执行步骤(3)， 否则，执行步骤(4)。(3) 当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：Work[j] := Work[i] + Allocation[i,j];Finish[i] := true;go to step 2;(4) 如果所有进程的Finish[i] = true都满足， 则表示系统处于安全状态；否则，系统处于不安全状态。 注意：Request检查成功。之后已经假设借出去了，修改了need和available、allocattion,在此基础上进行安全检查 假如现在有 P0 ~ P4 共五个进程，ABC 三类资源，个数为（10,5,7）。在某一时刻，资源剩余量为（3,3,2），各个进程的最大需求量、已分配量和需求量如下图所示：如何检测当前是否处于安全状态呢？尝试寻找安全序列：当前剩余资源（3,3,2），无法满足 P0 需要的（7,4,3），所以不能首先分配给 P0；但是可以满足 P1 需要的（1,2,2），P3 需要的（0,1,1），所以可以分配给 P1 和 P3，P1 和 P3 进入安全序列。P1 和 P3 执行完之后，归还资源，剩余资源（3,3,2）+（2,0,0）+（2,1,1）=（7,4,3），可以满足 P0 需要的（7,4,3），P2 需要的（6,0,0），P4 需要的（4,3,1），所以 P0、P2、P4 依次进入安全序列所以存在安全序列 P1-&gt;P3-&gt;P0-&gt;P2-&gt;P4 ，使得按照这个顺序分配资源后，每个进程都能拿到需要的资源并顺利完成，所以该状态是安全状态。看另一种情况。假如现在有 P0 ~ P4 共五个进程，ABC 三类资源，个数为（10,5,7）。在某一时刻，资源剩余量为（3,3,2），各个进程的最大需求量、已分配量和需求量如下图所示：当尝试寻找安全序列的时候，容易发现 P1 P3 可以满足，所以 P1 P3 进入安全序列，此后剩余资源为（7,4,3）。又由于 P0 P2 P4 都是无法满足的，所以实际上并不存在一个安全序列使得所有进程都能被分配资源。因此状态是不安全状态，可能发生死锁，取消资源分配。6、检测和解除死锁由于死锁发生的频率并不太高，所以商业操作系统的设计者认为死锁不是什么大问题，所以不用去管它！防止死锁的代价很高，比重启机器100次代价还高，因此不如直接重启。允许死锁发生，操作系统不断监视系统进展情况，判断死锁是否发生一旦死锁发生则采取专门的措施，解除死锁并以最小的代价恢复操作系统运行(1)资源分配图(Resource Allocation Graph)检测资源类:用方框表示（资源的不同类型）资源实例:用方框中的圆点表示（存在于每个资源中）进程 :用圆圈中加进程名表示分配边：资源实例——&gt;进程的一条有向边申请边：进程——&gt;资源类的一条有向边如果资源分配图中没有环路，则系统中没有死锁，如果图中存在环路则系统中==可能==存在死锁。==如果每个资源类中只包含一个资源实例，则环路是死锁存在的充分必要条件。==资源分配图化简首先找出非阻塞非孤立的进程点。P1 P2 都不是孤立的，所谓非阻塞指的是进程请求的资源数量足够，比如说 P2 请求 R1，由于 R1 已经有两个被 P1 占有，一个被 P2 占有，无多余资源，所以 P2 请求的资源数量不够，P2 是阻塞的；而 P1 请求 R2，因为 R2 只有一个被 P2 占有，所以有多于资源，P1 请求的资源数量足够，P1 是非阻塞的。这样就找到了符合条件的进程点 P1去除这样的点的所有边。那么就会去除 P1 的所有边，归还所有资源。P1 成为孤立点。重复第一步和第二步。此时，因为这次 P2 请求的 R2 资源是足够的（被 P1 释放了），所以 P2 是非阻塞非孤立的点，把他的全部边去除由于图中所有的边都能被消除，所以称该图可以被简化，因此它不存在死锁（如果不可简化，则存在死锁）==在进行一系列化简后若能消去图中所有的边，使所有进程结点成为孤立结点，则称该图是可完全简化的；否则是不可完全简化的====已经证明：所有的化简顺序都得到相同的不可简化图====同样可以证明，S为死锁的充分条件是：当且仅当S状态的资源分配图是不可完全简化的。该充分条件称为死锁定理==当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，重要的是以最小的代价恢复系统的运行。方法如下：重新启动最简单，最常用的方法就是进行系统的重新启动，不过这种方法代价很大，它意味着在这之前所有的进程已经完成的计算工作都将付之东流，包括参与死锁的那些进程，以及未参与死锁的进程。撤消进程剥夺资源进程回退进程回退策略，即让参与死锁的进程回退到没有发生死锁前某一点处，并由此点处继续执行，以求再次执行时不再发生死锁。虽然这是个较理想的办法，但是操作起来系统开销极大，要有堆栈这样的机构记录进程的每一步变化，以便今后的回退，有时这是无法做到的。7、总结]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统【五】]]></title>
    <url>%2Fposts%2F1f714689%2F</url>
    <content type="text"><![CDATA[三、处理机调度操作系统学习笔记-9：调度WHAT：按什么原则分配CPU—进程调度算法WHEN：何时分配CPU —进程调度的时机HOW：如何分配CPU —CPU调度过程（进程的上下文切换）1、处理机调度的层次和调度算法的目标进程调度是控制、协调进程对CPU的竞争,即按一定的调度算法从就绪队列中选中一个进程，把CPU的使用权交给被选中的进程一个作业，从进入系统并驻留在外存的后备队列上开始，直至作业运行完毕，可能要经历下面三级调度高级调度(High Scheduling，作业调度)作业调度也即高级调度，这个阶段可以看作是准备阶段。主要任务是按照一定的规则从外存上处于后备队列的作业中挑选一个或多个作业，为其分配内存，建立 PCB（进程） 等，使它们具备竞争处理机的能力。这个阶段进程的状态变化是：无 –&gt; 创建态 –&gt; 就绪态中级调度(Intermediate-Level Scheduling，提高内存使用率)内存调度也即中级调度，这个阶段可以看作是优化阶段。主要任务是将暂时不能运行的进程对换到外存中，使它们挂起；而当挂起的进程具备运行条件时，它们会被重新对换回内存，得到激活。这个阶段的主要目的是提高内存利用率和系统吞吐量。这个阶段进程的状态变化是： 静止就绪态 –&gt; 活动就绪态，静止阻塞态 –&gt; 活动阻塞态低级调度(Low Level Scheduling，进程调度)进程调度即低级调度，这个阶段让进程真正运行起来。主要任务是按照某种算法，从就绪队列中选取一个进程，分配处理机给它。进程调度是最基本、次数最频繁的阶段。这个阶段进程的状态变化是： 就绪态 –&gt; 活动态2、作业与作业调度作业 是一个比程序更加广泛的概念，它不仅包含了通常的程序和数据，而且还应配有一份作业说明书，系统根据该说明书来对程序的运行进行控制。在批处理系统中，是以作业为基本单位从外存调入内存的。作业步：在作业运行期间每个作业都必须经过若干个相对独立又相互关联的的顺序加工步骤才能得到结果，我们把其中每一个加工步骤称为一个作业步。例如程序作业分为编译、链接、运行作业步。(1)几个概念周转时间——指作业提交给系统开始，到作业完成为止的这段时间间隔周转时间通常作为评价批处理系统性能、选择作业调度方式与算法的准则。多道程序度：即允许多少个作业同时在内存中运行。允许多少个作业同时在内存中运行，取决于多道程序度。作业太多 服务质量下降 作业太少 资源利用率低。需要适当的折衷吞吐量：是指在单位时间内系统所完成的作业数(或工作量）。(2)进程调度方式非抢占式：“非抢占”即“不能抢占”。一旦把处理机分配给某个进程后，除非该进程终止或者主动要求进入阻塞态，否则会一直运行下去，不允许其它进程抢占自己占有的处理机。抢占式：把处理机分配给某个进程 A 后，如果有一个更重要、更紧急的进程 B 需要用到处理机，那么进程 A 会立即暂停，把处理机交给进程 B。3、调度算法CPU 利用率：忙碌的时间 / 总时间系统吞吐量：完成作业量 / 总时间周转时间：作业完成时间 - 作业提交时间 = 作业实际运行的时间 + 等待时间平均周转时间： 各作业周转时间之和 / 作业数带权周转时间：周转时间 / 作业实际运行的时间平均带权周转时间：各作业带权周转时间之和 / 作业数等待时间：进程或者作业处于等待处理机状态的时间之和，即 周转时间 - 作业实际运行的时间对于进程来说，等待时间指的是进程建立后等待被服务的时间之和（由于等待 I/O 完成的期间也属于被服务时间，所以这个时间不计入等待时间）对于作业来说，除了进程建立后的等待时间，还包括作业在外存后备队列中等待的时间平均等待时间：各作业等待时间之和 / 作业数响应时间：从用户提交请求到首次产生响应所用的时间(1) FCFS 算法FCFS 算法即“先来先服务”算法，类似于我们生活中的排队，谁先来，谁就先享受服务。对于作业调度，它指的是谁先到达后备队列，谁就先出队，进而先被执行；对于进程调度，它指的是谁先到达就绪队列，谁就先出队，进而先被执行。FCFS 算法是非抢占式的算法，不存在某个进程在执行的时候被其它进程抢占处理机的情况。它的优点是公平、算法实现简单，并且不会导致饥饿（不管等多久，所有进程最后都会运行，不存在某个进程永远得不到处理机的情况）缺点是对长作业有利、对短作业不利 —— 对于长作业，如果它先到，那么它自然无需做过多的等待，而即使是后到，它等待短作业的时间也是不足挂齿的，所以长作业怎么都不亏；对于短作业，如果它先到，自然也无需做过多等待，但是如果它后到，那么它不得不花很长的时间去等待长作业完成，然而它自己运行所需的时间却是很短的，所以说这个算法对短作业不利。在这种情况下，短作业的带权周转时间会很大，也即周转时间远远大于实际运行时间，表示有大量时间用于等待。有时候也说 FCFS 算法对 CPU 繁忙型作业有利，对 I/O 繁忙型作业不利。这是因为 CPU 繁忙型作业的特点是需要大量的 CPU 时间进行计算，而很少请求 I/O 操作，通常视作长作业。适用于批处理系统，不适于分时系统(2)短作业(进程)优先调度算法SJ(P)F短作业(进程)优先调度算法SJ(P)F，以要求运行时间长短进行调度，即启动要求运行时间最短的作业。==每次调度时选择当前已到达且运行时间最短的作业/进程.==可以分别用于作业调度和进程调度短作业优先(SJF)的调度算法，是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行；短进程优先(SPF)调度算法，则是从就绪队列中选出一估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时，再重新调度。 SJF平均周转时间和平均带权周转时间明显改善SJF 算法的优点在于，它拥有“最短的”平均等待时间和平均周转时间缺点在于，虽然这次顾及了短作业，但是没有顾及长作业，对长作业是不利的。因为一旦短作业源源不断进入，那么它们就会不断跑在长作业前面，导致长作业永远无法运行，产生“饥饿”甚至“饿死”现象。另外一个缺点是，在实际实现中，要做到真正意义上的短作业优先，具有一定难度.由于作业(进程)的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。(3)高优先权优先（HPF，Highest Priority First）调度算法非抢占式优先权调度算法系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成，或因发生某事件使该进程放弃处理机时，系统才将处理机重新分配给另一优先权最高的进程主要用于批处理系统中，也可用于某些对实时性要求不严的实时系统中抢占式优先权调度算法把处理机分配给优先权最高的进程，但在执行期间，只要出现另一个优先权更高的进程，则进程调度程序就立即停止当前进程的执行，并将处理机分配给新到的优先权最高的进程注意：只要系统中出现一个新的就绪进程，就进行优先权比较优先权的类型静态优先权静态优先权在创建进程时确定，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，例如，0-7或0-255，又把该整数称为优先数确定进程优先权的依据有如下三个方面：(1) 进程类型。 系统进程的优先权高于一般用户进程。(2) 进程对资源的需求。 如进程的估计执行时间及内存需要量少的进程，应赋予较高的优先权(3) 用户要求。 由用户进程的紧迫程度和用户所付费用的多少来确定优先权。系统开销小、不够精确、一般用在要求不高的系统中问题：用户将优先权设的较高，对其他进程不利！！短进程优先对长进程不利！！动态优先权随进程的推进或随其等待时间的增加而改变，以获得更好的调度性能可规定，在就绪队列中的进程，随其等待时间的增长，其优先权以速率a提高具有相同优先权初值的进程，则最先进入就绪队列，其将因其动态优先权变得最高而优先获得处理机，此即FCFS算法具有各不相同的优先权初值的就绪进程，则优先权初值低的进程，在等待了足够的时间后，其优先权便可能升为最高，从而可以获得处理机当采用抢占式优先权调度算法时，如果再规定当前进程的优先权以速率b下降，则可防止一个长作业长期地垄断处理机(4)高响应比优先调度算法（HRF）是FCFS和SJF的结合，克服了两种算法的缺点调度策略：响应比最高的作业优先启动==响应比（优先权） = （ 等待时间+实际服务时间 ）/ 实际服务时间 =响应时间/实际服务时间= 等待时间 / 实际服务时间 + 1====注意这里“要求服务的时间”就是实际需要运行的时间，等待时间则是从进程到达就绪队列的那一刻起，到发生进程调度这一段所花费的时间。==可以说它同时综合了 FCFS 算法和 SJF 算法的优点。为什么优先调度响应比高的进程？因为当两个进程的等待时间一样时，响应比越高的进程，它的实际运行时间越短，这一点类似于 SJF 算法，优先顾及运行时间短的进程；而当两个进程的实际运行时间一样时，响应比越高的进程，它的等待时间越长，等待时间越长说明该进程越先到达，这一点类似于 FCFS 算法，优先顾及先到达的进程。等待时间相同的作业，则要求服务的时间愈短，其优先权愈高，——对短作业有利要求服务的时间相同的作业，则等待时间愈长，其优先权愈高， ——是先来先服务长作业，优先权随等待时间的增加而提高，其等待时间足够长时，其优先权便可升到很高， 从而也可获得处理机,——对长作业有利是一种折衷，既照顾了短作业，又考虑了作业到达的先后次序，又不会使长作业长期得不到服务。(5)简单的时间片轮转法(RR—Round Robin)系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便停止该进程的执行，并将其放就绪队列尾；然后，再把处理机分配给就绪队列中新的队首。时间片的大小从几ms到几百ms优点：公平。保证就绪队列中所有进程在一给定的时间内，均能获得一时间片的处理机执行时间缺点：紧迫任务响应慢。UNIX中采用：时间片+优先权==注意：先入新到的进程，在放入时间片完的进程== (6)多级反馈队列调度算法设置多个就绪队列，并为各个队列赋予不同的优先级第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低该算法赋予各个队列中进程执行时间片的大小也各不相同在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍有多个级别的就绪队列，各级队列优先级从高到低，时间片从小到大每次有新进程到达，都会首先进入第一级队列，并按 FCFS 算法被分配时间片。如果时间片用完了而进程还没执行完，那么该进程将被送到下一级队列队尾。如果当前已经是最后一级，则重新放回当前队列队尾仅当第1~(i-1) 队列均空时，才会调度第i队列中的进程运行第i队列中某进程正在运行时，该进程因等待事件发生而进入阻塞队列，等待事件发生后，调度程序把进程放回到第i队列的末尾第i队列中某进程正在运行时，又有新进程进入优先权较高的队列(第1~(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，调度程序把正在运行的进程放回到第i队列的末尾多级反馈队列调度算法具有较好的性能，能较好的满足各种类型用户的需要。终端型作业用户。大多属于较小的交互性作业，只要能使作业在第一队列的时间片内完成，便可令用户满意。短批处理作业用户。周转时间仍然较短，至多在第二到三队列即可完成。长批处理作业用户。将依次在1~n级队列中轮转执行，不必担心作业长期得不到处理。习题调度算法关于多道程序调度。 关于如何画表，确实没找到太好的方法。思路1：按照每一段小阶段进行思考划分原因：只有前一段配合成功且完毕了，后面才能顺序执行下去。且不会有矛盾。优点：画出来就结束，无需修改前面的部分。缺点：小阶段的时间段不一致，需要考虑空闲时间是否会发生占领CPU。这样就需要往下考虑一个阶段。破坏了按照每个阶段思考划分的规矩。方法1：按照每个小阶段的最大时间段划分，将不足的进程小阶段后面的时间段切割为两部分拨给前面一部分的作为补充。缺点：数量多了容易造成切割多份，增加数量麻烦度。而且造成大量挪移问题。不推荐。思路2：按照优先级从高到底划分思考，原因：优先级高的CPU不会被抢占，只会抢占别人CPU，所以先画优先级高的避免CPU线上的的修改。优点：这样做CPU不需要每次修改了，若低优先级CPU发现使用段中有高优先级CPU，只需要将低优先级分割开，将剩下的部分画到高优先级运行后的空闲段即可。缺点：若低优先级IO段出现在了高优先级某个IO段开始的前面，需要将高优先级IO段以及后面的小阶段后推。因为IO无法抢占，低优先级的IO先到就使用IO。思路3：结合使用。将各个小阶段划分为组，每组优先级从高到低，将每组画完。优点：使得思路2中若有IO出现在前面使得相应进程的之后所有阶段需要后挪的问题中，我们需要挪移的小阶段变少。同时兼顾无需修改CPU的优点。因为题目不会很复杂使你需要挪很多。所以做题常用思路2，若出现IO挪移问题则使用思路3。黑笔画表，铅笔涂改。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaEE程序设计【九】]]></title>
    <url>%2Fposts%2F98cf7651%2F</url>
    <content type="text"><![CDATA[6、MyBatis的核心对象(1)SqlSessionFactorySqlSessionFactory是MyBatis框架中十分重要的对象，它是单个数据库映射关系经过编译后的内存镜像，其主要作用是创建SqlSession。SqlSessionFactory对象的实例可以通过SqlSessionFactoryBuilder对象来构建，而SqlSessionFactoryBuilder则可以通过XML配置文件或一个预先定义好的Configuration实例构建出SqlSessionFactory的实例。构建SqlSessionFactory12InputStream inputStream = Resources.getResourceAsStream("配置文件位置");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);SqlSessionFactory对象是线程安全的，它一旦被创建，在整个应用执行期间都会存在。如果我们多次的创建同一个数据库的SqlSessionFactory，那么此数据库的资源将很容易被耗尽。为此，通常每一个数据库都会只对应一个SqlSessionFactory，所以在构建SqlSessionFactory实例时，==建议使用单例模式。==(2)SqlSessionSqlSession是MyBatis框架中另一个重要的对象，它是应用程序与持久层之间执行交互操作的一个单线程对象，其主要作用是执行持久化操作。每一个线程都应该有一个自己的SqlSession实例，并且该实例是不能被共享的。同时，==SqlSession实例是线程不安全的==，因此其使用范围最好在一次请求或一个方法中，绝不能将其放在一个类的静态字段、实例字段或任何类型的管理范围（如Servlet的HttpSession）中使用。获取SqlSession session = sqlSessionFactory.openSession();使用完SqlSession对象后要及时关闭，通常可以将其放在finally块中关闭。123456SqlSession sqlSession = sqlSessionFactory.openSession();try &#123;// 此处执行持久化操作&#125; finally &#123;sqlSession.close();&#125;SqlSession中的方法查询方法：1234567 &lt;T&gt; T selectOne(String statement); &lt;T&gt; T selectOne(String statement, Object parameter); &lt;E&gt; List&lt;E&gt; selectList(String statement); &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter); &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter,RowBounds rowBounds); void select(String statement, Object parameter, ResultHandler handler);插入、更新和删除方法：123456int insert(String statement);int insert(String statement, Object parameter);int update(String statement);int update(String statement, Object parameter);int delete(String statement);int delete(String statement, Object parameter);其他方法：12345void commit(); 提交事务的方法。void rollback(); 回滚事务的方法。void close(); 关闭SqlSession对象。&lt;T&gt; T getMapper(Class&lt;T&gt; type); 返回Mapper接口的代理对象。Connection getConnection(); 获取JDBC数据库连接对象的方法为了简化开发，通常在实际项目中都会使用工具类来创建SqlSession：123456789101112public class MybatisUtils &#123;private static SqlSessionFactory sqlSessionFactory = null;static &#123;try &#123;Reader reader = Resources.getResourceAsReader("mybatis-config.xml");sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);&#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;public static SqlSession getSession() &#123;return sqlSessionFactory.openSession();&#125;&#125;线程安全问题：例如：服务器中的一个公共计数变量，调用某个方法就加一次。多个用户同时访问，同时读取为5 +1后更新为6。造成错误数据。线程不安全。线程安全是通过线程同步控制来实现的，也就是synchronized关键字。==可以保证一个方法一段时间内只能被一个线程使用。==7、MyBatis GeneratorMyBatis Generator 超详细配置8、动态SQLMyBatis动态SQL（认真看看， 以后写SQL就爽多了）真正的Mybatis动态sql — MyBatis Dynamic SQLMyBatis 令人喜欢的一大特性就是动态 SQL。 在使用 JDBC 的过程中， 根据条件进行 SQL 的拼接是很麻烦且很容易出错的。 MyBatis 动态 SQL 的出现， 解决了这个麻烦。MyBatis通过 OGNL 来进行动态 SQL 的使用的。(1)if在MyBatis中，&lt;if&gt;元素是最常用的判断语句，它类似于Java中的if语句，主要用于实现某些简单的条件选择。例如：使用&lt;if&gt;元素对username和jobs进行非空判断，并动态组装SQL1234567 select * from customer where 1=1 &lt;if test="username !=null and username !=''"&gt;and username like concat('%',#&#123;username&#125;, '%') &lt;/if&gt; &lt;if test="jobs !=null and jobs !=''"&gt;and jobs= #&#123;jobs&#125; &lt;/if&gt;if判断中的username是传入的参数。(2)choose、when、otherwise123456789101112select * from customer where 1=1&lt;choose&gt; &lt;when test="username !=null and username !=''"&gt; and username like concat('%',#&#123;username&#125;, '%') &lt;/when&gt; &lt;when test="jobs !=null and jobs !=''"&gt; and jobs= #&#123;jobs&#125; &lt;/when&gt; &lt;otherwise&gt; and phone is not null &lt;/otherwise&gt;&lt;/choose&gt;使用&lt;choose&gt;及其子元素依次对条件进行非空判断，并动态组装SQL。相当于 switch case default。和if 的区别在于其找到一个就停止判断之后的选项了。(3)where、trim在前两个小节的案例中，映射文件中编写的SQL后面都加入了“where 1=1”的条件，那么到底为什么要这么写呢？如果将where后“1=1”的条件去掉，那么MyBatis所拼接出来的SQL将会如下所示：select * from customer where and username like concat(&#39;%&#39;,?, &#39;%&#39;)可以看出上面SQL语句明显存在SQL语法错误，而加入了条件“1=1”后，既保证了where后面的条件成立，又避免了where后面第一个词是and或者or之类的关键词。不过“where 1=1”这种写法对于初学者来将不容易理解，并且也不够雅观。针对上述情况中“where 1=1”，在MyBatis的SQL中就可以使用&lt;where&gt;或&lt;trim&gt;元素进行动态处理。where处理123456789select * from customer&lt;where&gt; &lt;if test="username !=null and username !=''"&gt; and username like concat('%',#&#123;username&#125;, '%') &lt;/if&gt; &lt;if test="jobs !=null and jobs !=''"&gt; and jobs= #&#123;jobs&#125; &lt;/if&gt;&lt;/where&gt;trim处理123456789select * from customer&lt;trim prefix="where" prefixOverrides="and"&gt; &lt;if test="username !=null and username !=''"&gt; and username like concat('%',#&#123;username&#125;, '%') &lt;/if&gt; &lt;if test="jobs !=null and jobs !=''"&gt; and jobs= #&#123;jobs&#125; &lt;/if&gt;&lt;/trim&gt;prefix: 当 trim 元素包含有内容时， 增加 prefix 所指定的前缀prefixOverrides: 当 trim 元素包含有内容时， 去除 prefixOverrides 指定的 前缀suffix: 当 trim 元素包含有内容时， 增加 suffix 所指定的后缀suffixOverrides： 当 trim 元素包含有内容时， 去除 suffixOverrides 指定的后缀(5)set在Hibernate框架更新：发送所有的字段给持久化对象，运行效率差。在MyBatis中可以使用动态SQL中的&lt;set&gt;元素进行处理例如：使用&lt;set&gt;和&lt;if&gt;元素对username和jobs进行更新判断，并动态组装SQL。这样就只需要传入想要更新的字段即可。123456789101112&lt;update id="updateCustomer" parameterType="cn.edu.c.po.Customer"&gt; update customer &lt;set&gt; &lt;if test="username !=null and username !=''"&gt; username=#&#123;username&#125;, &lt;/if&gt; &lt;if test="jobs !=null and jobs !=''"&gt; jobs=#&#123;jobs&#125;, &lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt;(6)foreach假设在一个客户表中有1000条数据，现在需要将特定id值的客户信息全部查询出来，这要怎么做呢？一条一条的查询那如果要查询1000条数据呢,岂不是很累?在Java中用for循环查询考虑过N条查询语句时的查询效率了吗？针对上述需求，理想的解决方法就是使用MyBatis中动态SQL的&lt;foreach&gt;元素进行处理。其基本使用示例如下所示：123456789&lt;select id="selectByStudentIdList" resultMap="BaseResultMap"&gt; select &lt;include refid="Base_Column_List" /&gt; from student where student_id in &lt;foreach collection="list" item="id" open="(" close=")" separator="," index="i"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/select&gt;123456789101112131415161718@Test public void selectByStudentIdList() &#123; SqlSession sqlSession = null; sqlSession = sqlSessionFactory.openSession(); StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); List&lt;Integer&gt; ids = new LinkedList&lt;&gt;(); ids.add(1); ids.add(3); List&lt;Student&gt; students = studentMapper.selectByStudentIdList(ids); for (int i = 0; i &lt; students.size(); i++) &#123; System.out.println(ToStringBuilder.reflectionToString(students.get(i), ToStringStyle.MULTI_LINE_STYLE)); &#125; sqlSession.commit(); sqlSession.close(); &#125;生成的sql和运行结果如下：item：变量名。 即从迭代的对象中取出的每一个值.配置的是循环中当前的元素。变量名。 即从迭代的对象中取出的每一个值index：配置的是当前元素在集合的位置下标。索引的属性名。 当迭代的对象为 Map 时， 该值为 Map 中的 Key.collection： 必填， 集合/数组/Map的名称.配置的list是传递过来的参数类型（首字母小写），它可以是一个array、list（或collection）、Map集合的键、POJO包装类中数组或集合类型的属性名等。collection属性，该属性是必须指定的，而且在不同情况下，该属性的值是不一样的。主要有以下3种情况如果传入的是单参数且参数类型是一个数组或者List的时候，collection属性值分别为array和list（或collection）。推荐： 使用 @Param 来指定参数的名称， 如我们在参数前@Param(“ids”)， 则就填写 collection=ids如果传入的参数是多个的时候，就需要把它们封装成一个Map了，当然单参数也可以封装成Map集合，这时候collection属性值就为Map的键。多参数请使用 @Param 来指定， 否则SQL中会很不方便如果传入的参数是POJO包装类的时候，collection属性值就为该包装类中需要进行遍历的数组或集合的属性名。open和close：配置的是以什么符号将这些集合元素包装起来。循环开头的字符串和循环结束的字符串separator：配置的是各个元素的间隔符。(7)bindselect * from customer where username like &#39;%${value}%&#39;上述SQL语句有什么不妥？如果使用“${}”进行字符串拼接，则无法防止SQL注入问题；如果改用concat函数进行拼接，则只针对MySQL数据库有效；如果改用“||”进行字符串拼接，则只针对Oracle数据库有效。这样，映射文件中的SQL就要根据不同的情况提供不同形式的实现，这显然是比较麻烦的，且不利于项目的移植。为了减少这种麻烦，就可以使用MyBatis的&lt;bind&gt;元素来解决这一问题。MyBatis的&lt;bind&gt;元素可以通过OGNL表达式来创建一个上下文变量，其使用方式如下：1234567&lt;select id="findCustomerByName" parameterType="Integer" resultMap="BaseResultMap"&gt; &lt;bind name="pattern_username" value="'%'+_parameter.getUsername()+'%'" /&gt; select * from customer where username like #&#123;pattern_username&#125;&lt;/select&gt;_parameter.getUsername()表示传递进来的参数（也可以直接写成对应的参数变量名，如username）]]></content>
      <categories>
        <category>JavaEE程序设计</category>
      </categories>
      <tags>
        <tag>JavaEE程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaEE程序设计【八】]]></title>
    <url>%2Fposts%2Fe202570e%2F</url>
    <content type="text"><![CDATA[==POJO：====一个简单的Java类，这个类没有实现/继承任何特殊的java接口或者类，不遵循任何主要java模型，约定或者框架的java对象。在理想情况下，POJO不应该有注解。====JavaBean：====JavaBean是可序列化的，实现了serializable接口====具有一个无参构造器====有按照命名规范的set和gett，is（可以用于访问布尔类型的属性）方法==一、MyBatis基础中文文档1、什么是MyBatisMyBatis框架：ORM(Object/Relation Mapping)框架可以把数据库表中的一行数据映射为一个java对象。一行数据可以看做是一个java对象.操作这个对象,就相当于操作表中的数据。(由框架自动帮我们整合更新数据库)功能1.提供了创建 Connection, statement, Resultset的能力,不用开发人员创建这些对象了2.提供了执行sq1语句的能力,不用你执行sql.3.提供了循环sql,把sql的结果转为java对象,list集合的能力。4.提供了关闭资源的能力,不用你关闭 Conneetion, statement, Resultset开发人员只需要关注提供SQL语句。2、添加MyBatis使用Maven添加12345&lt;dependency&gt;&lt;groupId&gt;org.mybatis&lt;/groupId&gt;&lt;artifactId&gt;mybatis&lt;/artifactId&gt;&lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt;或者从github下载压缩包导入。如果底层采用的是MySQL数据库，还需要将MySQL数据库的驱动JAR包添加到应用程序的类路径3、工作原理mybatis使用的配置文件叫做sql映射文件:写sql语句的.一般一个表一个sql映射文件.mybatis的主配置文件个项目就一个主配置文件主配置文件。它提供了数据库的连接信息和sql映射文件的位置信息4、主配置文件配置文件的名字可自己命名1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="org/mybatis/example/BlogMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt;在MyBatis框架的核心配置文件中，&lt;configuration&gt;元素是配置文件的根元素，其他元素都要在&lt;configuration&gt;元素内配置。==常用：properties、environments、mappers==&lt;properties&gt;一个配置属性的元素，该元素通常用来将内部的配置外在化，即通过外部的配置来动态的替换内部定义的属性。例如，数据库的连接等属性，就可以通过典型的Java属性文件中的配置来替换，具体方式如下：1.编写db.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatisjdbc.username=rootjdbc.password=root2.配置&lt;properties… /&gt;属性&lt;properties resource=&quot;db.properties&quot; /&gt;3.修改配置文件中数据库连接的信息12345678910&lt;dataSource type="POOLED"&gt;&lt;!-- 数据库驱动 --&gt;&lt;property name="driver" value="$&#123;jdbc.driver&#125;" /&gt;&lt;!-- 连接数据库的url --&gt;&lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt;&lt;!-- 连接数据库的用户名 --&gt;&lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt;&lt;!-- 连接数据库的密码 --&gt;&lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt;&lt;/dataSource&gt;&lt;settings&gt;主要用于改变MyBatis运行时的行为，例如开启二级缓存、开启延迟加载等。通常不需要开发人员去配置 ，读者作为了解即可。&lt;settings&gt;元素中的常见配置的使用方式如下123456789&lt;settings&gt;&lt;setting name="cacheEnabled" value="true" /&gt;&lt;setting name="lazyLoadingEnabled" value="true" /&gt;&lt;setting name="multipleResultSetsEnabled" value="true" /&gt;&lt;setting name="useColumnLabel" value="true" /&gt;&lt;setting name="useGeneratedKeys" value="false" /&gt;&lt;setting name="autoMappingBehavior" value="PARTIAL" /&gt;...&lt;/settings&gt;&lt;typeAliases&gt;用于为配置文件中的Java类型设置一个简短的名字，即设置别名。别名的设置与XML配置相关，其使用的意义在于减少全限定类名的冗余。方法1.使用&lt;typeAliases&gt;元素配置别名的方法如下使用后直接写包名即可123&lt;typeAliases&gt;&lt;typeAlias alias="user" type="cn.edu.ccc.ch7.po.User"/&gt;&lt;/typeAliases&gt;方法2.通过自动扫描包的形式自定义别名，具体如下：使用后直接写包名即可123&lt;typeAliases&gt;&lt;package name=" cn.edu.ccc.ch7.po"/&gt;&lt;/typeAliases&gt;注意：如果在程序中使用了注解，则别名为其注解的值 。MyBatis框架默认为许多常见的Java类型提供了相应的类型别名，如下表所示&lt;typeHandler&gt;typeHandler：将预处理语句中传入的参数从javaType（Java类型）转换为jdbcType(JDBC类型)，或者从数据库取出结果时将jdbcType转换为javaType。在配置文件中注册自定义的类型处理器，它的使用方式有两种。1.注册一个类的类型处理器123&lt;typeHandlers&gt;&lt;typeHandler handler="cn.edu.ccc.ch7.type.CustomtypeHandler" /&gt;&lt;/typeHandlers&gt;2.注册一个包中所有的类型处理器123&lt;typeHandlers&gt;&lt;package name="cn.edu.ccc.ch7.type" /&gt;&lt;/typeHandlers&gt;ObjectFactoryMyBatis中默认的ObjectFactory的作用是实例化目标类，它既可以通过默认构造方法实例化，也可以在参数映射存在的时候通过参数构造方法来实例化。由于自定义ObjectFactory在实际开发时不经常使用，这里只需要了解即可 。通常使用默认的ObjectFactory。自定义ObjectFactory，具体如下：1.自定义一个对象工厂1234567891011121314public class MyObjectFactory extends DefaultObjectFactory &#123;private static final long serialVersionUID = -4114845625429965832L;public &lt;T&gt; T create(Class&lt;T&gt; type) &#123;return super.create(type);&#125;public &lt;T&gt; T create(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes,List&lt;Object&gt; constructorArgs) &#123;return super.create(type, constructorArgTypes, constructorArgs);&#125;public void setProperties(Properties properties) &#123;super.setProperties(properties);&#125;…….&#125;2.在配置文件中使用&lt;objectFactory&gt;元素配置自定义的ObjectFactory123&lt;objectFactory type="cn.edu.ccc.ch7.factory.MyObjectFactory"&gt;&lt;property name="name" value="MyObjectFactory"/&gt;&lt;/objectFactory&gt;&lt;plugins&gt;MyBatis允许在已映射语句执行过程中的某一点进行拦截调用，这种拦截调用是通过插件来实现的。&lt;plugins&gt;元素的作用就是配置用户所开发的插件。如果想要进行插件开发，必须要先了解其内部运行原理，因为在试图修改或重写已有方法的行为时，很可能会破坏MyBatis原有的核心模块。关于插件的使用，不做详细讲解，只需了解&lt;plugins&gt;元素的作用即可，有兴趣可以查找官方文档等资料自行学习。&lt;environments&gt;MyBatis的环境配置实际上就是数据源的配置，可以通过&lt;environments&gt;元素配置多种数据源，即配置多种数据库。使用&lt;environments&gt;元素进行环境配置的示例如下：123456789101112&lt;environments default="development"&gt;&lt;environment id="development"&gt;&lt;transactionManager type="JDBC" /&gt;&lt;dataSource type="POOLED"&gt;&lt;property name="driver" value="$&#123;jdbc.driver&#125;" /&gt;&lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt;&lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt;&lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt;&lt;/dataSource&gt;&lt;/environment&gt;...&lt;/environments&gt;1.UNPOOLED：不使用连接池，配置此数据源类型后，在每次被请求时会打开和关闭连接。它对没有性能要求的简单应用程序是一个很好的选择。在使用时，需要配置5种属性。2.POOLED：此数据源利用“池”的概念将JDBC连接对象组织起来，这种方式使得并发Web应用可以快速的响应请求，是当前流行的处理方式。在使用时，可以配置更多的属性。 (只要池子中有连接就能拿来用)3.JNDI：可以在EJB或应用服务器等容器中使用。容器可以集中或在外部配置数据源，然后放置一个JNDI上下文的引用。在使用时，需要配置2个属性。在MyBatis中，可以配置两种类型的事务管理器，分别是JDBC和MANAGED。关于这两个事务管理器的描述如下：JDBC：此配置直接使用了JDBC的提交和回滚设置，它依赖于从数据源得到的连接来管理事务的作用域。MANAGED：此配置从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期。默认情况下，它会关闭连接，但一些容器并不希望这样，为此可以将closeConnection属性设置为false来阻止它默认的关闭行为。注意：如果项目中使用的是Spring+ MyBatis，则没有必要在MyBatis中配置事务管理器，因为实际开发中，会使用Spring自带的管理器来实现事务管理 。&lt;mappers&gt;用于指定MyBatis映射文件的位置，一般可以使用以下4种方法引入映射器文件（文件方式不常用，因为开发环境和使用环境不一定相同），具体如下。1.使用类路径引入(最常用)123&lt;mappers&gt;&lt;mapper resource="cn/edu/ch7/mapper/UserMapper.xml"/&gt;&lt;/mappers&gt;2.使用本地文件路径引入123&lt;mappers&gt;&lt;mapper url="file:///D:/cn/edu/mapper/UserMapper.xml"/&gt;&lt;/mappers&gt;3.使用接口类引入123&lt;mappers&gt;&lt;mapper class="cn.edu.ch7.mapper.UserMapper"/&gt;&lt;/mappers&gt;4.使用包名引入123&lt;mappers&gt;&lt;package name="cn.edu.ch7.mapper"/&gt;&lt;/mappers&gt;&lt;databaseIdProvider&gt;用来支持多厂商数据库在主配置文件中配置：1234&lt;databaseIdProvider type="DB_VENDOR"&gt;&lt;property name="MySQL" value="mysql"/&gt;&lt;property name="Oracle" value="oracle" /&gt;&lt;/databaseIdProvider&gt;在映射文件中配置123456&lt;select id="SelectTime" resultType="String" databaseId="mysql"&gt;SELECT NOW() FROM dual&lt;/select&gt;&lt;select id="SelectTime" resultType="String" databaseId="oracle"&gt;SELECT 'oralce'||to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') FROM dual&lt;/select&gt;5、映射配置文件从文档中摘录：123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="org.mybatis.example.BlogMapper"&gt; &lt;select id="selectBlog" resultType="Blog"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;1234&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;这句话指定限制文件。mybatis-3- mapper.dtd是约束文件的名称,扩展名是dtd的.用来限制,检查在当前文件中出现的标签,属性必须符合 mybatis的要求.12345&lt;mapper namespace="org.mybatis.example.BlogMapper"&gt; &lt;select id="selectBlog" resultType="Blog"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;mapper是当前文件的根标签,必须的.namespace:叫做命名空间,唯一值的,可以是自定义的字符串.但是我们开发要求使用dao接口的全限定名称.在当前文件中,可以使用特定的标签,表示数据库的特定操作.&lt; select&gt;:表示执行查询, select语句&lt; update&gt;:表示更新数据库的操作,就是在&lt; update&gt;标签中写的是 update sql语句&lt; insert&gt;:表示插入,放的是 insert语句&lt; delete&gt;:表示删除,执行的 delete语句id:你要执行的sql语法的唯一标识, mybatis会使用这个id的值来找到要执行的sql语句。可以自定义,但是要求你使用接口中的方法名称.resultType：表示结果类型的,是sql语句执行后得到 Resultset,遍历这个 Resultset得到java对象的类型常用属性&lt;insert&gt;元素的特有属性执行插入操作后，很多时候需要返回插入成功的数据生成的主键值，此时就可以通过上面讲解的3个属性来实现。1.对于支持主键自助增长的数据库（如MySQL），可以通过如下配置实现：12345&lt;insert id="addCustomer" parameterType="cn.edu.ch7.po.Customer"keyProperty="id" useGeneratedKeys="true" &gt;insert into t_customer(username,jobs,phone)values(#&#123;username&#125;,#&#123;jobs&#125;,#&#123;phone&#125;)&lt;/insert&gt;&lt;update&gt;和&lt;delete&gt;元素的使用比较简单，它们的属性配置也基本相同。1.&lt;update&gt;和&lt;delete&gt;元素的常用属性如下：123456789101112&lt;updateid="updateCustomer"parameterType="cn.edu.ccc.ch7.po.Customer"flushCache="true"statementType="PREPARED"timeout="20"&gt;&lt;deleteid="deleteCustomer"parameterType="cn.edu.ccc.ch7.po.Customer"flushCache="true"statementType="PREPARED"timeout="20"&gt;2.&lt;update&gt;和&lt;delete&gt;元素的使用示例如下：12345678&lt;update id="updateCustomer" parameterType="cn.edu.ccc.ch7.po.Customer"&gt;update t_customerset username=#&#123;username&#125;,jobs=#&#123;jobs&#125;,phone=#&#123;phone&#125;where id=#&#123;id&#125;&lt;/update&gt;&lt;delete id="deleteCustomer" parameterType="Integer"&gt;delete from t_customer where id=#&#123;id&#125;&lt;/delete&gt;&lt;SQL&gt;元素SQL复用：在一个映射文件中，通常需要定义多条SQL语句，这些SQL语句的组成可能有一部分是相同的（如多条select语句中都查询相同的id、username、jobs字段），如果每一个SQL语句都重写一遍相同的部分，势必会增加代码量，导致映射文件过于臃肿。将这些SQL语句中相同的组成部分抽取出来统一提供引用方式。12345678&lt;sql id="customerColumns"&gt; id,username,jobs,phone&lt;/sql&gt;&lt;select id="findCustomerById" parameterType="Integer"resultType="cn.edu.ccc.ch7.po.Customer"&gt;select &lt;include refid="customerColumns"/&gt;from t_customerwhere id = #&#123;id&#125;&lt;/select&gt;1234567891011121314151617181920212223!--定义表的前缀名 --&gt;&lt;sql id="tablename"&gt;$&#123;prefix&#125;customer&lt;/sql&gt;&lt;!--定义要查询的表 --&gt;&lt;sql id="someinclude"&gt;from&lt;include refid="$&#123;include_target&#125;" /&gt;&lt;/sql&gt;&lt;!--定义查询列 --&gt;&lt;sql id="customerColumns"&gt;id,username,jobs,phone&lt;/sql&gt;&lt;select id="findCustomerById" parameterType="Integer"resultType="cn.edu.ccc.ch7.po.Customer"&gt;select&lt;include refid="customerColumns"/&gt;&lt;include refid="someinclude"&gt;&lt;property name="prefix" value="t_" /&gt;&lt;property name="include_target" value="tablename" /&gt;&lt;/include&gt;where id = #&#123;id&#125;&lt;/select&gt;通过&lt;include&gt;元素的refid属性引用id为someinclude的代码片段，先加入from,再通过获取&lt;property&gt;元素的值来组成表名&lt;resultMap&gt;&lt;resultMap&gt;元素表示结果映射集，是MyBatis中最重要也是最强大的元素。它的主要作用是定义映射规则、级联的更新以及定义类型转化器等。12345678910111213&lt;resultMap type="" id=""&gt;&lt;constructor&gt; &lt;!-- 类在实例化时,用来注入结果到构造方法中--&gt;&lt;idArg/&gt; &lt;!-- ID参数;标记结果作为ID--&gt;&lt;arg/&gt; &lt;!-- 注入到构造方法的一个普通结果--&gt;&lt;/constructor&gt;&lt;id/&gt; &lt;!-- 用于表示哪个列是主键--&gt;&lt;result/&gt; &lt;!-- 注入到字段或JavaBean属性的普通结果--&gt;&lt;association property="" /&gt; &lt;!-- 用于一对一关联 --&gt;&lt;collection property="" /&gt; &lt;!-- 用于一对多关联 --&gt;&lt;discriminator javaType=""&gt; &lt;!-- 使用结果值来决定使用哪个结果映射--&gt;&lt;case value="" /&gt; &lt;!-- 基于某些值的结果映射 --&gt;&lt;/discriminator&gt;&lt;/resultMap&gt;123456&lt;resultMap id="BaseResultMap" type="cn.edu.ch6.dao.Customer"&gt; &lt;id column="id" jdbcType="INTEGER" property="id" /&gt; &lt;result column="username" jdbcType="VARCHAR" property="username" /&gt; &lt;result column="jobs" jdbcType="VARCHAR" property="jobs" /&gt; &lt;result column="phone" jdbcType="VARCHAR" property="phone" /&gt; &lt;/resultMap&gt;ResultMap详解==Mybatis中resultMap使用==属性描述property需要映射到JavaBean 的属性名称。column数据库中数据表的列名或者标签别名。javaType一个完整的类名，或者是一个类型别名。如果你匹配的是一个JavaBean，那MyBatis 通常会自行检测到。然后，如果你是要映射到一个HashMap，那你需要指定javaType 要达到的目的。jdbcType数据表支持的类型列表。这个属性只在insert,update 或delete 的时候针对允许空的列有用。JDBC 需要这项，但MyBatis 不需要。如果你是直接针对JDBC 编码，且有允许空的列，而你要指定这项。typeHandler使用这个属性可以覆写类型处理器。这项值可以是一个完整的类名，也可以是一个类型别名。resultType将查询到结果映射封装成pojo类型中，前提是该pojo类的属性名和查询到的数据库表的字段名一致。这种映射封装mybatis帮我们自动做好了，不需要我们自己考虑。所以看起来我们是我们查询一些数据，然后返回类型是pojo。实际上内部映射封装不需要我们实现。resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询。现在针对上面案例，使用resultMap实现数据库表不变，现在有一个类属性名和字段对应不上，那么如何实现这这个类和表一一对应呢？]]></content>
      <categories>
        <category>JavaEE程序设计</category>
      </categories>
      <tags>
        <tag>JavaEE程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统【四】]]></title>
    <url>%2Fposts%2F70ef83ce%2F</url>
    <content type="text"><![CDATA[PV操作解题思路1.同步和互斥的关系进程（线程）之间的两种关系：同步与互斥。所谓互斥，是指三部在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。所谓同步，是指散步在不同进程之间的若干程序片断，它们的运行必须严格按照规定的 某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。显然，同步是一种更为复杂的互斥，而互斥是一种特殊的同步。也就是说互斥是两个线程之间不可以同时运行，他们会相互排斥，必须等待一个线程运行完毕，另一个才能运行，而同步也是不能同时运行，但他是必须要安照某种次序来运行相应的线程（也是一种互斥）！总结：互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。个人理解：==互斥问题：多个线程对某资源的一定程度上的独占性，重点体现空间性==进程互斥中用于实现互斥的P操作和V操作必须成对地出现==同步问题：多个线程能够互相配合并发执行所需要的某种顺序上的限制条件，重点体现时间性==进程同步的P操作和V操作，同样需要成对地出现，但处于不同的程序中==应先执行对同步信号量的P操作，再执行对互斥信号量的P操作，否则可能引起进程死锁==因为：若先对空间独占，再进行时间上的资源请求，若资源请求不到，而另一个释放资源的进程也被阻挡在空间独占，就会死锁2.解题思路信号量机制​ P：申请资源 V：访问资源，产生资源 S：大于0时代表当前可用资源，小于0时代表因请求该资源而被阻塞的资源）​ 有i个生产者，j个消费者，信号量empty的初值为k，信号量full初值为0，信号量mutex为1，共用k个缓冲区。求各信号量的取值范围？​ 此题帮助很好的理解了p v s的含义解题思路拿到一个应用题,一般进行如下分析:1.有无互斥2.有无同步3.有无前驱关系（本质上就是复合同步）4.有无类似读读共享、读写互斥情况5.若有互斥,套用互斥模式;若有同步,套用同步模式;若有前驱关系,套用前驱模式;若有读读共享情况,套用读者-写者模式解题注意:1.定义信号量;赋初值;解释信号量含义（互斥信号量一般为1。同步信号量的初始值要看对应资源的初始值是多少）2.信号量除初始化外只能由wait()、 signal()改变其值.即除初始化外,在算法中不能直接对信号量进行任何操作3.用类C语言描述算法(4)管程机制【操作系统】 管程机制在信号量机制中，每个要访问临界资源的进程都必须自备同步的PV操作，大量分散的同步操作会给系统管理带来麻烦，且容易因为同步操作不当而导致系统死锁。于是便产生了一种新的进程同步工具——管程（Monitors）。管程（Monitors）：是一个资源管理模块，其中包含了共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程（方法）所组成的资源管理程序。管程中包含条件变量，用于管理进程的阻塞和唤醒。其形式为 condition x；对它的操作仅有wait和signal。x.wait：正在调用管程的进程因 x 条件需要被阻塞或挂起，则调用 x.wait 将自己插入到 x 条件的等待队列上，并释放管程，直到 x 条件变化。此时其它进程可以使用该管程。x.signal：正在调用管程的进程发现 x 条件发生了变化，则调用 x.signal，重新启动一个因 x 条件而阻塞或挂起的进程。（与信号量的signal不同，没有s:=s+1的操作）个人理解：管程相当于把对临界资源的操作封装了起来，当进程要对资源进行操作时，只要调用管程中的方法就可以了，而不用进程自己担心同步和互斥的问题，管程的内部有自己的一套机制进行同步与互斥。管程中每次只允许一个进程进入管程。当调用管程的进程因为某原因阻塞或者挂起时，把这个原因定义为一个条件变量x。x.wait操作就是把自己放到一个队列上，这个队列上的进程都是因为x原因而阻塞的。x.signal操作就是让在x阻塞队列上的一个进程重新启动。相对形象的比喻：假如一个管程叫ATM（取款机），其包含两个方法：存款和取款，不同的人代表不同的进程，但是ATM只允许一个人在一个时间段中进行操作，当一个人在使用时，其他的人只能wait。此外，一个人如果使用的时间太长也不行，所以需要一个条件变量来约束他。比如一个人在操作ATM时突然接电话了，没法继续操作，把这个原因记为x，执行x.wait，让他离开ATM机，去接电话的队列中等待。等到打完电话，即调用了x.signal后，他就可以继续操作ATM了（一般令正在操作ATM的人操作完后，他才能重新进去）。生产者-消费者问题建立producer-consumer管程，其中包括两个方法：1.put(x)：生产者利用该过程将自己生产的产品投放到缓冲池中，并用整型变量 count 来表示在缓冲池中已有的产品数目，当 count≥n 时，表示缓冲池已满，生产者须等待。2.get(x)：消费者利用该过程从缓冲池中取出一个产品，当 count≤0 时，表示缓冲池中已无可取用的产品，消费者应等待。两个条件变量：notfull和notempty，代表进程阻塞原因producer-consumer管程的描述：1234567891011121314151617181920212223type producer-consumer=monitor Var in,out,count: integer； buffer: array[0, …, n-1] of item； notfull，notempty:condition； //条件变量 procedure entry put(item) begin if count&gt;=n then notfull.wait； //缓冲池已经满了，生产者需要等待（我觉得命名为full可能更好，代表原因；不过也可以理解为：等到notfull才继续执行） buffer(in):=nextp； in:=(in+1) mod n； count:=count+1； if notempty.queue then notempty.signal； //唤醒一个在notempty队列中等待的进程 end procedure entry get(item) begin if count&lt;=0 then notempty.wait； nextc:=buffer(out)； out:=(out+1) mod n； count:=count - 1； if notfull.quene then notfull.signal； end begin in:=out:=0；count:=0end不是很明白，怎么解决的资源打架问题(5)小结实现进程互斥时用P操作测试是否可以使用共享资源，这相当于测试“资源是否可以使用” ； 用V操作归还共享资源，这相当于发送了“共享资源已空闲”的消息。把进程的互斥与进程的同步统称为进程同步，把用来解决进程互斥与进程同步的机制（如PV操作）统称为同步机制但是，进程的互斥与进程的同步是有差别的。进程的互斥是进程之间竞争共享资源的使用权。这种竞争没有固定的必然关系，哪个进程竞争到使用权则共享资源就归哪个进程使用，直到使用完再归还使用权。若无进程在使用共享资源，就允许某申请资源进程去使用它，即使是一个刚刚使用过某共享资源的进程，而此时无其他进程要使用这个共享资源，则该进程仍可再次使用它。而进程同步的情况就不同了，涉及共享资源的并发进程之间有一种必然的依赖关系。当进程必须同步时，即使无进程在使用共享资源，尚未得到同步进程的消息仍然不能去使用这个资源所以用PV操作管理共享资源时，一定要正确区分互斥与同步。最关键的是确切地定义信号量，以及合理地调用各信号量上的P操作和V操作。6、进程通信操作系统学习笔记-7：进程通信进程通信指的是进程之间的信息的传播和交换。低级通信：进程之间的互斥和同步。信号量机制作为通信工具的缺点：(1)效率低 ；(2)通信对用户不透明。高级进程：通信是指用户可直接利用操作系所提供的一组通信命令，高效地传送大量数据的一种通信方式。特点：（1）使用方便操作系统隐藏了进程通信的细节，对用户透明，减少了通信程序编制上的复杂性。（2）高效的传送大量数据，利用通信原语实现。1. 共享存储进程 A 无法直接访问进程 B 的地址空间，反之亦然，所以提供一块可以供 AB 访问的共享空间。这块共享空间属于互斥的临界资源。1.1 基于数据结构各个进程共用某些数据结构，借以实现进程间的信息交换。比如共用一个长度为 10 的数组。这种共享速度慢、限制多，属于低级通信方式。1.2 基于存储区在内存中划出一块共享存储区，各个进程通过对这个共享区的读写交换信息、实现通信。数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，属于高级通信方式。2. 消息传递进程通过操作系统提供的“发送消息/接受消息”两个原语进行数据交换，而数据交换的基本单位是一个格式化的消息，该消息包括消息头和消息体。消息头包括：发送进程 ID，接受进程 ID，消息类型，消息长度等格式化的信息。2.1 直接通信方式发送进程发送消息之前，首先申请一个缓冲区，之后把消息复制到缓冲区，再通过发送原语把缓冲区发送给接受进程，缓冲区首先到达接受进程的消息缓冲队列队尾。接受进程通过接受原语读取队列消息，并复制到本地变量。2.2 间接通信方式也叫做信箱通信。发送进程发送的消息首先到达一个消息容器，接受进程再从消息容器中接受消息。3. 管道通信管道又名 pipe 文件，其实就是在内存中开辟一个大小固定的缓冲区。它采用的是半双工通信，一个时间段内只能实现单向的传输。另外，管道也是互斥的临界资源。管道写满的时候，写进程会被阻塞，直到读进程把数据读走；而管道空的时候，读进程会被阻塞，直到写进程把数据读入。这里要注意，管道与我们之前说过的生产者、消费者使用的缓冲区不同。写会一次性写完，读会一次性读完，不存在写一下、读一下的情况。进程通信，是指进程之间的信息交换，进程的互斥和同步，由于只能交换很少量的信息而被归结为低级通信，目前的高级通信机制可归结为三大类==① 共享存储器系统==相互通信的进程共享某些数据结构或共享存储区，进程之间能够通过这些空间进行通信，基于此，又可以分为如下两种类型：基于共享数据结构的通信方式，在这种通信中，要求诸进程共用某些数据结构，借此实现进程间的信息交换。基于共享存储区的通信方式，为了传输大量数据，在存储器中划出一块共享存储区，诸进程可通过对共享存储区中的数据的读或写来实现通信。==② 消息传递系统==进程间的数据交换是以格式化的消息为单位，程序员直接利用操作系统提供的一组通信命令（原语），不仅能实现大量数据的传递，而且还隐藏了通信的实现细节，使通信过程对用户是透明的，从而大幅减少通信程序编制的复杂性。==③ 管道通信==连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件，向管道（共享文件）提供输入的发送进程，以字符流形式将大量的数据送入管道；而接受管道输出的接受进程，则从管道中接受数据，由于发送和接受进程是利用管道进行通信的，因此叫做管道通信。管道通信需要具有三方面的协调能力：互斥（当一个进程正在对pipe执行读/写时，其他进程必须等待），同步（当写进程把一定数量的数据写入pipe，便去睡眠等待，到读进程取走数据后，再把它唤醒，当读进程读一个空pipe时，也应该睡眠等待，直到有数据写入管道，才将其唤醒），确定对方是否存在，只有确定了对方已存在时，才能进行通信。7、线程基本概念操作系统学习笔记-8：线程（1）线程的引入首先回忆一下为什么会有进程 —— 在以前，程序是串行执行的，为了让多道程序并发执行，引入了进程。进程虽然显著提高了资源利用率和系统吞吐量，满足了并发的需求，但是这种并发能不能做得更好呢？事实上，进程既是一个携带资源的独立单位，也是独立调度的基本单位，因此，在进程的创建、撤销和切换时，系统必须为之付出较大的时间空间开销（没办法“轻装上阵”）。鉴于此，系统不宜设置过多的进程，也不宜频繁地切换进程，这对于并发来说是一种限制。如何解决这个问题呢？可以把进程看作是管理初创公司的老板，一开始人手不足，老板既要管理公司，也要四处奔跑沟通业务；但是一旦人手充足，那么老板仍然可以管理公司，只是沟通业务的工作就可以交给手下人去执行了。同理，我们可以考虑依然让进程作为拥有资源的独立单位，但是独立调度的基本单位则不再是进程，而是新引入的线程了。它将进程的两个基本属性分开，==作为调度和分派的基本单位==，==不同时作为拥有资源的单位==，以“轻装上阵”；对于拥有资源的基本单位，又不对之进行频繁切换。在多线程OS中，通常一个进程包括多个线程，每个线程是利用CPU的基本单位，是花费最小开销的实体。（2）进程和线程的比较进程是指在系统中正在运行的一个应用程序每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内比如同时打开QQ、Xcode，系统就会分别启动2个进程1个进程要想执行任务，必须得有线程（每1个进程至少要有1条线程）==线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行==比如使用酷狗播放音乐、使用迅雷下载电影，都需要在线程中执行1个进程中可以开启多个线程，每个线程可以并行（同时）执行不同的任务：进程 -&gt;车间，线程-&gt;车间工人 多线程技术可以提高程序的执行效率 比如同时开启3条线程分别下载3个文件（分别是文件A、文件B、文件C）同一时间，CPU只能处理1个线程，只有1个线程在工作（执行）多线程并发（同时）执行，其实是CPU快速地在多个线程之间调度（切换）如果CPU调度线程的时间足够快，就造成了多线程并行执行的假象。如果线程非常非常多,CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源每条线程被调度执行的频次会降低总结调度的基本单位引入线程后，调度的基本单位不再是进程，而是线程。线程能够独立运行，且切换的时候，代价远远小于进程切换的代价。同一进程不同线程的切换，不会引起进程的切换。执行的基本单位通常认为进程不再作为可执行的实体。也即，可以说进程处于“执行”状态，但其实指的是该进程的某个线程正在执行；**可以说进程处于“挂起”状态，但其实指的是该进程的所有线程都被挂起。其他同理。**并发性进程间仍然能够并发，不仅如此，一个进程中的多个线程间也能并发，不同进程中的线程也能够并发，大大提高了 OS 的并发性。资源资源依然掌握在进程手中。为了性能考虑，线程仅占有一点必不可少的资源（比如 TCB，程序计数器等）。那么如何访问其它资源呢？事实上，同一进程的线程共享该进程所拥有的资源。另外，这些线程还共享同一片内存地址空间，所以也可以方便地进行通信。独立性同一进程中的线程间独立性要比不同进程间独立性低很多。前者独立性高，因为要防止进程之间彼此干扰和破坏；后者独立性低，因为同一进程的多个线程通常需要协作完成任务，互相之间可访问程度相对来说会比较高。系统开销在创建和撤销进程时，系统需要分配或者回收 PCB，分配或者回收资源，所以需要付出一定的时空开销；但是线程的创建和撤销的时空开销则明显小很多，尤其是在同一进程内的线程创建和撤销，这种开销会更加地小。支持多处理机系统传统的单线程进程，即使处理机再多，一个进程也只能运行在一个处理机上；但是引入了线程后，一个进程的多个线程可以分配到多个处理机上、并行执行。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typora优化]]></title>
    <url>%2Fposts%2F6eb48c74%2F</url>
    <content type="text"><![CDATA[1、主題嘗試 nord ==Maize== Bluebook Mo OneDark softgreen Night Pixyll Newsprint ==scribble== ==Vue== ==Lavender== ==gitlab== ==pie== Next ==Purple==2、快捷鍵和高亮设置官方文檔具体快捷键名称开启语言中的英文模式查看&quot;Highlight&quot;:&quot;Ctrl+Q&quot;注意还要开启高亮才行。3、未保存文件找回4、样式再修改https://pjchender.blogspot.com/2018/04/app-typora.html66 185 147修改CSS某些属性可从上述网址中表格查询例如下划线变色，查询到下划线对应为U则1234#下划线变色#write u &#123; color: #ecc514; &#125;倾斜小技巧：可以通过截图软件查看色彩 用10进制转16进制工具获得16进制RGB信息，在CSS中搜索，可以得到他人编写的CSS中相应设置位置，然后可以修改你的色彩常用结果==已经存入百度盘==常用样式：Vue并在其基础上修改：123456789101112131415161718192021222324252627282930313233#修改整体宽度#write &#123; max-width: 1000px; margin: 0 auto; padding: 20px 30px 100px;&#125;#下划线变色#write u &#123; color: #ecc514; &#125;#倾斜变色#write em &#123; padding: 0 5px 0 2px; color: #0cc4f1;&#125;/* heighlight.高亮设置 */#write mark &#123; background-color: #FFFF00; border-radius: 2px; padding: 2px 4px; margin: 0 2px; /* color: #222; */ /* font-weight: 500; */&#125;/*对超链接进行修改 */a &#123; color: #ff8e62; font-weight: 600; padding: 0 2px; text-decoration: none;&#125;其他可修改1234567891011/* 选择对引用框修改，但是我觉得vue主题自带就不错 */blockquote &#123; border-left: 4px solid #42b983; padding: 10px 15px; color: #777; background-color: rgba(66, 185, 131, .1);&#125;/*颜色备选粉色ff62ff红色]]></content>
  </entry>
  <entry>
    <title><![CDATA[操作系统【三】]]></title>
    <url>%2Fposts%2Fc7c29aab%2F</url>
    <content type="text"><![CDATA[(4)And型信号量上述进程互斥问题，即多个进程共享一个临界资源。假设：两个进程A和B，共享数据D和E，为其分别设置互斥信号量Dmutex和Emutex，初值都设为1。123456Process A： wait(Dmutex); wait(Emutex);Process B： wait(Emutex); wait(Dmutex);若执行：1234Process A： wait(Dmutex); //Dmutex=0Process B： wait(Emutex); //Emutex=0Process A： wait(Emutex); //Emutex=-1 A阻塞Process B： wait(Dmutex); //Dmutex=-1 B阻塞所以共享的资源越多，死锁的可能越大AND同步机制的基本思想：将进程在整个运行过程中需要的所有资源，一次性全部分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其他所有可能为之分配的资源，也不分配给它。即对临界资源的分配采取原子操作。12345678910Swait(S1, S2, …, Sn)&#123; while(1) &#123; if (S1&gt;=1 &amp;&amp; …&amp;&amp; Sn&gt;=1) &#123; for (i=1; i&lt;=n; i++) Si -- ; break; &#125; else Place the process in the waiting queue associated with the first Si found with Si &lt;1,and set the progress count of this process to the beginning of Swait operation &#125; //当某些资源Si不能被满足时，调用进程进入第一个资源Si没能满足的等待队列中，进程阻塞&#125;1234567Ssignal(S1, S2, …, Sn)&#123; while(1) &#123; for i:=1 to n do Si ++ ; Remove all the process waiting in the queue associated with Si into the ready queue &#125; //将等待队列中能满足所有资源需求的进程转移到就绪队列中准备执行&#125;(5)信号量集①一般信号量集记录型和AND信号量机制每次只能获得或释放一个单位的资源，相对低效 引入信号量集的思想每次可以分配若干个资源，但是每次分配前必须测试资源数量，看当前资源量是否大于可以分配资源的下界值ti ，当资源量低于下界值时便不予以分配。Swait(S1, t1, d1, …, Sn, tn, dn)Si 为资源信号量，di 为资源需求值，ti 为可分配资源的下限值1234567Swait(S1, t1, d1, …, Sn, tn, dn)&#123; if( S1&gt;= t1 &amp;&amp; … &amp;&amp; Sn&gt;= tn) for (i=1 ; i&lt;=n ; i++) Si= Si - di ; else Place the executing process in the waiting queue of the first Si with Si &lt; ti and set its program counter to the beginning of the Swait Operation //当某些资源不能被满足时，调用进程进入第一个资源小于ti的信号量的等待队列中，调用进程阻塞 &#125;12345Ssignal(S1, d1, …, Sn, dn)&#123; for (i=1 ; i&lt;=n ; i++) Si= Si +di ; Remove all the process waiting in the queue associated with Si into the ready queue//将等待队列中能满足所有资源需求的进程转移到就绪队列中准备执行 &#125;从P0 进程的角度来说，执行 P 操作的时候，不仅要传多个信号量进去，而且每一个信号量还有配套的 t 和 d，分别表示“最小必须满足值”和“分配数目”，也就是说，每一个资源 Si 的数目都必须大于等于对应的 ti，才能将其中的 di 个分配给某个进程；同理，执行 V 操作的时候，也是要传多对 Si，di 进去，让每一种资源都得到一定的释放，同时唤醒对应阻塞队列中的进程。一般信号量集的几种特殊情况：Swait(S, d, d)，只有一个信号量S，允许每次申请d个资源，若现有资源数少于d，不予分配。Swait(S, 1, 1)，蜕化为一般的记录型信号量若 S&gt;=1时，S=S-1 &gt;=0，允许进程进入临界区若 S&lt;1 时，S=S-1 &lt;0，临界区中有进程在执行，调用进程必须阻塞，进入等待队列Swait(S, 1, 0)，当S&gt;=1时，允许多个进程进入某特定区，当S变为0后，阻止任何进程进入特定区，相当于可控开关。一次只要申请一种资源，而且一次申请资源数为一个的使用记录型信号量一次申请多种资源，每种资源一次申请一个的使用AND信号量一次申请多种资源，每种资源一次申请多个的使用信号量集(6)信号量的应用利用信号量实现进程互斥为使多个进程互斥的访问某临界资源，须为该资源设置一互斥信号量mutex，并设其初始值为1，然后将各进程访问资源的临界区置于wait(mutex)和signal(mutex)之间即可。1234567891011semaphore mutex = 1;P0()&#123; P(mutex) critical section V(mutex)&#125;P1()&#123; P(mutex) critical section V(mutex)&#125;2.信号量实现进程同步在前面，我们一直用大量的篇幅解释进程互斥的实现，那么如何实现进程同步呢？也就是说，多个进程一起完成某项任务的时候，如何确保它们按照一定的先后顺序有秩序地执行呢？实际上，信号量机制也可以很好地实现进程同步。它的核心是三个关键步骤：==设置信号量初始值为 0====在”前操作“之后执行 V(S)====在”后操作“之前执行 P(S)==先来解释一下原理，即：为什么这样就可以保证两个操作的前后顺序呢？首先我们先记住一点，0 是一个非常关键的”分水岭“，大于 0 的时候不会发生阻塞，小于 0 则会发生阻塞。我们要确保”前操作“在前面，”后操作“在后面，实际上只要做到三件事：V 在”前操作“后面、P 在”后操作“前面、V 在 P 前面。第一个和第二个条件都是可以通过实际书写代码来做到的，而要达到第三个条件 —— V 在 P 前面，就有必要让信号量初始值为 0，因为一旦初始值为 0，则每当 P 想要”违规“抢先于 V 执行的时候，都会由于首先执行信号量自减的操作而导致当前所在进程进入阻塞队列 ，也就是说：==P 先于 V 执行 —&gt; P 所在进程会被阻塞 —&gt; ”后操作“始终无法执行==只有进行了A才能进行B则：fun1{while（1）{==A；====signal（s）；==}}fun2{while（1）{==wait（s）；====B；==}}所以，在这种情况下，就只能转而执行 V 所在的进程了。在这个进程里，由于 V 在”前操作“后面，所以一定是”前操作“执行完了再去执行 V。而执行 V 就会自增信号量，同时唤醒对方进程，对方进程再去顺序执行 P 操作 —— 虽然此时信号量又自减，但是是在加一的基础上自减，所以并不会导致再次阻塞，所以 P 执行完后就顺序执行”后操作“。由此，我们确保了两个操作一定是严格按照先后顺序执行的。3.信号量实现进程前驱关系其实这种情况就是把多个同步问题结合起来，对于每一对前驱关系来说，都有属于本关系的信号量，所以我们仍然是可以用信号量机制来实现的。5、经典进程的同步问题(1)生产者—消费者问题生产者 — 消费者问题描述的是一个对产品生产和消费的过程：首先，对于生产者，如果缓冲区没满，它就会生产产品并将其放入缓冲区，如果缓冲区已满，它就会进行等待；对于消费者，如果缓冲区不空，它就会取走产品并释放缓冲区，如果缓冲区已空，它就会进行等待。对于这个问题，不难看出有两个进程，一个是生产者进程，一个是消费者进程；同时有一个互斥关系，在同一时间内，只能有一个进程访问同一个缓冲区，要么放入产品，要么取走产品；同时有两个同步关系，一个指的是：必定是先生产产品，后取走产品，另一个指的是：必定是先释放缓冲区，后使用缓冲区。用数组表示具有n个缓冲区的缓冲池输入指针in指示下一个可投放产品的缓冲区，输出指针out指示下一个可从中获取产品的缓冲区，初值均为0。缓冲池组织为循环缓冲，输入指针 加1表示为in:=(in+1)% n，输出指针 加1表示为out:=(out+1)% n，当 in==out表示缓冲池空；(in+1)% n= =out时表示缓冲池满。12item buffer[n] ;int in=0, out=0;在生产者和消费者之间的公用缓冲池buffer[n]是生产者和消费者共享的临界资源，这个临界资源需要两个进程互斥的访问。可以设置两个信号量来表示缓冲区满和空两种情况，来控制生产者和消费者的进度情况。 ==注意：====1。每个程序中用于实现互斥的wait(mutex)和signal(mutex)必须成对地出现。====2。对资源信号量empty和full的wait和signal操作，同样需要成对地出现，但处于不同的程序中。====3。在每个程序中的多个wait操作顺序不能颠倒。应先执行对资源信号量的wait操作，再执行对互斥信号量的wait操作，否则可能引起进程死锁。==12345678910producer()&#123; consumer()&#123; while(1)&#123; while(1)&#123; 生产产品 P(mutex) P(mutex) P(full) P(empty) 从缓冲区中取走产品 把产品放入缓冲区 V(mutex) V(mutex) V(empty) V(full) 使用产品 &#125; &#125; &#125; &#125;这个写法的问题在于，还没有先检查缓冲区是否没满或者是否非空，就强行进行互斥的“上锁”。假如还是按照前面的流程，一开始处理机在 consumer 这里，那么 consumer 实际上在没有检查缓冲区是否非空的情况下就直接“上锁”了，这导致它在 P(full) 这一步的时候被卡住，只能等待，而在之后切换到 producer 的时候，正常情况下他应该生产可供对方消费的产品，但是由于对方已经上了锁，所以 producer 在 P(mutex) 这一步也被卡住了，只能进行等待。这也就是说，producer 等待 consumer 释放临界区，而 consumer 等待 producer 使用缓冲区，双方陷入循环等待，造成了“死锁”。另一种情况，我们也可以设想一开始处理机是在 producer 这里，那么是不是不会导致“死锁”呢？并不是。事实上，按照这种情况正常用完全部缓冲区之后，如果处理机还是在 producer 这里，那么 producer 在检查缓冲区是否已满之前也会将自己提前上锁，在 P(empty) 这一步陷入等待，之后即使进程切换到 consumer 这里，它也会因为对方提前上锁，而导致自己在 P(mutex) 这一步陷入等待。也就是说，这不过是前面那种”死锁“现象的翻版。==进程的同步与互斥分析==当并发的多个进程有直接制约关系时形成进程的同步。进程的同步：一个进程的执行需要另外一个或者多个进程的配合。这里的同步主要是协调的意思。当并发的多个进程有间接制约关系时形成进程的互斥。进程的互斥：多个进程有序、有效的竞争系统的共享资源。进程互斥中用于实现互斥的P操作和V操作必须成对地出现进程同步的P操作和V操作，同样需要成对地出现，但处于不同的程序中在每个程序中的多个P操作顺序不能颠倒。应先执行对同步信号量的P操作，再执行对互斥信号量的P操作，否则可能引起进程死锁利用AND信号量解决生产者——消费者问题1234567891011121314151617181920212223242526272829semaphore mutex=1, empty=n, full=0;item buffer[n] ;int in=0, out=0;void proceducer( ) &#123; do &#123; produce an item in nexp; … Swait(empty, mutex); buffer[in]:=nexp; in:=(in+1) % n; Ssignal(mutex, full); &#125; while(1);&#125;void consumer ( ) &#123; do &#123; Swait(full, mutex); nextc:=buffer[out]; out:=(out+1) % n; Ssignal(mutex, empty); consume the item in nexc; … &#125; while(1);&#125;(2)哲学家进餐问题五个哲学家共用一张圆桌，分别坐在周围的五张椅子上，在桌子上有五只碗和五只筷子，他们的生活方式是交替地进行思考和进餐。平时，一个哲学家进行思考，饥饿时便试图取用其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐。进餐毕，放下筷子继续思考。可见：相邻两位不能同时进餐；最多只能有两人同时进餐。首先，五个哲学家对应了五个进程，然后在同一个时间段内，对于同一支筷子，只能有一个哲学家去使用它，所以筷子是一种临界资源，我们用互斥信号量 chopstick = 1 表示。鉴于这里有五支筷子，所以我们准备一个互斥信号量数组 chopstick[5] = {1,1,1,1,1}。另外，由于任何一个哲学家都只可能拿离自己最近的左右筷子，所以为了加以区分，我们需要给哲学家和筷子进行编号。对于哲学家，从 0 到 4 进行编号，由于哲学家按照圆桌首尾连接，所以某个哲学家左右两边的筷子编号与自己本身的编号相关。以哲学家 i 为例，它左边的筷子编号是 i。右边则是 (i+1)%5，如下图所示：对每一个哲学家进程来说，它都只能拿起左右两边的筷子，并且一定是吃饭前拿筷子，吃饭后放下筷子，所以初步的伪代码是这样的（这里忽略思考的过程）：123456789Pi()&#123; while(1)&#123; P(chopstick[i]) P(chopstick[(i+1)%5]) eat() V(chopstick[i]) V(chopstick[(i+1)%5]) &#125;&#125;如果哲学家 0 号拿起左右筷子后，进程切换到哲学家 1 号，那么哲学家 1 号是会被阻塞的，所以这样写可以保证相邻的哲学家中有一个可以吃饭。但是，如果是拿起左筷子，之后进程切换到 1 号，那么 1 号也会拿起自己的左筷子，以此类推，直到 4 号也拿起自己的左筷子。接着，进程来到 0 号，这时候，0 号会发现自己已经没有右筷子可以拿了（作为 1 号的左筷子），于是 0 号被阻塞；同理，1 号也没有右筷子，所以他也被阻塞……以此类推，由于所有的哲学家都只有左筷子，他们的右筷子都在其他人手里，这导致了所有的哲学家都被阻塞，等待着另一个哲学家释放筷子。但实际上，没有任何哲学家能够吃饭，因此没有人可以释放筷子，这使得这些哲学家都陷入无限的等待中，造成“死锁”的发生。解决这个问题有三个方法。至多只允许有四位哲学家同时去拿左边的筷子，最终能保证至少有一位哲学家能够进餐，并在用毕后释放出他用过的两只筷子，从而使更多的哲学家能够进餐。准备一个互斥信号量 count，但是这个信号量初值不再是 1 ，而是 4，表示最多允许四个哲学家参与过程。当 count 减少到 -1 的时候，就不能再让哲学家进来了，因此可以保证最多只有四个哲学家。1234567891011Pi()&#123; while(1)&#123; P(count) P(chopstick[i]) P(chopstick[(i+1)%5]) eat() V(chopstick[i]) V(chopstick[(i+1)%5]) V(count) &#125;&#125;仅当哲学家的左右两只筷子均可用时，才允许他拿起筷子进餐。利用AND信号量机制解决哲学家进餐问题12345678semaphore chopstick[5] =&#123;1,1,1,1,1&#125;;Process i do&#123; think; Swait(chopstick[ ( i +1) % 5] , chopstick[ i ] ); eat; Ssignal(chopstick[ ( i +1) % 5] , chopstick[ i ] ); &#125;while[TRUE];利用互斥性，增加信号量用于互斥关系1234567891011Pi()&#123; while(1)&#123; P(mutex) P(chopstick[i]) P(chopstick[(i+1)%5]) V(mutex) eat() V(chopstick[i]) V(chopstick[(i+1)%5]) &#125;&#125;规定奇数号哲学家先拿他左边的筷子，然后再去拿右边的筷子；偶数号哲学家则相反。123456789101112131415161718192021Pi()&#123; while(1) &#123; if(i%2 == 0) // 偶数哲学家，先右后左。 &#123; P(chopstick[(i + 1)%5]) ; P(chopstick[i]) ; eat(); V(chopstick[(i + 1)%5]) ; V(chopstick[i]) ; &#125; else //奇数哲学家，先左后右。 &#123; P(chopstick[i]) ; P(chopstick[(i + 1)%5]) ; eat(); V(chopstick[i]) ; V(chopstick[(i + 1)%5]) ; &#125; &#125;&#125;(3)读者—写者问题有读者和写者两组进程，它们共同访问同一个文件。对于读者，它可以与多个读者共同读取文件（因为不会修改到文件）；对于写者，它不能与其他任何进程共同访问文件（如果另一进程是写，则可能覆盖同一内容；如果是读，则可能修改到要读的内容）。也就是说，这里的互斥问题是读写互斥的问题，但与之前不同的是，除了实现读写、写写的互斥，我们还要实现读读的“不互斥”。首先准备一个信号量 rw = 1 表示当前是否有进程在访问文件（注意一开始是没有这样的进程的，1 表示的不是进程数目，仅仅是使用互斥信号量时习惯上给定的初始值，这个看 wait 的代码就能理解了）。在不考虑“读读不互斥”的情况下，我们的伪代码是这样的：1234567Writer()&#123; Reader()&#123; while(1)&#123; while(1)&#123; P(rw) P(rw) 写文件 读文件 V(rw) V(rw) &#125; &#125;&#125; &#125;这个代码可以实现读写互斥，但显然无法实现“读读不互斥”，因为每个读进程之间也会受到 rw 的影响，使得最后只能有一个读进程访问文件。于是我们考虑从读进程入手，做一些改进。这里读和读不能同时进行的本质原因在于，所有的读进程都会经历“检查并上锁”这个步骤，而一个读进程进入后就会马上检查并上锁，导致另一个也想要进入的读进程被阻塞，所以我们考虑：能不能不要让所有的读进程都经历“检查并上锁”这一步骤？也就是说，某些进程可以跳过 P 操作，直接进入临界区，这样一来，这些进程就不存在在 P 操作这里被阻塞的可能性。什么样的进程可以跳过 P 操作呢？就是中间的那些读进程。因为一开始肯定要有读进程上锁、最后肯定要有读进程解锁，所以上锁和解锁的任务交付给第一个和最后一个进程，而中间的那些进程来去自如，只需要负责读文件，不需要参与上锁和解锁。为了区分读进程的次序，我们准备一个 count = 0 的变量，它表示的是当前有多少个读进程正在访问文件。然后在读文件的前后，我们分别对 count 进行加一和减一的操作，每次读文件开始之前 count 会加一，所以在此之前如果变量为 0 ，说明当前读进程是第一个读进程；同理，每次读文件之后 count 会减一，所以在此之后如果变量为 0 ，说明当前读进程是最后一个读进程；此时伪代码如下：1234567891011Reader()&#123; while(1)&#123; if(count==0) P(rw) count++ 读文件 count-- if(count==0) V(rw) &#125;&#125;但是这样会产生一些问题。比方 1 号读进程首先进入并上锁，然后在 P 操作之后、count 加一变成 1 之前，进程切换到 2 号读进程，那么 2 号读进程就会卡在 P 操作这个地方，陷入阻塞，显然这时候无法实现我们想要的“读读不互斥”；又比方说，1 号读进程在 count 减一变成 0 之后、释放 rw 之前，进程切换到了 2 号读进程，那么 2 号同样又会被卡在 P 操作这里。所以我们还要进行改进。问题其实就出在，对 count 的检查和赋值不是一个原子操作，这导致的结果是，如果在检查和赋值之间的空隙，进程发生切换，则必然会使得另一进程陷入阻塞。那么能不能让这两个操作一气呵成呢？事实上，可以把 count 当作是一个互斥访问的资源，对 count 的访问是互斥的，也就说明一个时间段内只能有一个读进程去访问它，即使这个过程中切换到了其它进程，那个进程也会被阻塞，从而保证只有一个进程可以访问 count，而这个访问就是检查和赋值，这种情况下，检查和赋值一定是不会被中断的。准备一个互斥信号量 mutex = 1 表示对 count 的互斥访问，将检查和赋值封装在一个 PV 操作里。伪代码如下：12345678910111213141516Reader()&#123; while(1)&#123; P(mutex) if(count==0) P(rw) count++ V(mutex) 读文件 P(mutex) count-- if(count==0) V(rw) V(mutex) &#125;&#125;现在我们再来跑一下过程。假设还是 1 号读进程运行到 P 操作的时候，进程切换到了 2 号读进程，那么由于互斥信号量 mutex 的存在，导致 2 号进程进入了 mutex 对应的阻塞队列 —— 是的，这时候看起来 2 号进程还是被阻塞了，不过我们要关注到的是，阻塞它的信号量是 mutex，不是 rw。这意味着，在进程重新切换回 1 号进程的时候，1 号进程一旦执行了 V(mutex)，就可以将 2 号进程唤醒并送到就绪队列了。也就是说，尽管 2 号进程还是经历了“阻塞”这个过程，但是这个过程只是为了确保 1 号进程检查和上锁两个操作的原子性，一旦操作完成，2 号进程马上就被唤醒了。而之前那种情况不同，之前的情况是，导致 2 号进程被阻塞的是信号量 rw，除非 1 号进程读完后释放，否则 2 号进程会一直处于阻塞状态。这就是说，2 号进程永远不可能与 1 号进程同时读文件，但是改进后是可以的。12345678910111213141516171819202122232425262728semaphore rmutex =1, wmutex= 1;int Readcount =0;void Reader() &#123; do &#123; wait(rmutex); //互斥访问读者数量 if Readcount==0 wait(wmutex); //如果当前读者数为0则测试是否有写者 Readcount =Readcount +1; //若没有则读者数加1 signal(rmutex); //修改读者数量过程结束，释放读者信号量 … perform read operation … wait(rmutex); //读操作结束，互斥访问读者数量，准备修改读者个数 Readcount =Readcount -1; if Readcount==0 //如果当前读者数为0则释放信号量 signal(wmutex); // wmutex允许写者进行写操作， signal(rmutex); //释放信号量rmutex允许其它读者修改读者数 &#125; while(TRUE);&#125;123456789101112131415161718void Writer () &#123; do&#123; wait(wmutex); //测试信号量wmutex的值确定是否可以进行写操作 perform write operation; //执行写操作 signal(wmutex); //写操作结束释放信号量&#125;while(TRUE)&#125;void main() &#123;cobegin reader();writer();coend&#125;但随之而来的又是另一个问题， “读写不公平”。也就是说，这样的代码本质上是对读进程更有利的。因为对读进程来说，一旦第一个读进程进来了，中间即使穿插再多的读进程，也都是允许的，他们根本不受到 rw 这个“锁”的限制；而对于写进程，它的运气就没这么好了，写进程只要想进来，就必须通过 rw 这个“锁”，而这个“锁” 实际上又掌握在最后一个读进程手里 —— 这就是说，万一读进程源源不断进来，始终轮不到最后一个读进程解锁，那么写进程就只能陷入无尽的等待了。既然 rw 这把锁无法做到公正对待每一个进程，那我们就考虑在外层加一把“更大、更公正的锁”。也就是说，所有的进程，无论读还是写，无一例外必须通过这把“锁”的检查。为此，我们准备一个新的互斥信号量 w = 1，并将 Writer 和 Reader 的一些关键操作封装在 w 的一对 PV 操作里。此时，伪代码如下：我们来跑一下流程。假设首先来到 1 号读进程，那么它就会执行 P 操作上锁，这个过程中即使有写进程想进来，也会被送到 w 对应的阻塞队列。在 1 号读进程执行到 V 操作之后，写进程才会被唤醒并送到就绪队列，之后就轮到写进程执行了，而写进程虽然通过第一个 P 操作，但是被卡在了第二个 P 操作（读进程尚未释放 rw），所以他来到了 rw 对应的阻塞队列。注意！重点来了，如果这时候 2 号读进程也想要访问文件，那么在以前，它是不需要通过任何检查就可以直接来读文件的，并且直到 2 号读进程释放 rw 之后，写进程才能真正来执行写文件的操作。但是现在由于我们加了一把“更大的锁”，导致 2 号进程也必须先通过 w 的检查，而由于写进程抢先在他之前上了锁，所以 2 号读进程被送到了 w 对应的阻塞队列。也就是说，现在的情况是：写进程等着 1 号读进程释放 rw，而 2 号读进程等着写进程释放 w，1 号读进程是让一切正常进行下去的关键。在处理机又来到 1 号读进程并执行 V(rw) 之后，写进程从 rw 的阻塞队列被唤醒，继续往下执行写文件的操作。而在写进程真正执行完之后，w 才能得到释放，由此又唤醒了 w 阻塞队列中的 2 号读进程，2 号读进程来到处理机运行。如果换一种情况，是按照 写者 — 读者 — 写者的顺序，那么由于读者在第二个写者之前，所以是读者作为阻塞队列队头，第二个写者则次之，在后续执行过程中，根据队列“先进先出”的原则，也会是读者先于第二个写者访问文件。也就是说，实际上谁先到、谁就在后续过程中先被执行（而不是像之前那种情况，无论写进程先还是后，读进程都可以“无视规则”抢先一步执行）。由此，我们就实现了“读写公平”。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统【二】]]></title>
    <url>%2Fposts%2F8adc39f9%2F</url>
    <content type="text"><![CDATA[3、进程控制状态的切换实质上是通过修改 PCB 的信息、让 PCB 出队或者入队来实现的，但是是谁来控制这个过程呢？—— 答案就是进程控制进程控制指的是对系统中所有进程，从创建到终止的全过程实行的管理和控制。进程控制是进程管理中最基本的功能，一般由操作系统的内核中的原语来实现。(1)操作系统内核现代操作系统一般将OS划分为若干层次，再将OS的不同功能分别设置在不同的层次中。通常将一些与硬件紧密相关的模块、各种常用设备的驱动程序以及运行频率较高的模块，都安排在紧靠硬件的软件层次中，将它们常驻内存，即通常被称为OS的内核。处理机的执行状态分为两种：系统态：又称为管态，或内核态。具有较高的特权，能执行一切指令，访问所有寄存器和存储区，传统的OS都在系统态运行。用户态：又称为目态。具有较低特权的执行状态，仅能执行规定的指令，访问指定的寄存器和存储区。一般应用程序只能在用户态运行，不能去执行OS指令及访问OS区域，这样可以防止应用程序对OS的破坏。原语（Primitive)操作：由若干条指令组成的，用于完成一定功能的一个过程，是原子操作：即一个操作中的所有动作，要么不做，要么全做，在执行过程中不允许被中断，原子操作在系统态下执行，常驻内存。(2)进程的创建引起创建进程的事件如下① 用户登录。② 作业调度。③ 提供服务。④ 应用请求。在OS中，允许一个进程创建另一个进程父进程，子进程，进程的层次结构在OS 中 允许一个进程创建另一个进程创建子进程的进程为父进程，由此形成进程树，树根为进程家族的祖先（UNIX)。Windows中不存在任何进程层次结构的概念，所有进程都具有相同的地位，进程之间的关系不再是层次关系，而是获得句柄与否，控制与被控制的简单关系。子进程可以继承父进程所拥有的资源，进程不能拒绝其子进程的继承权撤销父进程时，必须同时撤销其所有的子进程为了标识进程之间的家族关系，在PCB中设置了家族关系表项，以标明自己的父进程及所有的子进程(2)进程的终止正常结束异常结束（处决）越界错误：访问超出进程区域保护错：试图访问不允许访问的资源或文件非法指令：试图执行一条不存在的指令特权指令错：试图执行一条只允许OS执行的特权指令运行超时：执行时间超出了规定时间的最大值等待超时：等待时间超出了规定时间的最大值算术运算错：试图执行被禁止的运算，比如除0运算I/O故障：I/O过程错误外界干预（他杀）进程应外界的请求而终止运行。操作员或操作系统干预，例如发生死锁等父进程请求父进程终止(3)进程的阻塞与唤醒引起进程阻塞的事件请求系统服务启动某种操作新数据尚未到达无新工作可做正在执行的进程发生上述情况时，无法继续执行，于是通过调用阻塞原语block( )把自己阻塞。 将PCB中的状态由“执行”改为“阻塞”，并加入到阻塞队列中；转进程调度进行重新调度，将处理机分配给另一就绪进程，并进行切换，保留被阻塞进程的处理机状态（在PCB中），再按新进程的PCB中的处理机状态设置CPU的环境。进程的阻塞是一种主动行为唤醒原语wakeup( )的执行：把阻塞进程从等待该事件的阻塞队列中移出，将其PCB中的现行状态改为就绪，将PCB插入到就绪队列中。Block阻塞原语与唤醒原语wakeup作用相反，成对使用一个处于阻塞状态的进程不能自己唤醒自己。唤醒一个进程有两种方法：1、由系统进程唤醒2、由事件发生进程唤醒当由系统进程唤醒等待进程时，系统进程统一控制事件的发生，并将“事件发生”这一消息通知等待进程，从而使得该进程因等待事件已发生而进入就绪队列。等待进程由事件发生进程唤醒时，事件发生进程和被唤醒进程之间是合作关系。因此，唤醒原语既可以被系统进程调用，也可以被事件发生进程调用。我们称调用唤醒原语的进程为唤醒进程(4)进程的挂起与激活当出现引起进程挂起的事件时，系统利用挂起原语suspend( )将指定进程或处于阻塞的进程挂起挂起原语的执行：检查被挂起进程的状态，若处于活动就绪，则改为静止就绪，若处于活动阻塞，则改为静止阻塞，将该进程PCB复制到内存指定区域，若挂起的进程正在执行，则重新进行进程调度。当发生激活进程的事件时，系统利用激活原语active( )将指定进程激活。激活原语先将进程从外存调入内存，检查该进程的状态，若处于静止就绪，则改为活动就绪，若处于静止阻塞，则改为活动阻塞。若采用抢占调度策略，则新进程进入就绪队列时，检查是否要重新进行进程调度。如果系统中有n个进程，运行队列中进程的个数最多为1个就绪队列中进程的个数最多为n-1个阻塞队列中进程的个数最多为n个全部在等待外部条件，无法执行4、进程同步(1)基础概念进程同步的主要任务：使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性。(因为各个进程以各自独立的、不可预知的速度向前推进。执行过程会发生一些例如读后写等问题所以，我们要通过进程同步来解决此类问题。)两种形式的制约关系(1)间接相互制约关系(互斥关系)：源于资源共享(无意识安排的）(2)直接相互制约关系(同步关系)：源于进程合作（进程间的相互联系是有意识安排的）些资源在一个时间段内只允许一个进程使用，诸如各种物理设备、变量、数据、内存缓冲区等，这些称之为临界资源许多硬件资源或者共享变量都属于临界资源，多个进程可以共享，但是必须采用互斥方式。我们把并发进程中与共享变量有关的程序段称为临界区如果能保证一个进程在临界区执行时，不让另一个进程进入相关的临界区执行即各进程对共享变量的访问是互斥的，那么就不会造成错误为了实现临界资源的互斥访问，可以在逻辑上将一个进程对临界资源的访问过程分为四个部分：123456do &#123; extry section; // 进入区 critical section; // 临界区 exit section; // 退出区 remainder section; // 剩余区&#125; while(true)进入区：A 进程想要访问临界资源，首先会在进入区检查是否可以进入，由于此时没有其它进程占用临界资源，所以检查通过，同时它设置了一个 Flag 标志当前自己正在访问临界资源；临界区：实际访问临界资源的那段代码退出区：负责解除之前的 Flag剩余区：其它处理对于 B 进程，如果此时它也想要访问这个资源，同样就会在进入区做一个检查，它知道了 A 进程正在访问，所以自己就不能访问了。这样就实现了资源访问的互斥。对若干个并发进程共享某一变量的相关临界区的管理有三个要求（1）一次最多一个进程能够进入临界区。当有进程在临界区执行时，其他想进入临界区执行的进程必须等待：（2）不能让一个进程无限制地在临界区执行，即任何一个进入临界区的进程必须在有限的时间内退出临界区；（3）不能强迫一个进程无限制地等待进入它的临界区，即有进程退出临界区时应让一个等待进入临界区的进程进入它的临界区执行。由此产生了四个原则：==空闲让进==：当无进程处于临界区时，表明临界资源处于空闲状态， 应允许一个请求进入临界区的进程立即进入自己的临界区==忙则等待==：当已有进程进入自己的临界区时，表明该临界资源正被访问，因而其它所有试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。==有限等待==：对要求访问临界资源的进程，应保证该进程能在有限时间内进入自己的临界区，以免陷入“死等”状态，即不得使进程在临界区无休止地等待。==让权等待==：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”。(2)硬件同步机制操作系统学习笔记-4：进程同步与进程互斥（一）利用特殊的硬件指令解决临界区管理问题①中断屏蔽方法关中断：进程在临界区执行期间，计算机系统不响应中断，从而不会引发调度，不会发生进程调度，进而不会发生进程切换，保证了对锁的测试和关锁操作的连续性和完整性，因而有效地保证了互斥。缺点（1）滥用关中断权利可能造成严重后果；（2）关中断时间过长，影响系统效率；（3）关中断方法不适合多处理器系统。②Test-and-Set指令TestAndSetLock /TestAndSet 指令也叫 TSL/TS 指令。双标志方法的根本问题出在”上锁“和”检查“是非原子操作，导致某个进程可以利用这两个操作的空隙，而 TSL 指令将两个操作变成了原子操作（一气呵成，不留空隙），同时它也做到了像中断屏蔽指令那样，一旦进入临界区，执行过程就无法被中断。虽然这是硬件操作，不过我们暂且用伪代码来进行理解：1234567891011bool TestAndSet (bool *lock)&#123; bool old; old = *lock; *lock = true; return old;&#125;P0: P1:while (TestAndSet(&amp;lock)); while (TestAndSet(&amp;lock));critical section; critical section;lock = false; lock = false;remainder section; remainder section;其中，lock 是全局变量，记录当前临界区是否”上锁“。首先，进程 P0 想要访问临界区，那么就会来到 while 循环，在这个循环里，它一气呵成完成了”上锁“和”检查“的工作 —— 循环里执行了 TSL 函数，一方面将全局 lock 改为 true，一方面返回旧的值为 false 的 lock 给自己。所以，对自己来说，由于返回的是 false，它得以跳过循环进入临界区；而对 P1 进程来说，每次切换到它这里，它在 while 里企图”上锁“和”检查“的时候，都会由于之前全局 lock 已经被置 true 而陷入死循环。因此，整个过程就保证了 P0 的”上锁“和”检查“是一气呵成的原子操作，同时也让 P0 执行时绝对不会被切换。在 P0 执行完之后，全局 lock 再次置 false，以此类推。TSL 指令的方法实现简单，无需严格检查逻辑，也适用于多处理机环境，但是它仍然不满足”让权等待“的原则 —— 从伪代码可以看出，P1 在无法如愿进入临界区后仍然可能白白地占用处理机，导致”忙等“。③Wrap 指令Swap 指令或称 Exchange / XCHG 指令，它的逻辑其实和 TSL 指令差不多：1234567P0: P1:bool old = true; bool old = true; while (old == true) while (old == true) Swap(&amp;lock,&amp;old) ; Swap(&amp;lock,&amp;old) ; critical section; critical section;lock = false; lock = false;remainder section; remainder section;一开始全局 lock 还是 false，P0 想要进入临界区，首先置 old 为 true，后面用 Swap 完成交换，所以得以跳出循环进入临界区；而对于 P1 进程，由于它共享全局 lock，全局 lock = 自身 old = true，所以陷入了死循环，无法进入临界区。和 TSL 指令一样，Swap 指令也无法解决“让权等待”的问题。（3）信号量（Semaphore）机制（锁）Dijkstra发明的信号量机制是通过PV操作能够实现对临界区的管理要求。在荷兰文中，通过叫passeren，释放叫vrijgeven，PV操作因此得名。PV操作是由两个操作——P操作和V操作组成，为原语。P操作和V操作也可称为P操作原语和V操作原语，简称PV操作。P操作Wait(S)：检查信号量S是否小于等于0，若是则把调用Wait(S)的进程置成等待状态，否则将S减去1V操作signal(S)：将信号量加1①整型信号量信号量如果单纯是一个整数型的变量，那么就称为整型信号量，它的值记录了系统中某种资源的数量。在使用整型信号量的情况下，P 、V 操作是类似这样的：12345678910int S = 1;wait(int S) &#123; while(S &lt;= 0) /*do no-op*/ S = S-1 &#125;signal(int S)&#123; S = S+1&#125;同样以进程 P0，P1 为例进行说明：1234P0： P1:wait(S) wait(S) // 进入区critical section critical section // 临界区signal(S) signal(S) // 退出区假定 P0 想要进入临界区，那么它就会在进入区申请资源：执行 P 操作，进行“检查”和“上锁”，由于 S 一开始是1（表示目前有一个资源可以使用），所以 P0 可以跳过循环，成功申请到资源。此后，S 减一变为 0，代表已经没有可用资源了 —— 这一步也相当于上锁；对于 P1，当他想要申请资源的时候，同样先来到进入区执行 P 操作，由于 S = 0，所以此时 P1 陷入了死循环；再回到 P0 ，他完成任务后会在退出区释放资源，S加一变为 1，这时候 P1 才有机会退出循环，进而申请资源。整个过程其实和之前介绍的方法是很类似的，但是由于这次，“检查”和“上锁”两个操作被封装在一个原语里，所以这两个操作必定是一气呵成、无法被打断的，这就避免了某个进程钻空子的现象。但是同时我们也发现，在 P0 时间片用完后，P1 仍然会占用处理机进行没有意义的死循环，也就是仍然违背了“让权等待”的原则。于是在此基础上，又出现了记录型信号量②记录型信号量与整型信号量仅用一个单一变量记录可用资源数不同，记录型信号量的数据结构类似于一个结构体，它不仅记录了可用资源数 value，而且还提供了一个等待队列 L。记录型信号量的思想其实是，如果由于 P0 在使用临界资源而导致 P1 暂时无法使用，那么干脆就不给 P1 陷入循环的机会，直接让它自己去阻塞队列，这样 P1 在被唤醒之前，永远无法占用处理机，也自然就不可能出现白白占用处理机的情况。而在 P0 释放资源后，我们才来考虑唤醒 P1。记录型信号量的结构如下所示：1234typedef struct&#123; int value; struct PCB * list ;&#125; Semaphore;同时，记录型信号量的 P、V 操作也有所不同，如下所示：12345678910111213 wait(Semaphore *S)&#123; S-&gt;value=S.value-1; if (S-&gt;value&lt;0) block(S-&gt; list) &#125; signal(Semaphore *S) &#123; S-&gt;value++; if (S-&gt;value&lt;=0) wakeup (s-&gt; list)&#125;这里要注意的第一个地方是，value 是可用的资源数，当它大于 0 的时候自然是存在可用资源（供大于求），当它小于 0 的时候，则说明不仅无可用资源而且有其他进程等着用（供不应求）。第二个地方是，在进入区 value 一定会减一，表示申请到了资源，或者表示存在着某个进程有想要申请资源的意愿下面我们用例子来说明记录型信号量工作的过程，为了加深记忆，这里用四个进程来说明：1234PO: P1 P2 P3wait(S) wait(S) wait(S) wait(S)临界区 临界区 临界区 临界区signal(S) signal(S) signal(S) signal(S)假设计算机中有两台可用的打印机 A 和 B（也就是说，value = 2），有四个进程需要用到打印机资源。一开始假定是 P0 先占有处理机，那么 P0 就会在进入区申请资源 。由于 value 一开始是 2，所以 P0 成功申请到资源 A，之后 value 数量减一变为 1，同时来到临界区开始“干活”；在 P0 的时间片完了之后，P1 占有处理机，此时同样申请到资源 B，value 由 1 变为 0，之后来到临界区“干活”。自此，两个打印机都被占用了。在 P1 的时间片完了之后，P2 占有处理机，value 由 0 变为 -1 &lt; 0，前面我们说过，value &lt; 0 说明无可用资源，所以此时 P2 将自己主动送到了阻塞队列。接着来到了 P3，value 由 -1 变为 -2，P3 同样进入阻塞队列。P2，P3 都从运行态转为阻塞态。处理机又来到 P0，P0 很快执行完了，于是在退出区执行 P 操作释放资源，将 value 加一变为 -1，之后由于通过 if 检测到阻塞队列中有进程等着用资源，所以马上唤醒了队头的 P2 ，P2 从阻塞态回到就绪态，并直接进入临界区开始自己的工作，在完成后同样来到退出区释放资源，value 由 -1 变为 0，但是在 if 中还是检测到了队列中仍然有进程等着用资源，于是马上把队头的 P3 唤醒，P3 回到就绪态，并直接进入临界区开始工作，此后，value 由 0 变为 1，此时 if 不通过，说明队列中再也没有其它进程等着了，该拿到资源的进程都拿到了。自此，P0，P2，P3 都拿到了 A 资源，而 P1 也在不久后完成工作，在退出区释放资源 B，此时 value 从 1 变回最初的 2 ，代表占用的资源已经全数归还。PS：当然，实际情况还可能是，P2 拿到了 A 资源，P3 拿到了 B 资源，但分析过程也是大同小异的。显然，记录型信号量与前面介绍的所有方法最大的区别就在于，不会再有进程白白占用处理机进行没有意义的循环 —— 相反地，这些进程非常“老实”地把自己送到了阻塞队列，选择在那里慢慢地等待，等待其它进程完成后将自己唤醒，这种做法“既方便了别人，也方便了自己”。这就正好与我们多次强调的”让权等待“非常契合了。记录型信号量明显优于整型信号量，所以在提到 PV 操作的时候，一般默认指的都是记录型信号量。若用PV操作来管理进程互斥地进入临界区，则只要用一个信号量 ，该信号量的初值定为1任何一个进程，当要进入临界区时，先要调用P操作，以确定要进入临界区还是等待进入。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统【一】]]></title>
    <url>%2Fposts%2Fbacad521%2F</url>
    <content type="text"><![CDATA[一、操作系统引论0.基础概念和问题什么是操作系统?操作系统是系统软件，是一组控制和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序集合,是用户与计算机之间的接口。1、操作系统的基本特征四个基本特征：并发、共享、虚拟和异步(1)并发并行性：两个或多个事件在同一时刻发生并发性：两个或多个事件在同一时间间隔内发生进程——在系统中能独立运行并作为资源分配的基本单位(2)共享在操作系统环境下，所谓共享是指系统中的资源可供内存中多个并发执行的进程(线程)共同使用互斥共享方式（例如打印机，仅当 A 进程访问完并释放系统资源后，才允许另一进程访问该资源）临界资源(独占资源)：一段时间内只允许一个进程访问的资源同时访问方式（如磁盘设备，一段时间内是可以同时访问的。这里的同时是宏观层面上的）(3)虚拟通过虚拟技术把一个物理上地实体变为若干个逻辑上的对应物用于实现虚拟的技术，称为虚拟技术时分复用技术：通过利用处理机的空闲时间运行其它程序提高处理机的利用率把一个单一的大时间段分成多个时间片，交替执行各个进程。比如说虚拟处理器技术就是时分复用技术的一种 —— 单核计算机同时打开多个软件，在用户看来感觉像是多个 CPU 在跑这些软件。空分复用技术：通过利用存储器的空闲空间分区域存放和运行多道程序，提高内存的利用率虚拟存储器技术就是空分复用技术的一种 —— 计算机只有 4G 内存，虽然各个运行的软件消耗的总的内存远不止 4G，但它们还是可以正常运行，在用户看来感觉像是物理内存超过了 4G。(4)异步指进程的执行顺序和执行时间的不确定性多个程序并发执行，但是由于资源有限，进程的执行不是一贯到底的，以不可预知的速度向前推进。2、系统的主要功能(1)处理机管理功能①进程控制：为作业创建进程、撤销已结束的进程，以及控制进程在运行过程中的状态转换②进程同步：为多个进程(含线程)的运行进行协调协调方式：互斥和同步③进程通信：用来实现在相互合作的进程之间的信息交换；④调度：作业和进程的状态切换，包括作业调度和进程调度(2)存储器管理功能①内存分配：为每道程序分配内存空间，提高存储器的利用率，允许正在运行的程序申请附加的内存空间；②存储保护：确保每道用户程序都只在自己的内存空间中运行，彼此互不干扰；③地址映射(变换)：进程的逻辑地址到内存物理地址的映射。④内存扩充：用虚拟存储技术解决内存容量不足的问题；(3)设备管理功能①缓冲管理：在 I/O 和 CPU 之间引入缓冲，匹配CPU和外设的速度，提高两者的利用率和并行操作程度；缓冲区机制包括：单缓冲机制、双缓冲机制、公用缓冲池机制②设备分配：根据用户请求的设备类型和采用的分配算法，对设备进行分配③设备处理：实现 CPU 与设备控制器之间的通信。(4)文件管理功能①文件存储空间的管理：为文件分配外存空间,提高外存的利用率，并能有助于提高文件系统的运行速度;②目录管理：为文件建立一个目录项,并对众多的目录项加以有效组织，实现方便的按名存取，能实现文件共享，提供快速的目录查询手段。③文件读写管理和保护：对外存中的文件进行读写，提供防护(5)用户接口①命令接口（用户直接使用）：联机用户接口、脱机用户接口联机用户接口：由一组磁盘操作命令和命令解释程序组成脱机用户接口：由一组作业控制语言JCL组成②程序接口（用户通过程序间接使用）：让用户程序在执行中访问系统资源，是用户程序取得 OS 服务的唯一途径，有时候也叫做系统调用③图形用户接口二、进程的描述与控制操作系统学习笔记-3：初识进程和进程控制1、前趋图和程序执行只有在不存在前趋关系的程序之间才可能并发执行顺序执行：通常可以把一个应用程序分成若干个程序段，在各程序段之间，必须按照某种先后次序顺序执行，仅当前一操作(程序段)执行完后，才能执行后继操作。程序顺序执行时的特征(1) 顺序性：处理机的操作严格按照程序所规定的顺序执行，即每一操作必须在上一个操作结束之后开始。(2) 封闭性：程序是在封闭的环境下执行的，即程序运行时独占全机资源，资源的状态(除初始状态外)只有本程序才能改变它。程序一旦开始执行，其执行结果不受外界因素影响。(3) 可再现性：只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行，还是“停停走走”地执行，都将获得相同的结果。程序顺序执行时的特性，为程序员检测和校正程序的错误带来了很大的方便。程序的并发执行**是指在同一时间间隔内运行多个程序。也就是在一个程序运行结束之前，可以运行其它的程序。**==程序并发执行时的特征====间断性==：相互制约导致并发程序具有“执行—暂停—执行”这种间断性的活动规律==失去封闭性：==程序在并发执行时，多道程序共享系统的资源，因而这些资源的状态由多道程序来改变，程序运行失去封闭性。一程序的运行受到其他程序的影响。==不可再现性==：程序在并发执行时，失去封闭性导致其失去可再现性。程序在并发执行时，多道程序共享系统的资源， 程序运行失去封闭性。一程序的运行受到其他程序的影响, 失去封闭性导致其失去可再现性。2、进程的描述在多道程序设计的环境下，为了描述程序在计算机系统内的执行情况，必须引入新的概念－－进程进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。(1)进程的特征结构性(结构特征)：进程实体=程序段+进程控制块(PCB)+相关的数据段动态性进程：进程实体的一次执行过程，有生命周期。程序：程序是一组有序指令的集合，是静态的概念。动态性是进程最基本的特性并发性多个进程实体同存于内存中，在一段时间内同时运行，可以并发。程序不能并发执行。独立性：进程实体是一个能独立运行、独立分配资源和独立接受调度的基本单位，而程序则不是。异步性：进程按各自独立的、不可预知的速度向前推进。(2)进程的状态及转换三态模型：在多道程序系统中，进程在处理器上交替运行，状态也不断地发生变化。进程一般有3种基本状态：运行、就绪和阻塞。五态模型：对于一个实际的系统，进程的状态及其转换更为复杂。引入新建态和终止态构成了进程的五态模型。创建态：初始化 PCB，为进程分配系统资源就绪状态(Ready)：进程已获得除CPU之外的所有必需的资源，一旦得到CPU控制权，立即可以运行。运行状态(Running) ：该进程已获得运行所必需的资源，它的程序正在 处理机上执行。阻塞状态(Block)(等待或睡眠状态)：正在执行的进程由于发生某事件而暂时无法执行时，便放弃处理机而处于暂停状态，则称该进程处于阻塞状态或等待状态。终止态（结束态）：回收为进程分配的资源，撤销 PCB(3)挂起操作及进程状态转换挂起：前面所说的状态转换，是建立在内存资源够用的情况下 —— 当系统资源尤其是内存资源不够时，就需要将一些进程挂起（suspend），对换到外存中。（2）原因：引起进程挂起的原因是多样的，主要有：系统中的进程均处于阻塞态，处理器空闲，此时需要把一些阻塞进程对换出去，以腾出足够的内存装入就绪进程运行。进程竞争资源，导致系统资源不足，负荷过重，此时需要挂起部分进程以调整系统负荷，保证系统的实时性或让系统正常运行。把一些定期执行的进程（如审计程序、监控程序、记账程序）对换出去，以减轻系统负荷。用户要求挂起自己的进程，以便根据中间执行情况和中间结果进行某些调试、检查和改正。父进程要求挂起自己的后代进程，以进行某些检查和改正。操作系统需要挂起某些进程，检查运行中资源使用情况，以改善系统性能；或当系统出现故障或某些功能受到破坏时，需要挂起某些进程以排除故障。状态解释静止就绪态 → 活动就绪态内存中没有进程处于活动就绪态，或者处于静止就绪态的进程具有更高的优先级，那么静止就绪态就会被对换回来，此时才可能被调度执行活动就绪态 → 静止就绪态操作系统根据当前资源状况和性能要求，可能会把活动就绪态对换出去，成为静止就绪态。处于静止就绪态的进程不再被调度执行；活动阻塞态→ 静止阻塞态操作系统根据当前资源状况和性能要求，可能会把活动阻塞态对换出去，成为静止阻塞态。静止阻塞态→ 静止就绪态常见的情况是，引起进程等待的事件发生之后，相应的静止阻塞态进程将转换为静止就绪态静止阻塞态→ 活动阻塞态但有时候，如果静止阻塞态进程的优先级高于静止就绪队列中的任何进程、并且系统有把握它等待的事件即将完成，那么就会激活为活动阻塞态运行态→ 静止就绪态优先级较高的静止阻塞态在等待的事件完成后，可能会抢占 CPU，若此时资源不够，则可能导致正在运行的进程挂起为静止就绪态创建态→ 静止就绪态如果不分配给新建进程所需资源，则相应的进程将会转为静止就绪状态，对换到外存，不再参与调度，此时进程的创建工作尚未完成。进程一旦被挂起，就意味着它被对换到了外存中，此时该进程无法再被 CPU 直接调度，除非它被对换回内存中，回到活动就绪态。比如静止就绪态、静止阻塞态，最后要得到 CPU 的调度，都必须经历回归到活动就绪态的过程。(4)进程管理中的数据结构存放进程的管理和控制信息的数据结构称为进程控制块。PCB的作用①作为独立运行基本单位的标志。使一个在多道程序环境下不能独立运行的程序，成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。②能实现间断性运行方式。在多道程序环境下，程序采用走走停停间断性的运行方式，当进程暂停运行时，必须保存运行时的CPU现场信息，有了PCB就可以将CPU现场信息保存在被中断进程的PCB中，供该进程下次被调度执行时恢复CPU现场时使用。③提供进程管理所需要的信息。系统根据进程PCB中记录的程序和数据在内存或外存中的地址来找到相应的程序和数据。在进程的整个生命周期中，操作系统总是根据PCB来实现对进程的控制盒管理。④提供进程调度所需要的信息。PCB中记录了进程所处的状态信息。进程调度时需要的其它信息如优先级、进程等待时间、已执行时间等信息也存放在进程的PCB中。⑤实现与其它进程的同步与通信。进程同步机制是用于实现多个进程的协调运行的，在采用信号量机制时，要求在每个进程的PCB中都设置有相应的用于同步的信号量。在进程的PCB中还具有用于实现进程通信的区域或通信队列指针。它是进程管理和控制的最重要的数据结构，在创建时，建立PCB，并伴随进程运行的全过程，直到进程撤消而撤消。进程控制块是进程存在的唯一标志。系统的所有PCB组织成链表或队列，常驻内存的PCB区。进程控制块是操作系统中最重要的记录型数据结构。PCB中记录了OS所需的、用于描述进程情况及控制进程运行所需的全部信息。进程标识符：外部内部各一个处理机状态：通用寄存器、指令计数器、程序状态字 PSW，用户栈指针进程调度信息：进程状态、进程优先级、其它的进程调度信息进程控制信息：程序和数据的地址、进程同步和通信机制、资源清单、链接指针OS是根据PCB来对并发执行的进程进行控制和管理的。在进程的整个生命期中，系统总是通过PCB对进程进行控制的，系统是根据进程的PCB而感知到该进程的存在的。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaEE程序设计【七】]]></title>
    <url>%2Fposts%2F15697f4d%2F</url>
    <content type="text"><![CDATA[五、Spring-数据库1、Spring JDBCSpring JDBC模块主要由4个包组成，分别是core（核心包）dataSource（数据源包）object（对象包）support（支持包）。(1)JdbcTemplateJdbcTemplate类是Spring JDBC的核心（core）类。JdbcTemplate类的直接父类是JdbcAccessor，该类提供了一些访问数据库时使用的公共属性。DataSource：其主要功能是获取数据库连接，还可以引入对数据库连接的缓冲池和分布式事务的支持，它可以作为访问数据库资源的标准接口。SQLExceptionTranslator： 该接口负责对SQLException进行转译工作。通过必要的设置获取SQLExceptionTranslator中的方法，可以使JdbcTemplate在需要处理SQLException时，委托SQLExceptionTranslator的实现类来完成相关的转译工作。JdbcOperations接口定义了在JdbcTemplate类中可以使用的操作集合继承JdbcAccessor：获取DataSource、SQLExceptionTranslator 属性，能进行数据库连接和异常抛出实现JdbcOperations接口：实现增删改查功能。(2)Spring JDBC配置1.配置数据源dataSource2.配置JDBC模板jdbcTemplate注入数据源3.配置需要实例化的Bean注入JDBC模板1234567891011121314&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;&lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt;&lt;property name="url" value="jdbc:mysql://localhost:3306/javaee"/&gt;&lt;property name="username" value="root"/&gt;&lt;property name="password" value="root"/&gt;&lt;/bean&gt;&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;&lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt;&lt;bean id="xxx" class="Xxx"&gt;&lt;property name="jdbcTemplate" ref="jdbcTemplate"/&gt;&lt;/bean&gt;注意：关于上述示例dataSource配置中的4个属性说明driverClassName：所使用的驱动名称,对应驱动AR包中的 Driver类url：数据源所在地址username：访问数据库的用户名password：访问数据库的密码.dataSource：org.springframework.jdbc.datasource.DriverManagerDataSourcejdbcTemplate:`org.springframework.jdbc.core.JdbcTemplate`dataSource—&gt;注入-jdbcTemplate—&gt;注入-实例化的Beanproperty-placeholder提取数据库配置参数一、问题描述：1、有些参数在某些阶段中是常量，比如：（1）在开发阶段我们连接数据库时的连接url、username、password、driverClass等（2）分布式应用中client端访问server端所用的server地址、port，service等（3）配置文件的位置2、而这些参数在不同阶段之间又往往需要改变，比如：在项目开发阶段和交付阶段数据库的连接信息往往是不同的，分布式应用也是同样的情况。二、期望能不能有一种解决方案可以方便我们在一个阶段内不需要频繁书写一个参数的值，而在不同阶段间又可以方便的切换参数配置信息三、解决spring3中提供了一种简便的方式就是&lt;context:property-placeholder&gt;元素方法一：只需要在spring的配置文件里添加一句：12&lt;!--引入数据库配置信息 --&gt;&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;情况2配置多个12345678 &lt;bean id="propertyConfigure" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:/opt/demo/config/demo-db.properties&lt;/value&gt; &lt;value&gt;classpath:/opt/demo/config/demo-db2.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;即可，这里location值为参数配置文件的位置，参数配置文件通常放在src目录下，而参数配置文件的格式跟java通用的参数配置文件相同，即键值对的形式，例如：12345#jdbc配置test.jdbc.driverClassName=com.mysql.jdbc.Drivertest.jdbc.url=jdbc:mysql://localhost:3306/testtest.jdbc.username=roottest.jdbc.password=root四、应用1.这样一来就可以为spring配置的bean的属性设置值了，比如spring有一个jdbc数据源的类DriverManagerDataSource在配置文件里这么定义bean：1`&lt;bean id=``"testDataSource"` `class``=``"org.springframework.jdbc.datasource.DriverManagerDataSource"``&gt;`` ``&lt;property name=``"driverClassName"` `value=``"$&#123;test.jdbc.driverClassName&#125;"``/&gt;`` ``&lt;property name=``"url"` `value=``"$&#123;test.jdbc.url&#125;"``/&gt;`` ``&lt;property name=``"username"` `value=``"$&#123;test.jdbc.username&#125;"``/&gt;`` ``&lt;property name=``"password"` `value=``"$&#123;test.jdbc.password&#125;"``/&gt;``&lt;/bean&gt;`甚至可以将${ }这种形式的变量用在spring提供的注解当中，为注解的属性提供值其他详阅：spring配置文件引入properties文件：context:property-placeholder标签使用总结(3)jdbcTemplate方法使用Spring JdbcTemplate方法详解execute()方法：可用于执行任何sql语句，但是一般用来执行DDL语句；update()以及batchUpdate()方法：update()方法用来执行增加、修改和删除等语句；batchUpdate()方法用来执行批处理相关的语句；query()以及queryForXxx()：用来执行查询相关的语句；call()方法：用于执行存储过程、函数相关的语句；12345678910111213//1.查询一行数据并返回int型结果 jdbcTemplate.queryForInt("select count(*) from test"); //2. 查询一行数据并将该行数据转换为Map返回 jdbcTemplate.queryForMap("select * from test where name='name5'"); //3.查询一行任何类型的数据，最后一个参数指定返回结果类型 jdbcTemplate.queryForObject("select count(*) from test", Integer.class); //4.查询一批数据，默认将每行数据转换为Map jdbcTemplate.queryForList("select * from test"); //5.只查询一列数据列表，列类型是String类型，列名字是name jdbcTemplate.queryForList(" select name from test where name=?", new Object[]&#123;"name5"&#125;, String.class); //6.查询一批数据，返回为SqlRowSet，类似于ResultSet，但不再绑定到连接上 SqlRowSet rs = jdbcTemplate.queryForRowSet("select * from test");JdbcTemplate类支持的回调类预编译语句及存储过程创建回调：用于根据JdbcTemplate提供的连接创建相应的语句；​ PreparedStatementCreator：通过回调获取JdbcTemplate提供的Connection，由用户使用该Conncetion创建相关的PreparedStatement；​ CallableStatementCreator：通过回调获取JdbcTemplate提供的Connection，由用户使用该Conncetion创建相关的CallableStatement；预编译语句设值回调：用于给预编译语句相应参数设值；​ PreparedStatementSetter：通过回调获取JdbcTemplate提供的PreparedStatement，由用户来对相应的预编译语句相应参数设值；​ BatchPreparedStatementSetter：；类似于PreparedStatementSetter，但用于批处理，需要指定批处理大小；自定义功能回调：提供给用户一个扩展点，用户可以在指定类型的扩展点执行任何数量需要的操作；​ ConnectionCallback：通过回调获取JdbcTemplate提供的Connection，用户可在该Connection执行任何数量的操作；​ StatementCallback：通过回调获取JdbcTemplate提供的Statement，用户可以在该Statement执行任何数量的操作；​ PreparedStatementCallback：通过回调获取JdbcTemplate提供的PreparedStatement，用户可以在该PreparedStatement执行任何数量的操作；​ CallableStatementCallback：通过回调获取JdbcTemplate提供的CallableStatement，用户可以在该CallableStatement执行任何数量的操作；结果集处理回调：通过回调处理ResultSet或将ResultSet转换为需要的形式；​ RowMapper：用于将结果集每行数据转换为需要的类型，用户需实现方法mapRow(ResultSet rs, int rowNum)来完成将每行数据转换为相应的类型。​ RowCallbackHandler：用于处理ResultSet的每一行结果，用户需实现方法processRow(ResultSet rs)来完成处理，在该回调方法中无需执行rs.next()，该操作由JdbcTemplate来执行，用户只需按行获取数据然后处理即可。​ ResultSetExtractor：用于结果集数据提取，用户需实现方法extractData(ResultSet rs)来处理结果集，用户必须处理整个结果集；PreparedStatement和CallableStatement区别 :Statement接口提供了执行语句和获取结果的基本方法， PreparedStatement继承自Statement, 而CallableStatement继承自PreparedStatementPreparedStatement 接口添加了处理 IN 参数的方法CallableStatement 接口添加了处理 OUT 参数的方法PreparedStatement:可变参数的SQL,编译一次,执行多次,效率高;安全性好，有效防止Sql注入等问题;支持批量更新,批量删除;CallableStatement:继承自PreparedStatement,支持带参数的SQL操作;支持调用存储过程,提供了对输出和输入/输出参数(INOUT)的支持;Statement每次执行sql语句，数据库都要执行sql语句的编译 ，最好用于仅执行一次查询并返回结果的情形时，效率高于PreparedStatement。PreparedStatement是预编译的，使用PreparedStatement有几个好处在执行可变参数的一条SQL时，PreparedStatement比Statement的效率高，因为DBMS预编译一条SQL当然会比多次编译一条SQL的效率要高。安全性好，有效防止Sql注入等问题。对于多次重复执行的语句，使用PreparedStament效率会更高一点，并且在这种情况下也比较适合使用batch；代码的可读性和可维护性。注：executeQuery：返回结果集(ResultSet)。executeUpdate: 执行给定SQL语句,该语句可能为 INSERT、UPDATE 或 DELETE 语句， 或者不返回任何内容的SQL语句（如 SQL DDL 语句）。execute: 可用于执行任何SQL语句，返回一个boolean值，表明执行该SQL语句是否返回了ResultSet。如果执行后第一个结果是ResultSet，则返回true，否则返回false。(4)RowMapper的分析解释RowMapper的分析解释RowMapper是什么？怎么用？Spring中JdbcTemplate使用RowMapper(简单明了的代码)sping中的RowMapper可以将数据中的每一行数据封装成用户定义的类。我们在数据库查询中，如果返回的类型是用户自定义的类型(其实我们在数据库查询中大部分返回的都是自定义的类)则需要包装，如果是Java自定义的类型，如：String则不需要。如果sping与hibernate 相结合了,基本上是用不到,大多数都是在spring单独使用时用到，常见的情况就是与JdbcTemplate一起使用。可以通过建立内部类实现RowMapper接口,RowMapper中有一个mapRow方法,所以实现RowMapper接口一定要实现mapRow方法,而对自定义类的包装就在mapRow方法中实现。org.springframework.jdbc.core接口RowMapper所有已知实现类1234567BeanPropertyRowMapper，ColumnMapRowMapper，MappingSqlQueryWithParameters.RowMapperImpl，SingleColumnRowMapper，UpdatableSqlQuery.RowMapperImpl实现mapRow12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.cxl.demo.dao; import java.sql.ResultSet; import java.sql.SQLException; import java.util.List; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.RowMapper; import com.cxl.demo.entity.User; public class UserDaoImpl &#123; private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; public List&lt;User&gt; getUserByName(String username) &#123; String sql = "select * from t_user where username = ?"; Object[] params = new Object[] &#123; username &#125;; List&lt;User&gt; users = null; /** * 使用接口实现类 */ users = jdbcTemplate.query(sql, params, new UserRowMapper()); /** * 使用匿名内部类 * 如果UserRowMapper类只使用一次，单独为其创建一个类多余，可以使用匿名类 * 省略了书写一个实现类 */ users = jdbcTemplate.query(sql, params, new RowMapper&lt;User&gt;() &#123; @Override public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123; User user = new User(); user.setId(rs.getInt("id")); user.setUsername(rs.getString("username")); user.setPassword(rs.getString("password")); return user; &#125; &#125;); return (users != null &amp;&amp; users.size() &gt; 0) ? users : null; &#125; public class UserRowMapper implements RowMapper&lt;User&gt; &#123; @Override public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123; User user = new User(); user.setId(rs.getInt("id")); user.setUsername(rs.getString("username")); user.setPassword(rs.getString("password")); return user; &#125; &#125; &#125;BeanPropertyRowMapperBeanPropertyRowMapper使用注意事项BeanPropertyRowMapper/ParameterizedBeanPropertyRowMapper ，如果PO和数据库模型的字段完全对应（字段名字一样或者驼峰式与下划线式对应），如果使用JdbcTemplate则可以使用这个RowMapper作为PO和数据库的映射2、事务封装Spring用于事务管理的依赖包：spring-tx-4.3.6.RELEASE的JAR包在该JAR包的org.springframework.transaction包中，有3个接口文件PlatformTransactionManager、TransactionDefinition和TransactionStatusPlatformTransactionManager：Spring提供的平台事务管理器，主要用于管理事务。该接口中提供了三个事务操作的方法，具体如下：TransactionStatus getTransaction(TransactionDefinition definition);//用于获取事务状态信息void commit(TransactionStatus status);//用于提交事务void rollback(TransactionStatus status);//用于回滚事务PlatformTransactionManager接口只是代表事务管理的接口，并不知道底层是如何管理事务的，具体如何管理事务则由它的实现类来完成。该接口常见的几个实现类如下补充：多数据源必须用DataSourceTransactionManagerTransactionDefinition：TransactionDefinition接口是事务定义（描述）的对象，该对象中定义了事务规则，并提供了获取事务相关信息的方法事务的传播行为是指在同一个方法中，不同操作前后所使用的事务。传播行为有很多种，具体如下表所示 (“传播”建议理解：事务何时和如何创建)在事务管理过程中，传播行为可以控制是否需要创建事务以及如何创建事务，通常情况下，数据的查询不会影响原数据的改变，所以不需要进行事务管理，而对于数据的插入、更新和删除操作，必须进行事务管理。如果没有指定事务的传播行为，Spring默认传播行为是REQUIRED。TransactionStatus：接口是事务的状态，它描述了某一时间点上事务的状态信息。该接口中包含6个方法，具体如下Spring事务管理分两种方式编程式事务管理通过编写代码实现的事务管理，包括定义事务的开始、正常执行后的事务提交和异常时的事务回滚声明式事务管理通过AOP技术实现的事务管理，主要思想是将事务作为一个“切面”代码单独编写，然后通过AOP技术将事务管理的“切面”植入到业务目标类中声明式事务管理最大的优点在于开发者无需通过编程的方式来管理事务，只需在配置文件中进行相关的事务规则声明，就可以将事务应用到业务逻辑中。这使得开发人员可以更加专注于核心业务逻辑代码的编写，在一定程度上减少了工作量，提高了开发效率，所以在实际开发中，通常都推荐使用声明式事务管理。(1)基于XML方式的声明式事务基于XML方式的声明式事务是在配置文件中通过tx:advice元素配置事务规则来实现的。当配置了事务的增强处理后，就可以通过编写的AOP配置，让Spring自动对目标生成代理。tx:advice元素及其子元素如下图所示配置tx:advice元素的重点是配置tx:method子元素，上图中使用灰色标注的几个属性是tx:method元素中的常用属性。其属性描述具体如下123456789101112131415&lt;bean id="accountDao" class="cn.edu.ccc.ch5.jdbc.AccountDaoImpl"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate" /&gt; &lt;/bean&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="REQUIRED" isolation="DEFAULT" read-only="false" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;aop:pointcut expression="execution(* cn.edu. ch5.jdbc.*.*(..))" id="txPointCut" /&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPointCut" /&gt; &lt;/aop:config&gt;(2) 基于Annotation方式的声明式事务1、在Spring容器中注册事务注解驱动；12345...&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;2、在需要事务管理的类或方法上使用@Transactional注解。如果将注解添加在Bean类上，则表示事务的设置对整个Bean类的所有方法都起作用；如果将注解添加在Bean类中的某个方法上，则表示事务的设置只对该方法有效。使用@Transactional注解时，可以通过参数配置事务详情：例如1@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.DEFAULT, readOnly = false)(3)其他深入一文带你认识Spring事务透彻的掌握 Spring 中 @transactional 的使用]]></content>
      <categories>
        <category>JavaEE程序设计</category>
      </categories>
      <tags>
        <tag>JavaEE程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaEE程序设计【六】]]></title>
    <url>%2Fposts%2Fc76908d2%2F</url>
    <content type="text"><![CDATA[6、Spring实现动态代理（Spring-ProxyFactoryBean）注意：这里是org.aopalliance.intercept.MethodInterceptorCGLib是net.sf.cglib.proxy.MethodInterceptor123public interface MethodInterceptor extends Interceptor &#123; Object invoke(MethodInvocation invocation) throws Throwable;&#125;通过Object ret = invocation.proceed();执行被代理的方法而JDK方式是Object returnValue = method.invoke(target, args);CGLib是proxy.invokeSuper(obj, args)使用ProxyFactoryBean进行AOP第一步:创建一个业务类123456789101112package com.yjc.autoproxys;public class DoSomeServiceImpl &#123; public void doSome() &#123; System.out.println("doSome==============================="); &#125; public void doSome2() &#123; System.out.println("doSome2=========================================="); &#125;&#125;第二步:创建增强类,实现环绕增强要实现的MethodInterceptor 接口,重写invoke123456789101112131415package com.yjc.aroundproxy;import org.aopalliance.intercept.MethodInterceptor;import org.aopalliance.intercept.MethodInvocation;import org.springframework.aop.ThrowsAdvice;public class AroundProxyAdvice implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; System.out.println("前置==============="); //用于启动目标方法执行的 Object proceed = invocation.proceed(); System.out.println("后置==============="); return proceed; &#125;&#125;第三步:在Spring的核心配置文件中实现增强12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!--将增强类和目标业务都放入到Spring容器中--&gt; &lt;bean id="advice" class="com.yjc.aroundproxy.AroundProxyAdvice"&gt;&lt;/bean&gt; &lt;bean id="dosome" class="com.yjc.aroundproxy.DoSome"&gt;&lt;/bean&gt; &lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt; &lt;property name="proxyTargetClass" value="true"/&gt; &lt;property name="interceptorNames" value="advice"/&gt; &lt;!--如果用多种增强方式,value的值使用逗号(,)分割--&gt; &lt;property name="target" ref="dosome"/&gt; &lt;/bean&gt;&lt;/beans&gt;第四步:测试类1234567891011121314package com.yjc.aroundproxy;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AroundProxyTest &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext=new ClassPathXmlApplicationContext("com/yjc/aroundproxy/application_aroundproxy.xml"); DoSome proxyFactory = applicationContext.getBean("proxyFactoryBean", DoSome.class); proxyFactory.doSome(); proxyFactory.doSome2(); &#125;&#125;测试成功1、创建目标类2、创建切面类3、创建代理类实现MethodInterceptor接口，在invoke方法内设置增强import java.lang.reflect.Method;import org.aopalliance.intercept.MethodInterceptor;import org.aopalliance.intercept.MethodInvocation;3、配置Spring XML文件，设置工厂配置目标类bean配置代理类bean配置工厂org.springframework.aop.framework.ProxyFactoryBean必须：配置注入制定目标类：target&lt;property name=&quot;target&quot; ref=&quot;userDao&quot; /&gt;必须：配置目标类实现的接口：proxyInterfaces&lt;property name=&quot;proxyInterfaces&quot; value=&quot;cn.edu.ch3.jdk.IUserDao&quot; /&gt;必须：配置注入代理实现类：interceptorNames&lt;property name=&quot;interceptorNames&quot; value=&quot;myAspect&quot; /&gt;配置实现方式proxyTargetClass：true：使用 cglib，false(默认)：使用 jdk 动态代理&lt;property name=&quot;proxyTargetClass&quot; value=&quot;true&quot; /&gt;4、通过getBean获取对象，执行方法12345678&gt; String xmlPath = "applicationContext.xml";&gt; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath);&gt; // 从Spring容器获得内容&gt; IUserDao userDao = (IUserDao) applicationContext.getBean("userDaoProxy");&gt; // 执行方法&gt; userDao.addUser();&gt; userDao.deleteUser();&gt;7、AspectJSpring AOP,AspectJ, CGLIB 有点晕浅谈AOP以及AspectJ和Spring AOP漫谈AOP开发之初探AOP及AspectJ的用法Spring AOP也是对目标类增强，生成代理类。但是与AspectJ的最大区别在于—Spring AOP的运行时增强，而AspectJ是编译时增强。曾经以为AspectJ是Spring AOP一部分，是因为Spring AOP使用了AspectJ的Annotation。使用了Aspect来定义切面,使用Pointcut来定义切入点，使用Advice来定义增强处理。虽然使用了Aspect的Annotation，但是并没有使用它的编译器和织入器。其实现原理是JDK 动态代理，在运行时生成代理类。为了启用 Spring 对 @AspectJ 方面配置的支持，并保证 Spring 容器中的目标 Bean 被一个或多个方面自动增强，必须在 Spring 配置文件中添加如下配置&lt;aop:aspectj-autoproxy/&gt;当启动了 @AspectJ 支持后，在 Spring 容器中配置一个带 @Aspect 注释的 Bean，Spring 将会自动识别该 Bean，并将该 Bean 作为方面 Bean 处理。方面Bean与普通 Bean 没有任何区别，一样使用 &lt;bean…/&gt; 元素进行配置，一样支持使用依赖注入来配置属性值。AspectAspect被翻译方面或者切面，相当于OOP中的类，就是封装用于横插入系统的功能。例如日志、事务、安全验证等。JoinPointJoinPoint(连接点)是AOP中的一个重要的关键概念。JoinPoint可以看做是程序运行时的一个执行点。打个比方，比如执行System.out.println(“Hello”)这个函数，println()就是一个joinpoint；再如给一个变量赋值也是一个joinpoint；还有最常用的for循环，也是一个joinpoint。理论上说，一个程序中很多地方都可以被看做是JoinPoint，但是AspectJ中，只有下面所示的几种执行点被认为是JoinPoint：Pointcuts怎么从一堆一堆的JPoints中选择自己想要的JPoints呢？恩，这就是Pointcuts的功能。一句话，Pointcuts的目标是提供一种方法使得开发者能够选择自己感兴趣的JoinPointsadvice（处理逻辑）advice通知或者增强(Advisor)是我们切面功能的实现，它是切点的真正执行的地方。比如像写日志到一个文件中，advice（包括：before、after、around等）在jointpoint处插入代码到应用程序中。我们来看一看原AspectJ程序和反编译过后的程序。看完下面的图我们就大概明白了AspectJ是如何达到监控源程序的信息了。关键词说明示例before()before advice表示在JPoint执行之前，需要干的事情after()after advice表示JPoint自己执行完了后，需要干的事情。after():returning(返回值类型)after():throwing(异常类型)returning和throwing后面都可以指定具体的类型，如果不指定的话则匹配的时候不限定类型假设JPoint是一个函数调用的话，那么函数调用执行完有两种方式退出，一个是正常的return，另外一个是抛异常。 注意，after()默认包括returning和throwing两种情况返回值类型 around()before和around是指JPoint执行前或执行后备触发，而around就替代了原JPointaround是替代了原JPoint，如果要执行原JPoint的话，需要调用proceedTargetTarget指的是需要切入的目标类或者目标接口。ProxyProxy是代理，AOP工作时是通过代理对象来访问目标对象。其实AOP的实现是通过动态代理，离不开代理模式，所以必须要有一个代理对象。WeavingWeaving即织入，在目标对象中插入切面代码的过程就叫做织入。（1）Spring AOP与Aspect当你不用Spring AOP提供的注解时，Spring AOP和AspectJ没半毛钱的关系，前者是JDK动态代理，用到了CGLIB(Code Generation Library)，CGLIB是一个代码生成类库，可以在运行时候动态是生成某个类的子类。代理模式为要访问的目标对象提供了一种途径，当访问对象时，它引入了一个间接的层。后者是静态代理，在编译阶段就已经编译到字节码文件中。当你用到Spring AOP提供的注入@Before、@After等注解时，Spring AOP和AspectJ就有了关系。在开发中引入了org.aspectj:aspectjrt:1.6.11和org.aspectj:aspectjweaver:1.6.11两个包，这是因为Spring AOP使用了AspectJ的Annotation，使用了Aspect来定义切面,使用Pointcut来定义切入点，使用Advice来定义增强处理。虽然Spring AOP使用了Aspect的Annotation，但是并没有使用它的编译器和织入器。Spring AOP其实现原理是JDK动态代理，在运行时生成代理类。为了启用Spring对@AspectJ切面配置的支持，并保证Spring容器中的目标Bean被一个或多个切面自动增强，必须在Spring配置文件中添加如下配置1&lt;aop:aspectj-autoproxy/&gt;当启动了@AspectJ支持后，在Spring容器中配置一个带@Aspect注释的Bean，Spring将会自动识别该 Bean，并将该Bean作为切面Bean处理。切面Bean与普通Bean没有任何区别，一样使用&lt;bean.../&gt;元素进行配置，一样支持使用依赖注入来配置属性值。AspectJ和Spring AOP都是对目标类增强，生成代理类。AspectJ是在编译期间将切面代码编译到目标代码的，属于静态代理；Spring AOP是在运行期间通过代理生成目标类，属于动态代理。AspectJ是静态代理，故而能够切入final修饰的类，abstract修饰的类；Spring AOP是动态代理，其实现原理是通过CGLIB生成一个继承了目标类(委托类)的代理类，因此，final修饰的类不能被代理，同样static和final修饰的方法也不会代理，因为static和final方法是不能被覆盖的。在CGLIB底层，其实是借助了ASM这个非常强大的Java字节码生成框架。关于CGLB和ASM的讨论将会新开一个篇幅探讨。Spring AOP支持注解，在使用@Aspect注解创建和配置切面时将更加方便。而使用AspectJ，需要通过.aj文件来创建切面，并且需要使用ajc（Aspect编译器）来编译代码。​ 在Spring 2.0中，Pointcut的定义包括两个部分：Pointcut表示式(expression)和Pointcut签名(signature)123456//Pointcut表示式@Pointcut("execution(* com.savage.aop.MessageSender.*(..))")//Point签名private void log()&#123;&#125; 然后要使用所定义的Pointcut时，可以指定Pointcut签名如下：@Before("log()")这种使用方式等同于以下方式，直接定义execution表达式使用1@Before("execution(* com.savage.aop.MessageSender.*(..))")（2）Spring AOP中Aspect的XML方式使用Spring - AOP基于XML(aop:aspect)1、定义目标类接口12345678910public interface CustomerBo &#123; void addCustomer(); String addCustomerReturnValue(); void addCustomerThrowException() throws Exception; void addCustomerAround(String name);&#125;2、实现目标类12345678910111213141516171819202122232425public class CustomerBoImpl implements CustomerBo&#123; @Override public void addCustomer() &#123; System.out.println("addCustomer() is running"); &#125; @Override public String addCustomerReturnValue() &#123; System.out.println("addCustomerReturnValue() is running"); return "abc"; &#125; @Override public void addCustomerThrowException() throws Exception &#123; System.out.println("addCustomerThrowException() is running"); throw new Exception("Error"); &#125; @Override public void addCustomerAround(String name) &#123; System.out.println("addCustomerAround() is running, args: " + name); &#125; &#125;3、定义切面类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.ray.aspect; import java.util.Arrays; import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint; public class LoggingAspect &#123; public void logBefore(JoinPoint joinPoint) &#123; System.out.println("logBefore() is running!"); System.out.println("getName() : " + joinPoint.getSignature().getName()); System.out.println("******"); &#125; public void logAfter(JoinPoint joinPoint) &#123; System.out.println("logAfter() is running!"); System.out.println("getName() : " + joinPoint.getSignature().getName()); System.out.println("******"); &#125; public void logAfterReturning(JoinPoint joinPoint, Object result) &#123; System.out.println("logAfterReturning() is running!"); System.out.println("getName() : " + joinPoint.getSignature().getName()); System.out.println("Method returned value is : " + result); System.out.println("******"); &#125; public void logAfterThrowing(JoinPoint joinPoint, Throwable error) &#123; System.out.println("logAfterThrowing() is running!"); System.out.println("getName() : " + joinPoint.getSignature().getName()); System.out.println("Exception : " + error); System.out.println("******"); &#125; public void logAround(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println("logAround() is running!"); System.out.println("getName() : " + joinPoint.getSignature().getName()); System.out.println("getArgs() : " + Arrays.toString(joinPoint.getArgs())); System.out.println("Around before is running!"); joinPoint.proceed(); System.out.println("Around after is running!"); System.out.println("******"); &#125; &#125;4、配置XML(1)开启Aspect注解&lt;aop:aspectj-autoproxy/&gt;（XML方式非必须）(2)引入目标类、切面类的BEAN(3)配置切入①&lt;aop:config&gt;&lt;/aop:config&gt;引入配置区域②&lt;aop:aspect id=&quot;aspectLoggging&quot; ref=&quot;logAspect&quot; &gt; &lt;/aop:aspect&gt;引入各个切面的配置（可设置多个）③&lt;aop:pointcut id=&quot;pointCutBefore&quot; expression=&quot;execution(* com.ray.customer.bo.CustomerBo.addCustomer(..))&quot; /&gt;引入切点④&lt;aop:after method=&quot;logAfter&quot; pointcut-ref=&quot;pointCutAfter&quot; /&gt;设置增强方式和增强方法，注意切点引用，说明在哪个切点织入增强12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;bean id="customerBo" class="com.ray.customer.bo.impl.CustomerBoImpl"/&gt; &lt;!-- Aspect --&gt; &lt;bean id="logAspect" class="com.ray.aspect.LoggingAspect"/&gt; &lt;aop:config&gt; &lt;aop:aspect id="aspectLoggging" ref="logAspect" &gt; &lt;!-- @Before --&gt; &lt;aop:pointcut id="pointCutBefore" expression="execution(* com.ray.customer.bo.CustomerBo.addCustomer(..))" /&gt; &lt;aop:before method="logBefore" pointcut-ref="pointCutBefore" /&gt; &lt;!-- @After --&gt; &lt;aop:pointcut id="pointCutAfter" expression="execution(* com.ray.customer.bo.CustomerBo.addCustomer(..))" /&gt; &lt;aop:after method="logAfter" pointcut-ref="pointCutAfter" /&gt; &lt;!-- @AfterReturning --&gt; &lt;aop:pointcut id="pointCutAfterReturning" expression="execution(* com.ray.customer.bo.CustomerBo.addCustomerReturnValue(..))" /&gt; &lt;aop:after-returning method="logAfterReturning" returning="result" pointcut-ref="pointCutAfterReturning" /&gt; &lt;!-- @AfterThrowing --&gt; &lt;aop:pointcut id="pointCutAfterThrowing" expression="execution(* com.ray.customer.bo.CustomerBo.addCustomerThrowException(..))" /&gt; &lt;aop:after-throwing method="logAfterThrowing" throwing="error" pointcut-ref="pointCutAfterThrowing" /&gt; &lt;!-- @Around --&gt; &lt;aop:pointcut id="pointCutAround" expression="execution(* com.ray.customer.bo.CustomerBo.addCustomerAround(..))" /&gt; &lt;aop:around method="logAround" pointcut-ref="pointCutAround" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt;5、获取bean并测试1234567891011121314151617181920212223package com.ray.test; import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; import com.ray.customer.bo.CustomerBo; public class Test &#123; public static void main(String[] args) throws Exception &#123; ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml"); CustomerBo customer = (CustomerBo) context.getBean("customerBo"); // customer.addCustomer(); // customer.addCustomerReturnValue(); // customer.addCustomerThrowException(); customer.addCustomerAround("ray"); &#125;&#125;注意：AspectJ方式不要求必须是实现接口的类，实现接口不实现接口都行，我们编程经常面向接口，所以以实现了接口为例1、定义目标类接口2、实现目标类3、定义切面类4、配置XML(1)开启Aspect注解&lt;aop:aspectj-autoproxy/&gt;(2)引入目标类、切面类的BEAN(3)配置切入①&lt;aop:config&gt;&lt;/aop:config&gt;引入配置区域②&lt;aop:aspect id=&quot;aspectLoggging&quot; ref=&quot;logAspect&quot; &gt; &lt;/aop:aspect&gt;引入各个切面的配置（可设置多个）③&lt;aop:pointcut id=&quot;pointCutBefore&quot; expression=&quot;execution(* com.ray.customer.bo.CustomerBo.addCustomer(..))&quot; /&gt;引入切点④&lt;aop:after method=&quot;logAfter&quot; pointcut-ref=&quot;pointCutAfter&quot; /&gt;设置增强方式和增强方法，注意切点引用5、获取bean并测试（3）Spring AOP中Aspect的注解方式使用注意：AspectJ方式不要求必须是实现接口的类，实现接口不实现接口都行，我们编程经常面向接口，所以以实现了接口为例1、定义目标类接口2、实现目标类3、定义切面类4、配置注解(1)XML文件中开启Aspect注解&lt;aop:aspectj-autoproxy/&gt;(2)、声明Aspect是一个切面,以及声明为组件使得能够被SpringIOC识别装配@Aspect @Component(3)、使用一个无返回值空方法声明切点(4)、在各个方法前配置增强方式5、获取bean并测试接口1234public interface IUserDao &#123; public void addUser(); public void deleteUser();&#125;目标方法：12345678910111213141516@Repository("userDao")public class UserDaoImpl implements IUserDao&#123; @Override public void addUser() &#123; // TODO Auto-generated method stub System.out.println("添加用户"); &#125; @Override public void deleteUser() &#123; // TODO Auto-generated method stub System.out.println("删除用户"); &#125;&#125;切面：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;/** * 切面类，在此类中编写通知 */@Aspect@Componentpublic class MyAspect &#123; // 定义切入点表达式 @Pointcut("execution(* cn.edu.ccc.ch3.jdk.*.*(..))") // 使用一个返回值为 void、方法体为空的方法来命名切入点 private void myPointCut() &#123; &#125; // 前置通知 @Before("myPointCut()") public void myBefore(JoinPoint joinPoint) &#123; System.out.print("前置通知 ：模拟执行权限检查...,"); System.out.print("目标类是：" + joinPoint.getTarget()); System.out.println(",被织入增强处理的目标方法为：" + joinPoint.getSignature().getName()); &#125; // 后置通知 @AfterReturning(value = "myPointCut()") public void myAfterReturning(JoinPoint joinPoint) &#123; System.out.print("后置通知：模拟记录日志...,"); System.out.println("被织入增强处理的目标方法为：" + joinPoint.getSignature().getName()); &#125; // 环绕通知 @Around("myPointCut()") public Object myAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; // 开始 System.out.println("环绕开始：执行目标方法之前，模拟开启事务..."); // 执行当前目标方法 Object obj = proceedingJoinPoint.proceed(); // 结束 System.out.println("环绕结束：执行目标方法之后，模拟关闭事务..."); return obj; &#125; // 异常通知 @AfterThrowing(value = "myPointCut()", throwing = "e") public void myAfterThrowing(JoinPoint joinPoint, Throwable e) &#123; System.out.println("异常通知：" + "出错了" + e.getMessage()); &#125; // 最终通知 @After("myPointCut()") public void myAfter() &#123; System.out.println("最终通知：模拟方法结束后的释放资源..."); &#125;&#125;①关于空方法定义切点在Spring 2.0中，Pointcut的定义包括两个部分：Pointcut表示式(expression)和Pointcut签名(signature)123456//Pointcut表示式@Pointcut("execution(* com.savage.aop.MessageSender.*(..))")//Point签名private void log()&#123;&#125; 然后要使用所定义的Pointcut时，可以指定Pointcut签名如下：@Before("og()")这种使用方式等同于以下方式，直接定义execution表达式使用1@Before("execution(* com.savage.aop.MessageSender.*(..))")Spring AOP只支持以Spring Bean的方法执行组作为连接点，所以可以把切入点看作所有能和切入表达式匹配的Bean方法。切入点定义包含两个部分：一个切入点表达式：用于指定切入点和哪些方法进行匹配一个包含名字和任意参数的方法签名：将作为切入点的名称​ 在@AspectJ风格的AOP中，切入点签名采用一个普通的方法定义（方法体通常为空）来提供（方法名即为切点名），且该方法的返回值必须为void，切入点表达式需使用@Pointcut注解来标注。下面的代码片段定义了一个切入点，这个切入点将匹配任何名为transfer的方法的执行：12&gt; `//使用@Pointcut注解时指定切入点表达式` `@Pointcut``(``&quot;execution(* transfer(..))&quot;``)` `//使用一个返回值为void，方法体为空的方法来命名切入点，方法名即为切点名` `private` `void` `myPointcut()&#123;&#125;` &gt;​ 切入点表达式，也就是组成@Pointcut注解的值，是规范的AspectJ 5切入点表达式。如果想要了解更多的关于AspectJ切入点语言，请参见AspectJ编程指南。Spring中的AOP（六）——定义切入点和切入点指示符②关于proceedingJoinPointJoinPoint对象封装了SpringAop中切面方法的信息,在切面方法中添加JoinPoint参数,就可以获取到封装了该方法信息的JoinPoint对象.常用API方法名功能Signature getSignature();获取封装了署名信息的对象,在该对象中可以获取到目标方法名,所属类的Class等信息Object[] getArgs();获取传入目标方法的参数对象Object getTarget();获取被代理的对象Object getThis();获取代理对象③ProceedingJoinPoint对象ProceedingJoinPoint对象是JoinPoint的子接口,该对象只用在@Around的切面方法中,添加了以下两个方法。添加了以下两个方法。12Object proceed() throws Throwable //执行目标方法 Object proceed(Object[] var1) throws Throwable //传入的新的参数去执行目标方法Spring AOP中JoinPoint的用法]]></content>
      <categories>
        <category>JavaEE程序设计</category>
      </categories>
      <tags>
        <tag>JavaEE程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaEE程序设计【五】]]></title>
    <url>%2Fposts%2Fa267430b%2F</url>
    <content type="text"><![CDATA[2、原理了解：动态代理（JDK实现）深入AOP开发的基石-java动态代理动态代理利用了JDK API，动态地在内存中构建代理对象，从而实现对目标对象的代理功能。动态代理又被称为JDK代理或接口代理。静态代理与动态代理的区别主要在：静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中Java字节码文件，不一定在本地硬盘上，可以是网络资源，可以是内存中的资源，只要能够获取到就行。而JDK动态生成的代理，命名为$Proxy0或者$Proxy1 即$Proxy+num。不会显示在我们的硬盘文件中，而是在内存中动态生成，我们在开发文件夹下找不到。命名原码：类生成的源头：byte数组内 就是代理类字节码文件了。再配合类加载器等其他内容通过方法生成类。但是如何生成字节码文件的方法无法继续向下查询了。因为JDK1.6开始，相关原码不再有了。想查看可以去下载openJDK为了便于深入理解，经过使用特定方法，将其保存到硬盘后查看生成的代理：h是InvocationHandler，来自父类Proxy构造生成m3是反射生成的方法特点：动态代理对象不需要实现接口，但是要求目标对象必须实现接口，否则不能使用动态代理。JDK中生成代理对象主要涉及的类有java.lang.reflect Proxy，主要方法为12345static Object newProxyInstance(ClassLoader loader, //指定当前目标对象使用类加载器 Class&lt;?&gt;[] interfaces, //目标对象实现的接口的类型 InvocationHandler h //事件处理器) //返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。关于为何需要类加载器，因为动态生成字节码，需要相应的加载器Java反射什么是反射反射(Reflection)是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。通过反射机制，可以在运行时访问 Java 对象的属性，方法，构造方法等。类加载的完整过程如下：在编译时，Java 编译器编译好 .java 文件之后，在磁盘中产生 .class 文件。.class 文件是二进制文件，内容是只有 JVM 能够识别的机器码。JVM 中的类加载器读取字节码文件，取出二进制数据，加载到内存中，解析.class 文件内的信息。类加载器会根据类的全限定名来获取此类的二进制字节流；然后，将字节流所代表的静态存储结构转化为方法区的运行时数据结构；接着，在内存中生成代表这个类的 java.lang.Class 对象。加载结束后，JVM 开始进行连接阶段（包含验证、准备、初始化）。经过这一系列操作，类的变量会被初始化。Class 对象要想使用反射，首先需要获得待操作的类所对应的 Class 对象。Java 中，无论生成某个类的多少个对象，这些对象都会对应于同一个 Class 对象。这个 Class 对象是由 JVM 生成的，通过它能够获悉整个类的结构。所以，java.lang.Class 可以视为所有反射 API 的入口点。反射的本质就是：在运行时，把 Java 类中的各种成分映射成一个个的 Java 对象。举例来说，假如定义了以下代码：12&gt; User user = new User(); &gt;步骤说明：JVM 加载方法的时候，遇到 new User()，JVM 会根据 User 的全限定名去加载 User.class 。JVM 会去本地磁盘查找 User.class 文件并加载 JVM 内存中。JVM 通过调用类加载器自动创建这个类对应的 Class 对象，并且存储在 JVM 的方法区。注意：一个类有且只有一个 Class 对象。其它都是以它为根基创建的java.lang.reflect InvocationHandler，主要方法为1234 Object invoke(Object proxy, //被代理后的对象 Method method, //使用的方法 Object[] args) //方法的参数// 在代理实例上处理方法调用并返回结果。​ 例：保存用户功能的动态代理实现接口类： IUserDao12345package com.proxy;public interface IUserDao &#123; public void save();&#125;目标对象：UserDao123456789package com.proxy;public class UserDao implements IUserDao&#123; @Override public void save() &#123; System.out.println("保存数据"); &#125;&#125;动态代理对象：UserProxyFactory1234567891011121314151617181920212223242526272829303132package com.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyFactory &#123; private Object target;// 维护一个目标对象 public ProxyFactory(Object target) &#123; this.target = target; &#125; // 为目标对象生成代理对象 public Object getProxyInstance() &#123; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("开启事务"); // 执行目标对象方法 Object returnValue = method.invoke(target, args); System.out.println("提交事务"); return null; &#125; &#125;); &#125;&#125;测试类：TestProxy123456789101112131415package com.proxy;import org.junit.Test;public class TestProxy &#123; @Test public void testDynamicProxy ()&#123; IUserDao target = new UserDao(); System.out.println(target.getClass()); //输出目标对象信息 IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance(); System.out.println(proxy.getClass()); //输出代理对象信息 proxy.save(); //执行代理方法 &#125;&#125;输出结果12345class com.proxy.UserDaoclass com.sun.proxy.$Proxy4开启事务保存数据提交事务1、创建接口2、实现接口来创建目标类3、创建切面类4、实现InvocationHandler接口import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;(1)声明目标类作为私有成员，并且实现构造方法12345&gt; private IUserDao userDao;&gt; public JdkProxy(IUserDao userDao) &#123;&gt; this.userDao = userDao;&gt; &#125;&gt;(2)实现其中的invoke方法(调用切面类中的方法增强)12345678910111213&gt; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;&gt; // TODO Auto-generated method stub&gt; // 声明切面&gt; MyAspect myAspect = new MyAspect();&gt; // 前增强&gt; myAspect.check_Permissions();&gt; // 在目标类上调用方法，并传入参数&gt; Object obj = method.invoke(userDao, args);&gt; // 后增强&gt; myAspect.log();&gt; return obj;&gt; &#125;&gt;(3)创建获取增强代理实例的方法[也可以在使用中获取但是麻烦。]1234567&gt; public Object createProxy() &#123;&gt; // 参数1.类加载器&gt; // 参数2.被代理对象实现的所有接口&gt; // 参数3.使用代理类，进行增强，返回的是代理后的对象&gt; return Proxy.newProxyInstance(JdkProxy.class.getClassLoader(), userDao.getClass().getInterfaces(), this);&gt; &#125;&gt;&lt;font size=4 color=red&gt;**PS：可以调整构造函数的功能到createProxy中，减少工作量**&lt;/font&gt;5、使用(1)、获取目标类实例对象(2)、获取实现增强接口的代理实例对象(3)、通过代理实例对象的方法获取增强后目标类的对象目标对象——&gt;代理获取目标对象——&gt;产生增强目标对象——&gt;投入使用4、原理了解：动态代理（CGLib实现）源码详解系列(一)——cglib动态代理的使用和分析Cglib及其基本使用cglib (Code Generation Library )是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。cglib特点JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口。如果想代理没有实现接口的类，就可以使用CGLIB实现。CGLIB是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它需要你对JVM内部结构包括class文件的格式和指令集都很熟悉。cglib与动态代理最大的区别就是使用动态代理的对象必须实现一个或多个接口使用cglib代理的对象则无需实现接口，达到代理类无侵入。CGLIB动态代理能够实现基于方法级别的拦截处理CGLib动态代理执行方法,不是使用反射执行 Method.invoke()使用cglib需要引入cglib的jar包，如果你已经有spring-core的jar包，则无需引入，因为spring中包含了cglib。cglib的Maven坐标12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.5&lt;/version&gt;&lt;/dependency&gt;主要步骤1、创建目标类2、创建切面类3、实现MethodInterceptor接口，创建代理类import java.lang.reflect.Method;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy;（1）实现intercept方法，调用切面类方法进行增强4、通过使用Enhancer对象获取增强代理对象创建Enhancer对象：Enhancer是cglib代理的对外接口，以下操作都是调用这个类的方法setSuperclass(Class superclass)：代理谁？setCallback(final Callback callback)：怎么代理？（我们需要实现Callback的子接口MethodInterceptor，重写其中的intercept方法，该方法定义了代理规则)create()：获得代理类使用代理类目标对象：UserDao12345678package com.cglib;public class UserDao&#123; public void save() &#123; System.out.println("保存数据"); &#125;&#125;代理对象：ProxyFactory123456789101112131415161718192021222324252627282930313233343536package com.cglib;import java.lang.reflect.Method;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;public class ProxyFactory implements MethodInterceptor&#123; private Object target;//维护一个目标对象 public ProxyFactory(Object target) &#123; this.target = target; &#125; //为目标对象生成代理对象 public Object getProxyInstance() &#123; //工具类 Enhancer en = new Enhancer(); //设置父类 en.setSuperclass(target.getClass()); //设置回调函数 en.setCallback(this); //创建子类对象代理 return en.create(); &#125; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println("开启事务"); // 执行目标对象的方法 Object returnValue = method.invoke(target, args); System.out.println("关闭事务"); return null; &#125;&#125;函数参数信息Object表示要进行增强的对象Method表示拦截的方法Object[]数组表示参数列表，基本数据类型需要传入其包装类型，如int–&gt;Integer、long-Long、double–&gt;DoubleMethodProxy表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用测试类：TestProxy123456789101112131415161718package com.cglib;import org.junit.Test;public class TestProxy &#123; @Test public void testCglibProxy()&#123; //目标对象 UserDao target = new UserDao(); System.out.println(target.getClass()); //代理对象 UserDao proxy = (UserDao) new ProxyFactory(target).getProxyInstance(); System.out.println(proxy.getClass()); //执行代理对象方法 proxy.save(); &#125;&#125;输出结果12345class com.cglib.UserDaoclass com.cglib.UserDao$$EnhancerByCGLIB$$552188b6开启事务保存数据关闭事务关于为什么要用.getClass:java中getClass()方法简介CGLIB动态代理getClass()方法的作用获得了Person这个(类)Class，进而通过返回的Class对象获取Person的相关信息，比如：获取Person的构造方法，方法，属性有哪些等等信息。创建对象： Person p = new Person(1,”刘德华”);返回Class类型的对象： Class c = p.getClass();此时c是Class类型，Class提供了一系列的方法来获取类的相关信息，可以通过对象c来获取Person的信息。比如，获取Person这个类的类名：String perName = c.getName();本质还是反射例2：首先实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。然后在需要使用HelloConcrete的时候，通过CGLIB动态代理获取代理对象。1234567891011121314151617// CGLIB动态代理// 1. 首先实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。class MyMethodInterceptor implements MethodInterceptor&#123; ... @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; logger.info("You said: " + Arrays.toString(args)); return proxy.invokeSuper(obj, args); &#125;&#125;// 2. 然后在需要使用HelloConcrete的时候，通过CGLIB动态代理获取代理对象。Enhancer enhancer = new Enhancer();enhancer.setSuperclass(HelloConcrete.class);enhancer.setCallback(new MyMethodInterceptor());HelloConcrete hello = (HelloConcrete)enhancer.create();System.out.println(hello.sayHello("I love you!"));运行上述代码输出结果：12日志信息: You said: [I love you!]HelloConcrete: I love you!上述代码中，我们通过CGLIB的Enhancer来指定要代理的目标对象、实际处理代理逻辑的对象，最终通过调用create()方法得到代理对象，对这个对象所有非final方法的调用都会转发给MethodInterceptor.intercept()方法，在intercept()方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等；通过调用MethodProxy.invokeSuper()方法，我们将调用转发给原始对象，具体到本例，就是HelloConcrete的具体方法。CGLIG中MethodInterceptor的作用跟JDK代理中的InvocationHandler很类似，都是方法调用的中转站。注意：对于从Object中继承的方法，CGLIB代理也会进行代理，如hashCode()、equals()、toString()等，但是getClass()、wait()等方法不会，因为它是final方法，CGLIB无法代理。如果对CGLIB代理之后的对象类型进行深挖，可以看到如下信息：123456# HelloConcrete代理对象的类型信息class=class cglib.HelloConcrete$$EnhancerByCGLIB$$e3734e52superClass=class lh.HelloConcreteinterfaces: interface net.sf.cglib.proxy.FactoryinvocationHandler=not java proxy class我们看到使用CGLIB代理之后的对象类型是cglib.HelloConcrete$$EnhancerByCGLIB$$e3734e52，这是CGLIB动态生成的类型；父类是HelloConcrete，印证了CGLIB是通过继承实现代理；同时实现了net.sf.cglib.proxy.Factory接口，这个接口是CGLIB自己加入的，包含一些工具方法。注意，既然是继承就不得不考虑final的问题。我们知道final类型不能有子类，所以CGLIB不能代理final类型，遇到这种情况会抛出类似如下异常：12&gt; java.lang.IllegalArgumentException: Cannot subclass final class cglib.HelloConcrete&gt;同样的，final方法是不能重载的，所以也不能通过CGLIB代理，遇到这种情况不会抛异常，而是会跳过final方法只代理其他方法。如果你还对代理类cglib.HelloConcrete$$EnhancerByCGLIB$$e3734e52具体实现感兴趣，它大致长这个样子：123456789101112131415161718192021222324// CGLIB代理类具体实现public class HelloConcrete$$EnhancerByCGLIB$$e3734e52 extends HelloConcrete implements Factory&#123; ... private MethodInterceptor CGLIB$CALLBACK_0; // ~~ ... public final String sayHello(String paramString) &#123; ... MethodInterceptor tmp17_14 = CGLIB$CALLBACK_0; if (tmp17_14 != null) &#123; // 将请求转发给MethodInterceptor.intercept()方法。 return (String)tmp17_14.intercept(this, CGLIB$sayHello$0$Method, new Object[] &#123; paramString &#125;, CGLIB$sayHello$0$Proxy); &#125; return super.sayHello(paramString); &#125; ...&#125;上述代码我们看到，当调用代理对象的sayHello()方法时，首先会尝试转发给MethodInterceptor.intercept()方法，如果没有MethodInterceptor就执行父类的sayHello()。这些逻辑没什么复杂之处，但是他们是在运行时动态产生的，无需我们手动编写。5、JDK和CGLib动态代理对比JDK动态代理主要涉及java.lang.reflect包下边的两个类：Proxy和InvocationHandler。其中，InvocationHandler是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑贬值在一起。JDK动态代理的话，他有一个限制，就是它只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，如何创建动态代理实例哪？答案就是CGLib。CGLib采用底层的字节码技术，全称是：Code Generation Library，CGLib可以为一个类创建一个子类，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑。1、JDK动态代理具体实现原理：通过实现InvocationHandlet接口创建自己的调用处理器；通过为Proxy类指定ClassLoader对象和一组interface来创建动态代理；通过反射机制获取动态代理类的构造函数，其唯一参数类型就是调用处理器接口类型；通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数参入；JDK动态代理是面向接口的代理模式，如果被代理目标没有接口那么Spring也无能为力，Spring通过Java的反射机制生产被代理接口的新的匿名实现类，重写了其中AOP的增强方法。2、CGLib动态代理：CGLib是一个强大、高性能的Code生产类库，可以实现运行期动态扩展java类，Spring在运行期间通过 CGlib继承要被动态代理的类，重写父类的方法，实现AOP面向切面编程呢。3、两者对比：JDK动态代理是面向接口的。CGLib动态代理是通过字节码底层继承要代理类来实现（如果被代理类被final关键字所修饰，那么抱歉会失败）。4、使用注意：如果要被代理的对象是个实现类，那么Spring会使用JDK动态代理来完成操作（Spirng默认采用JDK动态代理实现机制）；如果要被代理的对象不是个实现类那么，Spring会强制使用CGLib来实现动态代理。]]></content>
      <categories>
        <category>JavaEE程序设计</category>
      </categories>
      <tags>
        <tag>JavaEE程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaEE程序设计【四】]]></title>
    <url>%2Fposts%2Fcdf9864c%2F</url>
    <content type="text"><![CDATA[四、Spring-AOPSpring AOP中的JDK和CGLib动态代理哪个效率更高？深入理解 Java 反射和动态代理Spring AOP 扫盲1、AOP(Aspect Oriented Program )面向切面编程首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。所谓的核心业务，比如登陆，增加数据，删除数据都叫核心业务所谓的周边功能，比如性能统计，日志，事务管理等等周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOPAOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。(1)AOP的一些概念切面(Aspect)： Aspect 声明类似于 Java 中的类声明，事务管理是AOP一个最典型的应用。在AOP中，切面一般使用 @Aspect 注解来使用，在XML 中，可以使用 &lt;aop:aspect&gt; 来定义一个切面。连接点(Join Point): 一个在程序执行期间的某一个操作，就像是执行一个方法或者处理一个异常。在Spring AOP中，一个连接点就代表了一个方法的执行。通知(Advice):在切面中(类)的某个连接点(方法出)采取的动作，会有四种不同的通知方式： around(环绕通知)，before(前置通知)，after(后置通知)， exception(异常通知)，return(返回通知)。许多AOP框架（包括Spring）将建议把通知作为为拦截器，并在连接点周围维护一系列拦截器。切入点(Pointcut):表示一组连接点，通知与切入点表达式有关，并在切入点匹配的任何连接点处运行(例如执行具有特定名称的方法)。由切入点表达式匹配的连接点的概念是AOP的核心，Spring默认使用AspectJ切入点表达式语言。介绍(Introduction): introduction可以为原有的对象增加新的属性和方法。例如，你可以使用introduction使bean实现IsModified接口，以简化缓存。目标对象(Target Object): 由一个或者多个切面代理的对象。也被称为”切面对象”。由于Spring AOP是使用运行时代理实现的，因此该对象始终是代理对象。AOP代理(AOP proxy): 由AOP框架创建的对象，在Spring框架中，AOP代理对象有两种：JDK动态代理和CGLIB代理织入(Weaving): 是指把增强应用到目标对象来创建新的代理对象的过程，它(例如 AspectJ 编译器)可以在编译时期，加载时期或者运行时期完成。与其他纯Java AOP框架一样，Spring AOP在运行时进行织入。(2)Spring AOP 中通知的分类(3)Spring AOP 中织入的三种时期编译期: 切面在目标类编译时被织入，这种方式需要特殊的编译器。AspectJ 的织入编译器就是以这种方式织入切面的。类加载期: 切面在目标类加载到 JVM 时被织入，这种方式需要特殊的类加载器( ClassLoader )，它可以在目标类引入应用之前增强目标类的字节码。运行期: 切面在应用运行的某个时期被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态创建一个代理对象，Spring AOP 采用的就是这种织入方式。(4)AOP 的两种实现方式AOP 采用了两种实现方式：静态织入(AspectJ 实现)和动态代理(Spring AOP实现)Spring AOP 实现Spring AOP 是通过动态代理技术实现的，而动态代理是基于反射设计的。Spring AOP 采用了两种混合的实现方式：JDK 动态代理和 CGLib 动态代理JDK动态代理：Spring AOP的首选方法。 每当目标对象实现一个接口时，就会使用JDK动态代理。目标对象必须实现接口CGLIB代理：如果目标对象没有实现接口，则可以使用CGLIB代理。AspectJ 实现AspectJ 是一个采用Java 实现的AOP框架，它能够对代码进行编译(一般在编译期进行)，让代码具有AspectJ 的 AOP 功能，AspectJ 是目前实现 AOP 框架中最成熟，功能最丰富的语言。ApectJ 主要采用的是编译期静态织入的方式。在这个期间使用 AspectJ 的 acj 编译器(类似 javac)把 aspect 类编译成 class 字节码后，在 java 目标类编译时织入，即先编译 aspect 类再编译目标类。2、原理了解：静态代理接口—&gt;目标类接口—&gt;代理类代理类内包含目标类代理类方法调用目标类方法，在代理类中进行代码编写，可实现增强目标类。这种代理方式需要代理对象和目标对象实现一样的接口。优点：可以在不修改目标对象的前提下扩展目标对象的功能。缺点：冗余。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。不易维护。一旦接口增加方法，目标对象与代理对象都要进行修改。接口类： IUserDao12345package com.proxy;public interface IUserDao &#123; public void save();&#125;目标对象：UserDao12345678package com.proxy;public class UserDao implements IUserDao&#123; @Override public void save() &#123; System.out.println("保存数据"); &#125;&#125;静态代理对象：UserDapProxy 需要实现IUserDao接口！12345678910111213141516package com.proxy;public class UserDaoProxy implements IUserDao&#123; private IUserDao target; public UserDaoProxy(IUserDao target) &#123; this.target = target; &#125; @Override public void save() &#123; System.out.println("开启事务");//扩展了额外功能 target.save(); System.out.println("提交事务"); &#125;&#125;测试类：TestProxy1234567891011121314package com.proxy;import org.junit.Test;public class StaticUserProxy &#123; @Test public void testStaticProxy()&#123; //目标对象 IUserDao target = new UserDao(); //代理对象 UserDaoProxy proxy = new UserDaoProxy(target); proxy.save(); &#125;&#125;输出结果123开启事务保存数据提交事务]]></content>
      <categories>
        <category>JavaEE程序设计</category>
      </categories>
      <tags>
        <tag>JavaEE程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaEE程序设计【三】]]></title>
    <url>%2Fposts%2F7ad49f29%2F</url>
    <content type="text"><![CDATA[三、Spring-bean转载:Spring Bean详细讲解spring中bean配置和bean注入Spring:Bean的实例化配置及依赖注入Spring-浅谈依赖注入Spring源码分析之—— Bean的实例化和依赖注入细节SpringMVC 源代码深度解析 IOC容器（Bean实例化和依赖注入）Spring 源码解析之 bean 的加载过程介绍1、Spring-Bean简介Bean配置信息定义了Bean的实现及依赖关系，Spring容器根据各种形式的Bean配置信息在容器内部建立Bean定义注册表，然后根据注册表加载、实例化Bean，并建立Bean和Bean的依赖关系，最后将这些准备就绪的Bean放到Bean缓存池中，以供外层的应用程序进行调用。什么是Bean?Spring Bean是被实例的，组装的及被Spring 容器管理的Java对象。Spring 容器会自动完成@bean对象的实例化。创建应用对象之间的协作关系的行为称为：装配(wiring)，这就是依赖注入的本质。Bean的本质就是Java中的类，而Spring中的Bean其实就是对实体类的引用，来生产Java类对象，从而实现生产和管理Bean 。2、Bean 三种配置方案基于xml配置Bean使用注解定义Bean基于java类提供Bean定义信息推荐方式：基于xml配置Bean、使用注解定义Bean①默认命名空间：它没有空间名，用于Spring Bean的定义；②xsi命名空间：这个命名空间用于为每个文档中命名空间指定相应的Schema样式文件，是标准组织定义的标准命名空间；③aop命名空间：这个命名空间是Spring配置AOP的命名空间，是用户自定义的命名空间。命名空间的定义分为两个步骤：第一步指定命名空间的名称；第二步指定命名空间的Schema文档样式文件的位置，用空格或回车换行进行分分隔。例如：1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;/beans&gt;使用的是标准命名空间。xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;文件设置：xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;(1)基于xml配置Bean在配置文件中，通常一个普通的Bean只需要定义id（或name）和class 两个属性即可如果在Bean中未指定id和name，则Spring会将class值当作id使用。例如:12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;bean id="bean1" class= "cn.edu.Bean1" /&gt;&lt;bean name="bean2" class= "cn.edu.Bean2" /&gt;&lt;/beans&gt;①scope 作用域在上表7种作用域中，singleton和prototype是最常用的两种作用域。singletonSpring容器默认的作用域Spring容器就只会存在一个共享的Bean实例singleton作用域对于无会话状态的Bean（如Dao 组件、Service组件）来说，是最理想的选择prototype对需要保持会话状态的Bean应该使用prototype作用域。在使用prototype作用域时，Spring容器会为每个对该Bean的请求都创建一个新的实例。但是和new不同，new是从磁盘中将class文件装到内存中，在生成，而prototype类似于克隆，除了第一次外，会从内存中复制。②生命周期singleton作用域：Spring容器可以管理singleton作用域的Bean的生命周期，在此作用域下，Spring能够精确的知道该Bean何时被创建，何时初始化完成，以及何时被销毁。prototype作用域：prototype作用域的Bean，Spring只负责创建，当容器创建了Bean实例后，Bean的实例就交给客户端代码来管理，Spring容器将不再跟踪其生命周期。(2)使用注解定义Bean标注为常用@Scope()定义作用域注解分为两类：1、一类是注册Bean,@Component , @Repository , @Service , @ Controller ,@Configration这些注解都是把你要实例化的对象转化成一个Bean，放在IoC容器中，等你要用的时候，它会和上面的@Autowired , @Resource配合到一起，把对象、属性、方法完美组装。2、一类是使用Bean，即是把已经在xml文件中配置好的Bean拿来用，完成属性、方法的组装；比如@Autowired , @Resource，可以通过byTYPE（@Autowired）、byNAME（@Resource）的方式获取Bean；①定义Bean [@Component , @Repository , @Service , @ Controller]1234567package com.baobaotao.anno;import org.springframework.stereotype.Component;import org.springframework.stereotype.Repository;//①通过Repository定义一个DAO的Bean@Component("userDao")public class UserDao &#123;&#125;在①处，我们使用@Component注解在UserDao类声明处对类进行标注，它可以被Spring容器识别，Spring容器自动将POJO转换为容器管理的Bean。它和以下的XML配置是等效的：1&lt;bean id="userDao" class="com.baobaotao.anno.UserDao"/&gt;除了@Component以外，Spring提供了3个功能基本和@Component等效的注解，它们分别用于对DAO、Service及Web层的Controller进行注解，所以也称这些注解为Bean的衍型注解：（类似于xml文件中定义Bean&lt;bean id=&quot; &quot; class=&quot; &quot;/&gt;@Repository：用于对DAO实现类进行标注；@Service：用于对Service实现类进行标注；@Controller：用于对Controller实现类进行标注；之所以要在@Component之外提供这三个特殊的注解，是为了让注解类本身的用途清晰化，此外Spring将赋予它们一些特殊的功能。②使用注解配置信息启动spring容器Spring提供了一个context的命名空间，它提供了通过扫描类包以应用注解定义Bean的方式：1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!--①声明context的命名空间--&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd" &gt; &lt;!--②扫描类包以应用注解定义的Bean--&gt; &lt;context:component-scan base-package="com.baobaotao.anno"/&gt; &lt;bean class="com.baobaotao.anno.LogonService"&gt;&lt;/bean&gt; &lt;!-- context:component-scan base-package="com.baobaotao" resource-pattern="anno/*.class"/ --&gt; &lt;!-- context:component-scan base-package="com.baobaotao"&gt; &lt;context:include-filter type="regex" expression="com\.baobaotao\.anno.*Dao"/&gt; &lt;context:include-filter type="regex" expression="com\.baobaotao\.anno.*Service"/&gt; &lt;context:exclude-filter type="aspectj" expression="com.baobaotao..*Controller+"/&gt; &lt;/context:component-scan --&gt;&lt;/beans&gt;在①处声明context命名空间，在②处即可通过context命名空间的component-scan的base-package属性指定一个需要扫描的基类包，Spring容器将会扫描这个基类包里的所有类，并从类的注解信息中获取Bean的定义信息。如果仅希望扫描特定的类而非基包下的所有类，你们可以使用resource-pattern属性过滤特定的类，如下所示：&lt; context:component-scan base-package=&quot;com.baobaotao&quot; resource-pattern=&quot;anno/*.class&quot;/ &gt;这里我们将基类包设置为com.baobaotao，默认情况下resource-pattern属性的值为”*/.class”，即基类包里的所有类。这里我们设置为”anno/*.class”,则Spring仅会扫描基包里anno子包中的类。(3)基于java类提供Bean定义不常用，请查看3、Bean 的实例化和依赖注入依赖注入（Dependency Injection，DI）：在运行期，由外部容器 动态地将依赖对象注入到组件中。(0)实例化和依赖注入的关系构造器方式，解析XML，用BeanDefinition存储构造信息，包含哪些属性作为构造器的参数，到时候一并构造；setter方式，解析XML，用BeanDefinition存储PropertyValues，在Bean实例化后通过set方式进行注入；注解方式，首先要开启注解功能，注入是通过注解后置处理器来完成的；（1）先List&lt;String&gt; beanDefinitionNames获取BeanName，然后通过BeanName 获取Map&lt;String, RootBeanDefinition&gt; RootBeanDefinition，然后判断是否为单例、不是抽象、是为Lazy-init=false 然后调用getBean方法。​ （2）如果BeanName是别名，先转换为原来的BeanName不是别名，然后如果缓存中有单例Bean时，就从缓存获取，如果没有的话，就创建一个​ （3）先检查是否父工厂存在，如果有的话，获取父工厂​ （4）判断Bean依赖对象所有的名称，如果有的话，获取依赖对象的名称，然后循环getBean（）；​ （5）检查Bean的作用域，Scope 作用域、原型作用域、Request等，来实例化Bean ,是由FactoryBean是创建创建对象的工厂Bean，通过调用这个对象的 getObject 方法就能获取用户自定义产生的对象，从而为 Spring 提供了很好的扩展性。Spring 获取 FactoryBean 本身的对象是在前面加上 &amp; 来完成的。​ （6）封装Bean，用 BeanWrapper是对Bean的包装，其接口中所定义的功能很简单包括设置获取被包装的对象，获取被包装bean的属性描述器，由于BeanWrapper接口是PropertyAccessor的子接口，因此其也可以设置以及访问被包装对象的属性值。BeanWrapper大部分情况下是在IOC内部进行使用，通过BeanWrapper,IOC容器可以用统一的方式来访问Bean的属性。​ （7）根据BeanName去容器缓存中获取已经Bean的包装好的BeanWrapper，如果没有就调用createBeanInstance(beanName, mbd, args)，实例化Bean​ (8)获取BeanWrapper里已经实例好的Bean，然后放到缓存，这样下次已经有了，就不用在创建。​ （9）设置Bean实例的属性,对需要转换的属性进行转换，例如数组等，如果属性是引用类型，如果引用Bean没实例化，要在实例化，把bean实例对象封装好依赖注入在注入进来。getBean(beanName);对bean进行实例化并对属性依赖进行注入过程。前面解析的代码不重要，主要是入口点，接下来才是重点， 创建bean时，如果缓存中有单例Bean时，就从缓存获取，如果没有就新建，通过匿名的内部类来创建Bean时根据Bean的作用域来创建的，有单实例作用域、原型作用域、Request等。个人认为：实例化过程中，发现依赖，会先初始化相应依赖才能进行依赖注入，这是个递归过程，直到找到最终的依赖，实例化后不断返回，依次实例化，最后实例化本Bean(1)实例化①构造器实例化构造器实例化是指Spring容器通过Bean对应的类中默认的构造函数来实例化Bean。123package cn.edu.instance.constructor;public class Bean1&#123;&#125;12&lt;bean id="bean1" class= " cn.edu.instance.constructor.Bean1" /&gt;&lt;/beans&gt;12345678public class InstanceTest1 &#123;public static void main(String[] args) &#123;String xmlPath = "beans1.xml";ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath);Bean1 bean = (Bean1) applicationContext.getBean("bean1");System.out.println(bean);&#125;&#125;②静态工厂方式实例化静态工厂是实例化Bean的另一种方式。该方式要求自己创建一个静态工厂的方法来创建Bean的实例。1234public class MyBean2Factory &#123;public static Bean2 createBean()&#123;return new Bean2(); &#125;&#125;1&lt;bean id="bean2" class="cn.edu.ccc.static_factory.MyBean2Factory" factory-method="createBean" /&gt;123456public class InstanceTest2 &#123;public static void main(String[] args) &#123;ApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans2.xml");System.out.println(applicationContext.getBean("bean2"));&#125;&#125;③实例工厂方式实例化实例工厂是采用直接创建Bean实例的方式，在配置文件中，通过factorybean属性配置一个实例工厂，然后使用factory-method属性确定使用工厂中的哪个方法。1234public class MyBean3Factory &#123;public Bean3 createBean()&#123;return new Bean3(); &#125;&#125;12&lt;bean id="myBean3Factory" class="cn.edu.ccc.instance.factory.MyBean3Factory" /&gt;&lt;bean id="bean3" factory-bean="myBean3Factory" factory-method="createBean" /&gt;123456public class InstanceTest3 &#123;public static void main(String[] args) &#123;ApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans3.xml");System.out.println(applicationContext.getBean("bean3"));&#125;&#125;(2)依赖注入（装配）①基于XML的装配设值注入属性注入即通过setXxx()方法注入Bean的属性值或依赖对象，由于属性注入方式具有可选择性和灵活性高的优点，因此属性注入是实际应用中最常采用的注入方式。属性注入要求Bean提供一个默认的构造函数，并为需要注入的属性提供对应的Setter方法。Spring先调用Bean的默认构造函数实例化Bean对象，然后通过反射的方式调用Setter方法注入属性值。12345678910111213141516171819202122232425262728293031323334353637package com.baobaotao.anno;import org.springframework.beans.factory.BeanNameAware;public class LogonService implements BeanNameAware&#123; private LogDao logDao; private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void setLogDao(LogDao logDao) &#123; this.logDao = logDao; &#125; public LogDao getLogDao() &#123; return logDao; &#125; public UserDao getUserDao() &#123; return userDao; &#125; public void setBeanName(String beanName) &#123; System.out.println("beanName:"+beanName); &#125; public void initMethod1()&#123; System.out.println("initMethod1"); &#125; public void initMethod2()&#123; System.out.println("initMethod2"); &#125; &#125;1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd" default-autowire="byName" &gt; &lt;bean id="logDao" class="com.baobaotao.anno.LogDao"/&gt; &lt;bean id="userDao" class="com.baobaotao.anno.UserDao"/&gt; &lt;bean class="com.baobaotao.anno.LogonService"&gt; &lt;property name="logDao" ref="logDao"&gt;&lt;/property&gt; &lt;property name="userDao" ref="userDao"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;构造方法注入使用构造函数注入的前提是Bean必须提供带参数的构造函数。1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.baobaotao.anno;import org.springframework.beans.factory.BeanNameAware;public class LogonService implements BeanNameAware&#123; public LogonService()&#123;&#125; public LogonService(LogDao logDao, UserDao userDao) &#123; this.logDao = logDao; this.userDao = userDao; &#125; private LogDao logDao; private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void setLogDao(LogDao logDao) &#123; this.logDao = logDao; &#125; public LogDao getLogDao() &#123; return logDao; &#125; public UserDao getUserDao() &#123; return userDao; &#125; public void setBeanName(String beanName) &#123; System.out.println("beanName:"+beanName); &#125; public void initMethod1()&#123; System.out.println("initMethod1"); &#125; public void initMethod2()&#123; System.out.println("initMethod2"); &#125; &#125;123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd" default-autowire="byName"&gt; &lt;bean id="logDao" class="com.baobaotao.anno.LogDao"/&gt; &lt;bean id="userDao" class="com.baobaotao.anno.UserDao"/&gt; &lt;bean class="com.baobaotao.anno.LogonService"&gt; &lt;constructor-arg ref="logDao"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg ref="userDao"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt;通过修改两种工厂的方法这种方式注入，少见②基于注解（Annotation）的装配1.@Autowired注入是按照类型注入的，只要配置文件中的bean类型和需要的bean类型是一致的，这时候注入就没问题。但是如果相同类型的bean不止一个，此时注入就会出现问题，Spring容器无法启动。2.@Resourced标签是按照bean的名字来进行注入的，如果我们没有在使用@Resource时指定bean的名字，同时Spring容器中又没有该名字的bean,这时候@Resource就会退化为@Autowired即按照类型注入，这样就有可能违背了使用@Resource的初衷。所以建议在使用@Resource时都显示指定一下bean的名字@Resource(name=”xxx”)XML的配置中通过bean元素来配置Bean12&lt;context:annotation-config /&gt;&lt;bean id="userDao" class="cn.edu.annotation.UserDaoImpl" /&gt;除了可以像示例中通过元素来配置Bean外，还可以通过包扫描的形式来配置一个包下的所有Bean：1&lt;context:component-scan base-package="cn.edu.annotation" /&gt;对于扫描到的类，Spring默认命名为首字母小写。1234567即@Controllerpublic class LoginController&#123;&#125;等价于&lt;bean id="loginController" class="XXX.LoginController"/&gt;@Resource其可以写在变量定义前，也可以写在setXXX方法前。@Resource默认按照ByName自动注入。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。使用注解时，若@Resource注解写在变量定义前，那么setXXX方法可以不写。但若是在xml文件中采用&lt;bean&gt;标签的set注入，需要实现setXXX方法。@Resource装配顺序：step1：如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。step2：如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。step3：如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。step4：如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。@Autowired基本等价于 @Resource。@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用@Resource与@Autowired的区别@Resource的作用相当于@Autowired，只不过@Autowired默认按照byType自动注入。@Resource默认按 byName自动注入构造器注入时，只能使用@Autowired。Set注入时，可以使用@Autowired或者@Resource（推荐）。③自动装配所谓自动装配，就是将一个Bean自动的注入到到其他Bean的Property中。Spring的元素中包含一个autowire属性，我们可以通过设置autowire的属性值来自动装配Bean。123&lt;bean id="userDao" class="cn.edu.annotation.UserDaoImpl" /&gt;&lt;bean id="userService" class="cn.edu.annotation.UserServiceImpl" autowire="byName" /&gt;&lt;bean id="userController" class="cn.edu.annotation.UserController" autowire="byName" /&gt;4、Spring的Bean管理的方式的比较5、Junit测试环境123@RunWIth(SpringJunit4ClassRunner.class)@ContextConfiguration(locations = &#123;"classpath:applicationContext.xml"&#125;例如：12345678910@RunWIth(SpringJunit4ClassRunner.class)@ContextConfiguration(locations = &#123;"classpath:applicationContext.xml"&#125;public class MyTest&#123;@Testpublic void hehe()&#123;//.......&#125;&#125;这种写法是为了让测试在Spring容器环境下执行。]]></content>
      <categories>
        <category>JavaEE程序设计</category>
      </categories>
      <tags>
        <tag>JavaEE程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaEE程序设计【二】]]></title>
    <url>%2Fposts%2F37ca3c7b%2F</url>
    <content type="text"><![CDATA[二、依赖倒置（DIP）、控制反转(IOC)和依赖注入(DI)解析解析1解析2解析31、依赖倒置 DIP(Dependency Inversion Principle)看起来就像是在说 把依赖倒过来但是 其实指的是来源于软件设计 6 大设计原则的依赖倒置：1、高层模块不应该依赖于低层模块,二者都应该依赖于抽象。2、抽象不应该依赖于细节,细节应该依赖于抽象。具体来讲，依赖倒置的核心思想是针对接口而不是实现编程。什么是依赖？当A类需要实例化B类后使用B类的成员才可正常工作时我们称作A类对B类产生了依赖什么是高层模块什么是低层模块？高层模块就是调用端，低层模块就是具体实现类。业务层自然就处于上层模块，逻辑层和数据层自然就归类为底层。什么是抽象？抽象就是指接口或抽象类。细节就是实现类。通俗来讲： 依赖倒置原则的本质就是通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合。问题描述： 类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。解决方案： 将类A修改为依赖接口interface，类B和类C各自实现接口interface，类A通过接口interface间接与类B或者类C发生联系，则会大大降低修改类A的几率。2、控制反转 IoC(Inversion of Control)也是个唬人的说法,并不是字面意思上的反转而是将[控制权]交给第三方通常情况下，class A依赖于class B,或者应用DIP之后依赖于Interface B,那么在运行时，我们必须自行主动的去实例化Interface B接口的实现类实例，然后将其引用传递给Class A，在传统的编程模型下，我们经常这样干。这样耦合度仍然很高，我们必须知道所依赖的实现类的一些细节。而IoC则是将实例化被依赖模块的责任交出去，不再主动去做依赖装配工作，这样我们就可以彻底的只针对接口编程，而无需关心具体的实现。IoC容器成为一个系统的对象容器和粘合剂，它负责创建对象的实例，并按照它们声明的依赖关系把它们粘合起来共同工作。通过配置文件或注解的方法，IoC容器会自动的满足模块之间的依赖关系，而无需我们再主动去处理依赖关系，只要被动接受就可以了。这种依赖关系的满足由主动实现到被动接受的转变，就是所谓的控制反转了。IoC与好莱坞原则(Don’t call me,i’ll call you!)比较相似。3、依赖注入DI(Dependency Injection)这个就字面理解通过第三方将[下层]的[依赖]注入[上层]理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：●谁依赖于谁：当然是应用程序依赖于IoC容器；●为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；●谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结：控制的什么被反转了？就是：获得依赖对象的方式反转了。实现依赖注入有 3 种方式：构造函数中注入setter 方式注入接口注入1234567/** * 接口方式注入 * 接口的存在，表明了一种依赖配置的能力。 */public interface DepedencySetter &#123; void set(Driveable driveable);&#125;123456789101112131415161718192021222324252627282930public class Person implements DepedencySetter &#123; //接口方式注入 @Override public void set(Driveable driveable) &#123; this.mDriveable = mDriveable; &#125; private Driveable mDriveable; //构造函数注入 public Person(Driveable driveable)&#123; this.mDriveable = driveable; &#125; //setter 方式注入 public void setDriveable(Driveable mDriveable) &#123; this.mDriveable = mDriveable; &#125; public void goToBeijing()&#123; System.out.println("以某种交通方式去北京"); mDriveable.drive(); &#125; public static void main(String ... args)&#123; Person2 person = new Person2(new Car()); person.goToBeijing(); &#125;&#125;接口这种方式和 Setter 方式很相似。有很多同学可能有疑问那么加入一个接口是不是多此一举呢？答案肯定是不是的，这涉及到一个角色的问题。还是以前面的餐厅为例，除了外卖员之外还有厨师和服务员，那么如果只有外卖员实现了一个送外卖的接口的话，那么餐厅配餐的时候就只会把外卖配置给外卖员。接口的存在，表明了一种依赖配置的能力。4、三者关系1.控制反转是设计模式,遵从了依赖倒置原则2.依赖注入是实现控制反转的手段依赖注入是实现控制反转的主要方式，另一种方式是依赖查找。两者的区别在于，依赖注入是被动的接收对象，而依赖查找是主动索取响应名称的对象，获得依赖对象的时间也可以在代码中自由控制。依赖查找更加主动，在需要的时候通过调用框架提供的方法来获取对象，获取时需要提供相关的配置文件路径、key等信息来确定获取对象的状态。比如使用JNDI来查找资源。依赖倒置原则是设计模式六大原则之一[控制反转]和[依赖注入]是[依赖倒置原则]的具体实现控制反转通过上层去描述 依赖注入通过下层描述 它们相辅相成也有人说依赖注入是控制反转的具体实现 控制反转是依赖倒置的具体实现。有一定道理 不过个人以为不太合适转自解析25、Spring中的体现(1)applicationContext.xml容器（常用、重要！）applicationContext.xml查找1.我们可以去Spring的官网的参考手册中找到自己需要的配置文件内容2.官方手册地址：https://docs.spring.io/spring/docs/5.0.8.RELEASE/spring-framework-reference/core.html#spring-core3.进入官网手册之后就可以找到有以下的配置示例，我们就可以在项目中新建配置文件applicationContext.xml文件然后将该示例的代码拷贝到我们配置文件中即可12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 在这里加入内容 --&gt;&lt;/beans&gt;(2)使用12345package cn.edu.ch1;public interface IUserDao &#123; public void say();&#125;12345package cn.edu.ch1;public interface IUserService &#123; public void say();&#125;123456789package cn.edu.ch1;public class UserDaoImpl implements IUserDao&#123; @Override public void say() &#123; // TODO Auto-generated method stub System.out.println("userDao say hello World !"); &#125;&#125;1234567891011121314151617package cn.edu.ch1;public class UserServiceImpl implements IUserService &#123; private IUserDao userDao; public void setUserDao(IUserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void say() &#123; // TODO Auto-generated method stub this.userDao.say(); System.out.println("userService say hello World !"); &#125;&#125;123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="userDao" class="cn.edu.ch1.UserDaoImpl" /&gt; &lt;bean id="userService" class="cn.edu.ch1.UserServiceImpl"&gt; &lt;property name="userDao" ref="userDao" /&gt; &lt;/bean&gt; &lt;/beans&gt;1234567891011121314package cn.edu.ccc.ch1;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestIoC &#123; public static void main(String[] args) &#123; ApplicationContext allApplicationContext=new ClassPathXmlApplicationContext("applicationContext.xml"); IUserDao userDao=(IUserDao) allApplicationContext.getBean("userDao"); userDao.say(); &#125;&#125;//结果//userDao say hello World !123456789101112131415package cn.edu.ch1;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestDI &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext=new ClassPathXmlApplicationContext("applicationContext.xml"); IUserService userService = (IUserService)applicationContext.getBean("userService"); userService.say(); &#125;&#125;//结果//userDao say hello World !//userService say hello World !解析:UserDaoImpl实现IUserDao接口UserServiceImpl实现IUserService接口；同时UserServiceImpl的say方法需要IUserDao接口的实现applicationContext.xml容器（工厂）中配置接口的实例。&lt;bean id=&quot;userDao&quot; class=&quot;cn.edu.ch1.UserDaoImpl&quot; /&gt; 使得UserDaoImpl实例化名为userDao的对象123&lt;bean id="userService" class="cn.edu.ch1.UserServiceImpl"&gt; &lt;property name="userDao" ref="userDao" /&gt; &lt;/bean&gt;使得UserServiceImpl实例化名为userService的对象，由于UserServiceImpl的say方法需要IUserDao的实例。所以需要注入。&lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot; /&gt;的意思是ref（引用）容器中名为userDao 的实例，注入到userService中的userDao成员中。]]></content>
      <categories>
        <category>JavaEE程序设计</category>
      </categories>
      <tags>
        <tag>JavaEE程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaEE程序设计【一】]]></title>
    <url>%2Fposts%2F7dcd0a3%2F</url>
    <content type="text"><![CDATA[一、绪论UML分析：StarUML文档：Word开发IDE：Eclipse单元测试：Junit压力测试：LoadRunner部署：maven什么是 Java ee?是一系列标准。很多厂商”实现”了这些标准Java ee应用服务器标准:Oracle的 WebLogic、IBM的 WebSphere、 Redhat的 JBOSSJava ee学什么?■狭义: Java ee规范( Servlet、JSP、EJB等等）■广义:所有遵循 Java EE规范的所有厂商(S∪N、IBM)、所有开源项目Apache、 Spring、 Hibernate、 My Batis1、JavaEE 介绍JavaEE不赚钱，JavaEE8之后转手eclipse基金会后续维护更新。2018年初，甲骨文不允许eclipse使用java名称，故javaEE8 有官方版本，eclipse下的版本 Jakarta8EE 。2、环境配置时间：2020.9.7JDK：推荐1.8.261Eclipse：越新越好2020-06Tomcat：8.5.57（注意小版本，即最后的位数最好最新）MySQL：5.5以后版本（注意MySQL8之后有新特性）Maven：最新3.6.3JDK需要安装，最好配置JAVA_HOME和PATHTomcat、Eclipse、MySQL解压即可，注意路径Eclipse的Server中选择Apache的tomcat进行配置Maven：注意配置阿里云镜像添加到Maven路径下的文件夹中settings.xml 的&lt;mirrors&gt;&lt;/mirrors&gt;中123456&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt;Eclipse中配置maven设置UpdateSettings：选择marven目录下的settings.xml这样设置会使得我们使用maven的时候是从阿里云镜像中下载。更快些新建maven 注意勾选下一步，maven会寻找原型项目，由于比较大,若比较卡的话，可以选择使用本地文件即：如果在“Select an Archetype”一步时间较长，可以选择加载本地archetype文件选择“org.apache.maven.archetypes”下的“maven-archetype-webapp”组名一般公司开发中会使用公司域名反写，这样生成的package就是域名反写+项目名。之后等待2分钟左右等待创建。项目创建完后会有错误。原因是默认使用的属性，例如JDK、runtime。和我们机器不一致，改成一致就行了。右键项目选址 bulid path 或者properties更改Java Build Path中的JDK为1.8（Eclipse自带）选定Targeted Runtimes为Tomcat v8.5更改Java Compiler中的JDK为1.8更改Project Facets中的JDK为1.8目录简介：编码集配置：所有文件编码改为UTF-8 避免出不必要的错!!!\1、修改 workspace text file encoding依次点击windows -&gt; Preferences -&gt; general -&gt; Workspace，修改如图的编码为UTF-82、修改资源文件编码依次点击windows -&gt; Preferences -&gt; general -&gt; Content Types，如下图，点击打开Text依次选择Java Source File、XML、Java Properties File等，在下面的Default encoding输入框中输入UTF-8，并点Update生效，有耐心，全改了。而且要检查子单元，父单元改了子单元不一定改，尤其是JSP相关子单元Text和其同级别的其他三个最高父节点，也可以改UTF-8。3、搜索 jsp file4、选中你正在开发的项目，点击鼠标右键，选择最后一个选项“Properties”：点击Resource,可以看到右边也有一个编码格式设置，如果不是UTF-8格式，则把它设置为UTF-8编码格式https://www.cnblogs.com/AlanLee/p/5295105.htmlhttps://blog.csdn.net/qq_24879495/article/details/780281803、驱动配置maven下，通过配置pom.xml可方便配置驱动。不必添加大片的jar包，这在实际开发中也是不现实的。方便控制jar包版本。不需要删掉再拷进去，只需要修改pom.xml即可。从https://mvnrepository.com/中搜索所需要的驱动例如添加mysql：1、搜索mysql2、找到MySQL Connector/J3、选择本机对应版本的最新。例如本机为5.5，则选择最新的5.1.49。点击即可自动复制4、添加到&lt;dependencies&gt; &lt;/dependencies&gt;中保存即可，之后会自动下载文件。可在项目中的 libraries中的maven dependence中查看下载的jar包5、类似的；我们可以找到spring的包，在POM中配置4、主题下载help—&gt;eclipse marketplace 搜索theme或者查看popular第一的（此时是2020.9.7）darkest dark theme with devstyle eclipse 进行下载安装后在preferences中搜索theme即可选择主题5、Maven web项目的目录结构浅析转载：cnblogs.com/b6952/p/10619760.html其它推荐阅读：https://www.cnblogs.com/now-fighting/p/4858982.html1、为啥又有Java Resources文件夹的代码，又有src文件夹的代码呢？那我想改代码要改哪里。其实，Java Resources文件夹下面的代码都是以包的形式展现的，主要是为了开发人员更好的找到修改的代码文件。Java Resources文件夹下的代码和src文件夹下面的代码其实就是一份。但是src下面还多了一个webapp的文件夹，这是放置前端页面以及脚本等内容的文件夹。2、那么整个工程编译生成之后，这些文件夹的层次关系变成啥样了呢？在工程视图中，选中工程名，右键选择属性，看看对应的配置信息就知道了。如下图，可见，webapp这个文件夹生成之后，其实webapp就相当于根目录了，webapp下面的文件/文件夹其实就是对应根目录下的文件/文件夹。而Java Resources文件夹下的代码(即src/main/java和/src/main/resources)，生成之后就跑到了根目录下的WEB-INF下的classes的路径下面了。target目录可选主要存放注解和一些class文件PS：多啰嗦一个东西，就是我们在一些例如spring的xml配置文件里面，经常可以看到&lt;import resource=&quot;classpath:spring-mybatis.xml&quot; /&gt;类似的配置。这里的这个spring-mybatis.xml文件是怎么找到的呢，其实它生成后，不就是在根目录下的WEB-INF下的classes的路径下嘛，这个就是classpath啦。]]></content>
      <categories>
        <category>JavaEE程序设计</category>
      </categories>
      <tags>
        <tag>JavaEE程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机图形学【四】]]></title>
    <url>%2Fposts%2F3e415e75%2F</url>
    <content type="text"><![CDATA[一、曲线曲面基础1、曲线曲面的表示显式表示的缺点：每一个x只对应一个y，因而不能表示封闭或者多值曲线，比如不能用显式方程表示一个圆。曲线的非参数表示存在的问题：与坐标系相关；会出现斜率无穷大的情况 （比如：x=3）；非平面曲线难用常系数的非参数化函数表示；不利于计算和编程。参数表示方法的优点：点动成线；可以选取具有几何不变性的参数曲线曲面表示形式；斜率容易计算t∈[0,1] ，使其相应的几何分量是有界的；可对参数方程直接进行仿射和投影变换；参数变化对各因变量的影响可以明显地表示出来。在自由曲线面的描述中常用的三种点:控制点：用来确定曲线和曲面的位置与形状，而相应曲线和曲面不一定经过的点；型值点：用来确定曲线和曲面的位置与形状，而相应曲线和曲面一定经过的点；插值点：为提高曲线和曲面的输出精度，在型值点之间插入的一系列点。2、连续性条件（1）参数连续性n阶参数连续性：指两个相邻曲线段的方程在相交点处具有相同的函数值、一阶和二阶导数……n阶导数交点处值也相同。（2）几何连续性n阶几何连续性：指两个相邻曲线段的方程在相交点处具有相同的函数值、一阶和二阶导数……n阶导数交点处值成比例。]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql使用时的一些坑记录【持续更新】]]></title>
    <url>%2Fposts%2F885cd113%2F</url>
    <content type="text"><![CDATA[1、添加外键错误 1452原因：创建完表之后，进行了信息录入和一段时间使用后进行设置外键，由于之前可能存在删除等操作，可能导致某些作为外键的数据在另一张表的主键中不存在解决:1、添加上缺少的数据2、直接情空该表]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机图形学【三】]]></title>
    <url>%2Fposts%2F896c4710%2F</url>
    <content type="text"><![CDATA[一、二维图形变换1、基本几何变换基本几何变换：基本几何变换都是相对于坐标原点和坐标轴进行的几何变换。(1)平移变换(2)比例变换当Sx=Sy时，称为整体比例变换(3)旋转变换【规定】：逆时针转动的角度为正，顺时针转动的角度为负。顺时针旋转θ角度 = 逆时针旋转-θ(或2π-θ)角度(4)对称变换关于x轴对称关于y轴对称关于原点对称关于y=x对称关于y=-x对称(5)错切变换错切变换：也称为剪切、错位变换，用于产生弹性物体的变形处理。错切变换引起图形角度关系的改变，甚至导致图形发生变形。沿X轴方向的错切沿Y轴方向的错切同时沿x方向和y方向错切2、复合变换复合变换是指：图形作一次以上的几何变换，变换结果是每次的变换矩阵相乘。任何一个复杂的几何变换都可以看作基本几何变换的组合形式。(1)同种类变换的复合二维复合平移变换二维复合比例变换二维复合旋转变换可见：旋转变换是错切变换和整体比例变换变换复合而来(2)相对任一参考点的二维几何变换(3)相对任意方向的二维几何变换y=x等之前提到过的特殊类型可直接使用，但是要明白其本质是这么来的一定注意角度，顺时针为负，逆时针为正二、二维观察和裁剪1、二维观察（1）基本概念用户坐标系：纸上的图形采用的坐标是实数域中的直角坐标系或是极坐标系，统称为用户坐标系。设备坐标系：屏幕上采用的坐标系是整数域中直角坐标系，这类坐标系统称为设备坐标系。窗口：在计算机图形学中，将在用户坐标系中需要进行观察和处理的一个坐标区域称为窗（Window）。视区（也叫视口）：为了在屏幕上指定显示图形的位置，在屏幕上定义一个矩形，该矩形称为视区，窗口内的图形就显示在屏幕上的视区中。即：将窗口映射到显示设备上的坐标区域称为视区（Viewport）。（2）二维观察流程WC: Windows Coordinates 用户坐标系VC: Viewing Coordinates观察坐标系DC: Device Coordinates 设备坐标系NDC: Normalized Device Coordinates 规范化设备坐标系用户坐标系到观察坐标系的变换：窗口到视区的变换2、裁剪在二维观察中，需要在观察坐标系下对窗口进行裁剪，即只保留窗口内的那部分图形，去掉窗口外的图形。（1）点的裁剪（2）直线段的裁剪—-Cohen-Sutherland算法基本思想：(1)若点P1和P2完全在裁剪窗口内，直线段完全可见，“简取”之(2)若点P1和P2均落在窗口外，直线段完全不可见，“简弃”之，(3)若直线段既不满足“简取”的条件，也不满足“简弃”的条件，则该直线段可能与窗口相交，此时，需要对直线段按交点进行分段，分段后重复上述处理。观察图像可以发现：两个点的编码只要有一个位置都是相同的1就一定需要舍去两个点的编码都是0000就一定要保留所以若code1|code2=0，对直线段应简取之，否则，若code1&amp;code2≠0，对直线段可简弃之(1)输入直线段的两端点坐标：P1(x1,y1)、P2(x2,y2)，以及窗口的四条边界坐标：wyt、wyb、wxl和wxr；(2)对P1、P2进行编码：点P1的编码为code1，点P2的编码为code2；(3)若code1|code2=0，对直线段应简取之，转(6)；否则，若code1&amp;code2≠0，对直线段可简弃之，转(7)；当上述两条均不满足时，进行步骤(4)；(4)确保P1在窗口外部：若P1在窗口内，则交换P1和P2的坐标值和编码；(5)计算直线段与code1中编码等于1对应窗口边界的交点，并用该交点的坐标值替换P1的坐标值。也即在交点S处把线段一分为二，并去掉P1S这一段。考虑到P1是窗口外的一点，因此可以去掉P1S。转(2);(6)用直线扫描转换算法画出当前的直线段P1P2;(7)算法结束。（3）直线段的裁剪—-中点分割算法当对直线段不能简取也不能简弃时，简单地把线段等分为二段，对两段重复上述测试处理，直至每条线段完全在窗口内或完全在窗口外(1)输入直线段的两端点坐标：P1(x1,y1)、P2(x2,y2)，以及窗口的四条边界坐标：wyt、wyb、wxl和wxr；(2)对P1、P2进行编码：点P1的编码为code1，点P2的编码为code2；(3)若code1|code2=0，对直线段应简取之，保留当前直线段的端点坐标，转(8)；否则，若code1&amp;code2≠0，对直线段可简弃之，转(9)；当上述两条均不满足时，进行步骤(4)；(4) 若code1=0且P1为窗口边界上的点，判断P1和P2是否在窗口边界的同一外侧。若在同一侧，则简弃之，绘制P1，转(9)，否则转(6);(5) 若code2=0且P2为窗口边界上的点，判断P1和P2是否在窗口边界的同一外侧。若在同一侧，则简弃之，绘制P2，转(9)，否则转(6);(6) 求出直线段的中点M，将P1M、P2M入栈；(7)当栈不空时，从栈中弹出一条直线段，记为P1P2，转(2)进行处理。否则，继续(6)；(8)当栈为空时，合并保留的直线段端点，得到窗口内的直线段P1P2。用直线扫描转换算法画出当前的直线段P1P2;(9) 算法结束。（4）直线段的裁剪—-Liang-Barsky算法前提：直线的参数方程(5)多边形的裁剪Sutherland-Hodgeman多边形裁剪算法（S-H多边形裁剪算法）基本思想：将多边形边界作为一个整体，每次用窗口的一条边对要裁剪的多边形进行裁剪。最终，多边形被裁剪后得到的边与窗口部分边界组成裁剪后的多边形。(6)多边形的裁剪Weiler-Atherton 多边形裁剪算法二、三维图形变换右手螺旋定则判断方向。1、旋转变换2、对称变换（1）平面对称（2）轴对称3、错切变换哪个轴数字不为0，哪个轴+方向轴上就会出现角度4、逆变换5、复合变换6、三维投影变换三视图：投影面与某一坐标轴垂直。正轴测：投影面与所有坐标轴不垂直。(1)正投影三视图主视图俯视图(1)投影变换(2)使H面绕x轴负转90°，使俯视图与主视图在同一个平面上。(3)使H面沿z方向平移一段距离-z0侧视图(1)侧视图投影的变换(2)使W面绕z轴正转90°(3)使W面沿负x方向平移一段距离x0正轴测正等测（等轴测）：投影面与3个坐标轴之间的夹角都相等。正二测：投影面与2个坐标轴之间的夹角都相等。β未知正三测：投影面与3个坐标轴之间的夹角都不相等。α、β均未知(2)斜投影斜等测：投影方向与投影面成45°角度（arctan1）。和投影面垂直的任何直线段，其投影的长度不变斜二测：投影方向与投影面成arctan2角度。和投影面垂直的任何直线段，其投影的长度为原来的一半(3)透视投影不平行于投影面的平行线的投影会汇聚到一个点，这个点称为灭点(Vanishing Point)。坐标轴方向的平行线在投影面上形成的灭点称作主灭点。一点透视有一个主灭点，即投影面与一个坐标轴正交，与另外两个坐标轴平行。二点透视有两个主灭点，即投影面与两个坐标轴相交，与另一个坐标轴平行。三点透视有三个主灭点，即投影面与三个坐标轴都相交。]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP程序设计【六】]]></title>
    <url>%2Fposts%2F2d3516ef%2F</url>
    <content type="text"><![CDATA[一、数据库设计进阶1、数据库管理类设计核心思想：可以设计一个工具类，专门用于管理数据库连接和实现基础访问定义数据库连接参数和连接对象1234private static String url = "jdbc:mysql://localhost:3306/myjsp";private static String user = "root";private static String pwd = "mysql";private static Connection connection;加载驱动程序（采用静态初始化块，只执行一次，在构造函数前执行）1234567static &#123; try &#123; Class.forName("com.mysql.jdbc.Driver"); &#125; catch (ClassNotFoundException ex) &#123;Logger.getLogger(DBManager.class.getName()).log(Level.SEVERE, null, ex); &#125;&#125;获取连接获取新连接123public static Connection getNewConnection() throws SQLException &#123; return DriverManager.getConnection(url, user, pwd);&#125;打开默认连接（采用单例模式，只保持一个连接对象,使用此函数会检查是否已经存在链接）12345public static void openDefaultConnection() throws SQLException &#123; if (connection == null || connection.isClosed()) &#123; connection = getNewConnection(); &#125;&#125;关闭连接直接关闭12345public static void closeConnection(Connection conn) throws SQLException &#123; if (conn != null) &#123; conn.close(); &#125;&#125;关闭默认连接，额外关闭了connection，这样可以创建新的默认连接1234public static void closeDefaultConnection() throws SQLException &#123; closeConnection(connection); connection = null;&#125;获取执行SQL语句的对象直接获取写好的sql1234public static PreparedStatement getPreparedStatement(String sql) throws SQLException &#123; openDefaultConnection(); return connection.prepareStatement(sql);&#125;设置获取待定参数的sql（采用可变参数形式，提高灵活性）123456789101112public static void setParams(PreparedStatement pstmt, Object... params) throws SQLException &#123; for (int i = 1; i &lt;= params.length; i++) &#123; Object param = params[i - 1]; if (param == null) &#123; pstmt.setNull(i, Types.NULL); &#125; else if (param instanceof Integer) &#123; //其他类型类似增加判断设置即可 pstmt.setInt(i, (int) param); &#125; else &#123; pstmt.setObject(i, Types.OTHER); &#125; &#125;&#125;执行更新1234567public static int executeUpdate(String sql, Object... params) throws SQLException &#123; PreparedStatement pstmt = getPreparedStatement(sql); setParams(pstmt, params); int n = pstmt.executeUpdate(); pstmt.close(); return n; &#125;执行查询123456public static ResultSet executeQuery(String sql, Object... params) throws SQLException &#123; PreparedStatement pstmt = getPreparedStatement(sql); setParams(pstmt, params); ResultSet rset = pstmt.executeQuery(); return rset; &#125;其他操作生成SQL语句字符串获取列名获取行数类似设计即可2、DAO模式的设计（Data Access Object，数据访问对象）是为某种类型的数据库或其他持久性机制提供一个抽象接口的对象。隐藏细节；职责分离；降低耦合；易于扩展基础数据库连接和操作—&gt;生成DBmanager；创建使用数据库的一套规范接口—-&gt;使用DBmanager，实现针对每一个表的操作的继承接口规范的类；在MVC中使用数据库时，只需要使用每个表的操作实现类即可。（通过封装，屏蔽掉了需要获取各种连接的部分，想查询，就使用查询方法，数据库连接，创建查询会话等都自动执行了。）DBmanager是最基本，是连接、增删改查操作的封装，DAO是一个规范，声明的是针对每个现实表实现的统一规范。实现每个表的操作类，需要调用DBmanager的基础操作，我们需要添加的只是sql语句或者一个Bean信息(1)设计接口规范(样例)1234567891011121314public interface DAO&lt;T&gt; &#123; //使用泛型，进一步提高数据类型的灵活性 public abstract int insert(T t) throws SQLException; public abstract int delete(Object... params) throws SQLException; public abstract int update(T t) throws SQLException; public abstract T queryOne(Object... params) throws SQLException; public abstract List&lt;T&gt; queryAll() throws SQLException; public abstract List&lt;T&gt; queryMany(int offset, int rows, String[] columnNames, Object... params) throws SQLException; public abstract List&lt;T&gt; toEntities(ResultSet rset) throws SQLException; public default List&lt;T&gt; query(String sql, Object... params) throws SQLException &#123; ResultSet rset = DBManager.executeQuery(sql, params); List&lt;T&gt; entities = toEntities(rset); return entities; &#125;&#125;(2)设计接口实现(样例)12345678910111213141516171819202122232425262728293031323334353637383940public int insert(User t) throws SQLException &#123; String sql = "insert into user values(?, ?, ?, ?, ?, ?)"; return DBManager.executeUpdate(sql, t.getId(), t.getPwd(), t.getGender(), t.getAge(), t.getEmail(), t.getType());&#125;public int delete(Object... params) throws SQLException &#123; String sql = "delete from user where 标识=?"; return DBManager.executeUpdate(sql, params);&#125;public int update(User t) throws SQLException &#123; String sql = "update user set 标识=?, 密码=?, 性别=?, 年龄=?, 邮箱=?, 类型=? where 标识=?"; return DBManager.executeUpdate(sql, t.getId(), t.getPwd(), t.getGender(), t.getAge(), t.getEmail(), t.getType(), t.getId());&#125;public User queryOne(Object... params) throws SQLException &#123; String sql = "select * from user where 标识=?"; List&lt;User&gt; users = query(sql, params); return users.isEmpty() ? null : users.get(0);&#125;public List&lt;User&gt; queryAll() throws SQLException &#123; String sql = "select * from user"; return query(sql);&#125;public List&lt;User&gt; queryMany(int offset, int rows, String[] columnNames, Object... params) throws SQLException &#123; String sql = DBManager.generateSql("user", offset, rows, columnNames, params); return query(sql, params);&#125;public List&lt;User&gt; toEntities(ResultSet rset) throws SQLException &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); while (rset.next()) &#123; User user = new User(rset.getString(1), rset.getString(2), rset.getString(3), rset.getInt(4), rset.getString(5), rset.getString(6)); users.add(user); &#125; rset.close(); return users;&#125;JSP页面出现空白，使用out.print检测到问题出在SQL方法使用语句上，则（1）检查SQL语句（语句格式、参数个数、参数顺序等）（2）检查数据库完整性（长度限制、类型限制、主键限制、非空限制等等）二、过滤器三、系统发布1、以war文件形式发布123456清理并构建：在项目结点右键单击选择“清理并构建”成功后生成文件：MyJsp\dist\MyJsp.war复制文件：复制文件MyJsp.war到webapps中启动Tomcat服务器：运行bin文件夹中的startup.bat启动浏览器进入系统：http://localhost:8080/MyJsp/index.jsp.war的名决定了网站根目录名。war本质上就是写的jsp、java等的压缩文件。使用压缩软件打开还是这些东西2、以web文件夹形式发布1234清理并构建：在项目结点右键单击选择“清理并构建”成功后生成文件夹：MyJsp\build\web复制文件夹：复制整个web文件夹到webapps中，然后改名为MyJsp…… //后续步骤与上面相同（其实war就是对web文件夹的压缩形式）本质是这个文件压缩后就是war至于tomcat部署相关请看【一】其它容器软件再自行查阅学习]]></content>
      <categories>
        <category>JSP程序设计</category>
      </categories>
      <tags>
        <tag>JSP程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语语法+词法【八】]]></title>
    <url>%2Fposts%2F9986c720%2F</url>
    <content type="text"><![CDATA[一、逗号的使用转自：https://zhuanlan.zhihu.com/p/55327367注：英文没有顿号（、），中文用顿号处，英文用逗号。逗号在句中表示一般性停顿。举例：When he came, I was busy cleaning my room.你说完came后停顿了下，那么，此句写出来时，came后要加逗号。除了表示停顿，语法上，根据句子结构，即使在没有停顿的地方，也要用逗号。如下：1. 并列句中，连词（and, but, or, for, so, nor, yet）前用逗号He asked the question in a loud voice, but no one answered.We were tied, and we decided to have a rest.Come early, or you will miss the show.It must have rain last night, for the ground is wet.He is an eccentric, yet you can’t help liking him.但，如果2个或3个并列从句很简短，意思又紧密相连，它们之间也可不用连词，只用逗号。比如：A memoir is history，it is based on evidence.——E.M.Forster。这种用法是特殊情况，比较少见，通常情况下，逗号不能连接前后完成的句子，必须要有连词。举例如下The teacher came in, we were talking.错误When the teacher came in, we were talking. 正确“the teacher came in”和“we were talking”都是主谓宾完整的句子，必须加连词，比如when2. 状语从句或短语（包括介词短语和分词短语）放在句首（主语前），或位于句子中间时，后面应用逗号。When the bell rang, the teacher dismissed the class.（对比The teacher dismissed the class when the bell rang.）In the ancient palace, they saw the throne where emperors used to sit.Born and brought up in the Sourth, she is not used to eating wheat.The audience, interested in the topic, asked the speaker many questions.如果主语前的从句或短语很短，其后可省略逗号，举例如下：On Friday I have an exam. Friday后省略了逗号On hearing the big noise I knew something terrible happened.In one corner of the room they found the injured cat.如果状语从句位于主句后，一般省去逗号。举例如下：The teacher dismissed the class when the bell rang.You will be unable to finish the work in time if you don’t start at once.3. 非限定性定语从句或短语，必须用逗号隔开。He had to leave his home town, where he had lived ever since he was born.Wang Ling, who is the best singer of the class, will teach us.My neighbors, John and Kim Sullivan, are both professors at the college.An old lady, nodding and smilling, invited us in.限定性定语从句或短语，不用逗号隔开，举例如下。The young man (who is) taking with the foreign reporter is the inventor of the machine.This is the house where the famous poet was born.4. 除了并列句，并列成分，即在句中起同样作用的一系列词或短语（它们共同为一个主体服务），用逗号分析。The little girl likes to sing, to dance, and to act.She buys bread, buffer, vegetables, and many other things.The beautiful, old house had a huge living room.The guests included the president, the first lady, the vice president and the minister of defence.（四个人都是Guest之列）He spent the weekend researching his topic, writing his essay and proofreading his final draft. (逗号之后的部分都是在描写he在周末的状态）记得把逗号加入并列连接词前的最后两个成分。否则,句子的含义可能不清楚。举例如下：5. 插入语的前后用逗号分开也可理解为：在完整的句子中插入任何信息，都要使用逗号。The film was, in my opinion, a waste of two hours.Your work, I am sorry to say, is not satisfactory.To call a spade a spade, the experiment was a failure.They have many courses: Chinese, English, Mathematics, History, to name just a few.Students, therefore, should be allowed to use cell phones in class.6. 逗号常用以下例句斜体部分前后Yes, I think so.No, it is not very good.She is the new teacher, isn’t she?He said, “The Summer Palace is like a fairyland.”“The Summer Palace is like a fairyland,” He said.“The Summer Palace,” he said, “ is like a fairyland.”写日期时，如果次序是“月—日—年”，在日和年之间加逗号。如果次序是“日-月-年”，则不加逗号。The delegation will arrive on October 5th, 2000.She was born on 24th May 1979.]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语语法+词法【七】]]></title>
    <url>%2Fposts%2F6eedef63%2F</url>
    <content type="text"><![CDATA[五、名词n. (Nouns)1、名词分类(1)专业名词、普通名词专有名词（大多数是不可数名词，在某些情况下可以复数使用，或者转换为普通名词，单数/复数使用）：人名、地名、国家、组织、单位、大型活动、著名事件等（首字母大写、如果缩写全部字母大写）普通名词：专业名词以外的名词人名：Jack 单位：Department of Education地名：Beijing 大型活动：Midi Festival国家：China 著名事件：Discovery of America组织：FBI专有名词复数使用，专业名词转换普通名词:There are two Jacks in our class我们班有两个杰克Millions of Lei Fengs have emerged in China中国出现了数百万的活雷锋Hey, Tom, have a Mrs. Carl is waiting for you嘿，汤姆，有一位卡尔夫人正在等你(2)可数名词、不可数名词可数名词（单数复数都可以，可以加数词计算）:apple、egg、boy、tree、family、class、police、team等不可数名词（只能单数，不可以加数词计算）:water、fire、、time、hope、knowledge、intelligence等等(3)具体名词、抽象名词具体名词（看得见摸得着，可数不可数都有）:man、Beijing、book、car、water、fire等等抽象名词（无形的各种事物，大多数是不可数）:time、hope、knowledge、love、anger等等2、名词单复数变化规则变化：不规则变化复合名词的变化不可数名词结尾，无复数形式：homework, newspaper, greenhouseman或woman做前缀，前后都要复数：man actor变成men actors3、名词的所有格单数名词/复数名词非s结尾，后加’s，单数名词s结尾，后加’sJack’s（杰克的）The boss’s car（老板的车）复数名词s结尾，后加’用and连接并列名词时候表示各自的所有关系，分别加’s，共同所有关系，只在最后一个名词加’sTom’s and Jack’s rooms（汤姆的房间和杰克的房间）Tom and Jack’s room（汤姆和杰克的房间）‘s+of双重所有格of+名词’s所有格This is a photo of my cat’s这是我猫的照片of+名词性物主代词He is a friend of mine他是我的朋友4、名词主谓一致（主语的单复数和谓语的单复数要保证一致）many a…或more than one+名词做主语，谓语用单数Many a man is smoking很多男人在抽烟More than one man is smoking不止一个男人在抽烟one and a half+复数名词做主语，谓语用单数One and a half watermelons is in the fridge冰箱里有一个半西瓜时间、钱、距离等各种单位看作整体，谓语用单数Two dollars is no big deal两美元没什么大不了Four miles is not a long way四英里的路不远加减乘除运算中，谓语用单数Five times five is twenty-five5乘5是25One plus one is two1加1是2含有集体概念的名词，根据上下文判断，整体概念谓语用单数，个体概念谓语用复数The family was in a poor way这个家庭生活贫困（整体概念，这个家庭）The family goes to the movies together这家人一起去看电影（个体概念，这个家的人）含有单复数形式一样的名词作主语，根据上下文判断，谓语用单数还是复数A fish was back in the water一条鱼回到了水中Some fish are still alive有些鱼还活着a/an+单数名词+or two做主语，谓语用单数、one or two+复数名词做主语，谓语用复数An apple or two is not enough一两个苹果是不够的One or two apples are not enough一两个苹果是不够的There be/Here be的就近原则（距离谓语近的名词，决定谓语单复数）There is one computer and two phones那有一台电脑和两台手机There are two computers and one phone那有两台电脑和一台手机Here is one apple and two bananas这有一个苹果和两个香蕉Here are two apples and one banana这有两个苹果和一个香蕉六、形容词adj(Adjectives.)1、分类属性：（表示人和物具有的属性）可以加very修饰beautiful类别：（表示事物的类别）不可以加very修饰empty、Chinese颜色：浅色前面加light、pale、bright、深色前面加dark、deep强调：absolute、utter、total、entire等等-ing和-ed：某人某事某种情况的特点表示令人感觉boring复合：形容词+名词+ed、形容词/副词+过去分词、形容词/副词/名词+现在分词、名词+形容词2、顺序This is a beautiful small wooden table.（这个一个漂亮的小木头桌子）限定 描述 大小 物质This is a beautiful big sphere broken old yellow patterned American cupreous classic sculpture.（这个一个漂亮的大球形坏掉的老旧黄色带花纹的美国铜质古典雕塑）3、比较级和最高级(1)变化(2)基本用法原级：没有比较的意思或者原级比较表示和什么一样（as…as/the same as/the identical with）That is good.（那很好）比较级：能单独使用，前面能加修饰词（a lot、much、rather、a little、even等），与than连用比较两者You should be more patient.（你应该更耐心）I swim faster than you.（我游的比你快）最高级：前面要加the，能单独使用，前面能加修饰词（far、mostly、almost、very、much等），at+最高级表示处于最什么状态That is the best choice.（那个最好的选择）The car power will at it best.（这车的动力将到达最佳状态）(3)特殊用法比较级and比较级，表示越来越，如果是多音节单词，单词只需要写一个，放最后面faster and faster（越来越快）more and more fantastic（越来越了不起）the比较级…the比较级，表示越怎么越怎么The richer, the more badass. （越有钱越无法无天）more than+名词=not only（不仅、不只）We are more than friend.（我们不只是朋友）more than+数词=over（超过）More than one billion people live in China.（超过10亿人生活在中国）more than+形容词=very（非常）We are more than interested in search gold.（我们对搜索黄金非常感兴趣）no more than：只有，仅仅（等于的意思）I have no more than four games.（我只有四款游戏）not more than：不超过（小于的意思）I have not more than four games.（我的游戏不超过四款）no more…than=neither…nor表示既不是也不是I have no more a PS4 than an XBOX ONE.（我既没有ps4也没有xbox one）not more…than=not so…as表示不如I am not more careful than you.（我不如你小心）less than表示少于We leave in less than a week.（我们不到一周就走）no less than表示多达The total amount is no less than 5000 dollars.（总金额多达五千美元）not less than表示不少于I have not less than four games.（我有不少于四款游戏）no less…than表示和什么一样I am no less careful than you.（我和你一样小心）七、副词adv.（Adverbs)1、副词分类(1)时间副词,表示时间或频率(2)地点副词，表示地点或位置表示地点：here、there、home、upstairs、downstairs、anywhere、everywhere、nowhere、somewhere、abroad、elsewhere等等表示位置：above、below、down、up、out、in、across、back、along、over、round、around、away、near、off、on、inside、outside、past等等(3)方式副词，表示行为方式carefully、properly、anxiously、suddenly、normally、fast、calmly、politely、proudly、 softly、warmly、slowly、badly等等(4)程度副词，表示动作程度nearly、rather、very、too、fully、almost、extremely、absolutely、slightly、simply、awfully、deeply、really、perfectly、quite、much等等(5)疑问副词，引导特殊疑问句how、when、where、why(6)强调副词，强调形容词或动词completely、perfectly、really、totally、really、mainly、only等等(7)连接副词，引导名词性从句（主语从句宾语从句表语从句）或者并列结构how、when、where、why、then、however、thereforeThe problem is how he can do it.问题是他如何做这事You feel all things, then what did you do?我感觉到了一切，然后你做了什么？(8)关系副词，引导定语从句when、where、why(9)句子副词，修饰句子actually、personally、certainly、definitelyActually, it is more than we need.实际上，它比我们需要的还要多2、副词结构以ly结尾的副词，大多数时候形容词+ly等于副词大部分以y结尾变成副词，变y为i加lywards、wise结尾的副词inwards、eastwards、clockwise、likewise本身ly结尾的形容词，不能变成副词或者长一样ugly、lonely、likely形容词和副词一样的hard、late、fast、tight本身就是副词，不是形容词变的so、very、just副词比较级变化，规则跟形容词比较级一样，形容词比较级特殊结构副词一样能用原级：A+实意动词+as+副词原形+as+BYou play basketball as well as Xukun Cai.你篮球打的跟蔡徐坤一样好比较级：A+实意动词+副词比较级+than+BI know you better than she.我比她更了解你最高级：A+实意动词+the+副词最高级+BRice grows the best in soil fertile.水稻在肥沃土地里生长得最好3、易混淆副词too、also、either、nortoo：肯定句和疑问句句尾，用逗号隔开Are you Chinese, too?also：肯定句的谓语动词之前，系动词之后You are also Chinese.either：否定句句尾，用逗号隔开I am not lucky, either.nor：放在句首Nor is Peter anywhere a good man.sometimes、sometime、some times、some timesometimes：有时候Sometimes I go shopping in the mall.有时候去我大商场购物sometime：未来的某个时候Peter, I will meet your mother sometime.皮特,我哪天去见下你的妈妈some times：很多次（一次once、两次twice）You have treated me quite some times recently. Now it’s my turn.你已经请我好几次了，这次轮到我请你了some time：一些时间I should stay home some time.我应该待在家一段时间farther、further表示地点距离远时候，两个词都能用，表示更远Can we walk farther/further tomorrow?我们明天能走远点吗？如果要表示更多、额外，要用further具体的远用farther或者further，抽象的远用furtherSee under for further information.更多内容详见下文most、mostlymost（名词、形容词、副词）表示最、很、十分It isthe most outlandish ideas.那是最奇特的想法mostly（副词）表示主要地、大部分地The atoms themselves are mostly empty space.原子本身大部分的空间是空隙八、动词v. (Verb)1、动词分类能做谓语实意动词：walk、eat、make等及物动词（vt.）不及物动词（vi.）系动词：is、are、look等不能做谓语助动词（没有实际意思，协助主要动词构成谓语的词）：have、do、shall、will、should、can等情态动词：can、may、must、need等be动词感官动词（feel、look、smell、sound、seem）变化动词（get、become、turn、grow）保持动词（keep、stay、remain、rest）2、动词形式动词原形第三人称单数：一般现在时，主语为第三人称单数（人称代词he she it、单个人名、地名、单数可数名词、不可数名词），谓语要用第三人称单数动名词和现在分词动名词起着名词的功能，常在句子中充当主语、定语、表语等成分现在分词来构成进行时态，与助动词be搭配构成句子的谓语，现在分词在句中还可以充当定语、表语和状语过去式和过去分词过去式单独做谓语，表示过去某个时间发生动作过去分词是动词的非谓语形式，表示被动或者完成3、动词时态英语的时态一共十六种，最常用的就六种按照时间轴分：4、动词语态（主动被动）(1)主动句改被动句1、把主动句的宾语改成被动句的主语2、把主动句的谓语动词改成，被动句谓语形式be+过去分词，并且人称和单复数要随着新主语变化，时态保持不变3、把主动句的主语前面加by，放到谓语之后，变化人称宾格，如果看前面就知道是谁被谁做了什么，或者上下文有交代是谁，可以省略by加主语4、其他句子成分保持不变My mother sweeps the floor every day morning.（我妈每天早上扫这地）The floor is swept by my mother everyday morning. （这地每天早上被我妈扫）I bought some books.（我买了一些书）Some books were bought (by me).（一些书被我买了）(2)特殊形式的被动双宾的被动语态形式，双宾的被动语态有两种改法例：He gave her some money. 他给了她一些钱把间接宾语改成被动语态的主语，直接宾语留着原位She was given some money（by him）. 她被（他）给了一些钱把直接宾语改成被动语态的主语，间接宾语前面加to或forSome money was given to her（by him）. 一些钱被（他）给了她宾补的被动语态主动语态的宾语改成主语， 宾补在被动语态中做主语的宾补We made him manger.我们选他做经理He was made manger （by us）.他被（我们）选做经理(3)什么时候用被动语态形式1、不知道动作执行者是谁的情况用被动语态This diamond was stolen yesterday.这钻石昨天被偷了2、强调动作承受者的情况用被动语态Peter was also grown in this country.皮特也是在这国家长大的3、说客观事实可以用被动语态The iPhone was created by Steven Jobs.Iphone是由史蒂芬·乔布斯创造的九、连词conj. (Conjunctions) 、感叹词 int. (Interjections)1、连词平行关系：and，not only…but also…，either..or..或者..或者..，neither…nor..两者都不，both and两者都。后面仨考研不咋考常见平行副词和短语：similarly、equally、likewise、at the same time、in the meanwhile转折关系：but，yet，while，whereas常见转折关系副词和短语：however、nevertheless、conversely、unexpectedly、unfortunately、on the contrary、by contrast选择关系：or，whether…or…（是…还是…？）常见选择关系副词和短语：alternatively因果关系：for，so，because可以当原因的连词，但是它还能当状语从句引导词（之后再讲区别because和for）常见因果关系副词和短语：therefore、thus、consequently、as a result递进：then常见递进关系副词和短语：besides、furthermore、moreover、additionally、subsequently、in addition2、感叹词oh,hello,hi,yeah]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语语法+词法【六】]]></title>
    <url>%2Fposts%2Fbced98fc%2F</url>
    <content type="text"><![CDATA[一、介词prep（Prepositions）用在名词或代词前，说明它与别的词的关系介词的核心理解就是介绍名词，表明关系。不会单独用，它只能接名词、代词、doing，接上就成了介词短语看到介词，除了极少数做表语，要么是定语要么是状语，当找核心的时候可以直接去掉，回头再过来分析(1)易混点-持续更新地点：on、in、atat某个具体位置、加小地点：At bus station（在公交车站）in后面跟大地点：In Beijing（在北京）on表示在上面，后面加楼层：时间：on、in、atat后面跟具体时刻，一天中的具体时间点，具体的周和节日：At midnight.（在午夜）in后面跟年、月、早晚、季节，一段时间，将来时中表示一段时间之后：In Spring（在春天）We will meet in a few days.（我们将在几天后见面）on后面跟具体的时间，某年某月某日星期几：On Monday September 2th 2019. （在2019年9月2日星期一）时间：after、inafter+具体时刻或者从句：表示在什么时刻之后，跟一般过去时态：I was always playing football after school.in+一段时间：表示在多久之后，跟将来时态：We will study math in a new semester.时间：since、forsince+具体时刻或者从句：自从什么时候起，一直到现在for+一段时间：总共有多长之久in the front of、in front ofin front of 表示在某物范围外的前面：There is a tree in front of the school.（学校前面有一棵树）in the front of 表示在某物范围内的前面：We sit in the front of the bus.（我们坐在公交车的前面）使用：by、in、with-穿过：through、across、overthrough穿过、通过森林、人群、门等等，个体穿过一遍区域across和over跨越、跨越过河流、街道、围墙等，跨越一个横向的障碍在…下面：under、below、beneathunder在…之下表示某物接触或覆盖某物时：We finished the project in under a year.（我们在一年内完成了这个项目）below某物低于某物、或者表示温度用：Below freezing.（冰点以下）beneath在…之下（抽象概念）能力、地位、期望低：The game is beneath my expectations.（这游戏低于我的预期）在…上面：above overabove 不一定垂直的上面over是垂直的上面between、amongbetween两种among三者或以上用：in、with、bywith：用某种工具、用身体某个部位、器官；一种实体by：某种方法、手段in：某种语言、颜色、声音、材料、字母大小写(2)介词短语需要逐渐积累(3)图示二、数词 num（Numerals）表示数目或顺序1、基数词(1)数词的表达规律英语中数字表达的规律：中文划分规律 1,0000,0000,0000英文划分规律 1,000,000,000,000从右往左，每三位加一个逗号，倒数第一个逗号之前是thousand，倒数第二个逗号之前是million，倒数第三个逗号之前是billion，倒数第四个逗号之前是trillion（一万亿）①逗号之间(就是每三位中的第三和第二位之间)的百位和十位之间要加and，②数字隔零要加and实际上就是通过三位数的表示+各自等级（trillion、billion、million、thousand）表示每一个级的数量，然后在每个级百位和十位之间加and（这个级全为0除外），连起来读即可。个位数（0~9）:zero one two three four five six seven eight nine十到十九（10~19 后面加teen）:ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen十位数，二十到九十（20~90后面加ty）:twenty thirty forty fifty sixty seventy eighty ninety二十以上，几十几（21~99 十位用几十，个位用个位）:twenty one、ninety nine（100~999）:one hundred、one hundred and one、nine hundred and ninety-nine（1,000~9,999）：one thousand、one thousand and one、one thousand and twenty、nine thousand nine hundred and ninety-nine（10,000~10,999）：（10,000）ten thousand、（10,001）ten thousand and one、（10,020）ten thousand and twenty、（10,200）ten thousand two hundred、（10,999）ten thousand nine hundred and ninety-nine.（11,000~99,999）:(11,000)eleven thousand、（11,001）eleven thousand and one、（11,020）eleven thousand and twenty、（11,200）eleven thousand two hundred、（99,999）ninety nine thousand nine hundred and ninety-nine（100,000~999,999）：（100,000）one hundred thousand、（100,001）one hundred thousand and one、（100,020）one hundred thousand and twenty、（100,200）one hundred thousand two hundred、（102,001）one hundred and two thousand and one、（999,999）nine hundred and ninety-nine thousand nine hundred and ninety-nine（1,000,000~99,999,999）：（1,000,000）one million、（1,000,001）one million and one、one million and one thousand、one million and ten thousand、（99,999,999）Ninety-nine million nine hundred and ninety-nine thousand nine hundred and ninety-nine（100,000,000~1,000,000,000–∞）：（100,000,000）one hundred million、（100,000,001）one hundred million and one、（100,001,000）one hundred million and one thousand、（101,000,000）one hundred and one million、（1,000,000,000）one billion、（31,020,900,888）Thirty-one billion and twenty million nine hundred thousand eight hundred and eighty-eight.(2)基数词特殊使用1、作数词时候，前面可以加数词，后面不能加s，two thousand，three thousands（错）2、如果数词用作名词时候，意思是好几…的时候，前面可以加some、many、several这种词或者加数词，后面可以加of hundreds of（好几百）five hundreds of（五百左右）many millions of （数百万）3、读年份：千年：读作“X thousand”： 1000=one thousand、2000=two thousand百年：读作“X hundred”： 1900=nineteen hundred、600=six hundred百位是零：读作“X thousand and Y”，可省略and： 2008=two thousand and eight 或 two thousand eight 1054=one thousand fifty-four百位不是零：读作“X hundred and Y”，可省略hundred and： 1997=nineteen hundred and ninety-seven 或 nineteen ninety-seven 1811=eighteen eleven十位是零 零读作oh： 1908=nineteen hundred and eight 或 nineteen oh eight测试：2013怎么读？2013=two thousand thirteen，不怕麻烦也可以说two thousand and thirteen2000B．C．读作：two thousand BC1558读作：fifteen fifty-eight1603读作：six teen(hundred and)three／sixteen oh three921读作：nine twenty-one4、表示时刻表示时刻（中国人描述时间习惯精确到个位分钟，外国人描述时间习惯精确到十位分钟，几分钟一般省略）6：00=six o’clock=six on the dot（6点整）6：05=six o five=five past six（6点05分，6点过5分）6：15=six fifteen=a quarter past six（6点15分，6点过一刻）6：30=six thirty=half past six（6点30分，6点半）6：45=six forty-five=a quarter to（till） seven（6点45分，7点差一刻）6：55=six fifty-five=five to（till） seven（6点55分，7点差5分）时区：time zones 上午：ante meridiem=a.m. 下午：post meridiem=p.m.24小时制=24-hour clock=military time（北美不太使用24小时制，都是说12小时制加am和pm）21：00=twenty one hours21：20=twenty one twenty5、电话号码、门牌号、价格都可以直接读数字偶尔：两个一样数字，三个一样数字（double、triple ）门牌号遇三位数分别读出各数字，遇四位数时则分成两半来读。例如：Room 302读作：Room three Of two／three zero two3491 King Street读作：thirty-four ninety-one King Stred价格：1美元=100美分，读的时候经常省略dollars和centsnine thirty= nine dollars and thirty cents (9.30$)ninety-nine ninety-eight= ninety-nine dollars and ninety-eight cents (99.98$)6、小数读的时候以小数点为界，小数点左边的数字为一个单位，表示整数，数字合起来读；小数点右边的数字为一个单位，表示小数，数字分开来读；小数点读作 point12.34读作twelve point three four但是当小数点前后都有数字0时，英语中的读法有很多种。记不住就照标准读法也行，即念法1例如：0.067念法一 zero point zero six seven念法二 point zero six seven念法三 nought point nought six seven念法四 point nought six seven念法五 o point o six seven念法六 point o six seven7、百分比：先念数字在加上「percent」这个字即可。2、序数词(1)序数词介绍第零到第九基数词后面加th（注意几个特殊）：zeroth first second third fourth fifth sixth seventh eighth ninth第十到第十九基数词后面加th（注意一个特殊）：tenth eleventh twelfth thirteenth fourteenth thirteenth fourteenth fifteenth sixteenth seventeenth eighteenth nineteenth第几十（把基数词结尾的y变成i再加eth）：twentieth thirtieth fortieth fiftieth sixtieth seventieth eightieth ninetieth第二十以上，第几十几（十位用基数词，个位用序数词）：twenty first ninety ninth第一百及以上(第整级数的后面加th，如果不是整数，保留基数词只变个位数)：one hundredth one thousandth one millionth one billionth(1,050,000,031st)one billion fifty million and thirty first(2)特殊用法1、使用序数词时，一般前面要加定冠词the2、日期的日在日期的写法上，英式先写日子，美式先写月份。英1999年4月6日=6th April l999美1999年4月6日=April 6，1999在读法上，英国人有两种表达方式：1．April the sixth，nineteen ninety-nine2．The sixth of April，nineteen ninety-nine美国人则一般这样表示：April sixth，nineteenninety-nine(省略“the”)3、表示楼层4、分数分数中分子用基数词表示，分母用序数词表示。序数词表示几分之几，分子大于一，分母有复数形式。（除了1/2特殊，用a／one half ）one third=1/3two thirds=2/3几个常用口语用法：1/2：a／one half1/4：a／one quarter(fourth)比较复杂的分数常常用over这个词表示。如：317/509读作：three hundred and seventeen over five hundred and nine5、序数词前面加a/an表示再一We read the book a third times我们读了三遍这本书三、冠词art (Articles)冠词用在名词前，帮助说明名词所指的范围 a, an, the1、定冠词The表示这个，特指某个名词，后面跟单数/复数名词，不可数名词表示上文提过的人和物——This car is popular, but the car isn’t cheap（这车很热门，但是这车不便宜）表示地理位置用——We are based in the Beijing（我们的总部设在北京）表示江河湖海用——The Yellow River（黄河）唯一存在的事物用——The earth（地球）最高级前用——This is the best cup of coffee（这个最好的一杯咖啡）表示强调时候前用——Beijing is the capital of China（北京是中国的首都）乐器之前用——I like to play the piano（我喜欢弹钢琴）2、不定冠词a、an泛指人和物，表示一个，后面加单数可数名词，辅音发音前面加a，元音发音前面加an第一次提到的人和物it’s a cat（这个一只猫）如果是对唯一事物具体情况说明Their dream is to go on a world tour（他们的梦想是去全世界巡回演出）和名词连用作表语或者同位语，代表职业I am an engineer（我是一个工程师）表示价格、速度、频率80 miles an hour（80英里每小时）固定短语会用have a good time（玩的开心）3、零冠词有情况下可以不需要加任何冠词;一般都是一些不具体的事物很广泛的概念：Sichuan dishes are spicy（四川菜很辣）书名、人名：I am reading “Journey to the West”（我正在读西游记）某些城市、国家：China is a big country（中国是一个大国）某些山河湖海洲：Asia（亚洲）星球：Mars（火星）语言、球类、学科、棋牌：I have studied English for ten years（我学了十年英语）三餐、日期、季节（一般不加冠词，如果要特指可以加the）It’s September 1th（这是九月一日）四、代词pron (Pronouns.)代替名词、数词、形容词We, this, them,myself1、人称代词、物主代词、反身代词2、指示代词说明近处远处、上下文的人或物3、疑问代词(疑问句)用来提出问题的代词，不分单复数，有修饰的名词决定what, who, whose, whom, which, whatever, whichever ,whoever, whomever4、关系代词（定语从句）用来引导定语从句的代词，充当定语从句成分who指人，在定语从句作主语whom指人，在定语从句作宾语which指物，在定语从句作主语或者宾语that指人，相当于who和whom；that指物，相当于which，在定语从句作主语或者宾语5、连接代词（名词性从句）用引导名词性从句（主语从句、宾语从句、表语从句）what什么、who谁、which哪个、whose谁的等等6、相互代词表示相互关系的代词each other、one anotherYou can test each other.你可以互相考验对方we’re still attracted to one another.我们依然喜欢彼此7、不定代词代替或者修饰不确定或不具体的人或物，可以做主语宾语表语定语状语all和both的区别all指三者或者以上的人或者物both指两个人或者物every和each的区别every表示每一个指3个或3个以上的整体中的每一个，侧重于整体each表示每个各个指两个或两个以上中的每一个，强调个别。either和neither的区别either表示两个中间的任何一个The woman was either drunk or crazy.这个女人要么喝醉了要么疯了Neither表示either的否定形式，两个都不I know neither of them.他们两我都不认识other和the other和another的区别other表示不同种类的另一个，其余Do you like other styles?你喜欢其他的款式吗？The other表示两个里面的另一个Why not try the other box?为什么不尝试另外一个盒子？another表示同种类的另一个，又一个I have another story.我有另一个故事others和the others的区别others表示其余的人或物，指大部分Some students are playing football, and others are watching them.有些学生正在踢球，其他学在看他们踢The others表示其余的人或物，指全部John and the others are here.约翰和其他人都在这many和much的区别Many表示很多，跟可数名词复数连用：I have many friends.Much表示很多，跟不可数名词连用：I have much time.something、anything、nothing、everything、somebody、anybody、nobody、everybodysomeone、anyone、everyone、no one的区别合成不定代词谓语动词用单数some- every-开头的用在肯定句中any-开头的用在否定句和疑问句和条件状语从句中]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emmet快速补全]]></title>
    <url>%2Fposts%2Ff1e95fe7%2F</url>
    <content type="text"><![CDATA[0、前言1、VSCode自带集成Emmet，可直接使用。若其他编辑器使用再具体搜索2、出现Emmet提示后制表符或者回车自动生成，后面不再赘述例：输入a后按回车或者table即可生成3、使用Table键还会自带输入位置调转，例如a，生成后就在href中，输入完Table就会到标签中间一、HTML语句1、基本功能(1)标签缩略diva，直接打a等等一系列标签都可以(2)嵌套使用例如：p&gt;span就会生成&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;可多重嵌套(3)标签带 CSS的id或者class例如：div#test生成&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;div.class生成&lt;div class=&quot;class&quot;&gt;&lt;/div&gt;类可以一次生成多个，ID不能，div.test1.text2—&gt;&lt;div class=&quot;test1 test2&quot;&gt;&lt;/div&gt;直接敲#test或者.class会默认生成以div为标签的内容，即和上面等效div.class#test生成&lt;div class=&quot;class&quot; id=&quot;test&quot;&gt;&lt;/div&gt;(4)顺带生成其他属性a[tittle=”test”]生成&lt;a href=&quot;&quot; tittle=&quot;test&quot;&gt;&lt;/a&gt;;可写多个(5)填充文本内容h1{test}—&gt;&lt;h1&gt;test&lt;/h1&gt;2、批量生成p*3div.test*3生成css样式class=test的3个div。使用table还能够顺序书写内容(1)名称带数字序占位$div#test$*3生成123&lt;div id="test1"&gt;&lt;/div&gt;&lt;div id="test2"&gt;&lt;/div&gt;&lt;div id="test3"&gt;&lt;/div&gt;比较实用，因为id只能唯一(2)不从1开始生成数字序@不从1开始生成序号：div#test$$@2*512345&lt;div id="test02"&gt;&lt;/div&gt;&lt;div id="test03"&gt;&lt;/div&gt;&lt;div id="test04"&gt;&lt;/div&gt;&lt;div id="test05"&gt;&lt;/div&gt;&lt;div id="test06"&gt;&lt;/div&gt;加入倒序功能：div#test$$@-5*3新版本貌似失效。3、嵌套生成&gt;生成子关系+生成兄弟关系^生成父关系(1)嵌套多重div&gt;p*3生成12345&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;可多重叠加例如:div&gt;p*2&gt;p,但是需要注意，后面的选项会作用在前面的项的每一个12345678&lt;div&gt; &lt;p&gt; &lt;p&gt;&lt;/p&gt; &lt;/p&gt; &lt;p&gt; &lt;p&gt;&lt;/p&gt; &lt;/p&gt;&lt;/div&gt;可配套使用嵌入id等：div&gt;p*3+h2.test1.test2生成123456&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;h2 class="test1 test2"&gt;&lt;/h2&gt;&lt;/div&gt;header+main&gt;section^footer12345&lt;header&gt;&lt;/header&gt;&lt;main&gt; &lt;section&gt;&lt;/section&gt;&lt;/main&gt;&lt;footer&gt;&lt;/footer&gt;ul*2&gt;li*2等价于(ul&gt;li*2)*212345678&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;4、默认添加tag.test默认生成的class=test的div标签列表后默认生成列表项ul&gt;.class*3=12345&lt;ul&gt; &lt;li class="class"&gt;&lt;/li&gt; &lt;li class="class"&gt;&lt;/li&gt; &lt;li class="class"&gt;&lt;/li&gt;&lt;/ul&gt;表格后面默认是行然后是列table&gt;.row*2&gt;.col*3=table&gt;tr.row*2&gt;td.col*3123456789101112&lt;table&gt; &lt;tr class="row"&gt; &lt;td class="col"&gt;&lt;/td&gt; &lt;td class="col"&gt;&lt;/td&gt; &lt;td class="col"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr class="row"&gt; &lt;td class="col"&gt;&lt;/td&gt; &lt;td class="col"&gt;&lt;/td&gt; &lt;td class="col"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;5、默认属性生成冒号使用。例：a:选择link则生成&lt;a href=&quot;http://&quot;&gt;&lt;/a&gt;常用：script:src、meta中的各类6、表单生成from、input输入即提示，不再赘述。select&gt;option若想写带value的，select&gt;[value=”test$”]*3,这里使用了默认select后默认认为你需要option二、CSS1、margin、paddingm10–&gt;margin:10px;m10p–&gt;margin:10%；m10r—&gt;margin:10rem;可敲四个边框：m10-20-30-40—&gt;margin: 10px 20px 30px 40px;同理，2-3个也一样适用单独敲：mt10—&gt;margin-top: 10px;mb、mr、ml同理可以使用负值2、改变字体fz16—font-size: 16px;fz1!—font-size: 1px !important;CSS其它自行查阅。因为感觉不顺手Emmet 文档]]></content>
      <categories>
        <category>Web系统设计</category>
      </categories>
      <tags>
        <tag>Web系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web系统设计【五】]]></title>
    <url>%2Fposts%2F6f3cef7c%2F</url>
    <content type="text"><![CDATA[JavaScript1、JavaScript概述与基础语法(1)什么是 JavaScriptJavaScript 是一种运行于JavaScript解释器/引擎中的解释型脚本语言.运行环境：1、独立安装的JS解释器(NodeJS)2、嵌入在[浏览器]内核中JS解释器浏览器内核的作用：负责页面内容的渲染。内核主要由两部分组成内容排版引擎解析HTML和CSS脚本解释引擎解析Javascript不同的浏览器的内核是不同的(2)JS组成1、核心(ECMAScript)2、文档对象模型(DOM,Document Object Model)让JS有能力与网页进行对话3、浏览器对象模型(BOM,Browser Object Model)让JS有能力与浏览器进行对话(3)JS特点开发工具简单，记事本即可无需编译，直接由JS引擎负责执行弱类型语言,由数据来决定 数据类型面向对象(4)JavaScript的使用1、将JS代码嵌入在元素”事件”中&lt;div id=&quot;&quot; onclick=&quot;JS代码&quot;&gt;xxx&lt;/div&gt;2、将JS代码嵌入在&lt;script&gt;标记中&lt;script&gt;&lt;/script&gt;允许出现网页的任意位置处3、将JS代码写在外部脚本文件中(.js)在页面中 引入 js文件&lt;script src=&quot;js文件路径&quot;&gt;&lt;/script&gt;注意：方法3中，该对标记中，是不允许出现任何内容的(5)语法规范使用 分号 来表示结束、大小写敏感、英文标点符号、由表达式、关键字、运算符 组成2、基本使用定义变量：var定义函数：function数据类型判断:获取数据类型：typeof(变量名) 或者typeof 变量名NaN：Not a NumberisNaN(数据) : 判断 数据是否为 非数字数据类型转换：toString()parseInt()parseFloat()Number()所有的数据类型 与 string 做 + 运算时，最后的结果都为 string分支：if elseswitch case循环：whiledo whilewhile、do while 都是判断条件为真继续执行for数组（类似python中的元组）：注意，由于其特性，数组内容可以不一致，例如[1,q,”weq”]创建：1、arr=[] 2、arr=new Array()数组的 length属性：记录了数组中理论上的元素个数length属性的值永远是最大下标+1。且更改其内容，就会改变其大小，减小的话就会删除多余元素三不：不限制数组的元素个数、不限制下标越界、不限制数组元素数据类型关联数组（字典）*创建：arr=[]；arr[“test”]=6； *遍历：for（var key in hash）数组APIString(arr) ：将arr中每个元素转为字符串，用逗号分隔固定套路: 对数组拍照: 用于鉴别是否数组被修改过arr.join(“连接符”) ：将arr中每个元素转为字符串，用自定义的连接符分隔，使用空串作为连接符则为无缝转成字符串扩展: 判断数组是空数组: arr.join(“”)==””将数组转化为页面元素的内容:concat() ：拼接两个或更多的数组，并返回结果。不直接修改原数组，而返回新数组！slice(starti,endi) ：返回现有数组的一个子数组范围是starti到endi，前闭后开一直选取到结尾: 可省略第二个参数如果选取的元素离结尾近: 可用倒数下标复制数组: arr.slice(0,arr.length);可简写为:arr.slice();删除splice(starti,n);删除arr中starti位置开始的n个元素，返回值被删除的元素组成的临时数组。直接修改原数组！返回值保存了被删除的元素组成的临时数组插入splice(starti,0,值1,值2,…)：starti位置，插入新值1,值2,…原starti位置的值及其之后的值被向后顺移替换splice(starti,n,值1,值2,…)：先删除arr中starti位置的n个值，再在starti位置插入新值强调: 删除的元素个数和插入的新元素个数不必一致。reverse() ：颠倒数组中元素的顺序arr.sort(): 默认将所有元素转为字符串再排列问题: 只能排列字符串类型的元素解决: 使用自定义比较器函数3、DOM什么是DOM？document object model DOM 是 W3C（万维网联盟）的标准， 是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结 构和样式。 对网页进行增删改查的操作。DOM标准：核心DOM：可操作一切结构化文档的API,包括HTML和XML万能!繁琐!HTML DOM：专门操作HTML文档的简化版DOM API 仅对常用的复杂的API进行了简化 不是万能! 简单对于开发人员来说，先用简单的，再用复杂的补充——以实现效果为目标在 HTML DOM 中，所有事物都是节点。DOM 是被视为节点树的 HTML。常用DOM方法getElementById()返回带有指定 ID 的元素。getElementsByTagName()返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。getElementsByClassName()返回包含带有指定类名的所有元素的节点列表。appendChild()把新的子节点添加到指定节点。removeChild()删除子节点。replaceChild()替换子节点。insertBefore()在指定的子节点前面插入新的子节点。createAttribute()创建属性节点。createElement()创建元素节点。createTextNode()创建文本节点。getAttribute()返回指定的属性值。setAttribute()把指定属性设置或修改为指定的值。(1)DOM查找var elem=document.getElementById(“id”)；按id属性，精确查找一个元素对象var elems=parent.getElementsByTagName(“tag”);按标签名找可用在任意父元素,例如：var ul = document.getElementById(‘menuList’);var list = ul.getElementsByTagName(‘li’);不仅查直接子节点，而且查所有子代节点返回一个动态集合，即使只找到一个元素，也返回集合，必须用[0],取出唯一元素。var list = document.getElementsByName(‘name’);通过name属性查找var elems=parent.getElemnetsByClassName(“class”);查找父元素下指定class属性的元素例如:var div = document.getElementById(‘news’);var list = div.getElementsByClassName(‘mainTitle’);通过CSS选择器查找一个：var elem=parent.querySelector(“selector”)selector支持一切css中选择器如果选择器匹配的有多个，只返回第一个*通过CSS选择器查找多个：var elems=parent.querySelectorAll(“selector”) *selector API 返回的是非动态集合:(2)DOM修改核心DOM: 4个操作①读取属性值：1.先获得属性(节点)对象，再获得节点对象的值:在 HTML DOM 中，所有事物都是节点。DOM 是被视为节点树的 HTML。所以，方法一：通过属性名获取该属性节点的对象，通过该对象获取属性值。有些繁琐，很少使用。获取节点对象(两种):var attrNode=elem.attributes[下标/属性名];var attrNode=elem.getAttributeNode(属性名)通过节点对象获取属性值:attrNode.value——属性值2.直接获得属性值：var value=elem.getAttribute(“属性名”);②修改属性值：elem.setAttribute(“属性名”, value);③判断是否包含指定属性：var bool=elem.hasAttribute(“属性名”)④移除属性：elem.removeAttribute(“属性名”)(3)DOM添加步骤：创建空元素(标签)、 设置关键属性、将元素添加到DOM树创建空元素：var elem=document.createElement(“元素名”)设置关键属性或样式直接通过elem.属性名设置属性直接通过elem.style.样式名设置样式；若样式过多可以通过elem.style.cssText=“样式内容”设置将元素添加到DOM树parentNode.appendChild(childNode)；可用于将为一个父元素追加最后一个子节点parentNode.insertBefore(newChild, existingChild)；尽量少的操作DOM树,因为每次修改DOM树，都导致重新layout1.如果同时创建父元素和子元素时，建议在内存中先将子元素添加到父元素，再将父元素一次性挂到页面2.如果只添加多个平级子元素时, 就要将所有子元素，临时添加到文档片段中。再将文档片段整体添加到页面文档片段: 内存中，临时保存多个平级子元素的 虚拟父元素用法和普通父元素完全一样4、BOM(1)简介Browser Object Model专门操作浏览器窗口的API其既没有标准的实现，也没有严格的定义, 所以浏览器厂商可以自由地实现BOM——没有标准, 有兼容性问题使用要注意浏览器对象模型：window: 代表整个窗口history: 封装当前窗口打开后，成功访问过的历史url记录navigator: 封装浏览器配置信息document: 封装当前正在加载的网页内容location: 封装了当前窗口正在打开的url地址screen: 封装了屏幕的信息event: 定义了网页中的事件机制例如：获取窗口大小完整窗口大小: window.outerWidth/outerHeight文档显示区大小: window.innerWidth/innerHeight(2)定时器什么是定时器?让程序按指定时间间隔自动执行任务。实现网页动态效果、计时功能等周期性定时器：让程序按指定时间间隔反复自动执行一项任务语法：var timer=setInterval(exp,time)；exp：执行语句time：时间周期，单位为毫秒停止定时器：clearInterval(timer); timer是定义的定时器一次性定时器：让程序延迟一段时间执行语法：setTimeout(exp,time)；exp：执行语句time：时间周期，单位为毫秒Jquery1、概述什么是 JQuery? 答：快速、简洁的第三方js库JQuery的核心理念是write less，do more（写更少的代码，做更多的事情）JQuery是DOM操作的终极简化，还屏蔽了浏览器的兼容性问题。核心DOM： 万能，但繁琐HTML DOM： 简单，但不是万能Jquery： 对DOM操作的终极简化如何使用JQuery？答：先引入JQuery.js , 再编写自定义脚本1、将JQuery.js 下载到服务器本地，在script中使用服务器路径2、使用CDN网络上共享的JQuery.js 生产环境中用的最多工厂函数：在JQuery中，无论使用哪种类型的选择符，都要从一个美元符号和一对圆括号开始：$()。所有能在样式表中使用的选择符，都能放到这个圆括号中的引号内。2、JQuery增删改查(1)查找$(“#myList”);就是document.getElementById(‘myList’);括号内的内容可以是基本选择器、层级选择器,他们的表示方法和CSS一样。表示兄弟关系时：(2)修改修改属性获取 $(“…”).attr(“属性名”)修改 $(“…”).attr(“属性名”,值)修改内容修改html内容html( )：(函数值为空)读取或(函数值为修改的内容)修改节点的HTML内容文本操作text( )：读取或修改节点的文本内容值操作val( )：读取或修改节点的value属性值修改样式直接修改css属性获取css样式(计算后的样式) $(“…”).css(“CSS属性名”)修改css样式 $(“…”).css(“css属性名”，值)通过修改class批量修改样式判断是否包含指定class：$(“…”).hasClass(“类名”添加class： $(“…”).addClass(“类名”)移除class ：$(“…”).removeClass(“类名”)(3)添加创建新元素：var $new = $(&quot;html代码片段&quot;)将新元素结尾添加到DOM树：$(parent).append($newelem)(4)删除$(“…”).remove()3、JQuery事件(1)事件绑定语法：$(“…”).bind(“事件类型”，function(e){….})(2)事件对象function(event)中的event这个对象中包含与事件相关的信息，也提供了可以影响事件在DOM中传递进程的一些方法。事件对象记录事件发生时的鼠标位置、键盘按键状态和触发对象等信息clientX/offsetX/pageX/screenX/x：事件发生的X坐标clientY/offsetY/pageY/screenY/y：事件发生的Y坐标keyCode : 键盘事件中按下的按键的值响应式布局响应式布局：检测设备信息，设备宽度不同， 布局不同.这里介绍两种布局方法:CSS3 Media Query媒体查询、第三方开源框架 Bootstrap1、CSS3媒体查询(1)Viewport视口视口：显示网页的区域为了响应式布局，我们对视口规定：布局视口=设备视觉视口、不可缩放实现视口规定:设置meta标签12&lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt;sublime中meta:vp即可 扩展出该设定(2)媒体查询检查设备宽度，根据宽度设置CSS样式设备屏幕尺寸超小屏extra small&lt;768小屏small≥768中等medium≥992大屏large≥1200媒体查询设计：@media表示媒体查询，之后跟查询何种对象的尺寸，这里是screen 可以是打印机等其他。and连接满足的条件min-height 页面最小高度min-width 页面最小宽度max-height 页面最大高度max-width 页面最大宽度根据CSS自上而下顺序解释特性，由于min-width 使用我们也需要将尺寸变化由小到大表示，这样做到覆盖。2、BootstrapBootstrap：来自 Twitter，Bootstrap4 ；开源、移动优先的前端框架 ；是基于 HTML、CSS、JavaScript、JQuery 的 ；写很少代码，实现多终端的页面适配。两个版本：编译版本（不需要修改源码时使用）、源代码版本（既包括源代码又包括编译版本）docs是说明和示例中文官网(1)Bootstrap使用方式一：下载下来引用方式二：CDN方式，通过超链接使用网络上保存的资源。区别只是在于路径设置。两者都是要按照CSS、Jquery、JS顺序引用123456&lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css" rel="stylesheet"&gt;&lt;script src="https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js"&gt;&lt;/script&gt;中文文档中有很多功能和相应源代码，复制下来就能使用了(2)栅格布局需要一个container包括栅格布局界面container中设置row，在row中划分列，来组织一行的栅格大小一行最多12列，放不开就会自动换行md可换，表示设备尺寸xs：extra small &lt;768sm：small ≥768md：medium≥992lg：large≥1200数字代表合并的栅格数，最小的1代表设备尺寸/12通过引入多个class就能够实现响应式布局了]]></content>
      <categories>
        <category>Web系统设计</category>
      </categories>
      <tags>
        <tag>Web系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程【八】]]></title>
    <url>%2Fposts%2F7fcd5454%2F</url>
    <content type="text"><![CDATA[六、面向对象方法学设计(续)3、系统设计面向对象方法学不断迭代更新，分析与设计也是互相作用，一定时刻明确它的特点。(1)系统分解面向对象设计模型：四部分组成。有些领域目标系统可只由3个或更少子系统组成。问题域：直接负责实现客户需求子系统。人机交互：实现用户界面子系统包括可复用的GUI子系统。任务管理：确定各类任务，把任务分配给适当的硬件或软件去执行。数据管理:负责对象的存储和检索的子系统。(2)设计问题域子系统是对分析阶段得到的结果在实现中的补充和迭代调整需求：如果用户需求或外部环境变化；分析模型不完整、准确。无论出现上述哪种情况，通常都只需简单地修改面向对象分析结果，然后再把这些修改反映到问题域子系统中。重用已有类：根据问题解决的需要，把从类库或其他来源得到既存类增加到问题解决方案中去。把问题域类组合在一起：设计时，从类库中引进一个根类，作为包容类，把所有与问题域有关的类关联到一起，建立类的层次。增加一般化类：某些特殊类要求一组类似的服务，应加入一般化的类，定义为所有特殊类共用的一组服务名，服务都是虚函数；在特殊类中定义其实现。调整继承关系：在OOA阶段建立的对象模型中可能包括多继承关系，但实现时使用程序设计语言可能只有单继承，需对分析结果修改。(3)设计人机交互子系统分析阶段：用户界面需求设计阶段：确定人机交互细节，窗口报表形式，命令层次等。三条黄金原则：置用户于控制之下：交互模式的定义不能强迫用户进入不必要的或不希望的动作的方式、允许用户交互可以被中断和撤销、当技能级别增长时可以使交互流水化并允许定制交互、使用户隔离内部技术细节减少用户的记忆负担：减少对短期记忆的要求、建立有意义的缺省、定义直觉性的捷径、界面的视觉布局应该基于真实世界的隐喻、以不断进展的方式揭示信息保持界面一致：所有可视信息的组织均按照贯穿所有屏幕显示所保持的设计标准、输入机制被约束到有限的集合，在整个应用中被一致地使用、从任务到任务的导航机制被一致地定义和实现使用颜色的指导原则：避免使用太多的颜色（通常一个窗口内不要多于三种颜色）、使用颜色的变化显示系统状态的变化、注意颜色的搭配(4)设计任务管理子系统在实际系统中，许多对象之间往往存在相互依赖关系。设计工作的一项重要内容就是，确定哪些是必须同时动作的对象，哪些是相互排斥的对象。进一步设计任务管理子系统。系统总有许多并发行为，需按照各自行为的协调和通信关系，划分各种任务（进程），简化并发行为的设计和编码。确定各类任务，把任务分配给适当的硬件和软件去执行。动态模型就是这种设计的基础。一、分析并发性并发对象：1.无交互行为的对象2.同时接受事件的对象检查各个对象的状态图，找没并发对象的路径（任何时候路径中只有单个对象是活跃的），称控制线。通过分离出控制线设计任务。并发任务的分配方案：1.每个任务分配到独立的处理器2.分配到相同处理器，通过操作系统提供并发支持二、设计任务子系统1、事件驱动型：指睡眠任务（不占用cpu），某个事件发生，任务被触发，醒来做2、时钟驱动型任务：按特定时间间隔去触发任务进行处理。如某些设备需要周期性的采集数据。3、确定优先任务：高优先级，分离成独立任务，保证时间约束。4、确定关键任务：严格可靠性，分离考虑，精心设计和编码，严格测试。5、确定协调任务：三个以上任务，引入协调任务，控制封装任务间协调。6、尽量减少任务数：任务多，设计复杂、不易理解、难维护7、确定资源需求：计算系统载荷，每秒处理业务数，处理一个业务花费时间，估算所需cpu（或其他固件）处理能力。综合考虑，确定哪些任务硬件实现，哪些任务软件实现。(5)设计数据管理子系统即设计合理数据库七、面向对象方法学实现1、程序设计语言所有语言都可完成面向对象实现，但效果不同。使用非面向对象语言编写面向对象程序，则必须由程序员自己把面向对象概念映射到目标程序中。选用面向对象语言有很多优点。2、程序设计风格(1)提高可重用性提高方法的内聚：方法只完成单个功能。涉及多个不相关功能，分解。减小方法的规模： 方法规模过大，分解。保持方法的一致性：功能相似方法有一致名字、参数特征（包括参数个数、类型和次序）、返回值类型、使用条件及出错条件等。把策略与实现分开负责做出决策，提供变元，管理全局资源，称策略方法。负责完成具体操作，称实现方法。实现方法相对独立，可在其它系统中重用，将二者分开。尽量不用全局信息：降低方法与外界耦合程度。利用继承机制：实现共享和提高重用程度的主要途径。①调用子过程，把公共代码分离出来，构成一个公用方法。②分解因子，从不同类相似方法分解出不同的代码，余下作为公用方法中公共代码。把分解出的因子作为名字相同算法不同的方法，在不同类中定义。(2)提高可扩充性封装实现策略： 应把类的实现策略（包括数据结构、算法等）封装起来，对外提供公有接口。不要用一个方法遍历多条关联链：一个方法应只包含对象模型中有限内容。否则导致方法过分复杂，不易理解和修改扩充。避免使用多分支语句：增添新类时会修改原有的代码。合理利用多态性机制。精心确定公有方法：公有方法是向公众公布的接口。(3)提高健壮性预防用户操作错误：任何输入（错误），给出提示信息，再次接收用户输入。检查参数合法性不预先确定限制条件：使用动态内存分配机制，创建未预先设定限制条件数据结构。先测试后优化3、面向对象程序测试(1)测试策略单元测试—&gt;集成测试—&gt;确认测试单元测试单元：封装的类和对象对程序内部具体单一功能模块测试，如程序用C++实现，主要对类成员函数测试。传统的测试方法都可使用，等价类划分、边值分析、逻辑覆盖法、基本路径法。集成测试在面向对象的软件中不存在层次的控 制结构，传统的自顶向下或自底向上的集成策略就没有意义了。 此外，由于构成类的各个成分彼此间存在直接或间接的交互，一次集成一个操作到类中（传统的渐增式集成方法）通常是不现实的。 面向对象软件的集成测试主要有下述两种不同的策略。基于线程的集成测试：把响应系统的一个输入或一个事件所需类集成起来。基于使用的集成测试：先测独立类，测完后测独立类下一层类（依赖类），到测完。确认测试测用户可见动作，可识别系统输出。 根据动态模型和描述系统行为的脚本设计确认测试用例。黑盒法(2)测试用例设计1、单元测试方法用例①随机测试：在类的多个操作排列中，随机选择。但是要注意有些方法有前置条件，据此我们需要找到一条最小操作排列。然后从奇遇操作随机选择测试。②划分测试：随机测试过于盲目，且不好分析。引出划分测试根据改变类状态能力划分设计测试用例：改变类状态；不改变类状态。基于类操作属性的划分： 使用该属性；修改属性；不操作该属性。根据类操作完成功能：初始化操作、计算、查询、终止③基于故障测试：错误推测法，如边界或输入输出为零等。2、集成测试方法用例https://blog.csdn.net/winterwinner/article/details/62835973、确认测试和传统确认测试方法一样，OO软件的确认关注用户可见的动作和用户可识别的系统输出。为辅助确认测试的导出，应充分分析模型中的用例图的场景来提高交互需求中发现错误的可能性。八、软件项目管理1、软件规模度量(1)代码行技术估计每个功能需要源代码（参考类似项目的历史数据）；累计；估计整个软件源程序行数。当程序较小时常用的单位是代码行数（LOC[line of code]），当程序较大时常用的单位是千行代码数（KLOC）。具体方法：1.多名（n）有经验软件工程师估计a:程序最小规模b:程序最大规模m:程序最可能规模2.求三种规模的平均值3.求程序规模优点：代码是所有软件开发项目都有的“产品”，而且很容易计算代码行数。缺点：源程序不等于软件,实现语言不同代码行数不同,不适用非过程语言(2)功能点技术依据软件信息域特性和软件复杂性评估结果估算软件规模。1、估算未调整功能点UFP2、计算技术复杂性因子DI以及计算TCF=0.65+0.01×DI3、计算功能点数FP=UFP×TCF2、工作量估算工作量是软件规模函数，单位为人月（pm）。支持大多数估算模型的经验数据，都是从有限个项目的样本集中总结出来的，因此，没有一个估算模型可以适用于所有类型的软件和开发环境。(1)静态单变量模型E=A+B*(ev)CA、B、C为经验常数，ev是估算变量（LOC或FP）。面向LOC估算模型面向FP估算模型(2)动态多变量模型工作量是软件规模和开发时间两个变量的函数。是根据从4000多个当代软件项目中收集的生产率数据推导出来的。(3)基于过程的估算将任务分解为相对较小任务集合。估算完成每个任务需要的工作量。累计.3、进度计划管理复杂工程项目，最好办法是把工程项目分解成许多逻辑步骤（作业），安排作业顺序，确定每项作业需要用时间，及作业开始和终止时间。把工作量分配给特定的软件工程任务并规定完成各项任务的起止日期，从而将估算出的项目工作量分布于计划好的项目持续期内。Gantt图例如：矩形木板房需重新油漆。三步：刮旧漆，刷新漆，清除溅在窗上油漆。15名工人，5把刮旧漆刮板，5把刷漆刷子，5把清除溅在窗上油漆小刮刀。在甘特图上加上菱形标记代表里程碑。4、软件开发组织形式(1)民主制小组（Democratic Team）组内成员之间可以平等交换意见。组内成员之间可以平等交换意见。优点：发挥每个成员积极性。缺点：削弱个人责任心和必要权威作用。且人员多了交流会影响效率适用领域：适合于研制时间长、开发难度大项目。(2)主程序员制小组专业化：每名成员完成受过专业训练的工作层次化：主程序员有绝对权威(3)现代程序员组主程序员由两人担任：技术负责人；行政负责人。分工明确。明确划分技术负责人和行政负责人权限.软件项目规模较大，程序员组分成若干个小组。将民主式程序员组与主程序员组的优点结合进来，形成包含分散决策组织形式。5、控制—风险管理使软件项目按预定计划和预期目标进行.(1)风险的类别项目风险：可能对项目的预算、进度、人力、资源、顾客和需求等方面产生不良影响的的潜在问题技术风险：潜在的设计、实现、接口、验证和维护等方面的问题，此外，规约的二义性、技术的不确定性、陈旧或不成熟的“领先的”技术都可能是技术风险商业风险：威胁要开发的软件的生存能力开发了一个无人真正需要的产品(市场风险)开发的产品不符合公司的整体商业策略(策略风险)建造了一个销售部门不知如何销售的产品(销售风险)由于重点转移失去了高级管理层支持(管理风险)没有得到充分预算或人力资源保证(预算风险)(2)风险识别采用系统化方法，识别特定项目已知和可预测的风险。例如风险检查表。(3)风险分析对已识别风险进行估计和评价，确定风险发生的概率与后果。定性分析。评估已识别项目风险影响和可能性，按可能产生影响排序。定量分析。(4)风险驾驭制定具体风险应对策略。-风险规避是设法降低风险出现的可能性；-风险缓解是设法减少风险产生的影响；-风险转移是将风险转移给第三方；-风险接受是采取应急方案应对风险的发生。6、控制—质量控制对于非物理实体，而是逻辑实体的软件怎么衡量？软件质量定义（ANSI/IEEE）：与软件产品满足规定的和隐含的需求能力有关的特征或特性全体。(1) 软件需求是度量软件质量的基础。(2) 按规范化标准定义开发准则，不遵守软件质量不能保证。(3) 不能忽略隐含需求。影响软件质量因素：用软件质量模型描述，较著名模型为McCall等人1979年提出，这些因素是从管理角度对软件质量的度量。不在赘述。软件质量保证措施：基于非执行的测试：复审或评审基于执行的测试：软件测试程序正确性证明技术复审的必要性（走查、审查）：走查：是开发者的一次友好的会议，需要仔细规划，有明确的目的、日程、持续时间和参与人员，许多小组以星期为单位走查。审查：最系统化严密的评审技术。审查范围比走查广泛、步骤较多。不再赘述7、控制—配置管理]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程【七】]]></title>
    <url>%2Fposts%2F88a67c17%2F</url>
    <content type="text"><![CDATA[四、面对对象方法学介绍(续)5、UML-物理框架系统架构：逻辑架构；物理架构。逻辑架构：描述系统功能。用例图、类图、对象图、状态图、活动图、协作图、顺序图。物理框架：关心的是实现。类和对象物理上分布在那个程序或进程中；程序进程在哪台计算机上运行；系统有哪些硬件设备，如何连接。用构件图和配置图。(1)构件图(Component Diagrams)构件图（Component Diagrams）展现了一组构件的类型、内部结构和它们之间的依赖关系。构件代表系统一物理实现块，一般作为一独立文件存在。构件种类：部署构件 工作产品构件 执行构件部署构件：是构成一可执行系统必要构件，如操作系统，Java虚拟机。工作产品构件：开发过程产物，包括源代码文件及数据文件。构件不直接参与可执行系统，用来产生可执行系统的中间工作产品。执行构件：构成一可执行系统必要构件，动态链接库、exe文件、CORBA构件、.net构件等。解析：虚线箭头：依赖关系，这些是执行构件的执行关系。(2)配置图(Deployment Diagrams)配置图（Deployment diagram）描述了系统硬件和软件物理配置情况和系统体系结构，显示系统运行时刻的结构。配置图包含结点和连接两个元素，配置图中的结点代表实际的物理设备以及在该设备上运行的构件和对象，结点的图符是一个立方体。配置图各结点之间进行交互的通信路径称为连接。用结点间的连线表示。6、UML扩展机制利用扩展机制，用户可定义使用自己的模型元素。(1)UML扩展机制-标签值标签值是存储元素相关信息字符串，可附加在任何独立元素（图形元素、视图元素）。标签是建模人员需要记录某些特性的名称；值是给定特性的值。标签值对项目管理特别有用，如元素创建日期开发状态、完成日期和测试状态。 标签值用｛｝扩起。(2)约束约束是用文字表达式表达的语义限制，对声明全局的或影响大量元素的条件特别适用。约束表示为括号中的表达式字符串，附加在类、对象、关系上和注释上等。(3)版类版类（版型）在模型本身中定义的一种模型元素，UML元素具有通用语义，利用版类进行专有化和扩展，在已有元素上增加新语义。版类用放置在基本模型元素符号中或附近的被《》括起的文字串显示，还可为特殊版型创建图标，替换基本元素符号。7、UML实例总用例图–&gt;各种子用例图–&gt;各种顺序图–&gt;各种协作图–&gt;各种类图–&gt;生成类核心代码例如：拟开发一软件，完成学校管理中的教务部门功能，包括班级管理、课程管理、帐户管理等，要求用UML建模。………等等顺序图+协作图7、uml建模工具StarUML亿图图示专家Software Ideas ModeleRGuiAstahArgo UMLhttps://zhuanlan.zhihu.com/p/30512183《UML与StarUML使用 》分享五、面对对象方法学分析1、分析过程面向对象分析过程：获取需求、整理需求、建立模型、书写需求规格说明书、复审。获取需求：获取需求和传统方法下需求分析一致不再赘述整理需求：整理需求传统方法也类似。书写需求陈述；需求陈述内容包括问题范围，功能需求，性能需求，应用环境及假设条件。建立模型：面向对象分析模型由三个独立模型组成功能模型：指明系统应“做什么”，由“用例图”表示。对象模型：描述静态结构, 定义做事情实体，类图和对象图表示。动态模型：描述交互过程, 由状态图和顺序图表示。需求陈述：某银行拟开发一个自动取款机系统，它是一个由自动取款机、中央计算机、分行计算机及柜员终端组成的网络系统。ATM和中央计算机由总行投资购买。总行拥有多台ATM，分别设在全市各主要街道上。分行负责提供分行计算机和柜员终端。柜员终端设在分行营业厅及分行下属的各个储蓄所内。该系统的软件开发成本由各个分行分摊。银行柜员使用柜员终端处理储户提交的储蓄事务。储户可以用现金或支票向自己拥有的某个账户内存款或开新账户。储户也可以从自己的账户中取款。通常，一个储户可能拥有多个账户。柜员负责把储户提交的存款或取款事务输进柜员终端，接收储户交来的现金或支票，或付给储户现金。柜员终端与相应的分行计算机通信，分行计算机具体处理针对某个账户的事务并且维护账户。拥有银行账户的储户有权申请领取现金兑换卡。使用现金兑换卡可以通过ATM访问自己的账户。目前仅限于用现金兑换卡在ATM上提取现金(即取款)，或查询有关自己账户的信息(例如，某个指定账户上的余额)。将来可能还要求使用ATM办理转账、存款等事务。所谓现金兑换卡就是一张特制的磁卡，上面有分行代码和卡号。分行代码唯一标识总行下属的一个分行，卡号确定了这张卡可以访问哪些账户。通常，一张卡可以访问储户的若干个账户，但是不一定能访问这个储户的全部账户。每张现金兑换卡仅属于一个储户所有，但是，同一张卡可能有多个副本，因此，必须考虑同时在若干台ATM上使用同样的现金兑换卡的可能性。也就是说，系统应该能够处理并发的访问。当用户把现金兑换卡插入ATM之后，ATM就与用户交互，以获取有关这次事务的信息，并与中央计算机交换关于事务的信息。首先，ATM要求用户输入密码，接下来ATM把从这张卡上读到的信息以及用户输入的密码传给中央计算机，请求中央计算机核对这些信息并处理这次事务。中央计算机根据卡上的分行代码确定这次事务与分行的对应关系，并且委托相应的分行计算机验证用户密码。如果用户输入的密码是正确的，ATM就要求用户选择事务类型(取款、查询等)。当用户选择取款时，ATM请求用户输入取款额。最后，ATM从现金出口吐出现金，并且打印出账单交给用户。2、功能模型功能模型用用例图表达，研究需求陈述建立用例图。步骤：1.识别外部执行者；2.识别用例；3.建立用例图；4.补充用例描述：为建立对象模型和动态模型打基础。从需求分析中要点提取：银行柜员使用柜员终端处理储户提交的储蓄事务。储户可以用现金或支票向自己拥有的某个账户内存款或开新账户。储户也可以从自己的账户中取款。通常，一个储户可能拥有多个账户。拥有银行账户的储户有权申请领取现金兑换卡。使用现金兑换卡可以通过ATM访问自己的账户。目前仅限于用现金兑换卡在ATM上提取现金(即取款)，或查询有关自己账户的信息(例如，某个指定账户上的余额)。将来可能还要求使用ATM办理转账、存款等事务。补充用例描述：为建立对象模型和动态模型打基础。参与者:就是使用这前置条件:使用前提触发器:什么时候出发替代事件过程：出现问题怎么办3、对象模型建立对象模型步骤：(1)确定分析类1、找出候选分析类确定边界类：通常，一参与者与一用例间交互或通信关联对应一边界类识别实体类：实体类通常是用例中的参与对象，对应着现实世界中“事物”①提取需求陈述中名词②筛选出正确的类：将冗余、无关、笼统、属性、操作进行合适的删除或者合并操作(2)确定类的关联初步确定关联：动词或动词词组、隐含关联、与用户及领域专家讨论补充。①直接提取动词短语②找需求陈述中隐含的关联③根据问题域专业知识得出的关联④筛选删除已删去类之间关联与问题无关或与实现密切相关的关联删去瞬时事件删除三元关联分解为二元关联或限定关联。*⑤进一步完善：正名、分解、补充 *(3)划分主题总行主题、分行主题、ATM主题(4)确定属性找需求陈述中的名词修改：误把类当属性：独立存在更重要，则应为类。误把链属性作为属性：属性要依赖某关联链存在，则为关联类的属性。误把限定当属性：属性值固定下来可减少重数，则应为限定。误把内部状态当属性：误把内部状态当属性过于细化：忽略对大多数操作都没有影响的属性。存在不一致属性：分解两个类。(5)识别继承(6)反复修改4、动态模型1.编写典型交互行为脚本2.从脚本中提取事件及相关对象，用顺序图表达3.确定对象状态及状态间转换关系，用状态图描绘六、面向对象方法学设计1、面向对象方法特点分析：提取、整理用户需求，建立问题域精确模型。设计：转变需求为系统实现方案，建立求解域模型。面向对象设计特点：分析和设计活动是一个多次反复迭代的过程。面向对象方法学在概念和表示方法上的一致性，保证了在各项开发活动之间的平滑(无缝)过渡，领域专家和开发人员能够比较容易地跟踪整个系统开发过程，这是面向对象方法与传统方法比较起来所具有的一大优势。（参考瀑布模型，不断迭代）2、准则及启发规则传统方法学的准则和启发规则也适用，不再赘述。①抽象：通过像类抽象机制实现 ，提高可重用性②信息隐蔽：通过封装性实现 ，提高独立性③弱耦合：对象间耦合：交互耦合（松散）、继承耦合（紧密）交互耦合：对象间通过消息连接实现，降低消息连接复杂度和信息数（减少参数个数，降低参数复杂度）继承耦合：一般类和特殊类之间耦合。有继承关系基类和派生类是系统中粒度更大模块。所以要保证低交互耦合，高继承耦合④强内聚：服务内聚：一个函数只完成一个功能。类内聚：一个类只有一个用途，否则分解。继承内聚：设计合理，是对领域知识正确抽取。⑤可重性：尽量利用已有类（类库、已创建类），创建新类也要考虑以后可重用性启发规则：设计结果清晰易懂：用词一致、使用已有协议、减少消息模式的数目、避免模糊的定义继承关系深度适当：约100个classes，则设计7±2层设计简单class：避免过多的属性和方法、分配给每个类任务应简单、objects间合作关系简单、使用简单的协议和服务： 经验表明，通过复杂消息相互关联的对象是紧耦合的，对一个对象的修改往往导致其他对象的修改。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程【六】]]></title>
    <url>%2Fposts%2F5aa60b88%2F</url>
    <content type="text"><![CDATA[四、面对对象方法学介绍1、简介传统软件工程方法学适用于中小型软件产品开发；面向对象软件工程方法学适用于大型软件产品开发；面向对象方法学方程式：OO＝对象＋类＋继承＋传递消息实现通信对象：具有相同状态的一组操作的集合，对状态和操作的封装。类：是一个抽象数据类型，它对具有相同状态和相同操作的一组相似对象的定义。实例：实例是由某个特定类所描述的一个具体对象。消息：要求某对象执行某个操作的规格说明。接收消息的对象：对象名消息名：函数名0或多个变元：函数值方法：对象执行的操作，即类中定义的服务。属性：类中所定义数据，对客观世界实体具体性质的抽象。继承：子类自动共享基类中定义的属性和方法的机制。多态性：在类等级不同层次可共享一个方法名，不同层次每个类按各自需要实现这个方法。A是基类，B和C是A的派生类，多态函数Test参数是A的指针，Test函数可以引用A、B、C的对象。重载：在同一作用域内，参数特征不同的函数可使用相同的名字。运算符重载：同一运算符可施加于不同类型操作数上面。面向对象方法学与人类习惯思维方法一致，稳定性好软件系统结构根据问题领域模型建立，功能需求变化不会引起软件结构整体变化，作局部性修改。可重用性好、易开发大型软件产品可维护性好。2、UML（Unified Modeling Language）统一建模语言介绍UML 全称为 Unified Modeling Language，是图示化、说明、构造一个软件系统并生成其文档的标准语言。它独立于开发过程，可与大多数面向对象开发过程配合使用。UML独立于程序设计语言，可用C++、Java等任何一种面向对象程序设计语言实现。UML构成：九大图：静态建模用例图（Use Case Diagrams）类图（Class Diagrams）对象图（Object Diagrams）动态建模顺序图（Sequence Diagrams）协作图（Sequence Diagrams）状态图（State Diagrams）活动图（Activity Diagrams）物理建模配置图(Deployment Diagrams)构件图(Component Diagrams)五视图：用例视图：定义了系统的外部行为，是最终用户、分析人员和测试人员所关心。该视图定义了系统的需求，因此约束了描述系统设计和构造的某些方面的所有其他视图。设计视图：描述的是支持用例视图中规定的功能需求的逻辑结构。它由程序组件的定义，主要是类、类所包含的数据、类的行为以及类之间交互的说明组成。实现视图：描述构造系统的物理组件，这些组件包括如可执行文件、代码库和数据库等内容。这个视图中包含的信息与配置管理和系统集成这类活动有关。进程视图：进程视图包括形成并发和同步机制的进程和线程。部署视图：部署视图描述物理组件如何在系统运行的实际环境(如计算机网路)中分布。*不同的视图突出特定的参与群体所关心的系统的不同方面，通过合并所有五个视图中得到的信息就可以形成系统的完整描述 *3、UML-静态建模(1)用例图（Use Case Diagrams）用例图描述外部执行者（actor）与系统的交互，表达系统功能，即系统提供服务。主要元素：用例和执行者。如何发现执行者？提问： 谁使用该系统；谁改变系统的数据；谁从系统获取信息；谁需要系统的支持以完成日常工作任务；谁负责维护、管理并保持系统正常运行；系统需要应付那些硬件设备；系统需要和那些外部系统交互；谁对系统运行产生的结果感兴趣。如何发现用例？提问： 执行者需获取何种功能，需要作什么；执行者需读取、产生、删除、修改或存储系统中某种信息；系统发生事件和执行者间是否需要通信。用例：执行者与计算机一次典型交互，代表系统某一完整功能。椭圆形+名字表示：①用例是从用户观点分析而不是系统观点。即联想生活的具体工作过程而不是抽象描述。②用例就是描述一个实际功能，不要太过细化。可理解成就是在找函数名，函数实现是在其内部的，这里不要搞出来。用例间关联：泛化关系(一般与特殊关系)、扩展关系、包含关系泛化关系(一般与特殊关系)：顶部空心三角的实线表达，由特殊指向一般。A是B和C的父类，B,C具有公共类（父类）A，说明A是B,C的一般化（概括，也称泛化）扩展关系：虚线箭头+&lt;&lt;extend&gt;&gt;说明表述。允许一个用例扩展另一用例提供的功能，与泛化关联类似，有更多规则限制：基本UseCase必须声明若干“扩展点”，扩展UseCase只能在扩展点上增加新行为。例如，系统中允许用户对查询的结果进行导出、打印。对于查询而言，能不能导出、打印查询都是一样的，导出、打印是不可见的。导入、打印和查询相对独立，而且为查询添加了新行为。包含关系：虚线箭头+&lt;&lt;include&gt;&gt;说明表述。一个基本UseCase行为包含另一个UseCase行为。例如:Check Credit检查输入的信用卡号是否有效，有足够资金。处理Purchase Ticket用例，总运行Check Credit用例执行者:描述与系统交互的人或物，代表外部实体（如用户、硬件设备或其它软件系统）。人形+名字表示：执行者关联：泛化关系(一般与特殊关系)泛化关系(一般与特殊关系)：顶部空心三角的实线表达，由特殊指向一般例：例：建立一航空公司的机票预定系统，让客户通过电话或网络买票、改变订票、取消订票、预定旅馆、租车等等。当一个用例使用另一个用例时,这两个用例之间就构成了使用关系.向一个用例中添加一些动作后构成了另一个用例,这两个用例之间的关系就是扩展关系,后者称为扩展用例。(2)类图（Class Diagrams）1、类图介绍类图是面向对象建模最常用的图，描述类与类间的静态关系。类属性的语法：[可见性] 属性名[：类型] [=初值]（带[]说明可省略。）可见性：公有（＋）、私有（－）、保护（#）公有：可被外部对象访问私有：不可为外部对象访问，只能为本类对象使用保护：可为本类对象和子类对象访问。类操作的语法：[可见性]操作名[（参数列表）] [：返回类型]例：2、类的版型：边界类、控制类、实体类、接口类边界类：位于系统与外界的交界处用户接口边界类User interface boundary class：窗体（form）、对话框（dialog box）、报表（report）外部系统边界类External system boundary class：表示通讯协议（如TCP/IP）的类、直接与外部设备交互的类、直接与外部系统交互的类控制类：每个用例通常有一个控制类，控制用例中的事件顺序，控制类也可以在多个用例间共用。实体类：用于对必须存储的信息和相关行为建模的类。接口类：描述一个类或构件服务的操作集，不含属性，只包含方法的声明。表示：3、类图的关系四种：关联、泛化（继承）、依赖、实现。用重数表示关联中的数量关系:n表示多；0..0 表示0; 0..1表示0或1；0..n表示0或多；1..1表示1; 1..n 表示 1或多；(1)关联关系：普通关联、导航关联、限定关联、关联类、聚合、组合①普通关联：普通关联：双向，用实线连接两个类。例如：一个作家可以有1个或多个计算机，一个计算机可以属于多个作家。②导航关联:关联是单向的，用实线箭头和导航关系连接两个类。例如：人拥有汽车③限定关联:限定符放在关联关系末端的矩形内。本来是多对多的关系，但是现在需要制定一个产品订货，限定产品ID为xx的产品只能用唯一的订货作业线订货。④关联类：如果关联需要有一些信息需要记录的话，用关联类记录关联附加信息。例：公司雇佣人，使用job记录雇佣产生的信息。⑤聚合（Aggregation）：整体与部分关系，较弱情况。 空心菱形端代表整体事物类；代表部分事物类可属于整体事物类。聚合关系中代表部分事物对象与代表聚合事物对象生存期无关，删除聚合对象不一定删除代表部分事物对象。⑥组合（Composition）：是整体与部分较强关系，实心菱形端代表整体事物类，代表部分类完全隶属于整体类。组合中删除组合对象，同时也就删除代表部分事物对象。(2)泛化关系,是指类间的“一般-特殊”关系。也就是继承。顶部空心三角的实线表达，由特殊指向一般。(3)依赖关系：一模型元素变化必影响另一模型元素。虚线箭头表述，依赖的类指向独立的类(4)实现:是指一个类描述了另一个类保证实现的合约。顶部是空心三角的虚线箭头表示。由一个类指向实现的类。系统设计视图中的类AccountBusinessRules（帐户商业规则）由接口类IRuleAgent（规则代理）实现。(3)对象图（Object Diagrams）​ *对象图表示一组对象之间联系，对象图是类图的实例。 *类图和对象图是建立对象模型主要工具，用于各类系统：信息管理系统、数据库系统、Web应用系统、实时控制系统。(4)包UML中包是对模型元素成组组织的通用机制。 把语言相近，可能一起变更模型元素组织在包里，便于理解复杂系统。包图由包和包间联系构成，包的联系：依赖、泛化。包依赖：一个元素定义改变引起另一元素发生相应改变，用虚线箭头表示包间依赖关系，虚箭线从依赖包指向独立包。包泛化：两个包间有一般特殊关系，实线+空心三角箭头表示包间泛化关系。4、UML-动态建模(1)消息简单消息：没有描述通信的细节。实线箭头表示。同步消息：调用者发出消息后等待消息返回后再继续执行。实线箭头结尾加×表示异步消息：调用者发出消息后不等待消息返回就继续执行。返回消息：代表从过程调用的返回。虚线箭头表示过程控制流:可省,隐含每个调用有配对返回非过程控制流(如异步)：不可省(2)顺序图（Sequence Diagrams）顺序图（sequence diagram） 描述对象间交互关系。对象用矩形框表示，框内标对象名；矩形框下的竖线代表对象的生命线；对象生命线上的细长矩形框表示对象被激活；对象间通信用对象间水平消息线表示，箭头形状表明消息类型（同步、异步或简单）。注：已经声明的对象可以将其图像表示代替矩形框更加清晰。(3)协作图（Sequence Diagrams）协作图（Collaboration diagram） 描述相互协作对象间交互关系和链接关系。顺序图着重表现交互时间顺序；协作图着重表现交互对象的静态链接消息；协作图显示对象间处理过程的分布。顺序图着重表现交互时间顺序；协作图着重表现交互对象的静态链接消息。协作图可以由顺序图转化。(4)活动图（Activity Diagrams）活动图（Activity diagram）描述为完成某一个用例需要做的活动以及这些活动的执行顺序。活动图由状态图变化而来，各自用于不同目的。状态图着重描述对象的状态变化以及触发状态变化的事件。活动图着重描述各种活动的执行顺序。业务活动流的分劈和接合用粗短线（同步杆）表示。一入多出为分劈； 多入单出为接合。注意区分同步杆和分支，分支是选择一个路，同步杆是两者均做。泳道：对象对活动的责任，泳道把活动分成若干组，把组指定给对象，对象履行该组活动。泳道说明了是哪个对象履行功能(5)状态图（State Diagrams）查看行为模型。不再赘述]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程【五】]]></title>
    <url>%2Fposts%2F3fa84051%2F</url>
    <content type="text"><![CDATA[三、结构化系统实现(续)2、软件测试(续)(4)测试策略（测试步骤）单元测试-&gt;集成测试-&gt;系统测试-&gt;验收测试1、单元测试测试内容模块接口： 数据是否正确进出模块。局部数据结构：局部数据的说明、初始化、默认值是否有问题。重要执行路径（白盒）：重要执行路径是否有错误计算、不正确比较或不适当控制流。出错处理通路：错误描述是否难于理解；记下错误是否与实际遇到错误不同；错误处理之前，错误条件已引起系统干预；错误处理不正确；描述错误信息不足以帮助确定错误位置；等错误处理是否恰当合适。边界条件（黑盒）： 最重要，软件容易在边界上失效。2、单元测试测试方法代码审查（人工）：先由编写人非正式进行，再由审查小组正式进行，可查30％到70％设计错误和编码错误。程序编写者讲解，审查小组审查。一般由经验丰富的开发人员执行。计算机测试：由于需要单独测试某一个模块所以我们需要设计一些辅助的程序来测试模块，主要有两种.驱动模块──相当被测模块主程序。接收测试数据，传送给被测模块，再输出测试结果。桩模块 ──存根模块。代替被测模块调用的子模块。3、集成测试测试内容穿越接口数据是否丢失；一模块功能是否对另一模块功能产生不利影响；各子功能组合起来，能否达到预期的父功能；全局数据结构是否有问题；单个模块误差累积起来，是否会放大等。（尤其是浮点等误差是否会放大。）4、集成测试测试方法①非渐增式集成：把所有模块一次组装进行测试。②渐增集成：将模块逐步组装成较大系统自顶向下集成深度优先广度优先自底向上集成非渐增式集成对于大型系统很难适用，因为太过复杂，直接合并甚至能否运行都位置。对于小型团体或个人软件开发来说，它就具有简单易行的特点完全使用自顶向下：不能直接使用调用的模块，而桩模块需要设计，由于自顶向下所以桩模块很麻烦完全使用自顶向上：设计控制模块即可，但是新增模块后是否会对已有模块造成影响很难判断，需要极高的耦合或者大量回归测试③混合策略改进的自顶向下测试方法：基本用自顶向下方法，早期用自底向上测试关键模块。混合法： 软件结构上层模块用自顶向下，下层用自底向上。5、回归测试重新执行已作过测试的某子集，保证变化没带来非预期副作用。回归测试集：（1）检测软件全部功能的代表性测试用例；（2）专门针对可能受修改影响的软件功能附加测试；（3）针对被修改过软件功能测试6、系统测试用于系统测试的测试类型:恢复测试：以不同方式强制软件出现故障，检测软件能否恰当完成恢复自动恢复:检测重新初始化、数据恢复、重新启动等是否正确。人工干预恢复:检测平均恢复时间是否在允许范围内。安全性测试：测试者扮演试图攻击系统角色：通过外部手段获取密码；通过客户软件攻击系统；控制系统使其他人无法访问；引发系统错误，期望在系统恢复中侵入系统等。只要有足够的资源和时间，一定能够侵入系统！设计目标：攻破系统付出代价大于攻破系统后得到信息价值。强度测试：检验系统能力最高达到实际限度, 让系统处于资源异常数量、异常频率、异常批量条件下测试系统承受能力。一般比平常限度高5-10倍的限度做测试用例。性能测试：软件运行性能与性能要求比较，检验是否达到性能要求规格。7、确认测试（验收测试）*确认测试以需求规格说明书为测试基础；采用黑盒法。主要就是测试不同用户不同环境下的软件表现。 *(5)调试软件调试是在进行了成功的测试之后才开始的工作。它与软件测试不同，调试的任务是进一步诊断和改正程序中潜在的错误。调试方法①强行排错（1）将内存内容打印出来分析。（2）程序特定部位设置打印语句。若找不到范围，可利用二分法。（3）自动调试工具。②回溯法排错(小程序常用)：确定最先发现“症状”位置。人工沿程序控制流程向回追踪源代码，直到找到错误根源或确定错误产生范围。③原因排除法对分查找法：如已知每个变量在程序内若干关键点正确值，用赋值或输入语句在程序中点附近“注入”正确值，运行程序检查输出。正确，错误原因在程序上半部分；反之，在程序后半部分。反复使用，将程序出错范围缩小到容易诊断的程度。归纳法：从一些线索（错误征兆）着手，通过分析它们之间的关系来找出错误。演绎法：演绎法是从一般原理或前提出发，经过排除和精化的过程来推导出结论的逻辑方法。根据已有测试用例，设想所有可能出错原因；逐个排除不正确的；验证余下假设确是出错原因。(6)软件可靠性可靠性:程序在给定时间间隔及环境条件下，按规格说明书的规定，成功运行的概率。可用性:给定的时间点，按规格说明书规定，成功运行概率。注意区别：可用性强调的是时间点，是否可用。可靠性是时间段：在该时间段内能否成功运行，其中可有系统自行修复漏洞、人工修复等时间，判断的是时间段内能否成功运行的可靠性。可靠性Ass=成功运行时间/成功运行时间+错误时间引入系统平均无故障时间MTTF和平均维修时间MTTR的概念，则：估算平均无故障时间：1000条指令5~20错误，是由大量数据得来的。只有Et我们无法获知，因为就连测试都是尽可能的发现错误。我们需要一些方法获取。（1）植入错误法：测试之前由专人在程序中随机植入错误，测试后，根据发现错误中原有的和植入的两种错误的比例，估计程序中错误总数。缺点：人为植入的错误，发生概率和自然有很大偏差。（2）分别测试法：如果能对程序中原有的错误加上标记，然后再通过进一步的测试，就可以对潜在故障进行估计。由甲乙两测试员分别测试，一测试员测出错误作为有标记错误。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语语法+词法【五】]]></title>
    <url>%2Fposts%2Fde21e42d%2F</url>
    <content type="text"><![CDATA[七、特殊结构1、强调句(1)什么是强调句It is ….that/（who）….that既能指物也能指人， who只能指人。强调句和原句时态一致，但是只有两种时态，is和was 含过去就was否则就is！强调句型就像一个框架，它在句子中不作任何成分，强调谁就把谁框到句首，其它部分都不变！所以，判断写的强调句是否正确：看去掉强调句框架的句子是否正确。强调句型可以强调句子中任何成分，唯一不能强调谓语！！区分主语从句和强调句型：去掉it…that…看句子是否正确完整。我昨天在街上遇到了我的旧情人I met my old flame in the street yesterday.就是我昨天在街上遇到了我的旧情人It was I that met my old flame in the street yesterday.就是昨天我在街上遇到了我的旧情人.It was yesterday that I met my old flame in the street.(2)考点分析1、写作写作中所有的句子都能写成强调句型。1、有很多的原因解释这种现象There remain abundant elements to account for the issue.It is abundant elements that there remain to account for the issue.It is to account for the issue that there remain abundant elements.2、你至今仍然没有意识到就是因为你交友不慎，你才没有考上心目中理想的大学So far , you have never realized that because you had unfavorable friends ，you failed to go to your dreamful university.So far, you have never realized that It was because you had unfavorable friends that you failed to go to your dreamful university.2、长难句分析But it is the arrival of new satellite channels-funded partly by advertising and partly by viewers subscriptions-that will bring about the biggest changes in the long term.subscription订阅advertise广告两个破折号之间是插入语funded partly by advertising and partly by viewers subscriptions插入语：可认为是定语、同位语、状语。in the long term根据原则先看看翻译成定语合不合适，不合适再换成状语。这里合适。但是，新的卫星频道的到来（部分由广告和部分由订阅者提供资金）将在长期内带来最大的变化。Perhaps it is humankind’s long suffering at the mercy of flood and drought that makes the idea of force the waters to do our bidding so fascinating.flood 洪水drought 干旱bidding 投标do one‘s bidding 服从也许是人类长期遭受洪水和干旱的苦难使强迫水服从于我们的想法变得如此迷人。2、倒装句(1)什么是倒装Do you love me ？Have you ever been Europe？Is your father a teacher？一般疑问句就是倒装。倒装就是把一句话写成一般疑问句的形式，也就是给一句话加个助动词或把be动词放在句首。①否定意义的词放在句首用倒装②so,nor/ neither位于句首，表明承前句子的肯定或否定时用倒装。so表示肯定，nor/ neither表示否定③含有so…that.结构的句子将so引导的部分置于句首时用倒装④only引出的状语位于句首时用倒装。注意是状语！⑤as引导让步状语从句，从句的表语可以放在句首构成部分倒装（前面已经讲过了，就是表语放在句首）⑥省略if的虚拟语气用倒装注意，前面说法表示句子处于的状态，后面倒装意味着把剩下的句子倒装；也就是给一句话加个助动词或把be动词放在句首。用法①我几乎不会说日语I can hardly speak Japanese.Hardly can I speak Japanese.can hardly才是否定词Playing phones not only influences the physical and mental health of youngsters but also waste their precious time.Not only does Playing phones influences the physical and mental health of youngsters but also waste their precious time.but also 不是否定词，且这是并列的两个句子，第一个句子倒装不影响第二个句子。在任何情况下我们都不能忽略保护环境的重要性Under no circumstances can we keep a blind eye to the issue of environmental protection.Under no circumstances已经是否定词了用法②I can cook . So can I cook.I can not cook. Nor can I cook.I can not dance well. My daughter can not dance either.I can not dance well，neither/ nor can my daughter.用法③He was so excited that he cannot help laughing at midnight【倒装为】 So excited was he that he cannot help laughing at midnight.He is having class so forcefully that everyone present was convinced.【倒装为】 So forcefully is he having class that everyone present was convinced.用法④His girlfriend called his name only once【倒装为】 Only once did his girlfriend call his name.My dearest mother always lives only in my deep heart【倒装为】 Only in my deep heart does my dearest mother always live.You will call your mother only when you need living expenses.【倒装为】 Only when you need living expenses will you call your mother.用法⑤as引导的让步状语从句，从句的!表语!可以放在句首构成部分倒装。As I seem ugly， I keep gentle.Ugly as I seem， I keep gentle.(2)倒装的考点分析1、写作倒装满分句型。文化交流不但能促进我们国家经济的发展，而且还能开阔个人的眼界。Not only can cultural exchange promote economic advance but also makes our eyesight broad .我累得浑身都没有劲了。So exhausted am I that I have no energy through out.只有在自己的家里，我才感到安全和放松。Only at home，do I feel relaxed.2长难句分析识别倒装句、还原倒装在翻译。Television is one of the means by which these feelings are created and conveyed-and perhaps never before has it served so much to connect different peoples and nations as is the recent events in Europe.serve服务means 手段电视是创造和传达这些情感的手段之一，而且与欧洲最近发生的事件一样，它在连接不同民族和国家之间的作用也许从来没有像现在这样重要。Only gradually was the by-product of the institution noted, and only more gradually still was this effect considered as a directive factor in the conduct of the institution.只是逐渐注意到该机构的副产品，而且直到后来才逐渐将此效果视为机构行为的指导因素。For example, they do not compensate for gross social inequality, and thus do not tell how able an underprivileged youngster might have been had he grown up under more favorable circumstances.compensate 补偿gross 重大的thus 从而inequality 不平等underprivileged 弱势群体省略了if例如，他们并不能弥补严重的社会不平等，因此也无法说明如果贫困的年轻人在更有利的条件下长大，他可能会有多大的能力。3、虚拟语气(1)什么是虚拟语气虚拟语气表示与事实相反或者表示委婉。用法①（一般用法）：if引导的条件状语从句。即if引导的条件状语从句都可以使用虚拟语气表达。(2)虚拟语气用法①（一般用法）如果你是我眼中的一滴泪，我就永远不会哭泣。普通条件句：If you are a tear in my eyes ，I will never shed it.虚拟语气：If you were a tear in my eyes ，I would never shed it.普通条件句：If I was a dog. I could sleep with you .虚拟语气：If I had been a dog. I could have slept with you .（情态动词没有过去式，could不变）如何把普通条件状语句变虚拟语气?，只需要把已经写好的句子的时态变成过去式就可以了。并且在虚拟语气中be 动词的过去式只有were，could=would=might=should如果下辈子我还记得你，我们死都要在一起。If remembered you in my next life ，we would never seperate with each other.如果你当初听我的话，你就应该通过这次考试了。If you had obeyed my instruction at the outset，you could have passed the examination.省略if的倒装：if去掉，+倒装（变一般疑问句）If Had you obeyed my instruction at the outset，you could have passed the examination.(3)普通用法考点分析1、作文满分句型If every citizen raised a pet in his family ，the environment would be destroyed.2、长难句分析虚拟语气无长难句分析，翻译一致(4)虚拟语气用法②（特殊用法）：以下情况从句用” should+v原形”表示虚拟，并且 should可以省略。以防：incase、lest、for fear that命(令)：order、direct、command贱(建议)：advise、suggest、propose要求：ask、request、demand、require用虚拟*是必要的：it is necessary/important that *只要见到这批单词，从句都用should+v原形表示虚拟，自己写should就不要省了。Incase that you should develop fatal infections ，you had better stay at home.老师要求我们交研究报告The teacher asks that we should hand in our research report.以下情况从句用一般过去时表示虚拟（很少）常见的有两个：would rather（宁愿）和 It is high time that（是…的时候了）It is high time that the dependence of kids were cultivated by their citizens.以下情况要区别对待：就是把它本来的时态写成过去式（很少）常见的词有：wish（和事实相反的希望）、if only(如果…该多好)、 but for(要不是..)、or/ otherwise(否则)、as if/as though(好像似乎)等If only I were a child If only I had been a child.(5)特殊用法考点分析1、写作对于普通市民来说，保护小区环境，不乱丢垃圾是非常必要的。It is necessary that the community environment should be protected and rubbish should be never dumped for the common.2、长难句分析虚拟语气无长难句分析，翻译一致4、情态动词情态动词是表达说话人主观态度的词汇，情态动词后+动词原形。情态动词就相当于助动词。(1)一般用法must必须should应该will、would：委婉的请求；时态上would是will的过去式，但是在做情态动词的时候不用过于区分都能用，都表示委婉Will you marry me？can、could ：意思一样，都是能够，时态上would是will的过去式，但是在做情态动词的时候不用过于区分都能用，只不过could更委婉may、might：意思一样，都是 可能，时态上would是will的过去式，但是在做情态动词的时候不用过于区分都能用，只不过might更委婉(2)特殊用法情态动词表示现在和将来的推测：情态动词后+动词原形I must be wealthy in future.情态动词表示对过去的的推测He must have been self-biased in his university.must have done ：一定做过某事；must的是can not 而不是must not ，must not 是禁止做….You need not have show your love in this way.*need not have done：本没必要做某事但是做了 *I could have become a prominent poet.could have done ：本能够做某事但没有做表示遗憾We should got married if there exists a chance.should have done：本能够做某事但没有做但是没有遗憾5、插入语它是指插在句子中的词语或句子，其位置比较灵活，通常用逗号、破折号隔开，与句子的其他部分之间没有语法上的关系。其作用是对一句话的附加解释、说明或总结，有时表示说话人的态度和看法，有时起强调作用，有时是为了引起对方的注意，还可以起转移话题或说明原因的作用，也可以承上启下，使语句间的衔接更为紧密。通常是定语、状语、同位语，放在句子的主谓之间。用逗号或破折号隔开(1)常用插入语副词作插入语，常见的有：(2)考点分析翻译时小括号隔开。八、句子的“态”小结1、时态时态就是时间+状态。一共4*4=16种。重点八种。时间：过去 现在 将来 过去将来状态：一般 进行 完成 完成进行时态v用法含义一般过去时v的过去式完全发生在过去，现在不这样了一般现在时v原型、v第三人称单数①现在一般都这样，经常性，习惯性发生②永恒的真理一般将来时will+v原型或者am/is/are going to+v原型；shall+v原型也可以（只能用在第一人称后，很少出现）现在的将来要发生的事过去将来时would+v原型或者was/were going to+v原型通常会搭配过去的环境才使用；站在过去看将来过去、现在、（将来）进行时be+doing 就是be动词的时态变现在完成时have/has done（v的过去分词）做完不做完不重要，重要的是有汇报总结做的结果的语义；现在的之前发生的事过去完成时had+done（v的过去分词）过去和过去完成，一个在前一个在后，具有说明发生顺序的作用2、情态情态动词是表达说话人主观态度的词汇，情态动词后+动词原形。情态动词就相当于助动词。(1)一般用法must必须should应该will、would：委婉的请求；时态上would是will的过去式，但是在做情态动词的时候不用过于区分都能用，都表示委婉Will you marry me？can、could ：意思一样，都是能够，时态上would是will的过去式，但是在做情态动词的时候不用过于区分都能用，只不过could更委婉may、might：意思一样，都是 可能，时态上would是will的过去式，但是在做情态动词的时候不用过于区分都能用，只不过might更委婉(2)特殊用法情态动词表示现在和将来的推测：情态动词后+动词原形I must be wealthy in future.情态动词表示对过去的的推测He must have been self-biased in his university.must have done ：一定做过某事；must的是can not 而不是must not ，must not 是禁止做….You need not have show your love in this way.*need not have done：本没必要做某事但是做了 *I could have become a prominent poet.could have done ：本能够做某事但没有做表示遗憾We should got married if there exists a chance.should have done：本能够做某事但没有做但是没有遗憾3、语态（主动和被动，只需要区分主动即可，其他常用都是主动）be donebe需要区分时态难写的一个：现在进行的被动他现在正在被打He is being to beaten .]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机图形学【二】]]></title>
    <url>%2Fposts%2Fc472e442%2F</url>
    <content type="text"><![CDATA[三、基本图形生成算法基本图形：指基本二维图形元素，包括点、直线、圆、椭圆、多边形域、字符串等。对于随机扫描显示器和向量绘图仪：将输出指令保存在显示文件中，再由指令把坐标值转换为偏转电压，并在每个刷新周期内，使电子束偏转到相应位置。对于光栅扫描显示器，图形的输出是输出平面。若把光栅扫描显示平面看作是像素的矩阵，则图形的输出就是在该矩阵上确定一个像素的集合来逼近该图形。具体地，输出时在指定的屏幕位置上控制Z轴辉亮，使该位置上的荧光点发亮。因此，图形的生成主要是研究图形的光栅化，即图形的扫描转换。为什么找点？注意！后面的虚方格网中，每个方格代表一个像素，方格中心设置坐标得到红色的坐标系。这样每个点对应背后的像素,可看到绿色是覆盖了虚方格网中的方格。1、直线的扫描转换(1)微分数值法（DDA）DDA算法原理：由于直线的一阶导数是连续的，而且对于△x和△y是成比例的，因此，可通过在当前位置（xi，yi）上分别加上小增量εΔx和εΔy（c为无穷小的正数）来求出下一点的坐标（xi+1，yi+1）。xi+1=xi+εΔxyi+1=yi+εΔy通常选择: ε=1/max(|△x|,|△y|) ，这样保证了位移偏移最大为1，像素不会断裂，必定会有点相接或者边相接保证连续。特点:增量算法（最大位移方向+1或-1）直观、易实现x、y、k必须是float，且每一步都必须对x、y进行舍入取整，不利于硬件实现。(2)中点Bresenham算法核心思想：在最大位移方向上走一步时，在另一个方向上是否走步取决于误差项的判断。改进后去除浮点运算增加速度。为什么乘上2△x后更新的时候还是d+…？因为d 初始就乘上2△x了 后面的d也包含这个意思。具体看证明过程。0≤K≤1K≥1-1≤K≤0K≤-1d0=△x-2△yd0=2△x-△yd0=-△x-2△yd0=-2△x-△ydi&gt;0：di+1=di-2△ydi&gt;0：di+1=di+2△x-2△ydi&gt;0：di+1=di-2△y-2△xdi&gt;0：di+1=di-2△xdi&lt;0：di+1=di-2△y+2△xdi&lt;0：di+1=di+2△xdi&lt;0：di+1=di-2△ydi&lt;0：di+1=di-2△x-2△y全部类型证明证明过程（0≤k≤1），k其它范围使用同样方法同样可证相应的d：(3)改进的中点Bresenham算法1、改为判断d和下一个中点的距离例如:0≤k≤1，根据DDA算法启发，我们知道x+1时，y+k。2、令e=d-0.5，消除大小比较改为符号比较。3、改进摆脱小数、除法运算2e△x来替换e最终得到0≤k≤1时Bresenham算法改进2、圆的扫描转换画圆，画出1/8即可，通过y轴y轴、直线y=x、y=-x的对称变换关系，可以得到其余部分。默认在原点设计即可，实现想要换位置直接在x、y上平移原点即可笛卡尔方程直接计算：极坐标直接计算：上面都是一整个圆，画1/8个圆调整取值域即可。但是上述算法有乘除开根号三角函数，效率低。下面是更高效的算法(1)圆的DDA算法使用和差公式：移项：xi-xi+1=yi·ε，因为移动最大间距为1，所以 yi·ε≤1，ε≤1/yi，因为y最大为R，所以ε≤1/R同理，xi也最终推出ε≤1/Rε选取的值越小，计算的点越多，但执行时间越长。为了在光栅系统上得到连续的边界，可选取ε﹦1／R，这样绘制的象素位置大约为一个单位间隔。此算法也被称为DDA圆的生成算法。此圆的生成算法中仍包含浮点数和乘法运算，影响速度。(2)圆的Bresenham算法移项得到隐函数——&gt;带入中点，＞0圆内选上＜0圆外选下—&gt;算大于0和小于0的递推项，算出初始项。注意：计算初始值，带入第一个中点，不是原点。使用d-0.25代替d消除小数：3、椭圆的扫描转换椭圆的中点Bresenham算法椭圆根据对称性，只需要画1/4即可。第一象限，先是X方向是最大位移方向，之后转换为Y，需要找到分界点。即切线斜率为-1的点。1.输入椭圆的长半轴a和短半轴b;2.计算初始值：d=b2+a2 (-b+0.25),x=0,y=b；3.绘制点(x,y)及其在四分象限上的另外3个对称点；4.判断d的符号。若d≤0，则先将d更新为d+b2(2x+3),再将（x,y）更新为（x+1,y）;否则先将d更新为d+b2(2x+3)+a2(-2y+2),再将（x,y）更新为（x+1,y-1） ;5.当b2(x+1)&lt;a2(y-0.5)时，重复步骤(3)和(4)，否则转(6);6.用上半部分计算的最后点(x,y)来计算下半部分中d的初值：d=b2(x+0.5)2+a2(y-1)2-a2b2 ;7.绘制点(x,y)及其在四分象限的另外3个对称点;8.判断d的符号.若d&lt;=0，则先将d更新为d+b2(2x+2)+a2(-2y+3),再将(x,y)更新为(x+1,y-1);否则先将d更新为d+a2(-2y+3),再将(x,y)更新为(x,y-1);9.当y＞＝0时，重复步骤(7)和(8)，否则结束。4、多边形的扫描转换和区域填充多边形的两种表示方法顶点表示：用多边形的顶点序列来刻划多边形。点阵表示:是用位于多边形内的像素的集合来刻划多边形。(占内存)既然大多数图形应用采用顶点序列表示多边形，而顶点表示又不能直接用于显示，那么就必须有从多边形顶点表示到点阵表示的转换，这种转换就称为扫描转换多边形或多边形的填充。(1)改进的有效边表算法（y连贯性算法）(1)初始化：构造边表ET，AET表置空；(2)将第一个不空的ET表中的边与AET表合并；(3)由AET表中取出交点对进行填充。填充时设一布尔变量b(初值为假)，令指针从AET中第一个结点到最后一个结点遍历一次，每访问一个结点，把b取反一次，若b为真，则把从当前结点的x值到下一结点的x值结束的区间用多边形色填充。填充之后删除y=ymax的边。(4) y_(i+1)=y_i+1,根据x_(i+1)=x_i+1/k计算并修改AET表，同时合并ET表中〖y=y〗_(i+1)桶中的边，按次序插入到AET表中，形成新的AET表；(5)AET表不为空则转(3)，否则结束。(2)区域填充区域是指已经表示成点阵形式的填充图形，它是像素集合。区域填充是指将区域内的一点(常称种子点)赋予给定颜色,然后将这种颜色扩展到整个区域内的过程。区域的表示方法：通常有内点表示和边界表示两种形式。边界表示法：把位于给定区域的边界上像素一一列举出来的方法。在边界表示法中，区域边界上的像素着同一颜色，而区域内的像素点不能着这种颜色。由于边界以特殊颜色指定，填充算法可逐个像素地向外处理，直到遇到边界颜色为止。以此为基础的区域填充算法称为边界填充算法(Boundary-fill Algorithm)。内点表示法：枚举出给定区域内所有像素的表示方法。在内点表示法中，区域内的所有像素点着同一颜色，而区域边界上的像素着不同的颜色。以内点表示法为基础的区域填充算法称为泛填充算法(Flood-fill Algorithm)。区域填充算法要求区域是连通的，因为只有在连通区域中，才可能将种子点的颜色扩展到区域内的其它点。区域通常分为4-连通区域和8-连通区域两类。扫描转换与区域填充的区别基本思想不同多边形扫描转换是指将多边形的顶点表示转化为点阵表示；它改变了表示方法。区域填充只改变区域的填充颜色，不改变区域表示方法。它已经是点阵表示了，只是涂色。基于的条件不同在区域填充算法中，要求给定区域内一点作为种子点，然后从这一点根据连通性将新的颜色扩散到整个区域；扫描转换多边形是从多边形的边界(顶点)信息出发，利用多种形式的连贯性进行填充的。当以边界表示时，4-连通边界填充算法只能填充4-连通区域，8-连通边界填充算法也只能填充8-连通区域。当以内点表示肘，8连通泛填充算法可以填充8-连通区域也可以填充4-连通区域，当然连通泛填充算法还是只能填充4连通区域。因为边界表示的算法选择涂色点的条件为，不是边界色且未置为填充色内点表示时算法选择涂色点的条件为，是给定的内部点的颜色且未置为填充色(3)反走样走样：用离散量表示连续量引起的失真，就叫做走样（Aliasing）。光栅图形的走样现象①阶梯（锯齿）状边界②图形细节失真③狭小图形遗失：动画序列中时隐时现，产生闪烁反走样方法：硬件方法：提高分辨率的反走样方法显示器的水平、竖直分辩率各提高一倍，则显示器的点距减少一倍，帧缓存容量则增加到原来的4倍，而扫描转换同样大小的图元却要花4倍时间。方法简单，但代价非常大。软件方法过取样：在高于显示分辨率的较高分辨率下用点取样方法计算，然后对几个像素的属性进行平均得到较低分辨率下的像素属性。重叠过取样基于加权模板的过取样区域采样 ：在整个像素区域内进行采样，这种技术称为区域采样。又由于像素的亮度是作为一个整体被确定的，不需要划分子像素，故也被称为前滤波。简单区域取样加权区域取样]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语语法+词法【四】]]></title>
    <url>%2Fposts%2Ff0eee44e%2F</url>
    <content type="text"><![CDATA[五、状语从句1、形容词、副词修饰的成分形容词：表语、定语副词：(动词、形容词、副词、整个句子)—-&gt;都是状语成分He cried sadly.He looks especially sad.He cried rather sadly.Actually，he cries.2、什么是状语状语就是在一个句子中，用来修饰实义动词、形容词、副词或整个句子的成分。状语在一句话当中，除了名词不能修饰，什么成分都可以修饰。状语的成分：副词、介词短语、非谓语动词、从句状语的位置：随便放3、状语从句状语从句的引导词是按照引导词本身的意思分类，一共分为九类强调：状语从句中连接词不作任何成分，只需要写出从句，根据从句本身的意思添加引导词即可。例如：Where there is a will, there is a way.(1)时间状语从句1、时间状语从句的表示1）引导词+句子when=while=as（当while翻译成“当…的时候”的时候后面要跟进行时态，不管是过去还是现在，要点是进行时态）before、aftersince自从（只要几句话带自从，主句一定是完成时态！）the moment=as soon asby the timeuntilnot until2、状语从句时态问题当爱来临的时候，我要牵住她的手。When love comes, I will hold her hands在所有的状语从句中，如果主句的动作和从句的动作都尚未发生的话，主语用一般将来时，从句用一般现在时表示将来。主将从现。当爱来临的时候，我没有牵住她的手。When love came, I failed to hold her hands体现了主句的动作和从句的动作都尚未发生才主将从现。否则是什么时态就写什么时态。3、区别until和not untilI will wait here until you come.I will not leave until you come.区别在于主句的谓语动词是瞬间动词还是延续性动词。如果是延续性动词就用until，如果是瞬间动词就用not until直到我长大，我才明白母亲的伟大。I did not realize the greatness of mothers until I grew up.4、when引导的时间状语从句省略的情况When I was a kid，I enjoyed singing songs.when引导的时间状语从句，如果主句和从句的主语一致，并且从句的谓语中有Be动词，此时从句的主语和Be动词可以同时省略。(2)地点状语从句（在哪儿…）1、地点状语从句的表示1）介词短语2）引导词+句子where这种树在潮湿的地方生长的很好。The kind of trees grow well in moist places.The kind of trees grow well where it is moist.做地点状语的通常都是介词短语，很少是从句。(3)原因状语从句（因为….）1、原因状语从句的表示1)引导词。使用：引导词+句子becauseasin thatsinceseeing thatconsidering thatnow thatgiven that他们全部等效，可替换，常用前四个。2)连词。使用：连接两个句子,for只能放在两个句子中间。而because等引导的句子可在任意位置for3)介词短语。使用：后跟n或者doingbecause ofdue toowing tothanks tofor the sake ofas a result of因为他粗心他出了一场事故He had a car accident because he was careless.He had a car accident for he was careless.He had a car accident because of his carelessness.(4)目的状语从句（为了….）1、目的状语从句的表示1)+动词原形toin order toso as to2)引导词+句子so that（通常放在句末不在句首）in order that为了看的更远，我们爬得更高。We will ascend higher in order to overlook farther.farther 具象的更远 further抽象的更远，例如两人的心更远了(5)结果状语从句（如此…以至于…）1、结果状语从句表示so. .that…such.. that….区别：so的后面跟形容词或者副词，而such后面跟名词。so that也能作为结果状语从句，表示结果。导致了……It feels so hot today that I wear my dress.Today is such a hot day that I wear my dress.so. .that…在作文中可以用在替换very上,实际上就是很….(6)让步状语从句（虽然、尽管）一个小技巧：明让步、暗转折，暗含的转折后内容就像but转折后的内容，是重点。无论是听力还是阅读都容易出题。1、让步状语从句表示1）连接词+句子althoughthougheven thougheven if前四个都是尽管的意思asas引导的让步状语从句，从句的!表语!可以放在句首构成部分倒装。As I seem ugly， I keep gentle.Ugly as I seem， I keep gentle.While（翻译成虽然、尽管，只能放在句首不能放在句中）while的小总结：while在句首，基本上就是“尽管”while后+进行时态，当…时候。while后不是进行时态一定不是“当…时”while当作“但是”基本上就是两句话中间(7)方式状语从句（好像、似乎）1、方式状语从句的表示1）连接词+句子as 按照…的方式the wayas if/ though2）介词短语+n/doingbythroughby means ofin….wayin….manner例：She looks as if she were made of ice.（were是虚拟语气）She talks with me as if she were my mother.（were是虚拟语气）(8)条件状语从句（只要..）1、条件状语从句表示1）引导词+句子ifonceas long assuppose thatsupposing thatunless =if notprovided thatso long as只要有一丝希望，我也不会放弃。If there seems a little hope，I will never give up.(9)比较状语从句as….as…than你看起来想我一样漂亮You are as beautiful as I.原句：You are as beautiful as I am beautiful.你比我看起来更漂亮You looks more beautiful than I.原句：You looks more beautiful than I am beautiful.它们一定不是me 而是I。因为写me结构破坏，主句和从句结构何在？(10)注意！常见的伴随是方式状语，但是它没有从句，通常是介词表示。4、状语和状语从句的考点分析(1)写作作文中任何一句话都可以加一个状语把句子拉长。I love you.I love you for my whole life.I love you although you do not love me.你可以像猪一样生活，但是你永远不会像猪一样快乐。One can live as if he were a pig conversely ，he can never be as delighted as a pig。(2)长难句分析能够快速的识别一句话当中的状语成分，并且把他们通顺的翻译出来。如何识别状语？一句话当中除了句子的主干和定语以外，其他部分都可以认为是状语。只要在句子中见到以下东西就是状语：①副词②比较状语从句③条件状语从句④结果状语从句⑤让步状语从句⑥原因状语从句⑦目的状语从句⑧方式状语从句⑨伴随状语所以我们主要任务就是区分时间和地点什么时候是状语什么时候是定语。只需要区分n+时间/地点。如果无法确定定语还是状语，定语优先原则。只有翻译成定语读起来很不通顺才翻译成状语。例：I love the boy in zhejiang university.虽然定、状都有其意思，但是定语是通顺的就按照定语来。翻译的时候状语都放在最前面。1、The Greeks assumed that the structure of language had some connection with the process of thought, which took root in Europe long before people realized how diverse languages could be.主：The Greeks谓：assumed宾：that the structure of language had some connection with the process of thought, which took root in Europe long before people realized how diverse languages could be.定：of language 、of thought、which took root in Europe long before people realized how diverse languages could be.状：in Europe、long before people realized how diverse languages could be.希腊人认为语言的结构与思维过程有关，这种思维过程早在人们认识到语言的多样性之前就已经扎根于欧洲。2、Social science is that branch of intellectual enquiry which seeks to study humans and their endeavors in the same reasoned orderly, systematic, and dispassioned manner that natural scientists use for the study of natural phenomena.主：science系：is表：that branch branch是可数名词，这里没+the也不是负数，而它又不能单独拿出来使用，所以这里不是标语从句！表语是that branch定：of intellectual enquirywhich seeks to study humans and their endeavors in the same reasoned orderly, systematic, and dispassioned manner that natural scientists use for the study of natural phenomenathat natural scientists use for the study of natural phenomena状： in the same reasoned orderly, systematic, and dispassioned mannerenquiry n.查询seek to 寻求intellectual n.知识分子 adj.智力的，脑力的endeavor努力reasoned 合理的orderly有顺序地systematic系统的dispassioned不偏心的manner 方式natural 自然的社会科学是知识研究的一个分支，这个分支（后置）试图以同样理性的有序的、系统的和冷静的方式来研究人类和人类的行为（状语翻译时提前），自然科学家也是用这种方式来研究自然现象的（定语较长，仍然后置）。3、The behavioral sciences have been slow to change partly because the explanatory items often seem to be directly observed and partly because other kinds of explanations have been hard to find.主：The behavioral sciences系：have been表：slow to change状：partly because the explanatory items often seem to be directly observed两个状语and并列。状：partly because other kinds of explanations have been hard to find.behavioral行为的行为科学之所以发展缓慢，部分原因是一些解释能直接被观察到，部分原因是其他种类的解释很难被发现。Traditionally, legal learning has been viewed in such situations as the special preserve of lawyers, rather than a necessary part of the intellectual equipment of an educated person.统上讲，在这些学院中，法律的学习被认为是律师所特有的活动，而不是受教育的人的知识储备的必要部分。While it is easy to ignore in our contact with them the effect of our acts upon their disposition, it is not so easy as in dealing with adults.虽然在和年轻人接触的时候（状语前置）很容易忽略我们的行为对他们性情的影响，但是在和成年人相处的时候（状语前置），我们却很难忽略这种影响。5、状语从句的一些特殊用法(1)as专题①as+n：作为②v+…（一般是n）+as：此时as 的意思取决于前面动词的意思③as+句子：说明as在引导状语从句，as的意思可能是当…的时候、因为、虽然尽管、好像似乎。需要语境。（极少考作为定语，看前面as和which作的定语引导词区别。）1、As a logical consequence of this development, separate journals have now appeared aimed mainly towards either professional or amateur readership.separate 分离journals 期刊aim 瞄准appear这里是系动词可看做beas是用法①由于这种发展的逻辑结果，现在出现了主要针对专业或业余读者的单独期刊。2、As a result, the support for ambition as a healthy impulse, a quality to be admired and fixed in the mind of the young, is probably lower than it has ever been in the United States.结果，将雄心壮志作为一种健康的冲动，一种在年轻人心目中受到钦佩和固定的品质的支持，可能比美国以往任何时候都低。as是用法①3、 I shall define him as an individual who has elected as his primary duty and pleasure in life the activity of thinking in Socratic（苏格拉底） way about moral problems.moral 道德v+as，说明中间的n移动了。实际上这个n后移了，它是 the activity of thinking in Socratic（苏格拉底） way about moral problems.实际上： I shall define him as an individual who has elected the activity of thinking about moral problems in Socratic（苏格拉底） way as his primary duty and pleasure in life .as是用法②我将他定义为以苏格拉底方式思考道德问题的活动作为他的主要职责和生活乐趣的个人。4、Tylor defined culture as” that complex whole which includes belief, art, morals, law custom,and any other capabilities and habits acquired by man as a member of society.”泰勒将文化定义为“一个复杂的整体，包括信仰，艺术，道德，法律习惯以及人类作为社会成员获得的任何其他能力和习惯。”5、As is true of any developed society, in America a complex set of cultural signals, assumptions,and conventions underlies all social interrelationships.signal信号convention惯例interrelationship相互关系as是用法③as做非限制性定语从句，修饰后面整个句子。就像任何发达社会一样，在美国，一系列复杂的文化信号，假设和惯例构成了所有社会相互关系的基础。6、Shortlists for job interviews, election ballot papers, lists of conference speakers and attendees:all tend to be drawn up alphabetically, and their recipients lose interest as they plough through them.Shortlists 入围名单ballot 选票alphabetically按字母顺序conference 会议attendees参加者recipients 收件人plough 犁as是用法③求职面试的候选人名单、选举投票的决选人名革、会议发言人及参茄会议人的名单，往往都是按照字母顺序排列的，当人们费劲地往后翻看这些名单时，早就没有了兴趣。7、With other audiences you mustn’t atempt to cut in with humor as they will resent an outsider making disparaging remarks about their canteen or their chairman.resent 怨恨disparage 贬低chairman主席as是用法③如果和其他听众一起，你千万不要试图插入幽默，因为他们会反感一个外人对他们的食堂或领导发表蔑视性的评论。（as翻译成“因为”）8、New forms of thought as well as new subjects for thought must arise in the future as they have in the past, giving rise to new standards of elegance.as well as 以及=andelegance优雅as是用法③就像过去那样，将来新的思维方式和新的思维主题一定会出现，从而出现新的关于优雅的标准。(2)than专题①not so much as = not even，意思是甚至不/没有②not so much A as B，与其说A倒不如说B③more A than B，与其说B不如说A④more than….后加名词：不仅仅是后加形容词或者副词：非常….后加数词：多余He cannot so much as spell a word.He is not so much a teacher as a poet.He is more a poet than a teacher.六、句子所有成分大总结(1)大总结主：名词、代词、非谓语动词、从句谓：实义动词、系动词宾：名词、代词、非谓语动词、从句表：名词、代词、非谓语动词、从句、形容词、介词短语。同位语：名词、代词、非谓语动词、从句定语：名词、代词、非谓语动词、从句、形容词、介词短语状语：副词、介词短语、非谓语动词、从句因为主语和宾语可以通过被动互换位置，所以成分一致。补语很少见，而且补语就可以认为是定语补充宾语。从句和非谓语动词除了谓语什么都能充当。且从句和非谓语动词可以互相替代主语、宾语、同位语成分一致。介词短语可充当表语、定语、状语。在系动词后表语、在n后定语、在实义动词后状语副词只能做状语表语和定语成分一致，定语修饰名词，表语说明主语的状态实际上就是修饰主语的，而主语一定是名词（名词、代词一定代指名词、动名词、名词性从句）My mother is an elegant lady.（形容词作定语）=My mother is a lady of elegance.（名词做定语）=My mother is a lady as elegant as a lily.（介词短语作定语）=My mother is a lady looking as elegant as a lily.（非谓语动词作定语）系动词没有被动，所以尽管是被看起来但是转为非谓语动词是looking=My mother is a lady who looks as elegant as a lily.（从句作定语）启示：写作不要只会用形容词作定语She killed her husband with a sharp knife.（介词短语作状语）=She，applying a sharp knife，killed her husband.（非谓语动词作状语）=When She applied a sharp knife，she killed her husband.（从句作状语）=形容词作状语不好概况这里不再赘述。启示：写作不要只会用副词作状语That I met you is my honor.（从句作主语）=Meeting you is my honor.（非谓语动词作主语）=……不再赘述My dream is passing/to pass the examination of postgraduates.（非谓语动词作表语）=My dream is that I pass the examination of postgraduates.（从句作表语）=……..不再赘述英语长难句的模样：(状语 (as做定语前置特殊))，主 (定语|同位语|状语) 谓 宾 (定语|同位语|状语)English is vital.加同位语-&gt;English,a universal language through out the world, is vital.加状语-&gt;English,a universal language through out the world, is vital although it is hard to recite these worlds.I will recommend you a tourist attractionI,an undergraduate in this university,will recommend you a tourist attraction which keeps popular with Chinese travelers.(2)练习教师节就要来了，我借这次机会向给了我帮助的老师表达真心的感谢。Teacher’Day approaching，I express my sincere appreciation to teachers who have given me assistance by the chance.生命很短暂这个事实已经被人们广泛的接受了。The truth that life becomes so short has been accepted by the mass.上课不集中精力而又希望通过考试的学生往往会发现结果不会令人满意。Students who failed to concentrate in class but wish to pass examination perceive that the consequence proves less impressive.为了实现我的梦想，我一直在思考该不该和男朋友分手。I,in order to realize my dream ,am considering whether I should depart with my boy friend.有学校的地方，司机应该缓行。Where there is/exists a school，drivers should go slowly.]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法设计与分析【六】]]></title>
    <url>%2Fposts%2Fce7827f4%2F</url>
    <content type="text"><![CDATA[一、回溯介绍1、概念回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。回溯法适用于复杂的，规模较大的问题有“通用解题方法”的美称。有许多问题，当需要找出它的解集 或者 要求回答什么解是满足某些约束条件的最佳解时，往往要使用回溯法解向量:希望问题的解 能够表示成一个 n 元式(x1, x2, …, xn)的形式。解空间:对于问题的一个实例，满足显式约束条件的所有解向量，构成了该实例的一个解空间。显约束:对分量 xi 的取值限定。隐约束:为满足问题的解 而对不同分量之间施加的约束。扩展结点：正在产生儿子的结点活结点：自身已生成，但其儿子还没有全部生成的结点死结点：所有儿子 已经产生的结点深度优先生成法：扩展结点1，一旦产生了它的一个儿子2，就把结点2当做新的扩展结点。在完成 以2为根的子树 的穷尽搜索之后，将结点1重新变成扩展结点，继续产生结点1的下一个儿子宽度优先生成法：在一个扩展结点变成死结点之前，它一直是扩展结点当所给问题是从n个元素的集合S中找出S满足某种性质的子集时，相应的解空间称为子集树当所给问题的确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。回溯法就是具有剪枝函数的深度优先生成法2、基本思想在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。3、效率子集树：结点数目 mn，计算时间 O(mn)排列树：结点数目 n!，计算时间 O(n!)回溯法的效率在很大程度上依赖于以下因素：产生 扩展结点x[k]的时间；满足显约束的扩展结点x[k]值的个数；剪枝时间：计算 可行性约束函数 和 上界函数 的时间；满足可行性约束函数和上界函数的 所有扩展结点x[k]的个数。好的剪枝函数，能显著地减少所生成的结点数。但是，这样的剪枝函数往往计算量较大。因此，选择剪枝函数时，通常存在生成结点数与剪枝函数计算量之间的折衷。4、用回溯法解题的一般步骤：（1）针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。（2）确定易于搜索的解空间结构（排列树、子集树)子集树：从元素中选哪几个，排列树：所需元素都要有，选一种排列（3）从根节点以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。用约束函数在扩展结点处剪去不满足约束条件的子树；用限界函数剪去得不到最优解的子树。5、算法框架（1）问题框架设问题的解是一个n维向量(a1,a2,………,an),约束条件是ai(i=1,2,3,…..,n)之间满足某种条件，记为f(ai)。(1)回溯方式(2)迭代方式6、实例(1)装载问题(2)旅行商问题(3)图着色问题(4)01背包]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>算法设计与分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP程序设计【五】]]></title>
    <url>%2Fposts%2F483b5d36%2F</url>
    <content type="text"><![CDATA[一、MVC1、什么是MVCMVC是一种开发模型。Model——View——Controller模型 ——视图——控制器JavaBean擅长数据存储与业务处理：Model–&gt;实体 + 业务JSP擅长数据提交与数据表示：View–&gt;提交 + 显示Servlet擅长逻辑控制与动作协调：Controller—&gt;控制 + 逻辑2、Model – JavaBean数据Bean：用于直接存储数据，属于最一般的Bean。一般形式就是成员变量及其getter/setter方法业务Bean：用于业务数据处理，含有若干功能实现，如数据库访问操作等。一般以方法（可使用static）提供业务处理功能，这样通过类名就可以使用。混合Bean：既有数据存储也有处理方法的Bean，但一般不使用。耦合高3、View – JSPJSP使用一般的HTML 和Bean 进行视图显示&lt;jsp:useBean id= &quot;bean&quot; type= &quot;bean.Bean&quot; scope= &quot;…&quot; /&gt;&lt;jsp:getProperty name=&quot;bean&quot; property=&quot;…&quot;/&gt;Set很少用。因为为了符合MVC模式，数据的存储会在servlet中设置注意：使用type而不使用class，目的是避免在JSP中重新创建新的bean，否则可能会把Servlet中创建的bean覆盖掉scope应与Servlet中存储bean时使用的生命周期一致property中指定的属性值应在bean中能够获取（getter方法）有时某些Bean也可以在JSP中创建（class；setProperty）4、Controller – Servlet1、创建、存储、使用Bean通过构造方法创建Bean，获取值，将存储进Bean，调用业务Bean处理任务2、Bean的存储（三种生命周期：request、session、application）request.setAttribute(“bean”, bean);HttpSession session = request.getSession();session.setAttribute(“bean”, bean);//有时可直接写成：request.getSession().setAttribute(“bean”, bean);ServletContext application = getServletContext();application.setAttribute(“bean”, bean);//有时可直接写成：getServletContext().setAttribute(“bean”, bean);3、控制JSP使用Java语言，进行逻辑控制，处理业务后使用合适的转发语句转入显示页面。重定向response.sendRedirect(location);转发 / 包含RequestDispatcher rdisp = request.getRequestDispatcher(path);rdisp.forward(request, response); //转发rdisp.include(request, response); //包含自动刷新response.setHeader(“refresh”, “3;url=location”);5、总结输入JSP页面，显示网页用户输入数据—&gt;送入到servlet，使用Bean进行存储、处理，最后转发到输出JSP页面—&gt;输出JSP页面调用Bean进行相应输出。二、数据库应用DBMS：MySQL、Derby（Java DB）、…管理工具：SQLyog、Navicat、Squirrel、…JDBC：Java DataBase Connectivity1、MySQL的安装注意事项①在设置编码时刻选择UTF-8防止乱码②安装目录中的主要文件my.ini：配置文件bin文件夹下mysqld.exe:MySQL服务器mysql.exe:客户端控制台MySQLInstanceConfig.exe：MySQL实例配置（安装SQL过程中会自动运行，也可再单独运行进行配置数据的修改）mysqladmin.exe：管理用客户端③MySQL服务的启动与停止通过Windows服务，若安装配置过程中设为Windows服务，则可以自动启动在计算机管理中可以查看、启动、关闭、设置MySQL服务在Windows命令窗口中启动：net start mysql停止：net stop mysql启动后在Windows任务管理器中会有“mysqld.exe”进程一般不直接使用MySQL 5.5 Command Line Client，需要记住很多命令，很麻烦！可以使用例如SQLyog的管理工具进行可视化管理比较方便④MySQL的卸载停止服务卸载程序删除C:\ProgramData\MySQL（数据库相关数据！）删除相关注册表项删除不彻底，重装出问题二、连接数据库1、JDBC体系结构(1)一些基础概念数据库:数据库是以一定方式储存在一起、能与多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合，可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据进行新增、查询、更新、删除等操作。DBMS:数据库管理系统(Database Management System)是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称DBMS。它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性。用户通过DBMS访问数据库中的数据，数据库管理员也通过DBMS进行数据库的维护工作。RDBMS:关系数据库管理系统（Relational Database Management System：RDBMS）是指包括相互联系的逻辑组织和存取这些数据的一套程序 (数据库管理系统软件)。关系数据库管理系统就是管理关系数据库，并将数据逻辑组织的系统。DBMS和RDBMS：DBMS是过去的50年中所出现的不同类型数据库管理技术的总称。RDBMS是DBMS的一种它的特点是使用一个基于行的表结构，将相关数据元素连接到一起，保证事务完整性，并维护数据的准确性和一致性。RDBMS的另一个显著属性是支持结构化查询语言(SQL)。近年来，一些非关系型数据库系统开始兴起但是目前关系数据库仍然是大多数IT架构的中心。JAVA DB(Derby): javadb就是一种关系数据库管理系统。Java DB是Apache Derby项目（Apache软件基金会（ASF）的开源关系数据库项目）的Oracle版本。 Apache Derby是纯Java，基于标准的关系数据库引擎。API:Application Programming Interface应用程序编程接口,是软件系统不同组成部分衔接的约定JDBC:JDBC (Java Database Connectivity) API，即Java数据库编程接口，是一组标准的Java语言中的接口和类，使用这些接口和类，Java客户端程序可以访问各种不同类型的数据库。比如建立数据库连接、执行SQL语句进行数据的存取操作。(2)JDBC体系一般情况下，在应用程序中进行数据库连接，调用JDBC接口，首先要将特定厂商的JDBC驱动实现加载到系统内存中，然后供系统使用。应用程序–&gt;链接数据库——&gt;调用JDBC API接口——&gt;特定厂商的JDBC驱动加载和JDBC Driver对接–&gt;使用DriverMannager对多个Driver 管理—&gt;连接完成通过JDBC API中的各种类对数据库进行操作最上层的Application:使用Java语言编写App,利用JDBC API,实现CRUD操作Create（增）Retrieve（查）Update（改）Delete（删）JDBC API：提供数据库访问接口连接（Connection）SQL声明（Statement、PreparedStatement、CallableStatement）结果集（ResultSet）元数据（DatabaseMetaData、ResultSetMetaData）JDBC Drivers：提供对数据库进行访问的驱动程序。与数据库类型有关，由开发方提供，jar文件格式需要添加到项目的“库”中，连接数据库前需要载入。最底层的DB：使用管理工具创建数据库，SQLyog + MySQL、NetBeans + Derby(3)JDBC核心组件JDBC核心组件DriverManager:此类管理数据库驱动程序列表。使用通信子协议将来自java应用程序的连接请求与适当的数据库驱动程序匹配。Driver：此接口处理与数据库服务器的通信，我们很少会直接与Driver对象进行交互。而是使用DriverManager对象来管理这种类型的对象Connection：该界面具有用于联系数据库的所有方法。连接对象通信上下文，即，与数据库的所有通信仅通过连接对象。Statement：使用从此接口创建的对象将SQL语句提交到数据库。除了执行存储过程之外，一些派生接口还接受参数。ResultSet： 在使用Statement对象执行SQL查询后，这些对象保存从数据库检索的数据。它作为一个迭代器，允许我们移动其数据。SQLException：此类处理数据库应用程序中发生的任何错误(4)数据库访问步骤（0）添加驱动程序:在项目的“库”中添加相应数据库的jar（1）加载驱动程序:Class.forName(“com.mysql.jdbc.Driver”);（2）获取连接对象：Connection conn = DriverManager.getConnection()jdbc：主协议；固定为：jdbcsubprotocol：子协议；由 DBMS 类型确定，如：derby、mysqlsubname：数据库信息；由具体的数据库名字确定（3）执行SQL语句（4）关闭连接对象:conn.close();1、通过DriverManager获取Connection对象,链接数据库使用DriverManager类来获取的Connection连接，是无法重复利用的。如果close（）后要想再利用，必须重新创建连接，所以没有完成对数据库的所有操作之前，一般不要close掉常用方法:public static Connection getConnection(String url, String user, String password)返回Connection对象2、通过Connection对象方法，建立该链接数据库的Statement类或者其子类对象用于执行SQL指令等。​ 主要方法：Statement stmt = conn.createStatement(int, int);创建向数据库发送sql的statement对象。1234567891011121314参数1：结果集游标的滚动类型及对数据库变化的反映ResultSet.TYPE_FORWARD_ONLY//默认参数结果集的游标只能向下滚动。 ；ResultSet.TYPE_SCROLL_INSENSITIVE//结果集的游标可以上下移动，当数据库变化时，当前结果集不变。 ResultSet.TYPE_SCROLL_SENSITIVE//返回可滚动的结果集，当数据库变化时，当前结果集同步改变。 参数2：是否能用结果集对数据库进行更新ResultSet.CONCUR_READ_ONLY//默认参数不能用结果集更新数据库中的表。 ResultSet.CONCUR_UPDATABLE//能用结果集更新数据库中的表。Statement stmt = conn.createStatement(); //参数取默认值PreparedStatement对象比Statement对象的效率更高，并且可以防止SQL注入，所以我们一般都使用PreparedStatementPreparedStatement prepareStatement(String sql);该方法返回预编译的Statement对象，即将SQL语句提交到数据库进行预编译；1234567例如：PreparedStatement stmt = conn.prepareStatement("select * from choice where knowledge=? and difficulty=?", ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY );设定参数stmt.setXxx(n, x); //n – 参数位置，x – 参数值例如：stmt.setInt(1, 3);stmt.setInt(2, 1);prepareCall(sql)：创建执行存储过程的callableStatement对象。3、通过Statement类或者其子类对象方法，执行SQL指令等，返回指令的结果集主要方法：ResultSet executeQuery(String sql)该方法用于执行查询语句，并返回查询结果对应ResultSet对象。该方法只能用于执行查询语句。​ int executeUpdate(String sql)用于执行 INSERT、UPDATE 或 DELETE 语句以及 SQL DDL（数据定义语言）语句，例如 CREATE TABLE 和 DROP TABLE。INSERT、UPDATE 或 DELETE 语句的效果是修改表中零行或多行中的一列或多列。executeUpdate 的返回值是一个整数，指示受影响的行数（即更新计数）。对于 CREATE TABLE 或 DROP TABLE 等不操作行的语句，executeUpdate 的返回值总为零 可以配合PreparedStatement对象，完成参数设置后，执行executeUpdate()即可更新数据库​ boolean execute(String sql) 该方法可以执行任何sql语句。如果执行后第一个结果为ResultSet对象，则返回true；如果执行后第一个结果为受影响的行数或没有任何结果，则返回false；4、通过ResultSet对象接受Statement类或者其子类对象用于执行SQL指令后的结果集。​ 主要方法：boolean next() 将结果集的记录指针定位到下一行，如果移动后的记录指针指向一条有效的记录，则该方法返回true；boolean Previous()移动到前一行boolean absolute( int row )将结果集的记录指针移动到第row行，如果row是负数，则移动到倒数第row行，如果移动后的记录指针指向一条有效记录，则该方法返回true；beforeFirst()移动resultSet的最前面。afterLast()移动到resultSet的最后面。值得注意的是，在ResultSet集合中初始指针指向为表头（行0，是表格的描述一行非数据行）在ResultSet集合，行从0开始列从1开始int getInt(int); //使用列号，从 1 开始计，从左到右获取指针指向的行的某列数据int getInt(String); //使用列名获取指针指向的行的某列数据boolean last()将结果集的记录指针定位到最后一行，如果移动后的记录指针指向一条有效的记录，则该方法返回true；void close()释放ResultSet对象；5、异常处理​ try-catch常用方法如上，其他方法建议查阅文档或者网络搜索。参考和建议阅读文章：JAVA数据库链接基础知识关于JDBC的简介（简介）（体系）（核心）（语法）JDBC层次结构和基本构成JDBC常用接口和类createStatement的参数JDBC的ResultSet接口（查询操作）、PreparedStatement接口重构增删改查jdbc就是这么简单]]></content>
      <categories>
        <category>JSP程序设计</category>
      </categories>
      <tags>
        <tag>JSP程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web系统设计【四】]]></title>
    <url>%2Fposts%2Fa22a3b%2F</url>
    <content type="text"><![CDATA[一、CSS3新特性CSS3具有一些新特性，由于w3c制定标准慢，尚未制定完毕，只是初稿时，浏览器厂商快速加入新属性的支持，加前缀。w3c确定标准后，才全面支持，去掉前缀。具体属性的支持可在W3C网页查看1、边框(1)圆角边框border-radius: 水平值，垂直值(填一个默认为圆形即所填=水平值=垂直值)左上角的形状border-top-left-radius: 水平值，垂直值右上角的形状border-top-right-radius: 水平值，垂直值左下角的形状border-bottom-left-radius: 水平值，垂直值右下角的形状border-bottom-right-radius: 水平值，垂直值这里的水平值和垂直值，指的是一其为横轴，纵轴构造的椭圆或者圆 在相应位置的边线作为边框。例如：椭圆边线边框和圆形边线边框胶囊状边框：上下的圆重合了同理，修改宽度，构造正方向盒子，添加适合的值可以构造圆形内容区域(2)阴影box-shadowbox-shadow：（方式）水平偏移 垂直偏移 模糊距离 阴影大小 颜色方式outset 默认值，外部阴影inset 可选，内部阴影水平偏移、垂直偏移：阴影以左上角为原点，向右向下为正方向偏移的距离。可为负值，即向左向上偏移模糊距离：阴影最外边模糊的范围阴影的大小:默认为0即为原大小。设置一个值表示四个方向增大或者减小的尺寸颜色：阴影的颜色​ box-shadow详解(3)图片边框border-image：source slice width repeatborder-image-source 用在边框的图片的路径border-image-slice 图片边框向内偏移。分为横向距离和纵向距离两个值，两条线将图片分割为九个区域border-image-width 图片边框的宽度。若不设置则会继承border-image-outset 边框图像区域超出边框的量。定义边框图像可超出边框盒的大小，默认为0。定义四个值和设置padding、margin一样border-image-repeat 图像边框是否应平铺(repeat)、铺满(round)或拉伸(stretch)。由slice切割的四个角保留，四个方向上的边框进行相应的repeat方式操作注意：border-image 必须与 border 配合使用。先指定出宽度和类型2、文本与文字(1)文本阴影text-shadow类似边框阴影box-shadowtext-shadow：水平偏移 垂直偏移 阴影模糊大小 颜色常见几种设计：描边浮雕：字体白，阴影黑(2)允许长单词、URL强制进行换行表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。word-wrap: 方式normal：不换行break-word：换行(3)@font-face 规则我们平显示的字体，都会在硬盘中有相应文件。而想要在Web上显示特殊的体系，需要用户自行下载对应的字体包，这样太过麻烦。我们将字体文件放入WEB站点目录下使用@font-face 进行调用。用户解析到时就会从服务器自动下载字体进行显示。不同的浏览器对字体文件格式支持不同。假若下载字体只有一种.ttf格式，可以通过查阅一些网址或者软件，生成其他格式。使用样例：(4)其他文本控制文本溢出处理：white-space：规定段落中的文本不进行换行normal：默认。空白会被浏览器忽略。pre：空白会被浏览器保留。其行为方式类似 HTML 中的 &lt;pre&gt; 标签。nowrap：文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br&gt; 标签为止。pre-wrap：保留空白符序列，但是正常地进行换行。pre-line：合并空白符序列，但是保留换行符。text-overflow:当文本溢出包含元素时发生的事情clip：修剪文本。ellipsis：显示省略符号来代表被修剪的文本。通常配合下面使用white-space: nowrap;overflow: hidden;string：使用给定的字符串来代表被修剪的文本。其他属性自行查阅3、2D变换和3D变换(1)2D变换：对元素进行旋转、缩放、移动、拉伸transform：旋转rotate()值为 XXdeg,可正可负，代表顺时针和逆时针旋转放缩scale(x,y)x:水平方向缩放的倍数y:垂直方向缩放的倍数，若省略，同x0~1,缩小；&gt;1放大倾斜skew(x_deg,y_deg)能够让元素倾斜显示，该函数包含两个参数值，分别用来定义X轴和Y轴坐标倾斜的角度。如果省略了第二个参数，则取默认值0。更改变换的中心点transform-origin: x-axis y-axis z-axis;默认值分别为50% 50% 0(2)3D变换transform-style： preserve(3d)向右X相上Y透过屏幕向客户ZrotateX(deg)如果值为正，元素将围绕X轴顺时针旋转；反之，如果值为负，元素围绕X轴逆时针旋转。rotateY(deg)如果值为正，元素将围绕X轴顺时针旋转；反之，如果值为负，元素围绕Y轴逆时针旋转。rotateZ(deg)如果值为正，元素将围绕X轴顺时针旋转；反之，如果值为负，元素围绕Z轴逆时针旋转。无透视下旋转效果：透视（眼睛到舞台的距离）perspective: px透视下的旋转效果设置3D变换，需要将内容放在父容器内，需要变换的父容器（可多个）再放入舞台内。父容器决定旋转关系，舞台决定透视关系。还有更多的3D变换内容，自行查阅4、过渡与动画(1)过渡transitiontransition：属性名 持续时间 过渡方法 何时开始；参数必须按照顺序进行定义，不能颠倒。transition-property，规定应用过渡的 CSS 属性的名称。none：没有属性会获得过渡效果。all：所有属性都将获得过渡效果。property：多个属性名称之间以逗号分隔。transition-duration 定义过渡效果花费的时间。默认值为0，常用单位是秒（s）或者毫秒（ms）transition-timing-function 规定过渡效果的时间曲线。实际上是定义了cubic-bezier(n,n,n,n)的四个特殊的值，也可以自己设置。transition-delay 规定过渡效果何时开始。默认值为0，常用单位是秒（s）或者毫秒（ms）。当设置为负数时，过渡动作会从该时间点开始，之前的动作被截断；设置为正数时，过渡动作会延迟触发。例如：(2)动画animation@keyframe name{}定义关键帧例如：帧的名字一般用%多少来设置animation：引用 @keyframes 动画的名称 动画完成时间 规定动画的速度曲线 何时开始；和transition类似。就是属性改成了自己设置的动画关键帧animation-name @keyframes 动画的名称填设置的动画的名称animation-duration 动画完成时间默认值为0，常用单位是秒（s）或者毫秒（ms）animation-timing-function 规定动画的速度曲线。默认是 “ease”。实际上是定义了cubic-bezier(n,n,n,n)的四个特殊的值，也可以自己设置。animation-delay 规定动画何时开始。允许负值，例：-2s 使动画马上开始，但跳过 2 秒进入动画。animation-play-state 规定动画是否正在运行或暂停。running（运动）|paused（暂停）常用于鼠标进入盒子停止播放。animation-iteration-count 规定动画被播放的次数。n 定义动画播放次数的数值。infinite 规定动画应该无限次播放。animation-direction 规定动画是否在下一周期逆向地播放。normal|alternate如果 animation-direction 值是 “alternate”，则动画会在奇数次数（1、3、5 等等）正常播放，而在偶数次数（2、4、6 等等）向后播放。注意：如果把动画设置为只播放一次，则该属性没有效果！animation-fill-mode 规定对象动画时间之外的状态。none 无forward 动画结束（to里面的所有样式）时的状态backward 动画开始（from里面的所有样式）时的状态both 动画开始或者结束时的状态。(3)过渡与动画的区别过渡属性transition可以在一定的时间内实现元素的状态过渡为最终状态，用于模拟一种过渡动画效果，但是功能有限，只能用于制作简单的动画效果；而动画属性 animation 可以制作类似Flash动画，通过关键帧控制动画的每一步，控制更为精确，从而可以制作更为复杂的动画。transition需要触发一个事件（大多是另一个CSS例如鼠标悬停）才会随着时间改变其CSS属性；animation在不需要触发任何事件的情况下，也可以显式的随时间变化来改变元素CSS属性，达到一种动画的效果过渡只有一组（两个：开始-结束） 关键帧，动画可以设置多个。5、滤镜filter定义了元素(通常是&lt;img&gt;)的可视效果(例如：模糊与饱和度)具体函数设定再查阅二、HTML5HTML5中具有很大的语义化倾向有了header、nav、footer、aside、content等标签可直接使用，减少了使用div的语义不明。有了em、strong取代i和b的语义不明确标签。有了自定义列表dl、列表项dt、描述dd具体请查询HTML5。]]></content>
      <categories>
        <category>Web系统设计</category>
      </categories>
      <tags>
        <tag>Web系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统概论【五】]]></title>
    <url>%2Fposts%2Fca3f1943%2F</url>
    <content type="text"><![CDATA[一、关系数据理论问题——什么是一个好的数据库逻辑设计?关系模式存在的问题 ：数据冗余度太大，浪费存储空间更新异常（Update Anomalies）插入异常（Insertion Anomalies），该插入的数据插不进去删除异常（Deletion Anomalies），不该删除的数据也删去了好的模式不会发生插入异常、删除异常、更新异常、数据冗余应尽可能少。这是由于模式中的某些数据依赖引起的。1、数据依赖数据依赖是一个关系内部属性与属性之间的一种约束关系，通过属性间值的相等与否体现出来的数据间的相互联系。 是现实世界属性间相互联系的抽象、是数据内在的性质、是语义的体现函数依赖(Functional Dependency，简记为FD)多值依赖(Multivalued Dependency，简记为MVD)连接依赖……2、关系模式的简化表示R(U, D, DOM, F)R：关系名，是符号化的元组语义U：该关系的属性集合D：属性组U中属性所来自的域DOM：属性向域的映象集合F：属性间数据的依赖关系集合简化：R &lt;U,F&gt;影响数据库模式设计的主要是 该关系的属性集合U 和 属性间数据的依赖关系集合F3、规范化-关系的规范化理论(1)函数依赖设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等则称“X函数确定Y”或“Y函数依赖于X”，记作X→Y。X称为这个函数依赖的决定属性组，也称为决定因素(Determinant)。将它想成函数，f（x）=y。所以！一个x只能对应一个值！而一个y可以对应多个x！问题经常问的是“基本”函数依赖，就是根据语义写最直接的那个函数依赖例： S(Sno, Sname, Ssex, Sage, Sdept)F＝ {Sno→Sname，Sno→Ssex，Sno→Sage，Sno→Sdept}函数依赖是语义范畴的概念。只能根据数据的语义来确定函数依赖。(2)平凡函数依赖与非平凡函数依赖X→Y，Y⊈X，则称X→Y是非平凡的函数依赖。X→Y，但Y⊆X ，则称X→Y是平凡的函数依赖。即推出的结果不在原因之内例：在关系SC(Sno, Cno, Grade)中，非平凡函数依赖： (Sno, Cno) → Grade平凡函数依赖： (Sno, Cno) → Sno (Sno, Cno) → Cno对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义，因此若不特别声明， 我们总是讨论非平凡函数依赖。(3)完全函数依赖与部分函数依赖完全函数依赖：设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。部分函数依赖：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。*即依据是最小的不能在缺少一个属性了就是完全函数依赖，能推出但是原因中的部分即可推出就是部分函数依赖 *(4)传递函数依赖在R（U，F）中，如果X→Y，（Y⊈X），Y↛X，Y→Z，则称Z对X传递函数依赖.记为：X → Z。注意: 如果Y→X, 即X←→Y，则Z直接依赖于X。全部路径都是单向的才叫传递函数依赖4、从函数依赖看码设K为关系模式R&lt;U，F&gt;中的属性或属性组合。问题问码是主码,因为主码可简称码主码，候选码都简称码，如果题目中出现码这个字，需要我们自行根据上下文判断,一般是主码码是数据系统中的基本概念。所谓码就是能唯一标识实体的属性，他是整个实体集的性质，而不是单个实体的性质。它包括超码，候选码，主码。若K → U（U完全依赖K），则K称为R的一个候选码(Candidate Key)。即K能够推出所有的其他属性，且为最小集。则K为候选码候选码是最小的超码，即K的任意一个真子集都不是候选码主码：若关系模式R有多个候选码，则选定其中的一个做为主码(Primary key)。主属性：包含在任何一个候选码中的属性 ，称为主属性（Prime attribute）非主属性：不包含在任何码中的属性称为非主属性（Nonprime attribute）或非码属性（Non-key attribute）全码：整个属性组是码，称为全码（All-key）外码：关系模式 R&lt;U,F&gt;中属性或属性组X 并非 R的码，但 X 是另一个关系模式的码，则称 X 是R 的外部码（Foreign key）也称外码。5、范式范式是符合某一种级别的关系模式的集合。关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式。第一范式（1NF）：的所有属性都是不可分的基本数据项第二范式（2NF）:在第一范式的基础上，每一个非主属性都完全函数依赖于主属性主码若是单一属性则一定满足第二范式投影解决第三范式（3ND）:在第二范式的基础上，非主键列必须直接依赖于主键，不能存在传递依赖即第二范式基础上，非主属性之间不能存在函数依赖投影解决BC范式（BCNF）：在第三范式的基础上，每一个决定因素都包含候选键，也就是说，只要属性或属性组A能够决定任何一个属性B，则A的子集中必须有候选键。BCNF范式排除了任何属性(不光是非主属性，2NF和3NF所限制的都是非主属性)对候选键的传递依赖与部分依赖。即在第三范式的基础上，不能有主键依赖于非主键等情况(注意主键不一定是一个，可能是多组主键)。排除了任何属性对候选键的传递依赖与部分依赖。例如：学生ID和专业是联合主键这个表的设计满足三范式，有主键，不存在主键的部分依赖，不存在非主键的传递依赖。但是这里存在另一个依赖关系，“专业”函数依赖于“导师”，也就是说每个导师只做一个专业方面的导师，只要知道了是哪个导师，我们自然就知道是哪个专业的了。StudentIdMajorAdvisorMajGPA1人工智能Edward4.02大数据William3.81大数据William3.73大数据Joseph4.0投影解决第二范式（2NF）和第三范式（3NF）的概念很容易混淆，区分它们的关键点在于：2NF：非主键列是否完全依赖于主键，还是依赖于主键的一部分；3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列。二、数据库设计1、 需求分析阶段准确了解用户的需求，撰写需求说明2、概念设计阶段它是整个数据库设计的关键，通过对用户需求进行综合，归纳与抽象，形成一个独立于具体DBMS的概念模型。E-R图的设计在此阶段。绘制E-R图为重点，详细查看软件工程。3、逻辑结构设计阶段将概念结果转换为某个DBMS所支持的数据模型。也就是指E-R图和关系模型的转换，具体为将实体，实体的属性和实体之间的联系转换为关系模式。4、数据库物理设计阶段为逻辑结果选取一个最适合应用环境的物理结构，包括存储结构和存取方法。5、数据库实施阶段此阶段利用SQL语句实现逻辑结构设计和物理设计阶段的内容，包括建立数据库，编制与调试应用程序等。6、数据库运行和维护阶段运行过程中不断的调整，修改和优化数据库系统。ER图：①透过关系，n可转化为多条线②两个实体之间必有一个关系（一般是动词，与两个实体名词构成主谓宾关系）假设有 A，B 两个实体，首先判断一个 A 对应几个 B，再判断一个 B 对应几个 A如果两边都是 1:1，那么 A 与 B 就是一对一的关系；如果两边只有一个 1:n，那么 A 与 B 就是一对多的关系；如果两边都是 1:n，那么 A 与 B 就是多对多的关系转化为关系模型:多对多：实体：①都是属性摆出来先选出主键、关系：①摆出来，加入链接的实体主键联合起来作为主键，同时又各自作为外键；②自身属性加进去一对多：实体：①都是属性摆出来先选出主键；②另外n部分的实体加入1部分的主键作为外键关系：①关系的属性加入到N部分进去作为普通属性一对一：实体：①都是属性摆出来先选出主键；②双方各自加入对方的主键作为外键；关系：①关系的属性加入到两个实体进去作为普通属性注意：一个关系可以连出多个实体三、嵌入式SQL4-4嵌入式SQL嵌入式SQL语句存储过程和函数PL/SQL存储过程操作实例及其讲解说明PL/SQL存储过程123456CREATE [OR REPLACE] PROCEDURE procedure_name [(parameter_name [IN | OUT | IN OUT] type [, ...])] &#123;IS | AS&#125; BEGIN &lt; procedure_body &gt; END procedure_name;procedure-name是要创建的存储过程的名称。*[OR REPLACE]*选项允许修改现有的过程。可选参数列表包含参数的名称，模式和类型。IN表示将从外部传递的值，OUT表示将用于返回过程外的值的参数。procedure-body包含可执行部分。使用AS关键字而不是IS关键字来创建存储过程。以下示例演示如何创建一个简单的存储过程，执行时它只显示字符串“Hello World！”在屏幕上。123456789101112&gt; SET SERVEROUTPUT ON SIZE 99999;&gt; CREATE OR REPLACE PROCEDURE greetings &gt; AS &gt; BEGIN &gt; dbms_output.put_line('Hello World!'); &gt; END; &gt; /&gt; -- 执行存储过程&gt; exec greetings;&gt; -- 或者&gt; EXECUTE greetings;&gt;四、数据库恢复技术1、事务所谓事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单元。事务定义语句：BEGIN TRANSACTION： 为事务的开始COMMIT： 提交事务的所有操作ROLLBACK： 当出现错误时，将已完成操作全部撤销，回滚到事务开始时的状态定义方式：显示定义： 显示调用数据库定义语句隐式定义： 系统按默认规则自动进行事务的特性(ACID)：原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)和持续性(Durability)(1) 原子性事务是数据库的逻辑工作单位，事务中包含的诸操作要么都做，要么都不做。(2) 一致性事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。(3) 隔离性一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰(4) 持续性指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其执行结果有任何影响。事务是恢复和并发控制的基本单位。保证事务ACID特性是事务管理的重要任务。故障种类以及恢复策略(1) 事务内部的故障有的可以通过事务程序本身发现，如转账时发现账户余额不足。更多的故障是非预期的，是不能由应用程序处理的，如运算溢出、并发事务发生死锁而被选中撤销该事务、违反了某些完整性限制等恢复策略：1&gt; 反向扫描日志文件，查找该事务的更新操作2&gt; 对事务的更新操作执行逆操作3&gt; 继续查找该事务的其他更新操作，并做同样处理，直至读到该事务的开始标记，事务故障恢复就完成了。(2) 系统故障指造成系统停止运转的任何事件，使得系统要重新启动。例如：硬件错误(CPU故障)、操作系统故障、DBMS代码错误、系统断电等。这类故障影响正在运行的所有事务，但不破坏数据库。这时主存内容，尤其是数据库缓冲区(在内存)中的内容都被丢失，所有运行事务都非正常终止。发生故障时，一些尚未完成的事务的结果可能已送入物理数据库，从而造成数据库可能处于不正确的状态。恢复子系统必须在系统重新启动时让所有非正常终止的事务回滚，强行撤销(UNDO)所有未完成事务。另一方面，有些已完成的事务可能有一部分甚至全部留在缓冲区，尚未写回到磁盘上的物理数据库中，系统故障使得这些事务对数据库的修改部分或全部丢失，这也会使数据库处于不一致状态，因此应将这些事务已提交的结果重新写入数据库。所以系统重新启动后，恢复子系统除需要撤销所有未完成的事务，还需要重做(REDO)所有已提交的事务，以将数据库真正恢复到一致状态。恢复策略：1.正向扫描日志文件，找出故障发生前已经提交的事务（有BEGIN有COMMIT），记入重做事务。同时找出未完成的事务（只有BEGIN），加入撤销队列2.对撤销队列中的事务进行撤销处理：反向扫描并执行逆操作3.对重做队列中的各个事务进行重做处理：正向扫描并重做(3) 介质故障也称硬故障，如磁盘损坏、磁头碰撞、强磁场干扰等。恢复策略1.装入最新的数据库后备副本，对于动态转储还需同时装入转储开始时刻的日志文件副本2.装入相应的日志文件副本（转储结束时刻的日志文件副本），重做已完成的事务(4) 计算机病毒：产生故障的原因，本身不是故障，可能产生故障2或32、恢复的实现技术建立冗余数据：数据转储静态转储：系统中无运行事务时进行的转储，转储期间不允许任何事务执行。优点：得到的一定是一个数据一致性的副本缺点：降低了数据库的可用性动态转储：转储和用户事务可以并发执行优点：系统可用性较好缺点：转储得到的副本不一定一致，因此必须建立日志文件等级转储期间各事务对数据库的修改活动海量转储：每次转储整个数据库，恢复更方便增量转储：每次只转储上一次转储后更新过的数据，恢复较复杂登记日志文件具有检查点的恢复技术1、 在日志文件中增加检查点记录2、 增加重新开始文件3、 恢复子系统在登录日记文件期间动态地维护日志五、并发控制1、概述不同的多事务执行方式：事务串行执行： 每个时刻只有一个事务运行交叉并发方式： 并行事务的并行操作轮流交叉运行同时并发方式： 每个处理机可以运行一个事务，多个处理机可以同时运行多个事务并发控制原因： 防止多个事务并发存取数据库时产生的同时读取和/或修改同一数据而造成的数据不一致性并发控制能保证事务的一致性，事务是并发控制的基本单位事务并发执行带来的数据不一致问题：丢失修改： 事务 T1 和 T2 读入同一数据并修改，T2 提交的结果破坏 T1 的提交，导致 T1 的修改被丢失不可重复读： 事务 T1 读取数据后，事务 T2 执行更新操作，使 T1 无法再现前一次读取结果包含三种情况： 后两种不可重复读有时也称为幻影现象事务 T1 读取某数据后，事务 T2 对其修改，当事务 T1 再次读该数据时，得到与前一次不同的值事务 T1 读取某数据后，事务 T2 删除其中部分记录，当 T1 再次读该数据时，发现某些记录消失事务 T1 读取某数据后，事务 T2 插入一些记录，当 T1 再次读该数据时，发现多了一些记录读脏数据： 事务 T2 读取事务 T1 修改的数据后，数据库回滚到 T1 修改前，则 T2 读取的数据即为脏数据2、封锁封锁： 事务 T 在对某个数据对象操作之前，先向系统发出请求，对其加锁。加锁后事务 T 就对该数据对象有了一定的控制，在事务 T 释放锁之前，其它的事务不能更新此数据对象封锁类型：排它锁(X锁)： 又称写锁，若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A共享锁(S锁)： 又称读锁，若事务 T 对数据对象 A 加上 S 锁，则其它事务只能读取 A，不能修改 A封锁协议：一级封锁协议：事务 T 在修改数据 A 之前，先对其加 X 锁，直到事务结束才释放解决了丢失修改问题二级封锁协议：事务 T 在读数据 A 之前，先对其加 S 锁，读完后释放解决了丢失修改与读脏数据问题三级封锁协议：事务 T 在读数据 A 之前，先对其加 S 锁，直到事务结束后释放解决了丢失修改、读脏数据、不可重复读问题3、活锁和死锁(1)活锁事务 T1 封锁了数据 R事务 T2 又请求封锁 R，于是 T2 等待T3 也请求封锁 R，当 T1 释放了 R 上的封锁之后系统首先批准了 T3 的请求，T2 仍然等待T4又请求封锁 R，当 T3 释放了 R 上的封锁之后系统又批准了T4的请求……T2 有可能永远等待，这就是活锁的情形(2)死锁死锁： 多个事务因竞争资源而出现的互相等待现象事务T1封锁了数据A，事务T2封锁了数据B，然后T1请求封锁B，与此同时T2也请求封锁A，但因为两个事务的请求都需要等待对方释放锁，这样就出现了永远在等待对方的死锁。死锁的预防：一次封锁法： 要求每个事务必须一次将所有要使用的数据全部加锁，否则不能继续执行顺序封锁法： 预先对数据对象规定一个封锁顺序，所有事物都按该顺序实施封锁破坏死锁产生条件的预防方法：破坏互斥条件：让资源允许共享破坏不可剥夺条件：有两种方法① 当其申请的资源得不到满足时，放弃其原先占有的资源② 高优先级进程申请的资源被占用时，将强迫该低优先级进程放弃已占有资源破坏零散请求条件：采用静态分配策略，即当一个进程在得到其所需要的所有资源之后才执行破坏循环等待条件：按照资源的特性，给资源从小到大编号，进程必须按照从小到大的顺序申请资源，且规定进程占有的资源号必须小于申请的资源号才能提出申请死锁的诊断：超时法： 若事务等待时间超过规定时限，就认为发生死锁时间设置短，容易误判时间设置长，死锁不能及时发现等待图法： 采用有向图 G = (T, U)T： 为结点集合，每个结点表示正在运行的事务U： 为边的集合，每条边表示事务等待的情况若 T1 等待 T2，则画一条从 T1 指向 T2 的边4、并发调度的可串行性可串行化调度： 多个事务的并发执行正确，当且仅当其结果与按某一次序串行执行这些事务时的结果相同可串行性是并发事务正确调度的准则一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度冲突可串行化调度： 调度 Sc 在保证冲突操作次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度 Sc’，如果 Sc’ 是串行的，称调度 Sc 为冲突可串行化的调度一个调度是冲突可串行化，一定是可串行化的调度冲突可串行化调度是可串行化调度的充分条件，不是必要条件。还有不满足冲突可串行化条件的可串行化调度。冲突操作： 指不同的事务对同一个数据的读写操作和写写操作5、两段锁协议两段锁协议： 指所有事务必须分两个阶段对数据项加锁和解锁。在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁，在释放一个封锁之后，事务不再申请和获得任何其他封锁第一阶段是获得封锁，也称为扩展阶段事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁第二阶段是释放封锁，也称为收缩阶段事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁同样的，事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件。若并发事务都遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的若并发事务的一个调度是可串行化的，不一定所有事务都符合两段锁协议封锁粒度(Granularity)：封锁对象的大小封锁粒度与系统的并发度和并发控制的开销密切相关：封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；封锁的粒度越小，并发度较高，但系统开销也就越大同时考虑封锁开销和并发度两个因素，适当选择封锁粒度需要处理多个关系的大量元组的用户事务：以数据库为封锁单位需要处理大量元组的用户事务：以关系为封锁单元只处理少量元组的用户事务：以元组为封锁单位多粒度树：以树形结构来表示多级封锁粒度；根结点是整个数据库，表示最大的数据粒度；叶结点表示最小的数据粒度如下图 三级粒度树。根结点为数据库，数据库的子结点为关系，关系的子结点为元组：多粒度封锁协议：① 允许多粒度树中的每个结点被独立地加锁② 对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁③ 在多粒度封锁中一个数据对象可能以两种方式封锁：显式封锁和隐式封锁显式封锁： 直接加到数据对象上的封锁隐式封锁： 是该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁（ps：显式封锁和隐式封锁的效果是一样的）对某个数据对象加锁，系统要检查：数据库复习总结数据库系统概论 第十一章课]]></content>
      <categories>
        <category>数据库系统概论</category>
      </categories>
      <tags>
        <tag>数据库系统概论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机图形学【一】]]></title>
    <url>%2Fposts%2Ff464089a%2F</url>
    <content type="text"><![CDATA[一、绪论1、计算机图形学及其相关概念(1)什么是图形？图形是图与形的总称，是能在人视觉中形成印象的对象。(2)图形分类：自然图形（景物、照片等）描述图形（数学方法描述的图形）(3)构成图形的要素几何要素：刻画对象的轮廓、形状等非几何要素：刻画对象的颜色、纹理等(4)表示图形的方法点阵表示：是用具有颜色信息的点阵来表示图形参数表示：图形的形状参数与属性参数来表示图形例如：半径为3红色的圆(5)广义的计算机图形包括图像和图形图像：以点阵图形式呈现，它更强调整体形式，记录点及它的灰度或色彩。例如照片、扫描图片和由计算机产生的真实感和非真实感图形等。放大失真图形：以矢量图形式呈现，计算机中由景物的几何模型与物理属性表示的图形。能体现几何个体，记录体元的形状参数与属性参数。放大不失真(6)计算机图形学计算机图形学是研究怎样利用计算机来生成、处理和显示图形的原理、方法和技术的一门学科。(7)计算机图形学的两个核心问题建模：如何在计算机中构造一个客观世界：几何建模绘制：如何将计算机中的虚拟世界展现出来：几何的视觉实现(8)一些和计算机图形学相关的学科关系计算机图形学：试图从非图像形式的数据描述来生成图像。从数据到图像计算机视觉：模拟生物外显或宏观视觉功能。从图像到数据数字图像处理：对图像进行各种加工以改善图像的视觉效果。从图像到图像2、计算机图形学的发展(1)显示器的三个发展阶段：画线显示器（矢量显示器/随机扫描显示器）-&gt;存储管式显示器-&gt;刷新式光栅扫描显示器(2)计算机图形学之父：伊凡·苏泽兰(Ivan.E.Sutherland)3、计算机图形学的应用计算机辅助设计与制造（CAD/CAM）科学计算可视化真实感图形实时绘制与自然景物仿真地理信息系统（GIS）虚拟现实（Virtual Reality）计算机动画等等4、计算机图形系统计算机图形系统的定义：计算机图形系统用来生成、处理和显示图形，是计算机硬件、图形输入输出设备、计算机系统软件和图形软件的集合。基本任务：研究如何利用计算机来生成、处理和显示图形。例如：如何用硬件来实现图形处理功能如何设计好的图形软件图形处理所需的数学处理方法和算法如何解决实际应用中的图形处理问题图形应用软件(核心)：解决某种应用问题的图形软件图形支撑软件：由一组公用的图形子程序组成的。它扩展了系统中原有高级语言和操作系统的图形处理功能。图形应用数据结构：一组图形数据文件，其中存放着欲生成的图形对象的全部描述信息。应用数据结构-&gt;图形支撑软件-&gt;图形应用软件二、计算机图形系统硬件基础1、图形输入设备鼠标和键盘光笔触摸屏操纵杆跟踪球和空间球数据手套数字化仪图像扫描仪声频、视频输入系统等等2、图形显示设备CRT:阴极射线显像管(1)阴极射线管的基本原理电子枪:是产生一个沿管轴方向(Z轴)前进的细电子束轰击荧光屏。荧光屏:荧光屏是用荧光粉涂敷在玻璃底壁上制成的，常用沉积法涂敷荧光粉。荧光粉的余辉特性：电子束轰击荧光粉时，荧光粉的分子受激而发光，当电子束的轰击停止后，荧光粉的光亮并非立即消失，而是按指数规律衰减。彩色阴极射线管荫罩式彩色显像管穿透式彩色显像管(2)CRT图形显示器分类随机扫描的图形显示器（随机扫描显示器）缺点：是为画线应用设计的，不能显示逼真场景、价格贵、驱动系统也较复杂。存储管式的图形显示器光栅扫描的图形显示器只有画水平、垂直或正方形的对角线时，才能用点或像素画出一条真正的直线，其他情况下的直线均呈阶梯状，这种现象称为走样或锯齿。(3)平板显示器非发射显示器（光学效应，将光转换为图形图案）液晶显示器（LCD）液晶的电光效应：当通电和不通电时液晶分子处于两种不同的排列，一种排列光线容易通过，另外一种排列阻止光线通过。视角太小，亮度和对比度不够大。可视角是指站在始于屏幕法线的某个角度的位置时仍可清晰看见屏幕图像所构成的最大角度，对显示器来说，可视角越大越好。发射显示器（电能转化为光能）等离子显示器 (Plasma Panel)薄片光电显示器 （Thin-Film Electroluminescent Display）发光二极管显示器 (Liquid-Emitting Diode, LED)未来显示器OLED: 有机发光二极管（Organic Light-Emitting Diode, OLED ）全息投影显示3、图形显示子系统用计算机做图形处理常常涉及大量的计算和数据处理，为了减轻主机CPU的负担，具有图形处理能力的计算机都配置显卡。显卡主要作用是：根据CPU提供的指令和有关数据将程序运行过程和结果进行相应的处理，并转换成显示器能够接受的文字和图形显示信号，通过屏幕显示出来。GPU英文全称Graphic Processing Unit, 是显卡的心脏。与CPU类似，只是GPU是专门为执行复杂的数学和几何计算而设计的。CUDA(Compute Unified Device Architecture,统一计算设备架构)，显卡厂商NVIDIA推出的运算平台。 CUDA™是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。CUDA是一个基于NVIDIA GPU的并行计算的架构。OpenCL (Open Computing Language，开放计算语言) 是一个为异构平台编写程序的框架，此异构平台可由GPU、CPU或其他类型的处理器组成。OpenCL实际上是针对异构系统进行并行编程的一个全新的API。4、其它概念(1)分辨率光点：是指电子束打在显示器的荧光屏上，显示器能够显示的最小的发光点。像素点：是指图形显示在屏幕上时候，按当前的图形显示分辨率所能提供的最小元素点。屏幕分辨率：也称为光栅分辨率、物理分辨率，它决定了显示系统最大可能的分辨率，任何显示控制器所提供的分辨率也不能超过这个物理分辨率。屏幕分辨率 = 水平方向上的光点数 × 垂直方向上的光点数显示分辨率：是计算机显示控制器所能够提供的显示模式分辨率，实际应用中简称为显示模式。存储分辨率：是指帧缓冲区的大小，一般用缓冲区的字节数表示。存储分辨率不仅与显示分辨率有关，还与像素点的色彩有关帧缓存大小的计算：x方向的像素点数 × y方向的像素点数×（log2n）/8其中：n为色数或灰度等级数区别与联系：①屏幕分辨率决定了所能显示的最高分辨率；②显示分辨率和存储分辨率对所能显示的图形分辨率有控制作用。③存储分辨率=显示分辨率x（log2n）/8其中：n为颜色数或灰度等级数(2)像素与帧缓存屏幕上一个像素点对应帧缓存中的一组信息。对应方式有：组合像素法、颜色位面法组合像素法：一个图形像素点的全部信息被编码成一个数据字节，按照一定方式存储到帧缓存中，编码字节的长度与点的属性（如颜色、灰度等）有关。颜色位面法：帧缓存被分成若干独立的存储区域，每一个区域称为一个位面（Bit Plane），每个位面控制一种颜色或者灰度，每一个图形像素点在每个位面中占一位，通过几个位面中的同一位组合成一个像素。改进：使用颜色查找表，颜色查找表也称调色板，由高速的随机存储器组成，用来储存表达像素色彩的代码。此时帧缓冲存储器中每一像素对应单元的代码不再代表该像素的色彩值，而是查色表的地址索引。(3)显示长宽比显示长宽比：水平点数与垂直点数之比。要求在屏幕两个方向上相同像素点数产生同样长度的线段，以使图形不至发生畸变。例如：当显示长宽比为4：3时，显示分辨率常为：640×480， 800×600， 1024×768 等。(4)屏幕坐标系(5)OpenGLOpenGL主要包括三个函数库，它们是核心库、实用函数库和编程辅助库。核心库：包含了OpenGL最基本的命令函数，以“gl”为前缀用来建立各种各样的几何模型、进行坐标变换、产生光照效果、进行纹理映射、产生雾化效果等所有的二维和三维图形操作。实用函数库：是比核心库更高一层的函数库，以“glu”为前缀。包括纹理映射、坐标变换、多边形分化、绘制一些如椭球、圆柱、茶壶等简单多边形实体。编程辅助库：提供了一些基本的窗口管理函数、事件处理函数和简单的事件函数，以”aux”作为前缀。目前AUX编程辅助库已经很大程度上被GLUT库取代了。]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法设计与分析【五】]]></title>
    <url>%2Fposts%2Fab766c2d%2F</url>
    <content type="text"><![CDATA[一、贪心策略描述转载：五大常用算法之三：贪心算法1、基本概念：​ 所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。​ 贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。​ 所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。2、贪心算法的基本思路：​ 1.建立数学模型来描述问题。​ 2.把求解的问题分成若干个子问题。​ 3.对每一子问题求解，得到子问题的局部最优解。​ 4.把子问题的解局部最优解合成原来解问题的一个解。3、贪心算法适用的问题​ 贪心策略适用的前提是：局部最优策略能导致产生全局最优解。​ 实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。4、贪心算法的实现框架​ 从问题的某一初始解出发；​ while （能朝给定总目标前进一步）​ {​ 利用可行的决策，求出可行解的一个解元素；​ }​ 由所有解元素组合成问题的一个可行解；5、分治、动态规划、贪心标准分治动态规划贪心算法适用类型通用问题优化问题优化问题子问题结构每个子问题不同很多子问题重复（不独立）只有一个子问题最优子结构不需要必须满足必须满足子问题数全部子问题都要解决全部子问题都要解决只要解决一个子问题子问题在最优解里全部部分部分选择与求解次序先选择后解决子问题先解决子问题后选择先选择后解决子问题表格转自：https://www.cnblogs.com/batys/p/3322553.html二、贪心实例（1）部分背包问题（2）霍夫曼编码（3）活动选择问题]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>算法设计与分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法设计与分析【四】]]></title>
    <url>%2Fposts%2Fc4e8a96a%2F</url>
    <content type="text"><![CDATA[一、动态规划介绍转自：五大常用算法之二：动态规划算法1、基本概念动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。2、基本思想与策略基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。3、适用的情况(1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。(2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。(3)有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）4、求解的基本步骤动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态(1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。(2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。(3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。(4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。实际应用中可以按以下几个简化的步骤进行设计：（1）分析最优解的性质，并刻画其结构特征。（2）递归的定义最优解。（3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值（4）根据计算最优值时得到的信息，构造问题的最优解5、算法实现的说明动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。使用动态规划求解问题，最重要的就是确定动态规划三要素：​ （1）问题的阶段 （2）每个阶段的状态​ （3）从前一个阶段转化到后一个阶段之间的递推关系。递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。​ 确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。​ f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}二、动态规划实例(1)0-1背包问题(2)最大子数组问题(3)最长公共子序列问题(4)最长公共子串问题(5)编辑距离问题(6)钢条切割问题(7)矩阵链乘法问题]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>算法设计与分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语语法+词法【三】]]></title>
    <url>%2Fposts%2F47c3fd2b%2F</url>
    <content type="text"><![CDATA[四、定语从句1、什么是定语？定语是修饰名词的成分。只要听到…的+n。…的就是修饰这个名词的定语成分。2、定语的成分1、形容词作定语那只善良的夜莺死了The innocent nightingale died.那只善良和勇敢的夜莺死了The nightingale brave and innocent died.（定语较长放后面）2、名词（短语）作定语夜莺的歌声能够使这朵玫瑰花开放The singing of the nightingale can make the rose bloom.3、介词短语作定语窗外的夜莺听到了年轻人的感叹The nightingale out of the window heard the sighs of the youngster.4、非谓语动词作定语那只唱歌的夜莺最后死的很悲惨The singing nightingale lost his life.主动ing被动ed5、从句作定语夜莺用生命换来的玫瑰花被扔掉了6、形容词性物主代词作定语（实际上就是形容词作定语）3、定语的位置前小后大：当一个单词修饰名词的时候，通常放在名词前；当多个单词修饰名词的时候通常放在名词后。练习：这是一个关于夜莺和玫瑰的故事This is a story about a nightingale and a rose可数名词不能单独使用，+a或者复数，或者特指时的the。由于这里是标题意思就是一个夜莺和一个玫瑰的故事，所以用a。介词短语作定语：about a nightingale and a rose那个懂爱的年轻人离开了王子的舞会The youngster grasping romance left the party of the prince.非谓语动词作定语：grasping romance名词作定语：the prince被拒绝的那个男生看起来很可怜The boy rejected looks pitiful.非谓语动词作定语：rejected不成文规定：当过去分词修饰名词的时候，即使只有一个单词，也通常放在名词后。可以在前，但是一般不这样做我有一些重要的事情告诉你I have something important to tell you.不成文规定：当形容词修饰不定代词的时候及时只有一个单词也通常放在名词后。可以在前，但是一般不这样做4、定语从句(1)定语从句的构成n.（先行词）+引导词+句子(2)定语从句的引导词定语从句的引导词是按照先行词的种类分的类。一共把引导词分为五类①当先行词是人的时候引导词有：who、whom、whose、（that）用that不错但是正式文一般用来指物不指人，可以忽略②当先行词是物的时候引导词有：that、which、whose③当先行词是时间的时候引导词有：that、which、when④当先行词是地点的时候引导词有：that、which、where⑤当先行词是原因的时候引导词有：that、which、why谁决定引导词的用法：①先行词：缩小范围能够得到上面的某种情况②引导词能够在从句中充当的成分。它们共同决定了定语从句引导词的用法同样都是that，在同位语从句和定语从句中扮演的角色不一样在同位语从句中扮演了引导词的角色，没有意思不做成分。在定语从句中扮演了引导词的角色，还扮演代词的角色所以要好好记住简单句各个成分的角色I will never forget the day ___ I met you.从that、which、when中选填when，因为that扮演代词，不缺代词能扮演的成分。when作为副词角色可以I will never forget the day___we spent.从that、which、why中选填that。why不行代词不可以做宾语，You had better have some reason___you are late.填why。同理定语从句引导词的分类新标准：引导词可以按照引导词本身的词性分类①代词(在从句中充当主语或者宾语成分)：that、which、who、whom②副词(在从句中不能充当任何主干成分)：where、when、why③形容词(在从句中修饰离它最近的名词)：whose所以结合分类1和分类2，先看先行词选出分类1后看从句中缺少的成分。通过分类2区分，分类2只需要记住各自代表的成分，以后看分类1就能得到其代表的成分就可以了。快速分析的结论：先行词人或物，从句不缺主谓宾，就是whose。先行词是时间，从句不缺主谓宾，就是when。先行词是地点，从句不缺主谓宾，就是where。先行词是原因，从句不缺主谓宾，就是why。从句缺主语或者宾语，that、which、who、whom中选定语从句练习：①夜莺用生命换来的玫瑰花被扔掉了The rose that the nightingale exchange with his life was discarded.②这些圆顶的建筑物看起来很漂亮Buildings whose roofs are round look beautiful.③成功属于有梦想的人已经被无数个事实所证明了It has bean validated by numerous facts that glories belong to those who have dreams/with dreams/having dreams.④穿自己的鞋不仅方便还确保一点：不用管别人的感受.Wearing my own shoes not only is（not only 前后都行） convenient but also ensure a point that the feelings of others can be ignored.⑤问题的关键是谁应该为道德的沦丧负责呢The point of the issue seems who should be responsible for the decline of ethics.⑥外表看起来邋遢的他其实内心很高尚.He whose appearance looks indecent proves noble in his mind.⑦那些全力以赴去实现梦想的人即使最终没有成功也不会感到遗憾这很重要.It seems indispensable that those who spare no efforts to realize their dreams never fell pitiful although they fail to achieve glories.⑧上课不集中精力而又想通过考试的同学往往会发现结果差强人意Students who fail to concentrate in class but wish to pass the examinations smoothly tend to find that the consequence proves less impressive.5、定语从句特殊用法练习1、that做引导词时的省略写作文不要省略，任何省略都不正式。that在引导定语从句的时候，如果在从句中充当的是宾语，that可以省略。注意是从句中充当宾语I love the book （that）my mother brought for me.如果见到两个名词或者代词直接放在一起中间没有被连词或者标点符号隔开，通常都是省略了that的定语从句The potential evolution of today’s technology, and its social consequences, is dazzlingly complicated, and it’s perhaps best left to science fiction writers and futurologists to explore the many possibilities we can envisage.2、区别限制和非限制性定语从句限制性：前面名词的范围不明确，从句内容用来限定这个名词的范围甚至确定这个名词非限定性：前面名词的范围明确，从句只是一种额外的补充说明罢了。I love Amy，who is beautiful.我爱艾米，艾米很美丽。I love Amy who is beautiful.我爱美丽的艾米。I met your friend who is staying in Paris.I met your mother ，who is staying in Paris.在分析长难句的时候，非限制性定语从句（逗号隔开的）就相当于插入语可以完全不看（考试的答案也不会从非限制性定语从句得到），限制性定语从句一定要看。Edison, whose inventions have been over 2,000, is a famous scientist.爱迪生是一个著名的科学家，爱迪生的发明有两千多项。3、as和which引导的特殊非限制性定语从句which引导的非限制性定语从句可以修饰前面整个句子，as也可以但是which只能放在主句的后面，as则可前可后且as只能引导非限制性定语从句He enjoy talking with young ladies，which drives me mad.He enjoy talking with young ladies，as drives me mad.As drives me mad，He enjoys talking with young ladies.4、先行词和引导词之间有介词的情况先行词和引导词之间有介词时：人不用who而用whom，物不用that只能用which写作文也不要这样写，没事找事。马云是一个我们应该学习的人He is the man ___ we should learn from. 填who whom都行.He is the man from ___ we should learn .只能填whom.I will never forget the day __ I met you. 填whenI will never forget the day on __ I met you. 填which5、区别 the same….as； the same..that引导的定语从句as像，that是根据语境区分He is the same man as I love .他就像我爱的男人He is the same man that I love.他就是我爱的男人6、定语从句中引导词which和that的区别that的词义是“那个”，暗指单个对象。which的词义是“那一个”，暗指多个对象中的一个。6、区分定语从句和同位语从句I have a dream that sounds funny.(定语从句)I have a dream that I will become a rich lady.(同位语从句)相同点：①都是先行词+引导词+句子不同点：解释和修饰①看从句本身的意思，定语从句是对前面名词的修饰，而同位语从句是对前面名词意思的解释②看引导词that在从句中是否充当了成分，如果充当了成分就是定语从句，如果没有充当成分就是同位语从句③定语从句的先行词可以是所有的名词，同位语从句的先行词只能是抽象名词④定语从句的引导词总共有八个，而同位语从句的引导词一般都是that实际上除了翻译和写作没必要区别。7、定语从句的至难点—寻找先行词The words used by the speaker may stir up unfavorable reactions in the listener（ ）interfere with his comprehension; hence, the transmission-reception system breaks down.A. who B.as C. which D. whathence因此先行词是reactions说话者使用的话语可能会引起干扰听者理解力的不良反应， 因此，收发系统出现故障。①When someone abandons you, he is the one who should get loss ，because for him, he loses someone who loves him but for you, you lose someone who does not love you.①定语从句的先行词是它前面最近的那个名词②For workers it can mean an end to the security, benefits and sense of importance that came from being a loyal employee.先行词：the security, benefits and sense of importance②定语从句的先行词是它前面并列的几个名词③The Greeks assumed that the structure of language had some connection with the process of thought, which took root in Europe long before people realized how diverse languages could be.take root in 扎根先行词：that the structure of language had some connection with the process of thought③定语从句的先行词是它前面的一个从句④My husband enjoy talking with other young ladies, which really gets me go mad先行词：My husband enjoy talking with other young ladies,④定语从句的先行词是它前面的一个句子⑤As a linguist, he acknowledges that all varieties of human language, including non-standards like Black English,can be powerfully expressive — there exists no language or dialect in the world that cannot convey complex ideas.linguist语言学家dialect 方言convey 传达先行词：language or dialect⑤定语从句的先行词和引导词被隔开了必须读懂句子才能明白修饰的是哪个！！！所以多记单词，多分析！8、定语从句的考点分析(1)写作①名词都可以有意识的加个定语，拉长句子Pets (which look cute as well as healthy) can reduce loneliness (of senior citizens) (without any children)(who can take care of them.)Reading books (which keep beneficial to our physical and mental health) can add knowledge (of all children and adults)(2)英汉差异对比1、汉语：意合 英语：形合句子结构上：中文尝尝省略主语人们通过语境意思判断主语，而英语不行逻辑关系词的使用上：中文不喜欢使用逻辑关系词而是通过语义判断，英语上有逻辑关系则基本上都必须加逻辑关系词2、汉语：主动 英语：被动例：汉：在过去几十年里，政府采取了各种措施预防灾害的发生。​ 翻译成英：在过去几十年里，各种措施被政府采取了去预防灾害的发生。3、汉语：多短句 英语：多长句*启示：英语长难句分析，在阅读中可心中翻译成多个短句。翻译中中文的多个短句可以合成一个长句。 *合并方式：①非谓语动词注：主语不一致则写成独立主格。②并列句③从句WuZhen is a water town in zhejiang province. It locates near the river from Beijing to Hangzhou.（京杭大运河不会表示就这样写）乌镇是浙江的一个水镇。它位于京杭大运河。WuZhen locating near the river from Beijing to Hangzhou is a water town in zhejiang province.WuZhen is a water town in zhejiang province and locates near the river from Beijing to Hangzhou.WuZhen which locates near the river from Beijing to Hangzhou is a water town in zhejiang province.(3)长难句分析目的：能够找到一句话当中的定语成分并且把它们翻译出来找定语的关键就是找名词，只要定语后又一堆话，只要不是动词就暂定为修饰这个名词的定语成分（还有可能是状语），定语从名词后开始到主句的谓语动词结束，如过定语在主句的谓语后的话，定语一般到句末结束。如果定语后有连词的话定语不再是到句末结束而是到连词之前结束。一个大定语通常会有多个小定语Creating a ”European identity“ （that respects the different cultures and traditions which go to make up the connecting fabric of the Old Continent） is no easy task and demands a strategic choice.identity 身份demand需求make up 构成建立一种尊重不同文化和传统以构成旧大陆联系结构的“欧洲身份”并非易事，需要战略选择。In Europe, as elsewhere, multi-media groups have been increasingly successful groups (which bring together television,radio, newspapers, magazines and publishing houses that work in relation to one another).one another彼此在欧洲，与其他地方一样，多媒体团体已成为越来越成功的团体，它们将相互联系的电视，广播，报纸，杂志和出版社聚集在一起。Some of these causes are completely reasonable results of social needs. Others are reasonable consequences of particular advances in science being to some extent self-accelerating.reasonable合理的advance n进步In short, a leader of the new school contends, “the scientific revolution”, as we call it, was largely the improvement and invention and use（ of a series of instruments that expanded the reach of science in innumerable directions.）初二语法：直接引语：双括号引起来，间接引语：宾语从句直接引语:直接引用别人的原话叫做直接引语，直接引语通常置于引号内（“引用原话”）。间接引语用自己的话转述别人的意思，或引用自己说过的话， 都叫做间接引语。间接引语多数用宾语从句来表达。as we call it(插入语)插入语要么是同位语、要么是状语，偶尔是定语。contend v角逐、竞争，是动词instrument仪器innumerable 无数的reach n 范围Astrophysicists working with ground-based detectors at the South pole and balloon-borne instruments are closing in on such structures, and may report their findings soon.Astrophysicist天体物理学家detector探测器ground-based地基、路基borne v承担 bear的过去分词balloon-borne气球携带，球载close in 逼近使用南极的地基探测器和球载仪器的天体物理学家们正在研究这些结构，并且很快将会发表它们的发现。与南极地面探测器和气球运载工具合作的天体物理学家正在这种结构附近工作，并可能很快报告其发现。After six months of arguing and final 16hours of hot parliamentary debates Australia’s northern Territory became the first legal authority in the world to allow doctors to take the lives of incurably ill patients who wish to die.parliamentary 议会Territory 领土incurably 难以治愈经过六个月的辩论和最后16个小时的议会激烈辩论，澳大利亚北部地区成为世界上第一个允许医生夺走希望死于不治之症的患者的生命的法律机构。Whether to use tests, other kinds of information, or both in a particular situation depends, therefore, upon the evidence from experience concerning comparative validity and upon such factors as costs and availability.comparative 相对的validity 有效性factor 因素因此，在特定情况下是否使用测试，其他类型的信息，或两者都使用，取决于经验中有关比较有效性的证据以及成本和可用性等因素。]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程【四】]]></title>
    <url>%2Fposts%2F50368516%2F</url>
    <content type="text"><![CDATA[二、结构化设计（续）6、过程设计（详细设计）(1)过程设计任务确定模块算法、确定模块使用数据结构、确定模块接口（系统外部接口、用户界面、内部模块间接口细节、输入数据和输出数据）实际上就是具体如何实现模块功能，对此进行详细设计(2)结构化程序设计结构化程序设计定义：经典定义：程序代码通过顺序、选择、循环三种控制结构连接，单入口单出口。扩展定义：可限制使用GOTO语句、DO_UNTIL和DO_CASE修正定义：LEAVE和BREAK，可从循环中转移出来。实际上就是合理使用顺序、选择、循环、和一些控制语句进行程序设计。(3)结构化程序设计工具①程序流程图程序流程图是历史最悠久、使用最广泛的过程设计工具。国内常用的表示符号：标准的表示符号求n的阶乘算法表示实例：优点：对控制流程描绘直观，便于初学者掌握。缺点： （1）不是逐步求精好工具，过早考虑控制流程，非整体结构；（2）用箭头代表控制流，程序员随意转移控制；（3）不易表示数据结构和调用关系。②N-S图计算n阶乘的N-S图：特点：(1)功能域（一特定控制结构的作用域）明确；(2)不可能任意转移控制；(3)容易确定局部和全程数据的作用域；(4)容易表现嵌套关系，也可表示模块的层次结构。③PAD图可逐步求精：计算n阶乘的PAD图优点：(1)使用PAD图设计的程序必然是结构化程序；(2)PAD图描绘的程序结构十分清晰；(3)用PAD图表现程序逻辑，易读、易懂、易记；(4)容易将PAD图转换成高级语言源程序；(5)支持自顶向下逐步求精。④判定表能清晰表示复杂的条件组合与应做动作间对应关系。左上部列出所有条件；左下部所有可能做的动作；右上部表示各种条件组合的一矩阵；右下部是和每种条件组合相对应的动作。例：行李托运算法的判定表行李种类&lt;=30都免费，所以只设为一个组合，其他三个自由组合2^3+1=9种。每种对应的方案用‘X’表示⑤判定树判定表变种，表示复杂条件组合与应做动作间对应关系。更加直观。优点：形式简单，易看出含义，易于掌握和使用。缺点：简洁性不如判定表，相同数据元素重复写多遍，越接近叶端重复次数越多。(4)程序复杂度介绍使用比较广泛的McCabe方法1.根据过程设计结果画出相应流图流图描述程序控制流，基本图形符号如下图所示。2.计算流图的环形复杂度三种方法：V（G）＝区域数V（G）＝E-N＋2 E为流图中边数，N为流图中节点数V（G）＝P＋1 P为判定点数例子：*V(G)＝4 (区域数) **V(G)＝11(边数)－9(结点数)＋2＝4 *V(G)＝3(判定结点数)＋1＝4取任意一种方法即可，区域数比较方便7、面向数据结构设计方法(1)Jackson方法看课本。即分析输入和输出的数据结构，具体到每一个循环级，思考怎样的操作能够转换该数据结构。(2)Warnier方法自行查阅三、结构化系统实现1、编码(1)语言选择程序设计语言分类：机器语言、汇编语言、高级语言如何选择？系统用户要求：如果开发系统由用户维护，通常要求用熟悉的语言书写可以使用的编译程序：运行目标系统环境可提供编译程序限制可选用语言的范围可以得到的软件工具：有支持程序开发的软件工具可以利用。工程规模：规模庞大，现有语言不适用，设计实现供该工程项目使用程序设计语言程序员知识：如果和其他标准不矛盾，应选择程序员熟悉的语言软件可移植性要求：若目标系统在不同计算机上运行，选择可移植性好的语言软件的应用领域：选择语言时应充分考虑目标系统的应用范围。例如一些硬件设施中选择汇编或者C(2)编码风格逻辑简明清晰、易读易懂是重要标准程序内部的文档恰当的描述符：命名规则一致、避免过长或过短、缩写规则一致、函数用大写字母开头单词适当注解：源程序中有效注解量在20%以上序言性注解：模块开始，描述模块功能、主要算法、接口特点、重要数据及开发简史（设计者、复审者及时间、修改日期）中间注解：插在程序中间，解释这段代码的必要性及功能。良好的视觉组织：空格、空行、缩进数据说明数据说明次序应标准化常量-&gt;简单变量-&gt;数组-&gt;公用数据块-&gt;文件整形-&gt;实型-&gt;字符-&gt;逻辑多个变量名在一个语句说明，按字母顺序排列。复杂数据结构用注解说明实现方法和特点。语句构造（简单）尽量避免复杂条件测试；尽量减少“非”条件测试；例如: if not(a&gt;b）应该使用 if a&lt;=b避免大量使用循环嵌套和条件嵌套；利用括号使表达式运算次序清晰直观。尽量少用go to语句if、for、do、while、case、switch、default 等语句占一行，且if 、for 、do 、while 等语句的执行语句部分无论多少都要加括号{}输入输出1.对所有输入数据都进行检验，保证输入有效；2.检查输入项重要组合合法性；3.保持输入格式简单；4.使用数据结束标记，不要求用户指定数据数目；5.提示交互式输入请求，如可用选择或边界数值6.程序设计语言对格式有严格要求时，应保持输入格式一致；7.设计良好输出报表；8.给所有输出数据加标志效率（和存储容量）;实际上效率控制需要在需求分析时就确定。程序运行时间存储器效率输入输出效率2、软件测试软件测试的目标黑盒测试：如果知道产品应具有功能，可通过测试来检验是否每个功能都能正常使用。（忽略过程，关注输入和输出结果是否正确）白盒测试：如果知道产品内部工作过程可通过测试来检验产品内部动作是否按照规格说明书的规定正常进行。（）测试准则：（1）所有测试应能追溯到用户需求，测试的目的是发现错误，其中最严重的是不能满足用户需求的错误。（2）应尽早地和不断地进行软件测试。不应把软件测试仅看作是软件开发一独立阶段，应把它贯穿到软件开发各阶段中。需求分析等各种过程都需要测试的介入，早发现错误节省成本。（3）充分注意测试中群集现象（Pareto原理）。测试后程序中残存错误数与程序中已发现错误数目成正比，80％错误与20％模块有关。（4）测试应从小规模开始，逐步进行大规模测试。方便查找错误点（5）不能做到穷举测试。想测试所有可能的输入是不可能的（6）第三方测试原则。自己很难发现自己的错误(1)白盒测试—逻辑覆盖①语句覆盖：选择测试数据，使被测程序中每个语句至少执行一次特点：只要语句都执行过就行。②判定覆盖：每个语句至少执行一次，每个判定的真假分支至少执行一次。特点：语句都执行过，且配个判定的真假情况都出现过。③每个语句至少执行一次，判定表达式每个条件取各种可能结果特点：语句都执行过，且每个每个小条件的真假情况都出现过。④判定/条件覆盖：取足够多测试数据，使判定表达式每个条件都取各种可能值，且每个判定表达式也都取到各种可能结果。注意：有时判定／条件覆盖不比判定覆盖更强⑤条件组合覆盖：选足够多的数据，是每个判定表达式中条件的各种组合都至少执行一次特点：一个判定中每个小条件的真假构成组合，将几个判定的组合构建构建在一起，保证每个判定中的各种组合都执行过一次。注意：一定要明确“都执行过一次”的含义。例如判定A：只有一个条件，有两个条件所以有四种组合，判定B：也有两个条件所以有四种组合。而满足⑤的覆盖不是4*4而是4，因为一次执行A、B中的各一个语句，四次就能全部覆盖掉。(2)白盒测试–控制结构测试1、基本路径测试①使用程序复杂度中的McCabe方法导出流图、计算环形复杂度。②使用深度优先探索确定线性独立路径的基本集合独立路径：至少包含一条在定义该路径之前不曾用过的边。环形复杂度为独立路径基本集的上界。即环形复杂度是几，独立路径就有几条。③设计测试用例覆盖基本集合的路径例：计算不超过100个在规定值域内有效数的平均值；同时计算有效数字的综合和个数。用PDL描述的如图。设计符合各个路径的测试用例：注意:一些独立路径无法独立测试（本例路径1），程序的正常流程不能形成独立执行该路径所需的数据组合（路径1，需要满足total.valid&gt;0），这种情况下这些路径必须作为其他路径的一部分来测试。2、循环测试(1)简单循环① 零次循环：从循环入口直接跳到循环出口。② 一次循环：查找循环初始值方面的错误。③ 二次循环：检查在多次循环时才能暴露的错误。④ m次循环：此时的m＜n。⑤ 最大次数循环、比最大次数多一次循环、比最大次数少一次的循环。(2)嵌套循环①从最内层循环开始，置所有其它层循环为最小值② 对最内层循环做简单循环的全部测试。③ 逐步外推，测试时保持所有外层循环变量取最小值，其它嵌套内层循环变量取“典型”值。④ 反复进行，直到所有各层循环测试完毕。(3)连锁循环各个循环互相独立，可用与简单循环相同方法进行测试。几个循环不是互相独立，需要使用测试嵌套循环。（4）非结构化循环：使用结构化程序设计方法重新设计(3)黑盒测试黑盒着重测：软件功能黑盒发现错误类型：（1）功能不正确或遗漏（2）界面错误（3）数据结构或外部数据库访问错误（4）性能错误（5）初始化或终止错误1、等价类划分把程序的输入域划分成若干数据类，从每一数据类选取少数有代表性数据做为测试用例。在各数据类中，各输入数据对揭露程序中的错误等效。有效等价类：合理，有意义输入数据构成集合。无效等价类：不合理，无意义输入数据构成的集合。等价类划分原则：(1)输入条件规定范围，定义一有效等价类和两无效等价类。(2)输入条件是布尔量，一个有效等价类和一个无效等价类。(3)规定输入数据一组值,，程序对每个输入值分别进行处理。每个输入值确立一有效等价类，针对这组值确立一个无效等价类。例：教工分房方案中，按教授、副教授、讲师、助教分别计分。 有效类4个；无效类1个。(4)规定输入数据必须遵守规则，定义一有效等价类（符合规则）和若干无效等价类（从不同角度违反规则）例：Pascal语言规定“一个语句必须以分号‘;’结束”。 这时，可以确定一个有效等价类“以‘;’结束”，若干个无效等价类：以‘:’结束、以‘,’结束等。(5)已划分等价类中各元素在程序中处理方式不同，将等价类进一步划分更小等价类。确立测试用例：建立等价类表，列出所有划分出等价类:（1）为每一等价类规定一唯一编号；（2）设计一新测试用例，尽可能多覆盖尚未被覆盖有效等价类，重复，直到所有有效等价类被覆盖；（3）设计一新测试用例，仅覆盖一尚未被覆盖无效等价类，重复，直到所有无效等价类被覆盖。注意字眼：对于有效等价类：尽可能多、未覆盖；对于无效等价类：每个仅覆盖一个。例：某城市电话号码由三部分组成地区码：空白或3位数字前缀：非“0’或‘1’开头的四位数字后缀：4位数字2、边界值分析边界值分析是等价类划分补充。测试①恰好边界、②边界外一点、③边界内一点的数据边界选择原则：（1）输入条件规定了取值范围，则以该范围作为边界；（2）输入条件规定值的个数，则以个数为边界；（3）针对规格说明的每个输出条件，使用原则（1）和（2）；（4）如果规格说明给出的输入或输出域是有序集合（如有序表、顺序文件等），则选取集合中特定次序的元素作为边界，如第一个、最后一个元素等；（5）如果程序中使用了一个内部数据结构，则应选择该结构的边界上的值，如数组、链表等；（6）分析规格说明，找出其它可能边界条件。例：某报表处理系统要求用户输入处理报表日期，日期在2001年1月至2005年12月，由年、月6位数字字符组成，前四位代表年，后两位代表月。用边界值分析法写出测试用例。3、错误推测由经验的工程师，靠经验和直觉推测程序可能存在错误，有针对性编写检查这些错误的测试用例。例如：编写关于月份，测试用例很大程度就能猜到2月的易错点。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP程序设计【四】]]></title>
    <url>%2Fposts%2F27a59871%2F</url>
    <content type="text"><![CDATA[一、ServletServlet是服务器端的小服务程序，它能够处理客户端的请求并产生响应。Servlet将HTTP请求和响应封装在Java类中实现各种Web应用,Servlet对象由Servlet容器管理（创建、使用、销毁）,客户端可以通过访问Servlet获取服务。JSP最后的形式也是Servlet，这个转换过程是由JSP容器自动完成的，JSP是Servlet技术的一种应用。1、如何编写Servlet因为：Servlet以Java类的形式实现，所以：编写Servlet就是编写Java类1、创建包2、创建Servlet类部署方式有两种，一是注解方式，二是描述符方式。一般使用注解方式，比较方便，之后解释。3、编写代码处理请求 + 产生响应基本上都是在processRequest()中处理JSP：HTML中嵌入Java代码Servlet：Java代码中输出HTML2、Servlet的部署部署Servlet的目的就是告诉Servlet容器Servlet的具体情况，以便于容器进行管理。例如：Servlet叫什么名字Servlet的访问形式、Servlet的初始化参数等等①基于注解的部署方式位置：在类定义的上面一行基本格式@WebServlet(name = “MyServlet”, urlPatterns = {“/MyServlet”})@WebServlet：注解标志name：Servlet的名称，默认为Servlet的类名urlPatterns：指定一组Servlet的URL匹配模式，有多个时以逗号分隔②基于描述符的部署方式位置：Web页 -&gt; WEB-INF-&gt; web.xml3、Servlet的访问①在浏览器地址栏中直接访问1http://localhost:8084/HelloJsp/MyServlet②通过表单访问123&lt;form action="MyServlet" method="POST"&gt; 访问MyServlet &lt;input type="submit" value="访问" /&gt;&lt;/form&gt;③通过超链接访问1&lt;a href="MyServlet"&gt;访问MyServlet&lt;/a&gt;传递参数问题：在URL中直接传递： MyServlet?name=value&amp;name=value通过表单传递：&lt;form&gt; … &lt;/form&gt;然后在servlet中使用request等获取进行处理例如：4、Servlet的相关类与接口Servlet中文API文档-个人整理版Java Servlet API中文说明文档注意：斜体方法为抽象，所以service是在HttpServlet中实现的，在GenericServlet中没有实现，但是继承自Servlet接口中的其他四个方法实现了。其它同理能看出。当你在写Servlet的时候必须直接或间接的Servlet实现这个接口。一般趋向于间接实现：通过从javax.Servlet.GenericServlet或javax.Servlet.http.HttpServlet派生而在自己编写web在实现HttpServlet时，必须至少重写下面中的一个doGet()doPost()doPut()doDelete()init()，初始化servlet对象，完成一些初始化工作。destroy()，当容器监测到一个servlet从服务中被移除时，容器调用该方法，释放资源。getServletInfo()，获取servlet相关信息。所以编写servlet主要就是重写方法、添加成员、使用对象。下面介绍对象的功能5、Servlet的已经写好的可使用的，方便我们编写web功能的类(1)HttpSevletRequestHttpServletRequest和ServletRequest都是接口HttpServletRequest继承自ServletRequest HttpServletRequest比ServletRequest多了一些针对于Http协议的方法。 例如：getHeader()， getMethod() ， getSession()详细方法解读：javaweb学习总结(十)——HttpServletRequest对象(一)HttpServletRequest详解HttpServletRequest详解：获取HTTP请求消息(2)HttpSevletResponse详细方法解读：javaweb学习总结(七)——HttpServletResponse对象(一)javaweb学习总结(八)——HttpServletResponse对象(二)HttpServletResponse详解：封装HTTP响应消息(3)HttpSession方法详解：http://www.51gjie.com/javaweb/863.html(4)Cookie方法详解：http://www.51gjie.com/javaweb/859.html(5)ServletContextServletContext用来存放全局变量，每个Java虚拟机每个Web项目只有一个ServletContext,这ServletContext是由Web服务器创建的，来保证它的唯一性。由于一个WEB应用中的所有Servlet共享同一个ServletContext象，因此Servlet对象之间可以通过ServletContext对象通讯。ServletContext对象通常也被称之为Context域对象。详细方法解释http://www.51gjie.com/javaweb/854.htmlServletConfig和ServletContext接口及其使用方法详解（附带实例）(6)ServletConfig方法说明功能描述String getInitParameter(String name)根据初始化参数名返回对应的初始化参数值Enumeration getInitParameterNames()返回一个 Enumeration 对象，其中包含了所有的初始化参数名ServletContext getServletContext()返回一个代表当前 Web 应用的 ServletContext 对象String getServletName()返回 Servlet 的名字，即 web.xml 中元素的值ServletConfig和ServletContext接口及其使用方法详解（附带实例）6、Servlet工作原理Servlet对象的生命周期由容器统一管理，我们只要在需要的方法中添加满足功能要求的代码即可。初始化调用init方法，对象创建后，只一次服务调用service方法，每次请求都会调用，在不同线程中执行销毁调用destroy方法，服务器关闭时，只一次7、Servlet的应用(1)初始化参数（文件操作）①注解方式（在 @WebServlet 注解中添加，相对固定）②描述符方式（在 web.xml 配置文件中添加，相对灵活）③获取初始化参数(2)共享变量根据Servlet的生命周期，一个Servlet被请求而创建对象后，其成员变量可被共享例如：由此可以由多个用户共同计算一个表达式(3)重定向（Redirect）、转发（Forward）、包含（Include）在servlet中转发可使用绝对路径：例如http://localhost:8084/HelloJsp/ch05/login.jsp或者/HelloJsp/ch05/login.jspjsp跳转到servlet使用../+servlet名例如：action=”…/LoginServlet”method=”post”id=“form” &gt;，因为默认注解方式的servlet放置在了根目录下servlet相对路径跳转相对于servlet配置的路径，使用默认系统注解的servlet配置在根目录（‘/’意味着根目录）下。所以若默认注解改为/ch05/CheckLogin，则jsp跳转到servlet直接使用LoginServlet即可同时servlet跳转到jsp只需要使用login.jsp即可设置servlet的urlpattern时，写在最后是servlet名。名为CheckLogin的servlet放在根目录则为/CheckLogin，放在ch05文件夹下则为/ch05/CheckLogin服务器在解析绝对路径时，比浏览器解析绝对路径时，，多了一部分，这部分就是项目名，项目文件夹这里是hellojsp服务器在解析路径时，’src’,’WebRoot’,这些文件夹其实都忽略了，这样说或许不准确，但便于理解，也解释说，则两个目录下的文件，都是在同一个根目录下，客户端解析路径不会从项目文件夹，而是根目录即web目录详细路径跳转问题：https://www.cnblogs.com/alsf/p/9194268.html1.重定向（Redirect）:从当前 Servlet 重定向到另一个 Servlet 或 JSP实现：response.sendRedirect(location);location:直接：String location = “url”;编码：String location = response.encodeRedirectURL(url);该方式会将sessionID存入url维持回话注意：浏览器中的地址发生变化（客户端发出了对新地址location的新请求）原请求不能传递到重定向的位置（发出新请求则原请求即失效）2.转发（Forward）：将当前的请求转发到另一个 Servlet 或 JSP实现：①获取转发器 RequestDispatcher rdisp = request.getRequestDispatcher(path);②进行转发rdisp.forward(request, response);直接request.getRequestDispatcher(path).forward(request,response);path:相对路径：相对当前servlet的位置“/”开始，以当前服务目录的根目录为起始点注意：浏览器中的地址不变化（客户端没有发出新的请求，服务器进行再处理）请求能够传递到所转发的位置（请求可在转发到的页面中继续进行处理）&lt;jsp:forward page = &quot;…&quot; /&gt;转为Java代码就是如此3.包含（Include）：将另一个 Servlet 或 JSP 的执行结果包含到当前的 Servlet 中实现：①获取转发器 RequestDispatcher rdisp = request.getRequestDispatcher(path);②进行包含rdisp.include(request, response);*直接request.getRequestDispatcher(path).include(request,response); *说明：path：与 Forward 含义相同浏览器中的地址不变化（客户端没有发出新的请求）请求能够传递到所包含的位置（请求可在被包含的页面中继续进行处理）&lt;jsp:include page = &quot;…&quot; /&gt;转为Java代码就是如此include和Forward的区别：forward方法是把百请求的内容转发到另外的一个度servlet.而include是把另一个servlet处理过后的内容拿过来(4)session与Cookie1.使用session2.使用cookie的一般过程创建一个cookie（在服务器端创建，用于添加） Cookie cookie = new Cookie(name, value); //name, value都是String读取cookie（从客户端读到服务器，用于获取等） Cookie[] cookies = request.getCookies();将一个cookie添加到客户端（发送到客户端，用于保存） response.addCookie(cookie);浏览器对cookie处理方式的设置Internet选项 -&gt;隐私 -&gt;高级 -&gt;Cookie3.session 与 cookie 比较存在的位置session保存在服务器端（对象形式）cookie保存在客户端（文件形式）有效期session的有效期（发呆时间） - 达到发呆时间、invalidate、关闭浏览器cookie的有效期可使用setMaxAge方法进行设置（默认为浏览器关闭时）安全性session比cookie的安全性高（cookie可能会被窃取、篡改、……）网络传输量session直接保存在服务器端，不需要进行传输（占用服务器内存空间）cookie需要通过网络在客户端与服务器端进行传输（占用客户端磁盘空间）*jsp设置的session值，在servlet取出为null的问题：一般情况下使用HttpSession session=request.getSession(false); *https://blog.csdn.net/xxd851116/article/details/4296866]]></content>
      <categories>
        <category>JSP程序设计</category>
      </categories>
      <tags>
        <tag>JSP程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统概论【四】]]></title>
    <url>%2Fposts%2Fa5a1dc04%2F</url>
    <content type="text"><![CDATA[一、数据库完整性1、数据库完整性的概念及分类(1)什么是数据库完整性?数据库完整性(DB Integrity)是指DBMS应保证的DB的一种特性–在任何情况下的正确性、有效性和一致性广义完整性：语义完整性、并发控制、安全控制、DB故障恢复等狭义完整性：专指语义完整性，DBMS通常有专门的完整性管理机制与程序来处理语义完整性问题。(本讲专指语义完整性)关系模型中有完整性要求：实体完整性、参照完整性、用户自定义完整性(2)数据库完整性管理的作用不正当的数据库操作，如输入错误、操作失误、程序处理失误等会引发数据库完整性的问题。数据库完整性管理防止和避免数据库中不合理数据的出现，DBMS应尽可能地自动防止DB中语义不合理现象。如DBMS不能自动防止，则需要应用程序员和用户在进行数据库操作时处处加以小心，每写一条SQL语句都要考虑是否符合语义完整性，这种工作负担是非常沉重的，因此应尽可能多地让DBMS来承担。(3)怎样保证数据库完整性？DBMS允许用户定义一些完整性约束规则(用SQL-DDL来定义)当有DB更新操作时，DBMS自动按照完整性约束条件进行检查，以确保更新操作符合语义完整性DBA使用DBMS提供的DDL编写完整性约束规则，当需要更新程序时，依照完整性规则，检查更新是否符合规则，进而决定是否允许更新。完整性约束条件(或称完整性约束规则)的一般形式：Integrity Constraint ::= ( O，P，A，R)O：数据集合：约束的对象？P：谓词条件：什么样的约束？A：触发条件：什么时候检查？R：响应动作：不满足时怎么办？在A条件下触发对对象O的P约束检查，满足则更新，不满足启动相应动作R(4)数据库完整性的分类①按约束对象分类域完整性约束条件：施加于某一列上，对给定列上所要更新的某一候选值是否可以接受进行约束条件判断，这是孤立进行的关系完整性约束条件：施加于关系/table上，对给定table上所要更新的某一候选元组是否可以接受进行约束条件判断，或是对一个关系中的若干元组和另一个关系中的若干元组间的联系是否可以接受进行约束条件判断前者为域完整性约束条件后者为关系完整性约束条件②按约束来源分类结构约束：来自于模型的约束，例如函数依赖约束、主键约束(实体完整性)、外键约束(参照完整性)，只关心数值相等与否、是否允许空值等；内容约束：来自于用户的约束，如用户自定义完整性，关心元组或属性的取值范围。例如Student表的Sage属性值在15岁至40岁之间等。蓝色为结构约束，红色为内容约束③按约束状态分类静态约束：要求DB在任一时候均应满足的约束；例如Sage在任何时候都应满足大于0而小于150(假定人活最大年龄是150)。动态约束：要求DB从一状态变为另一状态时应满足的约束；例如工资只能升，不能降：工资可以是800元，也可以是1000元；可以从800元更改为1000元，但不能从1000元更改为800元。2、SQL语言实现约束的方法-Create TableCreateTable有三种功能：定义关系模式、定义完整性约束和定义物理存储特性这里体现了定义完整性约束DEFAULT { default_constant | NULL}指的是设置默认值col_constr为列约束，之后介绍table_constr为表约束，之后介绍(1)Col_constr列约束Col_constr列约束：只能应用在单一列上，其后面的约束如UNIQUE,PRIMARY KEY及search_cond只能是单一列唯一、单一列为主键、和单一列相关使用REFERENCES引用另一表tablename的列colname的值，如有ON DELETE CASCADE 或ON DELETE SETNULL语句，则删除被引用表的某列值v 时，要将本表该列值为v 的记录删除或列值更新为null；缺省为无操作 。CHECK后的条件可以是任意where语句定义REFERENCES，不需要指出FOREIGN KEY，默认就是本列作为外键，只需要指出外表的对应主键最后还可以使用on update和ondelete同理。默认是no action不作为，可以选择 cascade级联操作和set null示例//假定Ssex只能取{男，女}, 1≤Sage≤150, D#是外键12345Create Table Student ( S# char(8) not null unique, Sname char(10),Ssex char(2) constraint ctssex check (Ssex=‘男’ orSsex=‘女’), Sage integer check (Sage&gt;=1 and Sage&lt;150),D# char(2) references Dept(D#) on delete cascade,Sclass char(6) );//假定每门课学分最多5分，最少0分1234Create Table Course ( C# char(3) , Cname char(12), Chours integer,Credit float(1) constraint ctcredit check (Credit &gt;=0.0 andCredit&lt;=5.0 ), T# char(3) references Teacher(T#) on deletecascade );(2)table_constr表约束table_constr表约束：是应用在关系上，即对关系的多列或元组进行约束，列约束是其特例列约束直接跟随在列后，表约束需要逗号隔开后书写，虽然逗号隔开区分其和其他的表述，可以在任意位置书写，但是我们一般放在句末列约束直接跟在列后，所以定义REFERENCES，不需要指出FOREIGN KEY，默认就是本列作为外键，只需要指出外表的对应主键即可。而表约束则需要指出来本表作为外键的列Check只涉及一个列，则列约束和表约束效果相同，若涉及多个列则约束效果不同例如://假定严格约束20学时一个学分12345Create Table Course ( C# char(3) , Cname char(12), Chours integer,Credit float(1) constraint ctcredit check (Credit &gt;=0.0 andCredit&lt;=5.0 ), T# char(3) references Teacher(T#) on deletecascade, primary key(C#),constraint ctcc check(Chours/Credit = 20) );1234Create Table SC ( S# char(8) check( S# in (select S# from student)) ,C# char(3) check( C# in (select C# from course)) ,Score float(1) constraint ctscore check (Score&gt;=0.0 andScore&lt;=100.0),(3)撤消或追加约束的语句 Alter Table(不同系统可能有差异)drop：删除modify：修改add：添加示例：撤消SC表的ctscore约束(由此可见，未命名的约束是不能撤消)12Alter Table SCDROP CONSTRAINT ctscore;示例：若要再对SC表的score进行约束，比如分数在0~150之间，则可新增加一个约束。在Oracle中增加新约束，需要通过修改列的定义来完成123Alter Table SCModify ( Score float(1) constraint nctscore check (Score&gt;=0.0 andScore&lt;=150.0) );有些DBMS支持独立的追加约束,注意书写格式可能有些差异12Alter Table SCAdd Constraint nctscore check (Score&gt;=0.0 and Score&lt;=150.0) );3、SQL语言实现约束的方法-断言一个断言就是一个谓词表达式，它表达了希望数据库总能满足的条件,表约束和列约束就是一些特殊的断言SQL还提供了复杂条件表达的断言。其语法形式为：1CREATE ASSERTION &lt;assertion-name&gt; CHECK &lt;predicate&gt;当一个断言创建后，系统将检测其有效性，并在每一次更新中测试更新是否违反该断言。断言测试增加了数据库维护的负担，要小心使用复杂的断言。示例“每笔贷款,要求至少一位借款者账户中存有最低数目的余额，例如1000元”1234borrower(customer_name, loan_number,…) //客户及其贷款(一笔贷款的借款者)account(account_number,…, balance) //账户及其余额depositor(account_number, customer_name) //客户及其账户(一个借款者的账户)loan(loan_number, amount) //每一笔贷款123456789create assertion balance_constraint check(not exists (select * from loanwhere not exists (select * from borrower, depositor, accountwhere loan.loan_number = borrower.loan_numberand borrower.customer_name = depositor.customer_nameand depositor.account_number = account.account_numberand account.balance &gt;= 1000)))4、实现数据库动态完整的方法—触发器TriggerCreate Table中的表约束和列约束基本上都是静态的约束，也基本上都是对单一列或单一元组的约束(尽管有参照完整性)，为实现动态约束以及多个元组之间的完整性约束，就需要触发器技术TriggerTrigger是一种过程完整性约束(相比之下，Create Table中定义的都是非过程性约束),是一段程序，该程序可以在特定的时刻被自动触发执行，比如在一次更新操作之前执行，或在更新操作之后执行。事件：BEFORE | AFTER { INSERT | DELETE | UPDATE …}当一个事件(Insert, Delete, 或Update)发生之前Before或发生之后After触发。操作发生，执行触发器操作需处理两组值：更新前的值和更新后的值，这两个值由corr_name_def的使用来区分提交时刻为，提交SQL语句，BEFORE和AFTER时刻的区别瞬间就是值更新与否的瞬间[FOR EACH ROW | FOR EACH STATEMENT]对操作影响的每一条结果(前者)进行后续操作次数和操作影响的行数相同，或整个更新操作完成(后者)进行后续操作只进行一次corr_name_def的定义NEW [row] [as] new_row_corr_name//更新后的新元组命别名为OLD [row] [as] old_row_corr_name//更新前的旧元组命别名为NEW TABLE [as] new_table_corr_name//更新后的新Table命别名为OLD TABLE [as] old_table_corr_name//更新前的旧Table命别名为corr_name_def将在检测条件或后面的动作程序段中被引用处理实例：设计一个触发器当进行Teacher表更新元组时, 使其工资只能升不能降12345678create trigger teacher_chgsal before update of salaryon teacherreferencing new x, old yfor each row when (x.salary &lt; y.salary)beginraise_application_error(-20003, 'invalid salary on update');//此条语句为Oracle的错误处理函数end;假设student(S#, Sname, SumCourse), SumCourse为该同学已学习课程的门数，初始值为0，以后每选修一门都要对其增1 。设计一个触发器自动完成上述功能。1234567create trigger sumc after insert on screferencing new row newifor each row//这里任何时候都为真。beginupdate student set SumCourse = SumCourse + 1where S# = newi.S# ;end;假设student(S#, Sname, Sage, Ssex, Sclass)中某一学生要变更其主码S#的值，如使其原来的98030101变更为99030131, 此时sc表中该同学已选课记录的S#也需自动随其改变。设计一个触发器完成上述功能123456create trigger updS# after update of S# on studentreferencing old oldi, new newifor each row//这里任何时候都为真。beginupdate sc set S# = newi.S# where S# = :oldi.S# ;end;假设student(S#, Sname, SumCourse), 当删除某一同学S#时，该同学的所有选课也都要删除。设计一个触发器完成上述功能123456create trigger delS# after delete on Studentreferencing old oldifor each rowbegindelete sc where S# = :oldi.S# ;end;假设student(S#, Sname, SumCourse), 当删除某一同学S#时，该同学的所有选课中的S#都要置为空值。设计一个触发器完成上述功能123456create trigger delS# after delete on Studentreferencing old oldifor each rowbeginupdate sc set S# = Null where S# = :oldi.S# ;end;假设Dept(D#, Dname, Dean), 而Dean一定是该系教师Teacher(T#, Tname, D#, Salary)中工资最高的教师。设计一个触发器完成上述功能(更新系主任了)123456789create trigger upddean before update of Dean on Deptreferencing old oldi, new newifor each row when ( dean not in(select Tname from Teacher where D# = :newi.D#and salary &gt;=all (select salary from Teacher where D# = :newi.D#))beginraise_application_error(-20003, 'invalid Dean on update');end;二、数据库安全性1、数据库安全性的概念数据库安全性是指DBMS应该保证的数据库的一种特性(机制或手段)：免受非法、非授权用户的使用、泄漏、更改或破坏数据库安全性管理涉及许多方面：社会法律及伦理方面：私人信息受到保护，未授权人员访问私人信息会违法公共政策/制度方面：例如，政府或组织的信息公开或非公开制度安全策略：政府、企业或组织所实施的安全性策略，如集中管理和分散管理，需者方知策略(也称最少特权策略)数据的安全级别: 绝密(Top Secret), 机密(Secret),可信(Confidential)和无分类(Unclassified)数据库系统DBS的安全级别：物理控制、网络控制、操作系统控制、DBMS控制数据库安全是由各个层次来保障的，物理实现、网络控制、操作系统、DBMS控制等等一些列的层次和方向实现，这里我们只着重介绍DBMS控制方面(1)DBMS的安全机制自主安全性机制：存取控制(AccessControl)通过权限在用户之间的传递，使用户自主管理数据库安全性强制安全性机制：通过对数据和用户强制分类，使得不同类别用户能够访问不同类别的数据推断控制机制：(可参阅相关文献)防止通过历史信息，推断出不该被其知道的信息；防止通过公开信息(通常是一些聚集信息)推断出私密信息(个体信息)，通常在一些由个体数据构成的公共数据库中此问题尤为重要数据加密存储机制：(可参阅相关文献)通过加密、解密保护数据，密钥、加密/解密方法与传输本课程着重介绍DBMS的自主安全性机制和强制安全性机制(2)数据库管理员的责任和义务熟悉相关的法规、政策，协助组织的决策者制定好相关的安全策略规划好安全控制保障措施，例如，系统安全级别、不同级别上的安全控制措施，对安全遭破坏的响应，划分好数据的安全级别以及用户的安全级别实施安全性控制：DBMS专门提供一个DBA账户，该账户是一个超级用户或称系统用户。DBA利用该账户的特权可以进行用户账户的创建以及权限授予和撤消、安全级别控制调整等2、数据库自主安全性机制通常情况下，自主安全性是通过授权机制来实现的。用户在使用数据库前必须由DBA处获得一个账户，并由DBA授予该账户一定的权限，该账户的用户依据其所拥有的权限对数据库进行操作; 同时，该帐户用户也可将其所拥有的权利转授给其他的用户(账户)，由此实现权限在用户之间的传播和控制。(1)DBMS怎样自动实现自主安全性?DBMS允许用户定义一些安全性控制规则(用SQL-DCL来定义)，当有DB访问操作时，DBMS自动按照安全性控制规则进行检查，检查通过则允许访问，不通过则不允许访问(2)数据库自主安全性访问规则{ AccessRule｝通常存放在数据字典或称系统目录中，构成了所有用户对DB的访问权利;用户多时，可以按用户组建立访问规则访问对象可大可小(目标粒度Object granularity):属性/字段、记录/元组、关系、数据库权利：包括创建、增、删、改、查等谓词：拥有权利需满足的条件(3)一个自主安全性控制的例子员工管理数据库的安全性控制示例Employee(P#, Pname, Page, Psex, Psalary, D#, HEAD)安全性访问要求：员工管理人员：能访问该数据库的所有内容，便于维护员工信息收发人员：访问该数据库以确认某员工是哪一个部门的，便于收发工作，只能访问基本信息，其他信息不允许其访问每个员工：允许其访问关于自己的记录，以便查询自己的工资情况，但不能修改部门领导：能够查询其所领导部门人员的所有情况高层领导：能访问该数据库的所有内容，但只能读自主安全性的实现方式①存储矩阵通过S和O能够确定一个t，存储矩阵能够实现SOT的安全性控制但是无P的参与。可以编写一个程序，在用户提交了一个SQL语句的时候，先根据表对象在存储矩阵中查询访问关系，若全都能访问则再在存储矩阵中查询表的属性的访问关系若全都能访问则能够执行，否则不能。而这个程序就是DBMS的安全性控制程序②视图通过视图可以限制用户对关系中某些数据项的存取,例如：12视图1：CreateEmpV1as select*fromEmployee视图2：CreateEmpV2as selectPname,D#fromEmployee通过视图可将数据访问对象与谓词结合起来，限制用户对关系中某些元组的存取，例如：12视图1： CreateEmpV3asselect*fromEmployeewhereP#=:UserId视图2： CreateEmpV4asselect*fromEmployeewhere Head=:UserId用户定义视图后，视图便成为一新的数据对象，参与到存储矩阵与能力表中进行描述,所以他可以递归使用，视图中再建立新的视图。视图全部实现了SOTP的控制3、利用SQL语言实现数据库自主安全性SQL语言包含了DDL,DML和DCL。数据库安全性控制是属于DCL范畴(级别1)Select : 读(读DB, Table, Record, Attribute, … )(级别2)Modify : 更新Insert : 插入(插入新元组, … )Update : 更新(更新元组中的某些值, …)Delete : 删除(删除元组, …)(级别3)Create : 创建(创建表空间、模式、表、索引、视图等)Create : 创建Alter : 更新Drop : 删除级别高的权利自动包含级别低的权利。如某人拥有更新的权利，它也自动拥有读的权利。在有些DBMS中，将级别3的权利称为账户级别的权利，而将级别1和2称为关系级别的权利。(1)授权命令user-id ，某一个用户账户，由DBA创建的合法账户public, 允许所有有效用户使用授予的权利privilege是下面的权利SELECT | INSERT | UPDATE | DELETE | ALL PRIVILEDGESWITH GRANT OPTION选项是允许被授权者传播这些权利,添加则允许，不添加则不允许示例假定高级领导为Emp0001, 部门领导为Emp0021, 员工管理员为Emp2001,收发员为Emp5001(均为UserId, 也即员工的P#)1234Grant All Priviledges ON Employee TO Emp2001;Grant SELECT ON EmpV2 TO Emp5001 ;Grant SELECT ON EmpV3 TO public;Grant SELECT ON EmpV4 TO Emp0021;注意：授予视图访问的权利，并不意味着授予基本表访问的权利(两个级别：基本关系级别和视图级别)授权者授予的权利必须是授权者已经拥有的权利(2)收回授权命令示例1revoke select on employee from UserB;4、安全型控制的其他简介(1)授权的传播范围问题传播范围包括两个方面：水平传播数量和垂直传播数量水平传播数量是授权者的再授权用户数目(树的广度)垂直传播数量是授权者传播给被授权者，再被传播给另一个被授权 者, …传播的深度(树的深度)有些系统提供了传播范围控制，有些系统并没有提供，SQL标准中也并没有限制。当一个用户的权利被收回时，通过其传播给其他用户的权利也将被收回如果一个用户从多个用户处获得了授权，则当其中某一个用户收回授权时 ，该用户可能仍保有权利。例如UserC从UserB和UserE处获得了授权，当 UserB收回时，其还将保持UserE赋予其的权利。由此引发的授权范围问题值得思考，这里不再深入，可查阅资料(2)强制安全性机制强制安全性通过对数据对象进行安全性分级:绝密(Top Secret), 机密(Secret),可信(Confidential)和无分类(Unclassified),同时对用户也进行上述的安全性分级从而强制实现不同级别用户访问不同级别数据的一种机制.用户S, 不能读取数据对象O, 除非Level(S)&gt;=Level(O)低阶用户不能读取高阶数据用户S, 不能写数据对象, 除非Level(S)&lt;=Level(O)。高阶用户不能写低阶数据，否则更改了对象的安全等级使得原本能访问的低阶用户也不能访问了DBMS引入强制安全性机制, 可以通过扩展关系模式来实现，对属性和元组引入安全性分级特性或称分类特性R(A1: D1, C1, A2: D2, C2…, An:Dn, Cn, TC)其中 C1,C2,…,Cn分别为属性D1,D2,…,Dn的安全分类特性; TC为元组的分类特性这样, 关系中的每个元组, 都将扩展为带有安全分级的元组, 例如强制安全性机制使得关系形成为多级关系(不同级别用户所能看到的关系的子集)，也出现多重实例、多级关系完整性等许多新的问题或新的处理技巧，在使用中需注意仔细研究。关于强制安全性机制的内容，可参看其他有关的文献。4、数据库安全性控制的常用方法1.安全性标准：TCSEC和CC（我国标准）2.存取控制：存钱控制的机制主要包括定义用户权限和合法权限检查3.自主存取控制(C2级):用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限，用户还可以将其拥有的权限授予其他人用户权限由两个要素组成:数据库对象和操作类型，在数据库系统中，定义存取权限被称为授权sql语句:（[]表示可有可无）授权：GRANT&lt;权限&gt;[,&lt;权限&gt;]…ON&lt;对象类型&gt;&lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]…TO&lt;用户&gt;[,&lt;用户&gt;]…[WITH GRANT OPTION]；回收权限：REVOKE&lt;权限&gt;[,&lt;权限&gt;]…ON&lt;对象类型&gt;&lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]…FROM&lt;用户&gt;[,&lt;用户&gt;]…[CASCADE|RESTRICT];角色：CREATE RPLE &lt;角色名&gt;给角色授权和收回与普通的操作一致，将权限替换成角色4.强制存取控制(B1级)：每一个数据库对象被标以一定的密级，每一个用户也被授予某一个级别的许可证。对于任意一个对象，只有具有合法许可证的用户才可以存取基本规则：1.仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体2.仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体例子:银行职业可以修改金额但是不可以看金额，主管可以看数据但是不可以改数据。5.视图：可以通过视图机制将要保密的数据对无权存取的用户隐藏起来，从而自动对数据提供一定程度的安全保护SQL：CREATE VIEW XXXASSELECT NAMEFROM YYY6.审计：把用户对数据库的所有操作自动记录下来放入审计日志。提供了一种事后检查的安全机制7.数据加密：存储加密和传输加密]]></content>
      <categories>
        <category>数据库系统概论</category>
      </categories>
      <tags>
        <tag>数据库系统概论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统概论【二】]]></title>
    <url>%2Fposts%2F5f926633%2F</url>
    <content type="text"><![CDATA[一、关系模型1、基本概念形象地说，一个关系(relation)就是一个Table。关系模型就是处理Table的，它由三个部分组成：描述DB各种数据的基本结构形式(Table/Relation)描述Table与Table之间所可能发生的各种操作(关系运算)描述这些操作所应遵循的约束条件(完整性约束)(1)基本结构①“列”的取值范围“域(Domain)”域是一组具有相同数据类型的值的集合,如整数的集合、字符串的集合、全体学生的集合集合中元素的个数称为域的基数(Cardinality)②“元组”及所有可能组合成的元组：笛卡尔积(Cartesian Product)笛卡尔积是由n个域形成的所有可能的n-元组的集合，也就是所有域取值的任意组合若Di的基数为mi，则笛卡尔积的基数，即元组个数为：m1×m2×…×mn③关系(Relation)关系(Relation)是一组域D1 , D2 ,…, Dn的笛卡尔积的子集笛卡尔积中具有某一方面意义的那些元组被称作一个关系(Relation)④属性名由于关系的不同列可能来自同一个域，为区分，需要为每一列起一个名字，该名字即为属性名。⑤关系模式(Schema)或表标题(head)关系可用R(A1:D1 , A2:D2 , … , An:Dn )表示，可简记为R(A1 , A2 , … ,An )这种描述又被称为关系模式(Schema)或表标题(head)在计算机中域名及属性向域的映象常常直接说明为 属性的类型、长度例如：Student( S# char(8), Sname char(10), Ssex char(2),Sage integer, D# char(2), Sclass char(6) )R是关系的名字, Ai 是属性, Di 是属性所对应的域, n是关系的度或目(degree), 关系中元组的数目称为关系的基数(Cardinality)例如:家庭(丈夫:男人，妻子:女人, 子女:儿童)或家庭(丈夫，妻子, 子女)关系模式是对关系的描述, 关系是关系模式在某一时刻的数据,所有同一关系模式下，可有很多的关系例如:⑥码（key）候选码（Candidate key）：若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码所以候选码可以是一个或者多个且关系中可以有很多组候选码，即具有几组选择，没一组都是可以唯一表示一个元组，例如学生学号，和学生的家庭住址+名字，就是两组候选码全码（All-key）：最极端的情况：关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key）主码：若一个关系有多个候选码，则选定其中一个为主码（Primary key）DBMS以主码为主要线索管理关系中的各个元组主属性：候选码的诸属性称为主属性（Prime attribute）不包含在任何侯选码中的属性称为非主属性（Non-Prime attribute）或非码属性（Non-key attribute）有多组候选码则这些组中的属性每一个都是主属性外码(Foreign Key)/外键：关系R中的一个属性组（可一个或多个），它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。两个关系通常是靠外码连接起来的。外码是非主属性的子集的值一个关系中含有外码，则该关系称为为参照关系（Referencing Relation）,以该外码为主码的关系称为被参照关系（Referenced Relation）或目标关系（Target Relation）可以理解为作为外码就是参照该码作为候选码的关系的信息来构建的一个关系可以是参照关系同时也可以是被参照关系例如“合同”关系中的客户号不是候选码，但却是外码。因它与“客户”关系中的候选码“客户号” 相对应。⑦基本关系的性质列是同质的（Homogeneous），即来自同一个属性，每一列中的分量来自同一域，是同一类型的数据列不同质的例子:不同的列可出自同一个域列的顺序无所谓,列的次序可以任意交换，即区分哪一列是靠列名行的顺序无所谓，行的次序可以任意交换，即：区分哪一行是靠某一或某几列的值(关键字/键字/码字)任意两个元组的候选码不能相同分量必须取原子值若纵向具有合并项，可以拆开；若横向具有合并项则需要分成两个表。这是一般处理⑧关系和表的联系理论上，关系的任意两个元组不能完全相同。(集合的要求：集合内不能有相同的两个元素)；现实应用中，表(Table)可能并不完全遵守此特性。关系是对表的数学描述，表示关系的体现，在现实应用中，表可以出现一些元素相同的特殊情况，而作为严格的数学，关系则不能(2)基本操作之后再细致介绍(3)完整性约束关系的三类完整性约束：实体完整性、参照完整性、用户定义的完整性①实体完整性（Entity Integrity）实体完整性要求每个表都有唯一标识符，每一个表中的主键字段不能为空或者重复的值。关系的主属性不能取空值，空值就是“不知道”或“不存在”或“无意义”的值关系中的元组对应到现实世界相互之间可区分的一个个个体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识的个体，这是不容许的。非主属性可以取空指，但不提倡在进行关系操作时，有时关系中的某属性值在当前是填不上的，比如档案中有“生日不详”、“下落不明”、“日程尚待公布”等，这时就需要空值来代表这种情况。关系模型中用‘?’表征。数据库中有了空值，会影响许多方面，如影响聚集函数运算的正确性，不能参与算术、比较或逻辑运算等。有空值的时候是需要特殊处理的，要特别注意。②参照完整性规则参照完整性要求关系中不允许引用不存在的实体。设定相应的更新删除插入规则来更新参考表。如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2 中某个元组的Pk 值，或者为空值即如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在。例如：R1的专业选项D#的值必须是专业关系中存在的值③用户自定义完整性即用户针对具体的应用环境定义的完整性约束条件例如：二、关系代数1、关系代数操作包括：集合操作和纯关系操作2、为什么要提出关系代数SQL实际上就是一个程序，SQL语言描述的就是各种关系运算，DBMS解析为关系模型的基本运算，再执行各种基本运算。用户只需要使用SQL语言即可，非常方便3、基本操作(1)补充：并相容性定义：关系R和关系S的属性数目必须相同，对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同例如：某些关系代数操作，如并、差、交等，需满足“并相容性”(2)“并”操作定义：假设关系R和关系S是并相容的，则关系R与关系S的并运算结果也是一个关系，记作：R ∪S, 它由或者出现在关系R中，或者出现在S中的元组构成。通俗：并运算就是将两个关系的元组合并成一个关系，在合并时去掉重复的元组。例如：(3) “差”操作定义：假设关系R 和关系S是并相容的，则关系R 与关系S 的差运算结果也是一个关系，记作：R- S, 它由出现在关系R中但不出现在关系S中的元组构成。通俗：差运算就是保留R中各个不再S中的元组例：(4) “笛卡尔积”操作定义：关系R () 与关系S() 的广义笛卡尔积(简称广义积,或 积 或笛卡尔积) 运算结果也是一个关系，记作： R x S, 它由关系R中的元组与关系S的元组进行所有可能的拼接(或串接)构成。通俗：积运算就是R中的元组和S中的元组，以元组为单位，进行组合排列的结果组成一个新表例如：(5)“选择”操作给定一个关系R, 同时给定一个选择的条件condition(简记con), 选择运算结果也是一个关系，记作con(R) , 它从关系R中选择出满足给定条件condition的元组构成。通俗：就是选择符合条件的元组（行）条件的书写很重要:θ可以为：&gt;、=、&lt;、&lt;&gt;、≥、≤例如：(6)“投影”操作定义：给定一个关系R, 投影运算结果也是一个关系，记作 A(R) , 它从关系R中选出属性包含在A中的列构成。通俗：就是选择符合条件的属性（列）例如:4、扩展操作所有的扩展操作都能通过基础操作表达实现(1)交(Intersection)定义：假设关系R和关系S是并相容的，则关系R与关系S的交运算结果也是一个关系，记作：R ∩S, 它由同时出现在关系R和关系S中的元组构成。通俗：交运算就是将取交集元组*注意:交运算可以通过差运算来实现R∩ S = R - (R - S) = S - (S - R) *例如：(2)“连接”操作本质：两个关系的笛卡尔积经过选择操作的结果，只是选择条件必须是两个具有可比性的属性注意：虽然我们理解成先积后选，但是实际上当引入连接操作后，DBMS可直接进行连接操作，而不必先形成笛卡尔积，效率更高。原因之后会学到例如:(3)“等值-连接”操作等值连接是一种特殊的连接本质：两个关系的笛卡尔积经过选择操作的结果，只是选择条件必须是两个具有可比性的属性且比较符号为=例如:(4) “自然连接”操作自然连接是一种特殊的等值连接本质：两个关系的笛卡尔积经过选择操作的结果，只是选择条件必须是两个相同属性且1、比较符号为=2、属性组是相同的可去掉一组(5) “除”操作除法常用于“包含了所有的”这种字样，一般S就是“XX所有的”这种XX条件表示除操作的结果保证和S进行积操作的结果全部在R中！R中减去S的属性，剩下的属性能够包含所有的S的属性的行选择出来！通俗:若为R÷S，则选择R中对应属性含有S的属性值元组，在每个元组中除了S的属性组中的属性组，找出能和所有的S元组构成当前R中元组的属性组。例如:(1）中S为属性A3，所含元组为c，则在R中找到前三组，因为S中只有一个元组c，所以对应R中三个元组前面的A1、A2值组成的元组就组成的最后的R÷S结果(2）中S为属性A3，所含元组为c、f、g、h，则在R中找到前七组被A3分为四类，这四类元组中只有（a，e）都存在于四类元组中，所以为最后的R÷S结果(3)(4)均为如此“除”操作的基础操作解释：(6)“外连接”操作定义：两个关系R与S进行连接时，如果关系R(或S)中的元组在S(或R)中找不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S(或R)中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接(Outer Join)。悬浮元组（Dangling tuple）：两个关系R和S在做自然连接时，关系R中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃了，这些被舍弃的元组称为悬浮元组。外连接具有三种形式:左外连接、右外连接、全外连接*通俗:就是在连接的基础上，对于找不到匹配元组的元组，进行保留防止信息丢失，那边开那边元组数目不丢失，不匹配的相关信息使用？或null标记 *全外连接：左外连接和右外连接：*SELECT __ From __ Where__ **Π、（[表、连接]）、σ *not in —&gt; -(差)θ可以为：&gt;、=、&lt;、&lt;&gt;、≥、≤​]]></content>
      <categories>
        <category>数据库系统概论</category>
      </categories>
      <tags>
        <tag>数据库系统概论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程【三】]]></title>
    <url>%2Fposts%2Fe71b9c73%2F</url>
    <content type="text"><![CDATA[二、结构化设计（续）1、结构化设计的概念与原理传统软件工程方法学采用结构化设计技术（SD）。从工程管理角度结构化设计分两步：①概要设计： 将软件需求转化为数据结构和软件系统结构。②详细设计： 过程设计，通过对结构细化，得到软件详细数据结构和算法。结构化设计与分析的关系：数据设计：数据模型及核心数据字典转变为数据结构。体系结构设计：功能模型中数据流图转变成计算机模块框架。接口设计：功能模型中数据流图转变成软件内部、软件与协作系统间、软件与用户间通信方式。过程设计：行为模型及功能模型中的“处理规格说明”转换成软件构件过程描述。(1)结构化设计的概念与原理-模块化“模块“又称”构件”一般指用一个名字调用的相邻程序元素序列。模块化设计(modular design): 按适当的原则把软件划分为一个个较小的、相关而又相对独立的模块。但是不能无限划分，接口成本会增加(2)结构化设计的概念与原理-抽象奇妙的数字 7±2，是人类信息处理能力的限度，不能同时考虑所有细节。所以我们需要抽象，抽象就是抽出事物的本质特性，暂不考虑细节。(3)结构化设计的概念与原理-求精求精是指为了能集中精力解决主要问题，尽量推迟对细节问题的考虑，实际上是一个细化过程，与抽象是互补的概念。（就是将抽象细化，将实现的细节添加进去）抽象使得设计者能够说明过程和数据，同时却忽略底层细节；求精帮助设计者在设计过程中揭示底层细节。(4)结构化设计的概念与原理-信息隐藏每个模块的实现细节对于其他模块来说是隐藏的也就是说，模块中所包含的信息是不允许其他不需要这些信息的模块访问的。每个客户只能通过接口来了解该模块，而所有的实现都隐蔽起来。(5)结构化设计的概念与原理-模块独立模块独立：具有独立功能且和其他模块没过多作用。理由：1.容易分工合作2.容易测试和维护，修改工作量较小，错误传播范围小，扩充功能容易两个定性度量标准：耦合和内聚。2、模块独立(1)耦合原则：尽量使用数据耦合，少用控制耦合，限制公共环境耦合， 完全不用内容耦合。耦合是软件结构中不同模块间互连程度度量。取决模块间接口复杂程度，通过接口数据。追求尽可能松散耦合系统。非直接耦合：两个模块分别能独立地工作不需要另一模块存在。数据耦合：两模块通过参数交换数据信息。即A的结果只作为B的一个处理数据参与。控制耦合：两模块通过参数交换控制信息（包括数字形式）。即A的结果能够决定B的运行进程选择。公共环境耦合：两个或多个模块通过一公共数据环境作用。这个公共环境可以是全局变量、共享通信区、存储介质上的文件、物理设备等具有两种可能（1）一模块送数据，另一模块取，等价数据耦合。（2）两模块既往公共环境送又从里面取，介于数据耦合和控制耦合之间。内容耦合：（1）一模块访问另一模块内部数据；（2）一模块不通过正常入口转到另一模块内部；（3）两模块有部分程序代码重叠（汇编程序）；（4）一模块有多个入口。(2)内聚内聚是模块内各元素彼此结合紧密程度。功能内聚：一模块中各部分是完成某一功能必不可少组成部分。顺序内聚：模块内处理元素同某功能密切相关，顺序执行。通信内聚： 一模块内各功能部分都使用相同输入数据，或产生相同输出数据。例如:在“获得配件单价和库存单”模块，产生配件单价和库存单都是使用的配件编号。过程内聚：模块内处理元素相关，特定次序执行。如把流程图中循环部分、判定部分、计算部分分成三个模块，这三个模块都是过程内聚模块。例：在该模块中由于累计销售额和累计订货量都能够在一个循环中计算，过程内聚。时间内聚：多为多功能模块，要求所有功能在同一时间内执行。如初始化模块和终止模块及紧急故障处理模块。强调模块内处理的元素只是在时间上具有强烈的关联性，所以一般只是在初始化和终止中使用逻辑内聚：一模块完成功能在逻辑上属相同相似一类。偶然内聚：模块内各部分间没有联系，即使有也很松散。例如，A：把记录号放入N、B：从主文件读取信息、C：X+1三个模块功能调用很简单，就放在一个模块M中，于是这个模块中很多语句互不干系，只是看A、B、C的调用决定使用哪一块。从上往下内聚度逐渐减少。功能内聚&gt;顺序内聚&gt;通信内聚&gt;过程内聚&gt;时间内聚&gt;逻辑内聚&gt;偶然内聚。过程内聚和时间内聚尽量少用。逻辑内聚和偶然内疚尽量不要出现。3、启发规则启发规则是一些前辈归纳的对设计软件由帮助的规则。(1)改进软件结构提高模块独立性初步结构分解或合并，降低耦合提高内聚。将两个模块中相似的部分做成一个模块，复用代码。提高内聚，降低耦合(2)模块规模应该适中过大分解不充分，但进一步分解不应降低模块独立性。 过小开销大于有效操作，模块数目过多系统接口复杂。 通常语句行数在50～100（一页纸），最多不超过500行。(3)深度、宽度、扇出和扇入应适当深度：软件结构控制层数，标志一系统大小和复杂程度。宽度：软件结构同一层模块数最大值，越大系统越复杂。扇出：一模块直接控制（调用）模块数，过大，模块复杂，过小（如1）不好。3－9。扇出过了怎么办？将扇出的模块观察联系再分类，增加中间层模块扇入：有多少上级模块直接调用它，越大共享该模块上级模块越多。扇入过了怎么办？同样的，将扇入的模块观察联系再分类，增加中间层模块例如:深度5宽度7改善高扇出软件结构示例：改善后：(4)模块作用域应在控制域内作用域：受该模块内判定影响的所有模块集合。控制域：模块本身及所有直接或间接从属它的模块集合。若模块作用域不在控制域内，会增大模块间控制耦合。改善作用域不在控制域的软件结构方法一：移动判定点方法二：移动作用域改善作用域不在控制域的软件结构图:方法一：移动判定点方法二：移动作用域(5)降低模块接口复杂程度模块接口复杂是软件发生错误一主要原因。应使信息传递简单且和模块功能一致。例如：一个处理一元二次方程的函数，AX2+BX+C=0，A，B，C，X1，X2分别作为函数的参数就不如A、B、C放入一个数组X1、X2放入一个数组进行传递好(6)设计单入口、单出口模块尽量保证上层进入下层输出(7)模块功能可预测输入数据相同，产生同样输出。模块功能防止过分受限。客户说10个字符以内，你就设计10字符以内吗？以后有新的高需求了就得推到重来不可预测模块:不可预测的模块，不能够进行测试，你无法知道输入数据对应的输出是什么。4、面向数据流设计方法面向数据流的设计要解决的任务，就是将软件需求分析阶段生成的逻辑模型数据流图映射（Mapping）表达软件系统结构的软件结构图。结构化设计属于面向数据流的设计方法。(1)软件结构图默认就是上调用下，不需要箭头。数据信号空心圆圈表示，控制信号实心圆圈表示。判断调用使用菱形，循环调用使用带箭头的弧线(2)信息流类型1.变换流信息沿输入通路进入系统，由外部形式变换成内部形式，通过变换中心加工处理后再沿输出通路变换成外部形式离开软件系统。2.事务流 信息沿输入通路到一处理，由处理根据输入信息类型在若干动作序列中选一个执行。处理称事务中心,它接收输入信息（又称事务）、分析每个事务确定类型、根据事务类型选取一活动通路。是事务流的最明显的特征。(3)变换流分析实例例：软件做在只读存储器中，使设备具有某些“智能”。假设的仪表板将完成下述功能：（1）通过模/数转换实现传感器和微处理机接口；（2）在发光二极管面板上显示数据；（3）指示每小时英里数（mile/h）、行驶里程和每加仑油行驶的英里数（mile/Gal）等；（4）指示加速或减速（5）超速警告：发出超速警告铃声。1.复查基本系统模型。确保系统输入和输出数据符合实际。2.复查并精化数据流图。因为我们在转换成为模块表示的软件结构图时，数据流图的某些部分可能过大或者顺序不利于编程等，不利于实现。我们需要侧向方便软件实现的现实进一步复查并精化数据流图，正确、处理项完成相对独立功能。最终得到数字仪表板系统数据流图如下：3.确定数据流图具有变换特性还是事务特性。没有明显事务中心（一进然后判断多出的一个进行处理。），则为变换型。4.通过划分数据流边界找出变换中心①输入边界：输入数据流向中心推。判断输入数据是变成了输入数据的某种形式还是变成了输出。如果数据流经过了某个处理还是输入数据的某种形式那么边界就推过这个处理，否则停止。②输出边界：位于产生最终输出的处理之前。结果：5.通过划分的数据流边界完成一级分解6.完成第二级分解对每个输入结构，逆向细分调用。对变换结构同理对变换结构同理7.对初步软件结构精化为了软件设计方便，进行进一步细化精化。(4)事物流分析实例软件结构：一接收分支和一发送分支。（4）面向数据流设计过程总览注意启发式设计规则来精化软件结构不断复查、细化分析出变换流和事务流之前，两者工作相同5、人机界面设计(1)常见问题1.系统响应时间用户觉得系统立即响应时间范围0.1-1秒，超出1秒会让用户注意到延迟1-10 秒 鼠 标 显 示 成 为 沙 漏10 到18 秒 由微帮助来显示处理进度18 秒 以 上 显示处理窗口，或显示进度条但响应时间也不能过短，因为这样会短迫使用户加快操作节奏，导致出错。易变性：易变性指响应时间相对平均响应时间偏差，越低越好，否则会让用户误认为系统工作异常。2.用户帮助措施手册和联机帮助（不离开用户界面）。联机帮助两类：集成帮助和附加帮助。集成帮助设计在软件里面，附加帮助系统建成后加到软件中，前者可用性更强。请求帮助：帮助菜单，特殊功能键，HELP 命令。显示帮助信息：独立窗口、参考某个文档、屏幕固定位置悬浮作简短提示组织帮助信息：平面结构，通过关键字访问、层次结构，查更详细信息、超文本结构3.出错信息处理以用户可用理解术语；提供清楚、易理解报错信息（出错位置、原因）；从错误中恢复的建设性意见；信息用颜色等在视觉上引人注目；可能造成负面后果。4.命令交互建议保留命令交互方式控制序列:Ctrl-C(拷贝) Ctrl-H(帮助) Ctrl-P(打印)功能键：F1（帮助）键入命令命令宏机制：用户定义名字代表一个常用命令序列。(2)设计建议1.一般交互保持人机界面菜单选择、命令输入、数据显示风格一致；提供有意义信息反馈：双向通信；破坏性动作前要确认：删除、覆盖；允许取消大多数操作；减少两次操作之间必须的记忆量；提高对话、移动和思考的效率；允许犯错误：保护不受致命错误破坏；按功能对动作分类，设计屏幕布局；提供帮助措施；用简单的动词或动词短语作为命令名。2.信息显示显示与当前工作有关信息；简单易懂方式表示数据：图形、图表；使用一致标记、标准缩写和可预知颜色；产生有意义出错信息；3.数据输入减少用户输入动作：鼠标选择、滑动标尺等；使当前不适用命令不起作用；交互灵活：保留各种输入方式；让用户控制交流；对所有输入都提供帮助；消除冗余输入：数据单位、整钱后键入.00、提供缺省值等。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语语法+词法【二】]]></title>
    <url>%2Fposts%2F4b8c9b5d%2F</url>
    <content type="text"><![CDATA[三、名词性从句1、名词能够充当的成分名词能够充当主语The movies looks terrific.名词能够充当宾语I admire his mother.名词能够充当表语Gump is a man.名词能够充当同位语I enjoy the part，the beginning.同位语：用来解释名词的成分，所以他可以修饰主语、宾语、表语。名词、代词、非（谓语动词）做同位语都有逗号，只有从句做同位语没有逗号。同位语成分：1、名词2、代词3、非谓语动词I enjoy the sports，running4、从句写作中同位语加分。例如：My mother，a typical housewife，playing Mahjong ，a Chinese entertainment.主语写作时不要都使用同位语，这里只是演示同位语的位置可以在主语、宾语只要在作文中见到名词，都可以有意识的在它的后面加一个同位语，对该名词进行补充说明.Persistence ，a active mentality，plays a critical role in the glories of all children and aduls坚持，一种积极的心态，在所有的孩子和成年人的成功中扮演重要角色.2、什么是名词性从句主语从句：The moviesWhat i saw looks terrific.宾语从句：I admire his motherwhat she said.表语从句：Gump is a man who we should learn from.同位语从句：I enjoy the part that a bird is flying in the sky，the beginning .名词在句子中能够充当的成分，从句都能充当，这就是名词性从句3、名词性从句的引导词从句=引导词+句子，所以一个句子想变成从句很简单，但是需要选对引导词That he has got divorced is my fault. 它已经离婚了是我的错误Whether he has got divorced is obvious.他是否已经离婚了是显而易见的Who he will marry is a secret. 他要和谁结婚是一个秘密名词性从句的引导词是按照从句的类型分的类，一共把引导词分成三类1、that：当从句是陈述句时。并且that在从句中不充当任何成分也没有任何意思2、Whether：当从句是一般疑问句时（但是注意改成从句需要变成陈述句）。并且whether也不充当任何成分，意思是是否3、所有的特殊疑问词：当从句是特殊疑问句时。（注意改成从句需要变成陈述句）英语中所有的从句一定是陈述句的形式！！也就是引导词+主语+谓语的形式练习：①我正在思考，外星人存在吗。I am wondering whether alien is exist.②女人总是对的是一个常识That women tend to be right remains common knowledge.③我的意思是孝敬父母是中华民族传统美德My meaning seems that supporting the elderly remains a Chinese conventional virtue.（美德可数！）④有一天你会发现，事业、亲情、友情Someday，one will perceive that career，kinship and friendship prove more indispensable than romance.三个不可数名词当做主语，但是谓语依然是复数不是单数，要看全部的主语是不是单数one day是已经发生过某件事情的某一天，someday 如果一件事情没有发生的某一天不特指的“你”，翻译成one⑤重点是你什么时候有钱The point seems when wealth will become available for you.4、写作中的使用(1)主语从句主语从句满分句型：把主语从句放到句末，用it作为形式主语it….that…..(注意和最后学习的强调句型区分)显而易见的是、众所周知的是：It is apparent that…It looks beyond dispute thatIt has been widely accepted that….It is universally acknowledged that…It keeps my argument that….=I think that….主语从句的满分句型可以写在作文中任何一句话的前面，用来拉长句子。练习:显而易见，关于勤奋这个话题已经引起广泛关注了It looks beyond dispute that issue about diligence has been brought into the limelight.(2)同位语从句练习:他已经找到了一个女朋友，这件事情使他的家人很开心。The matter that he managed to find a girlfriend makes his superiors rejoiced.或The matter makes his superiors rejoiced that he managed to find a girlfriend.同位语从句既可以放在它所解释的名词后，也可以放到整句话的后面练习:没有什么能够掩盖他正在变老这个事实。Nothing can hide the truth that he is getting old.河南人都是骗子这种想法是不正确的The outlook proves wrong that private individuals in Henan seem all deceivers.温室里的花朵不能经受风雨这个事实表明，我们不应该溺爱孩子。The evidence that flowers in the greenhouse fail to undergo storms indicates that kids should not be spoiled by their senior citizens.5、长难句分析目的：能够识别各个名词性从句并且把它们通顺的翻译出来。(1)如何识别主语从句只要见到有引导词放在句首，并且从句后没有被逗号隔开，就一定是主语从句。主语从句从句首后开始，到主句的谓语动词（前面没有引导词的谓语动词）结束。除此以外，见到it….that也通常都是主语从句，主语是that到最后it是形式主语。练习:Whether the Government should increase the financing of pure science at the expense of technology or vice versa often depends on the issue of which is seen as the driving force.主语：Whether the Government should increase the financing of pure science at the expense of technology or vice versa由Whether….or….并列的两个从句共同充当主语谓语：depends on宾语： the issue修饰 the issue的定语of which is seen as the driving forcevice versa超纲词，难点，不知道何成分，不能使用之前的找对应成分。考使用or的选择关系，推测另一半的意思政府是否应该以牺牲技术为代价增加对纯科学的资助，反之亦然，通常取决于谁被视为推动力的问题。分析长难句就是以最快的速度找到一句话的主谓宾定状补同成分圈起来，然后用中国人的习惯分部分翻译出来使它通顺练习：How well the predictions will be validated by later performance depends upon the amount reliability, and appropriateness of the information used and on the skill and wisdom with which it is interpreted.主语：How well the predictions will be validated by later performance谓语：depends upon宾语：the amount reliability, and appropriateness定语：of the information used并列：on the skill and wisdom with which it is interpreted.（n+n+定语）分析and前，得到省略了谓语depends以后的行为将会在多准确上证明这些预言取决于所使用的的信息的数量可靠性和适合性并且还取决于解释这个信息的技巧和智慧It is generally agreed that a person of high intelligence is one who can grasp ideas readily，make distinctions, reason logically, and make use of verbal and mathematical symbols in solving problems.主语:that a person of high intelligence is one who can grasp ideas readily，make distinctions, reason logically, and make use of verbal and mathematical symbols in solving problems.谓语：is agreedis是助动词，帮助agreed构成句子主谓结构。人们普遍认为，一个高智商的人应该能够容易地掌握思想，做出区分，逻辑推理并利用语言和数学符号来解决问题。For example, it has long been known that total sleep deprivation is 100 percent fatal to rats，yet, upon examination of the dead bodies, the animals look completely normal.主语：that total sleep deprivation is 100 percent fatal to rats，yet, upon examination of the dead bodies, the animals look completely normal.谓语：has long been known例如，很早以前就知道剥夺全部睡眠对大鼠是100％致命的，但是，检查尸体后，这些动物看起来完全正常。Furthermore, it is obvious that the strength of a country’s economy is directly bound up with the efficiency of its agriculture and industry, and that this in turn rests upon the efforts of scientists and technologists of all kinds.主语： that the strength of a country’s economy is directly bound up with the efficiency of its agriculture and industry, and that this in turn rests upon the efforts of scientists and technologists of all kinds.主：that the strength of a country’s economy谓：is directly bound up宾语：with the efficiency of its agriculture and industry, and that this in turn rests upon the efforts of scientists and technologists定语：of its agriculture并列：that this in turn rests upon the efforts of scientists and technologists系：is表：obviousbind-bound 绑in turn = conversely 相反的rests upon 依靠此外，很明显，一个国家的经济实力与农业和工业的效率直接相关，而这又取决于各种科学家和技术人员的努力。(2)如何识别宾语从句只要实意动词(动宾形式)或动词短语后面（介宾形式）有引导词就暂定为宾语从句,偶尔若是主谓宾宾，那就是是第二个宾语是宾语从句练习：She said（that）she would marry an old rich man.这个句子告诉我们，宾语从句中的that可以省略，并且所有的名词性从句中，that只能在宾语从句中省略。但是在正式文体中不能省掉，而考研中就是正式文体。自己写不要省略！！I wonder if I can pass the National Postgraduate Entrance Examination smoothly.这个句子告诉我们，宾语从句中“是否”可以写成if，但是if只能引导宾语从句，而 whether可以引导所有的名词性从句，建议作文中永远写成 whether，遗忘if吧。This alone demonstrates that the television business is not an easy world to survive in. A fact underlined by statistics shows that out of eighty European television networks no less than 50% took a loss in 1989.take a lose 亏本underlined v.强调 n.下划线out of 在这里翻译成在…只中！根据语境翻译仅此一项就表明电视业务不是一个容易生存的世界。统计数据强调的事实表明，在1989年，欧洲80个电视网络中，不少于50％亏损。He believes that this very difficulty may have had the compensating advantage of forcing him to think long and intently about every sentence, and thus enabling him to detect errors in reasoning and in his own observations.主语：He谓语：believe宾语：that this very difficulty may have had the compensating advantage of forcing him to think long and intently about every sentence, and thus enabling him to detect errors in reasoning and in his own observations.主：this very difficulty谓： have had宾语：advantage定语：of forcing him to think long and intently about every sentence并列定语：and thus enabling him to detect errors in reasoning and in his own observations.compensate 补偿–》compensating 补偿性的（一个句子中不能有两个谓语，这里作为不是动词，作为补偿性的）intently 专心地、force to 强迫、enable 使能、detect 检测、observation 观察 reason v.推理n.原因in doing sth. 翻译成在…的过程中。他认为，这种困难可能具一种可以迫使他长时间认真地思考每个句子，从而使他能够发现推理和自己的观察中的错误的补偿优势。You have all heard it repeated that men of science work by means of induction（归纳法）and deduction（演绎法 ） that by the help of these operations, they, in a sort of sense, manage to extract from Nature certain natural laws, and that out of these, by some special skill of their own, they build up their theories.主：You谓：have heard宾：it宾补：repeated三个并列宾语从句，指的是it，他们是形式宾语，很少见，有难度extract 提取、certain 某些in a sort of 在某种程度上你们都已经重复听到过这些事情了吧，科学家通过归纳法和演绎法工作，通过这些操作，他们在某种意义上设法从自然界中提取某些自然定律，并从这些自然定律中，通过他们自己的特殊技能，他们建立了自己的理论。(3)如何识别表语从句只要系动词后面有引导词就是表语从句练习：A report consistently brought back by visitors to the Us is how friendly, courteous and helpful most Americans were to them.courteous 有礼貌的参观者不断带回的一份报告显示，大多数美国人对他们有多么友好，礼貌和乐于助人。Galileo’s greatest glory was that in 1609 he was the first person to turn the newly invented telescope on the heavens to prove that the planets revolve around the sun rather than around the earth.invented 发明的prove 证明revolve 围绕伽利略最大的成就在于，他在1609年率先将新发明的望远镜转向天空，以证明行星绕着太阳而不是绕地球旋转。Women are much too preoccupied by family.Once the marriage begins to disintegrate they are lost. That is where their unhappiness spring from and that is why most divorced mothers regard themselves as victims.preoccupied 全神贯注disintegrate 瓦解victims 受害人spring from sth 起源于，来自于妇女过于全神贯注于家庭，一旦婚姻开始瓦解，她们就会迷失方向。 这就是他们不快乐的根源，这就是为什么大多数离婚的母亲都把自己当作受害者。(4)如何识别同位语从句只要名词后面有引导词就暂定为同位语从句（更可能是定语从句）练习：Being interested in the relationship of language and thought, Whorf developed the idea that the structure of language determines the structure of habitual thought in a society.habitual 习惯性的对语言和思想的关系很感兴趣，Whorf提出了一种思想，即语言的结构决定了社会中习惯性思维的结构。A century ago, Freud formulated his revolutionary theory that dreams were the disguised shadows of our unconscious desires and fears.formulate 制定unconscious 无意识一个世纪以前，弗洛伊德提出了他的革命性理论，即梦想是我们潜意识里的欲望和恐惧的隐蔽阴影。But the idea that the journalist must understand the law more profoundly than an ordinary citizen rests on an understanding of the established conventions and special responsibilities of the news media.profoundly 深刻地ordinary 普通的convention 惯例主语：the idea谓语：rests onreporter：现场报道的那些记者。interviewer：采访的记者，面试官。journalist 写期刊的记者。rest on=depend on 取决于、基于宾语：an understanding of the established conventions and special responsibilities of the news media.但是，新闻工作者必须比普通公民更深刻地理解法律的思想是基于对新闻媒体既定惯例和特殊责任的理解。Evidence came up that specific speech sounds are recognized by babies as young as 6 months old.specific 具体的、特定的evidence 证据come up 上来 出现注意！“证据出现了”不缺宾语，是主谓结构。这里是一个位置放到后面的同位语从句。6个月大的婴儿能够识别特定的声音这种证据已经出现了。Concerns were raised that witnesses might be encouraged to exaggerate their stories in court to ensure guilty verdicts.witnesses 证人exaggerate 夸大verdicts 判决这句和上一句一样也是不缺宾语。为了保证有罪的判决，证人可能在法庭上夸大他们的故事这种担心已经出现了。]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语语法+词法【一】]]></title>
    <url>%2Fposts%2F7b9a7785%2F</url>
    <content type="text"><![CDATA[一、简单句英语的句子必须具备主谓结构，并且主语一定是谓语动作的发出者，如果有宾语的话，宾语一定是谓语动作的承受者句子的基本结构：1、主谓结构He died （不及物动词！）2、主谓宾结构​ 谓语：实义动词，具有实际意义的动词，讲、说、踢等等3、主谓(系)表结构​ 谓语：系动词，be动词感官动词：look（seem、appear）、smell、taste、sound、feellook看起来，写作时=seem=appearsmell，名词气味，taste，名词喜爱爱好have taste for sth 喜爱sthsound，名词声音，形容词甜美的your sounds sound sound变化：become（重要）、get（重要）、turn（一般颜色变化）、grow（grow up，长大、变大）、fall（一般变坏）保持：keep（重要）、stay、exist、remain（重要）、stand、prove4、主谓宾宾5、主谓宾宾补I brought him a dogyou should keep the room clean and tidy如何判断宾宾和宾宾补，只需要在最后两个宾语中间加一个be动词如果读起来意思是对的那就是宾宾补。原理：宾宾两个宾语是无关系的，宾宾补 ，两者之间具有补充说明的意思所以，下面句子是宾宾补we made him our monitor二、重点：句子的成分句子的成分：词性的问题，例如什么词不能做什么语英语词性很重要，汉语是表意语言，英语是逻辑性很强的语言，很注重结构，可以说英语就是和词性挂钩的。1、谓语(1)谓语的成分有时态的实义动词或者系动词充当谓语，必须具有时态，一个句子写出来就带有时态。(2)一句话中动词能不能多？非（谓语动词）和非谓语（动词）由于书面上不好说明，所以我们称呼非（谓语动词）为不是动词一句话中只能有一个动词存在，并且充当谓语，多余的动词全部都要变成不是动词谓语只能是动词，动词只能做谓语，所以我们需要把一句话当中所有不作谓语的动词全变成不是动词（相对于修饰的成分来说+ing表主动、+ed表被动、+to do表示目的）(3)练习练习：大熊猫是熊科中最罕见的成员，主要生活在中国西南部的森林里Pandas are the rarest members in bear family，mainly living in the forest of Chinese southwest.要点：1、只能有一个谓语，选重要的，分不清时谁都行2、可数名词不能单独使用，要么+a或者+the 要么变成复数3、先写罕见成员在写熊科，先写森林在写中国西南部后面会讲练习：长江流经不同的生态体系，是诸多濒危物种的栖息地，灌溉了中国五分之一的土地。YangZi River flowing through diverse ecological systems ，keeps the home of a sea of endangered species，irrigating 1/5 land.要点：1、英语中所有的系动词都可以替换be动词练习：我爱你,你爱我I loving you，you love me .要点：1、两句话怎么写成一句话？ 答：逗号，五句话也能写成一句，但是还是要符合一句话的规则，只能有一个动词，其他动词变成不是动词2、该句式，写作满分句式，但是不是这么简单弱智的句子。在英语中叫做独立主格，是非（谓语动词）中的一种形式练习（写成独立主格）：冬天来了，春天就不远了Winter approaching，spring will be around the corner.练习：我是一个老师，我很喜欢唱歌Being a teacher ，I have passion for singing songs.为什么是省略第一句的I而不是第二句？答：因为变换完毕后，第二句是一个完整句子需要有主语，而第一句being不是动词了，不是一个完整句子了，所以能省略I。独立主格的主语和后面句子的主语是不一样的。这个是分词作状语，后面会讲。但是本质上是一回事，只不过独立主格的主语不一致不能省略，而分词作状语可以省略，仅此而已(4)一句话动词能不能少？绝对不能，当一句话需要动词而又没有动词的时候永远都加be 动词，并且be动词没有意思Your mother must very beautiful.需要变为Your mother must be very beautiful.情态动词不能做谓语，所以需要添加动词。然而翻译的时候加“是”很奇怪，所以实际上，就是为了满足句子条件的添加，不做任何成分I against you需要变成I am against youagainst虽然是个动词的意思，但是却是介词！同理，am加上去后没有意思平时的一些 be angry with 为什么加be？就是因为一句话不能缺少动词。为什么agree with 没有be？就是因为agree是动词，不缺了。实际上没有什么“固定搭配”这种话，很多短语都带be但是这个be却没有意思又有一些不带be，就是这个原因。2、主语(1)主语的成分名词、代词、非（谓语动词）、从句（引导词+句子）Handsome and strong are his nature.显然是错的，主语不再上述四种之一。修改：名词做主语：handsomeness and strength are his nature代词只能替代名词出现，所以不行非（谓语动词）做主语：Being handsome and strong is his nature当一句话需要动词而又没有动词的时候永远都加be 动词，不管是谓语，主语、宾语都是的。非谓语动词做主语，谓语动词使用单数(2)一句话当中主语能不能少？一句话的主语绝对不能少。（祈使句是在当时为了表示语气而省略主语）一句话没有主语的时候怎么办？1、加it作为主语：必须与天气、温度、时间有关系。北京很冷，不是Beiing is cold，北京不能冷。是北京的天气冷。 It is cold in beijing.机舱里狠闷：It feels exceedingly hot in the cabin.（这里依旧是一个系动词替换be动词，feels比is要好）2、there be 句型，没有主语但是听到“有”的时候使用有很多的人喜欢我：There （be/exist/seem/remain）exist a host people being fascinating with me.（单词越准确写作得分越高，所以这里以后一般不用be而是exist，但是不论换那个都翻译成是“有”，一句话不能有两个动词，be换成being）3、被动：当听到一句话没有主语或者是听到人称代词作主语的时候都可以考虑写成被动必须指出坚持很重要：Persistence must be pointed out outstandingly crucial.越来越多的人认为过度捕捞很严重：Overfishing is claimed more then fearful by an increasing amount of professorsmore then+形容词或者副词翻译成很XX、非常XX。写被动很好，但是有三种情况无被动：动词后面有介词时，无被动（即不及物动词，但是不好记，记住有介词无被动更简单）系动词无被动have翻译成有的意思讲也没有被动4、人称代词做主语不到万不得已，不要用人称代词做主语练习：如果有梦想，就应该会成功。If there exists a dream ，glories are supposed to be achieved.3、宾语(1)宾语的成分名词、代词、非(谓语动词)、从句（引导词+句子）主语和宾语可以通过被动换位置，所以他们的成分是相同的宾语可以无。完整主谓结构练习：问：你喜欢去哪儿旅游?答：我喜欢重庆非(谓语动词)： like being/to be in Chongqing名词： like Chongqing4、表语(1)表语的成分名词、代词、非(谓语动词)、从句（引导词+句子）、形容词、介词短语作表语练习：I smile on the stage是什么类型的简单句?答：主谓。I exchange with my watch为什么是错误语句?答：exchange是实义动词，实义动词分为及物动词和不及物动词，exchange是及物动词，必须有宾语，它没有5、简单句的考点分析(1)写作1.所有写不来的长难句，暂时都写成简单句，一定要保证语法正确写：越来越多的大学生自杀，这个事实表明我们应该关注这个话题了。同位语从句+宾语从句表示：The evidence that an increasing number of undergraduates commit suicide indicate that the problem should be cared about简单句表示：More and more university students commit suicide . We should pay attention to this problem.写：站在讲台上的那个女人看起来很好看定语从句：The lady who is on the stage is very beautiful.简单句：There is a lady on the stage. She looks very beautiful.2.所有写不来的单词都可以写成自己会的词汇，反正老师也不知道我想表达什么意思…………^^(2)长难句分析分析长难句的第一步就是找这句话中的动词也就是谓语，从而找到一句话的主谓宾。如果一句话当中找到多个动词的，就确定主句的谓语动词(前面没有引导词的动词)二、并列句1、什么是并列句就是用连词连接两个句子2、常见的连词平行关系：and，not only…[but also…/but…/but…as well]常见平行副词和短语：similarly、equally、likewise、at the same time、in the meanwhile转折关系：but，yet，while，whereas常见转折关系副词和短语：however、nevertheless、conversely、unexpectedly、unfortunately、on the contrary、by contrast选择关系：or，whether…or…（是…还是…？）either..or..或者..或者..，neither…nor..两者都不，both and两者都。后面仨考研不咋考常见选择关系副词和短语：alternatively因果关系：for，so，because可以当原因的连词，但是它还能当状语从句引导词（because引导的句子可放在句子任意位置，for只能在两个句子中间。在原因状语从句中还会讲到）常见因果关系副词和短语：therefore、thus、consequently、as a result递进：then常见递进关系副词和短语：besides、furthermore、moreover、additionally、subsequently、in addition3、考点(1)写作只要写作的上下句之间有逻辑关系，就一定要用逻辑关系词（连词、副词、介词和介词短语）英语是一个具有清晰逻辑关系的语言，两句在中文中有逻辑的话翻译成英语之间若没有逻辑关系词语，那么在那些英语母语的人来说就没有逻辑关系，看不懂练习：爱情早已不在了，他还停留在过去。分析：转折关系。Romance has gone，but he still misses the past.连词和其他逻辑关系词的区别在于：连词的前面有无逗号均可，而其它的逻辑关系词前面要么用句号，要么加连词and。注意使用连词，一定是一句话！其他逻辑关系次可以是多句话然后阐述逻辑关系.练习：有朋自远方来，不亦乐乎There remain an army of companies coming form afar，and confidently，I feel more than delighted.你还记得那天吗？我没有通过四级考试，一个人在雨中哭泣，你走过来拍拍肩膀告诉我：”人生没有终点”并列句写法：Do you still keep that day in mind？I failed to pass CET-4 and as a result ，I shed tears in the rain alone .At the same time，you came up to me and subsequently you beat my shoulder and told me “There exists no destination in life”.(2)完形填空最少2个最多8个，几乎每年3~4个逻辑关系填空只需要读懂逻辑关系词前后两句话的意思然后判断关系就OK了.完形填空的单词一定是简单的，长难句也是简单的.别说读不懂！我喜欢森林，___它很美丽（因果）我喜欢森林，___我喜欢海洋（平行）我喜欢森林,___它太远了（转折）(3)长难句分析在分析长难句的时候，只要见到并列连词的出现，通常都会有省略主语相同省主语，主谓相同省主谓，主谓宾相同省主谓宾。总之，两个句子并列，什么相同就能够省什么。（并列句特权，其他省略不是）多个句子并列，中间的连接词可以改变，只要意思符合即可。若是同种并列关系，前面逗号最后一个词来并列即可。分析长难句的第二步就是找连词，但是当连词在连接两个单词的时候，这个连词就装作没看见。（He is cool and handsome）那如何查找省略的内容呢？一句话只要有省略就一定会省略在连词后而不是连词前。所以连词后有的成分连词前面通常都要有，如果连词后只有一个成分的话连词前面一定能找到它的对应成分，如果连词后有多个成分的话连词前不一定能找到他们的全部成分但是至少能找到一个；连词前面有而连词后面没有的成分便是省略的内容①Under modern condition s, this requires varying measures of centralized control and hence the help of specialized scientists such as economists and operational research experts.Under modern conditions是状语，暂时忽略之后讲。找谓语：只有一个动词requires，所以他就是谓语。得到主谓宾结构找并列词：两个and，第二个and连接的是两个单词忽略。找连接词前后对应成分：the help of specialized scientists对应measures of centralized control，省略只能在连词后面，而后面没有前面有的就是this requires主谓结构。省略的就是这个主谓结构目前，这需要各种中央控制的各种措施，所以这也需要专家的帮助，比如说经济学家和操作研究专家。②The data suggest, for example, that physically attractive individuals are more likely to be treated well by their parents, sought out as friends, and pursued romantically.多个句子并列，只在最后两个句子加并列词！状语的知识之后再讲，这里提一下：实意动词后面的一堆东西都是状语从句也之后再讲。v+ed可能是被动，可能是过去式，可能是不是动词，没有语境是不能判断的副词只能做状语首先找到主句的谓语，suggest。 are是从句的谓语前面有引导词不是主句的。而其它的都是“不是动词”。其次找到并列词，and，由于是多个句子，所以实际上是多个句子并列。分析结构：pursued romantically是v(ed)+状语;sought out as friends是v(ed)+状语（判断as friends是状语前面提示了一下，这里知道就行之后再细讲）；treated well by their parents也是v(ed)+状语，后面有而前面没有的就是（physically attractive individuals） are more likely to be。省略（主）谓（系）③There is no agreement whether methodology refers to the concepts peculiar to historical work in general or to the research technique appropriate to the various branches of historical inquiry.peculiar=weird=odd都是奇怪的意思，peculiar to 是….专属的，….特有的in general，一般的、inquiry打听、询问，technique技术定语现在知道就行以后再讲找到主语谓语：is，refer前面有引导词whether，不是主语谓语；得到there be 结构，找到并列词whether…..or…… 分析or的前后得到省略部分to the concepts peculiar to historical work in general 对应to the research technique appropriate to the various branches of historical inquiry.*所以省略的就是 （methodology）refers *the concepts peculiar对应the research；to historical work in general对应appropriate to the various branches of historical inquiry.翻译：方法论指的是一般的历史研究中所特有的概念，还是指的是适合各个历史研究分支的方法人们没有达成一致意见。④Until these issues are resolved, a technology of behavior will continue to be rejected, and with it possibly the only way to solve our problems.找主语谓语：will continue，are前面有引导词until。找并列词：andreject拒绝，resolve解决代词指代题的做题方法：就近原则（离得近的名词或者时间更可能，注意单复数对应）和一致原则（带入后意思要一致）这里it就代表a technology of behaviorand后：介词短语（with it）+状语+n+定语and前：n+定语+will continue to be rejected多了will continue to be rejected，根据相应位置在and后相应位置添上行为技术将继续遭受拒绝并且和行为技术一起，很可能的是，解决我们问题的唯一方法也将被拒绝，知道我们的问题被解决。⑤ Darwin was convinced that the loss of these tastes for pictures or music was not only a lossof happiness, but might possibly be injurious to the intellect, and more probably to the moral character.同理找到主语谓语 was，其他都是在引导词后的从句谓语tastes，味道、爱好，尝起来；intellect智商；injurious有害的；moral character道德品质be convinced that=thinkmight possibly对应more probably；to the intellect对应to the moral character，少be injurious，在相应位置添上，而在往前看，这两句对应缺失的就是loss of these tastes for pictures or music达尔文认为缺失了对于画画和音乐的兴趣不单只是失去了快乐，而且更可能对它的道德品质也造成了伤害⑥As families move away from their stable community, their friends of many years, and their extended family relationships, the informal flow of information is cut off, and with it the confidence that information will be available when needed and will be trustworthy and reliable.主语谓语：is cut off第一个and，并列两个名词，不算。第四个and：并列两个形容词，不算第二个and：介短+n+同位语从句（可当做定语从句，以后再讲）前面：n+定语从句+谓语。所以省略了is cut off第三个and：由will be 很容易可以得到。省略的就是informationAs的意思有很多，需要根据语义翻译that information will be available when needed and will be trustworthy and reliable.是个同位语从句，同位语从句和定语从句翻译出来一致，之后会讲。随着家人搬离稳定的社区，他们多年的朋友和他们的大家庭关系，和非正式的信息流一起被切断了，当需要的时候我们就会得到这些可靠的信息的自信也随之消失了.]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统概论【三】]]></title>
    <url>%2Fposts%2F128cc561%2F</url>
    <content type="text"><![CDATA[导图一、SQL语言概述1、SQL语言的功能概述DDL（Data Definition Languages）语句：数据定义语言，这些语句定义了不同的数据段、数据库、表、列、索引等数据库对象的定义。常用的语句关键字主要包括 create、drop、alter等。DML（Data Manipulation Language）语句：数据操纵语句，用于添加、删除、更新和查询数据库记录，并检查数据完整性，常用的语句关键字主要包括 insert、delete、udpate 和select 等。(增添改查）DCL（Data Control Language）语句：数据控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括 grant、revoke 等。SQL由分为：交互式SQL、嵌入式SQL、动态SQL等。之后学习举例使用的数据库：学生：学号S#, 姓名Sname, 性别Ssex, 年龄Sage, 所属系别D#，班级SclassStudent ( S# char(8), Sname char(10), Ssex char(2),Sage integer, D# char(2), Sclass char(6) )院系：系别D#，系名Dname, 系主任DeanDept ( D# char(2), Dname char(10), Dean char(10) )课程：课号C#, 课名Cname, 教师编号T#, 学时Chours，学分CreditCourse ( C# char(3), Cname char(12), Chours integer,Credit float(1), T# char(3) )教师：教师编号T#，教师名Tname, 所属院系D#，工资SalaryTeacher ( T# char(3), Tname char(10), D# char(2),Salary float(2) )选课：学号S#, 课号C#, 成绩ScoreSC ( S# char(8), C# char(3), Score float(1) )2、利用SQL语言建立数据库建立数据库包括两件事：定义数据库和表（使用DDL）,向表中追加元组（使用DML）(1)SQL-DDLDDL具有很多功能，这里我们学习简单的创建数据库，后面功能再陆续介绍(2)创建数据库的语句—Create Database数据库(Database)是若干具有相互关联关系的Table/Relation的集合, 数据库可以看作是一个集中存放若干Table的大型文件示例：创建课程学习数据库SCT1create database SCT;Create Database的其他特性例如定义完整性约束等，之后介绍(3)创建关系/表的语句—Create Table示例：定义学生表 Student1Create Table Student ( S# char(8) not null , Sname char(10),Ssex char(2), Sage integer, D# char(2), Sclass char(6) );示例：定义课程表Course1Create Table Course ( C# char(3) , Cname char(12), Chours integer,Credit float(1), T# char(3) );“ [ ] ”表示其括起的内容可以省略，“ | ” 表示其隔开的两项可取其一Primary key: 主键约束。每个表只能创建一个主键约束。Unique: 唯一性约束(即候选键)。可以有多个唯一性约束。Not null: 非空约束。是指该列允许不允许有空值出现，如选择了Not null表明该列不允许有空值出现。在SQL-92标准中定义的数据类型：char (n) :固定长度的字符串varchar (n) :可变长字符串int :整数 // 有时不同系统也写作integernumeric (p，q) :固定精度数字，小数点左边p位，右边p-q位real :浮点精度数字 //有时不同系统也写作float(n)，小数点后保留n位date :日期 (如 2003-09-12)time : 时间 (如 23:15:003)…..现行商用DBMS的数据类型有时和上面有些差异，请注意;和高级语言的数据类型，总体上是一致的，但也有些差异。(4)SQL-DML(5)向表中追加元组的值 –Insert Into示例：追加学生表中的元组123Insert Into Student Values ( ‘98030101’ , ‘张三’, ‘男’, 20， ’03’， ‘980301’);Insert Into Student ( S#, Sname, Ssex, Sage, D# , Sclass)Values ( ‘98030102’ , ‘张四’, ‘女’, 20， ’03’， ‘980301’);示例：追加课程表中的元组12Insert Into Course Values ( ‘001’ , ‘数据库’, 40, 6， ’001’); /*所有列名省略，须与定义或存储的列名顺序一致*/Insert Into Course(Cname, C#, Credit, Chours, T#) Values (‘数据库’, ‘001’, 6, 40, ‘001’); /*如列名未省略，须与语句中列名的顺序一致*/values后面值的排列，须与into子句后面的列名排列一致若表名后的所有列名省略， 则values后的值的排列，须与该表存储中的列名排列一致3、利用SQL语言进行简单查询(1)单表查询-Select-From-Where示例：检索教师表中所有工资少于1500元或者工资大于2000元 并且是03系的教师姓名？123Select TnameFrom TeacherWhere (Salary &lt; 1500 or Salary &gt; 2000) and D# = ’03’;语义：从表名所给出的表中，查询出满足检索条件的元组，并按给定的列名及顺序进行投影显示。相当于对表进行了选择和投影操作。Select语句中的select … , from… , where…, 等被称为子句，在以上基本形式基础上会增加许多构成要素，也会增加许多新的子句，满足不同的需求。如投影所有列，则可以用*来简写逻辑运算符用 and , or,not 来表示, 同时也要注意运算符的优先次序及括弧的使用。书写要点是注意对自然语言检索条件的正确理解。(2)检索结果之去重复记录-Select Distinct-From-Where关系模型不允许出现重复元组。但现实DBMS，却允许出现重复元组，但也允许无重复元组。在Table中要求无重复元组是通过定义Primary key或Unique来保证的;而在检索结果中要求无重复元组, 是通过DISTINCT保留字的使用来实现的。示例：在选课表中，检索成绩大于80分的所有学号1234Select DISTINCT S#From SCWhere Score &gt; 80;//重复元组被DISTINCT过滤掉，只保留一份(3)检索结果之排序-Select-From-Where-Order ByDBMS可以对检索结果进行排序，可以升序排列，也可以降序排列。ascend升序|descend降序，默认为升序示例：按学号由小到大的顺序显示出所有学生的学号及姓名12Select S#, Sname From StudentOrder By S# ASC ;示例：检索002号课大于80分的所有同学学号并按成绩由高到低顺序显示12Select S# From SC Where C# = ‘002’ and Score &gt; 80Order By Score DESC ;​(4)模糊查询-SELECT-FROM-WHERE * LIKE *模糊查询问题:比如检索姓张的学生，检索张某某；这类查询问题，Select语句是通过在检索条件中引入运算符like来表示的找出匹配给定字符串的字符串。其中给定字符串中可以出现%, _等匹配符.匹配规则：“%” 匹配零个或多个字符“_” 匹配任意单个字符“ \ ” 转义字符，用于去掉一些特殊字符的特定含义，使其被作为普通字符看待, 如用 “%”去匹配字符%，用\_ 去匹配字符_示例：检索所有姓张的学生学号及姓名12Select S#, Sname From StudentWhere Sname Like ‘张%’ ;示例：检索名字为张某某的所有同学姓名12Select Sname From StudentWhere Sname Like ‘张_ _’;示例：检索名字不姓张的所有同学姓名12Select Sname From StudentWhere Sname Not Like ‘张%’;4、利用SQL语言进行多表联合查询多表联合检索可以通过连接运算来完成，而连接运算又可以通过广义笛卡尔积后再进行选择运算来实现。检索条件中要包含连接条件，通过不同的连接条件可以实现等值连接、不等值连接及各种连接注意:检索条件的设定决定了何种连接(1)表更名与表别名(重名处理)连接运算涉及到重名的问题，如两个表中的属性重名，连接的两个表重名(同一表的连接)等，因此需要使用别名以便区分上述定义中的as 可以省略当定义了别名后，在检索条件中可以使用别名来限定属性有时表名很长时，为书写条件简便，也定义表别名，以简化书写(2)等值连接示例：按“001”号课成绩由高到低顺序显示所有学生的姓名(二表连接)123Select Sname From Student, SCWhere Student.S# = SC.S# and SC.C# = ‘001’Order By Score DESC;示例：按‘数据库’课成绩由高到低顺序显示所有同学姓名(三表连接)123Select Sname From Student, SC, CourseWhere Student.S# = SC.S# and SC.C# = Course.C# and Cname = ‘数据库’Order By Score DESC;等值连接，检索条件就是=(2)不等值连接示例：求有薪水差额的任意两位教师123Select T1.Tname as Teacher1, T2.Tname as Teacher2From Teacher T1, Teacher T2Where T1.Salary &gt; T2.Salary ;示例：求年龄有差异的任意两位同学的姓名123Select S1.Sname as Stud1, S2.Sname as Stud2From Student S1, Student S2Where S1.Sage &gt; S2.Sage ;(3)多表联合查询训练示例：求既学过“001”号课又学过 “002”号课的所有学生的学号123Select S1.S# From SC S1, SC S2Where S1.S# = S2.S# and S1.C#=‘001’ and S2.C#=‘002 ;求“001”号课成绩比“002”号课成绩高的所有学生的学号123Select S1.S# From SC S1, SC S2Where S1.S# = S2.S# and S1.C#=‘001’ and S2.C#=‘002’ and S1.Score &gt; S2.Score;注意正确理解用自然语言表达的查询语义，并用SQL正确表达,有时候自然语言的直译是错误的！该写法是错误的，一个人选择的李明的课又选择了其他老师的课也会被选进去5、利用SQL语言进行增-删-改(1)SQL-之Insert之前我们学到insert的简单用法，用来插入一条指定元组值的元组，接下来我们学习批量插入。插入子查询结果中的若干条元组。待插入的元组由子查询给出。新建立Table: St(S#, Sname), 将检索到的满足条件的同学新增到该表中123Insert Into St (S#, Sname)Select S#, Sname From StudentWhere Sname like ‘%伟 ’ ;示例：新建Table: SCt(S#, C#, Score), 将检索到的成绩及格同学的记录新增到该表中123Insert Into SCt (S#, C#, Score)Select S#, C#, Score From SCWhere Score&gt;=60 ;示例：追加成绩优秀同学的记录123Insert Into SCt (S#, C#, Score)Select S#, C#, Score From SCWhere Score&gt;=90 ;注意：当新增元组时，DBMS会检查用户定义的完整性约束条件等，如不符合完整性约束条件，则将不会执行新增动作（将在后面介绍）。还可以有更复杂的“查询后插入到新表中”的语句，例如可以将中间结果存储成表—这很有用！示例：新建Table: St(S#, Sname, avgScore), 将检索到的同学的平均成绩新增到该表中1234Insert Into St (S#, Sname, avgScore)Select S#, Sname, Avg(Score) From Student, SCWhere Student.S# = SC.S#Group by Student.S# ;此SELECT语句的书写语法后面再解释。(2)SQL-之Delete注意：当删除元组时，DBMS会检查用户定义的完整性约束条件等，如不符合完整性约束条件，则将不会执行删除动作如果Where条件省略，则删除所有的元组。示例：删除SC表中所有元组1Delete From SC ;示例：删除98030101号同学所选的所有课程1Delete From SC Where S# = ‘98030101’ ;示例：删除自动控制系的所有同学(此是一简单的嵌套子查询，后面会有更详细解释。)12Delete From Student Where D# in( Select D# From Dept Where Dname = ‘自动控制’);示例：删除有四门不及格课程的所有同学(此SELECT语句的书写语法后面再解释)123Delete From Student Where S# in( Select S# From SC Where Score &lt; 60Group by S# Having Count(*)&gt;= 4 );(3)SQL-之Update如果Where条件省略，则更新所有的元组示例：将所有教师工资上调5%12Update TeacherSet Salary = Salary * 1.05 ;示例：将所有计算机系的教师工资上调10%1234Update TeacherSet Salary = Salary * 1.1Where D# in( Select D# From Dept Where Dname = ‘计算机’)示例：当某同学001号课的成绩低于该课程平均成绩时，将该同学该门课成绩提高5%(此SELECT语句的书写语法后面再解释。)12345Update SCSet Score = Score * 1.05Where C# = ‘001’ and Score &lt; some( Select AVG(Score) From SCWhere C# = ‘001’ ) ;示例：将张三同学001号课的成绩置为其班级该门课的平均成绩(此SELECT语句的书写语法后面再解释。)12345678Update SCSet Score = ( Select AVG(SC2.Score)From SC SC1, Student S1, SC SC2, Student S2Where S1.Sclass = S2.Sclass and SC1.S# = S1.S#and SC2.S# = S2.S# and S1.Sname=‘张三’and SC1.C# = ‘001’ and SC1.C# = SC2.C# )Where C# = ‘001’ and S# in ( Select S# From StudentWhere Sname = ‘张三’ ) ;6、利用SQL语言修改与撤销数据库(1)修改数据库alter：改变drop：删除modify：修改add：添加示例：在学生表Student(S#,Sname,Ssex,Sage,D#,Sclass)基础上增加二列Saddr, PID1Alter Table Student Add Saddr char[40], PID char[18] ;示例：将上例表中Sname列的数据类型增加两个字符1Alter Table Student Modify Sname char(10) ;示例：删除学生姓名必须取唯一值的约束1Alter Table Student Drop Unique( Sname );(2)撤销示例：撤消学生表Student1Drop Table Student;示例：撤消教师表Teacher1Drop Table Teacher;示例：撤消SCT数据库1Drop database SCT;注意，SQL-delete语句只是删除表中的元组,而撤消基本表droptable的操作是撤消包含表格式、表中所有元组、由该表导出的视图等相关的所有内容，所以使用要特别注意。(3)数据库指定与关闭命令有些DBMS提供了操作多个数据库的能力，此时在进行数据库操作时需要指定待操作数据库与关闭数据库的功能。指定当前数据库1use 数据库名;关闭当前数据库1close 数据库名;二、SQL语言之复杂查询与视图1、子查询为什么需要子查询？答:现实中，很多情况需要进行下述条件的判断集合成员资格某一元素是否是某一个集合的成员集合之间的比较某一个集合是否包含另一个集合等集合基数的测试测试集合是否为空测试集合是否存在重复元组子查询：出现在Where子句中的Select语句被称为子查询(subquery) , 子查询返回了一个集合，可以通过与这个集合的比较来确定另一个查询集合。种类：IN、NOT IN子查询、SOME、OR子查询、Exists子查询(1)IN、NOT IN子查询示例：列出张三、王三同学的所有信息12Select * From StudentWhere Sname in (“张三”, “王三”);它相当于：12Select * From StudentWhere Sname = “张三” or Sname = “王三”;示例：列出选修了001号课程的学生的学号和姓名(该方法，是不连接表的方法)12Select S#, Sname From StudentWhere S# in ( Select S# From SC Where C# = ‘001’ ) ;示例：求既学过001号课程, 又学过002号课程的学生的学号(该方法，是不连接表的方法)123Select S# From SCWhere C# = ‘001’ andS# in ( Select S# From SC Where C# = ‘002’ ) ;示例：列出没学过李明老师讲授课程的所有同学的姓名?123Select Sname From StudentWhere S# not in ( Select S# From SC, Course C, Teacher TWhere T.Tname = ‘李明’ and SC.C# = C.C#and T.T# = C.T# );非相关子查询：内层查询独立进行，没有涉及任何外层查询相关信息的子查询相关子查询：内层查询需要依靠外层查询的某些参量作为限定条件才能进行的子查询之前的举例都是非相关子查询。外层向内层传递的参量需要使用外层的表名或表别名来限定相关子查询只能由外层向内层传递参数，而不能反之；这也称为变量的作用域原则。示例：求学过001号课程的同学的姓名12345Select SnameFrom Student StudWhere S# in ( Select S#From SCWhere S# = Stud.S# and C# = ‘001’ ) ;(2)θ-SOME、θ-OR子查询语法中， θ是比较运算符： &lt; , &gt; , &gt;= , &lt;= , = , &lt;&gt;。语义：将表达式的值与子查询的结果进行比较：如果表达式的值至少与子查询结果的某一个值相比较满足θ 关系，则“表达式 θ some (子查询)”的结果便为真；如果表达式的值与子查询结果的所有值相比较都满足θ 关系，则“表达式 θ all (子查询)”的结果便为真；在SQL标准中，也有θ-any谓词，但由于其语义的模糊性：any,“任一”是指所有呢？还是指某一个？不清楚，所以被 θ-some替代以求更明晰表达式 = some (子查询）等价于 表达式 in (子查询)*表达式 &lt;&gt; all (子查询)等价于 表达式 not in (子查询) *示例：找出工资最低的教师姓名12Select Tname From TeacherWhere Salary &lt;= all ( Select Salary From Teacher );示例：找出001号课成绩不是最高的所有学生的学号123Select S# From SCWhere C# = “001” andScore &lt; some ( Select Score From SC Where C# = “001” );示例：找出所有课程都不及格的学生姓名(相关子查询)123Select Sname From StudentWhere 60 &gt; all ( Select Score From SCWhere S# = Student.S# );示例：找出001号课成绩最高的所有学生的学号123Select S# From SCWhere C# = “001” andScore &gt;= all ( Select Score From SC Where C# = “001” );示例：找出98030101号同学成绩最低的课程号123Select C# From SCWhere S# = “98030101” andScore &lt;= all ( Select Score From SC Where S# = “98030101” );示例：找出张三同学成绩最低的课程号1234Select C# From SC, Student SWhere Sname = “张三” and S.S#=SC.S# andScore &lt;= all ( Select Score From SCWhere S#=S.S# );(3)【Not】Exists子查询（量词∃）Exists就是量词∃语义：子查询结果中有无元组存在不加not形式的Exists谓词可以不用,和直接查询等效，我们一般使用的是 not exists该语法可以理解为：将主查询的数据，放到子查询中做条件验证，根据验证结果（TRUE 或 FALSE）来决定主查询的数据结果是否得以保留。而EXISTS符合为真，NOT EXISTS是不符合为真，详细解释由于其特性,只返回True或者False来决定。所以，一般需要将外表和内表关联起来，否则只是根据内标是否返回而判断not exists很难理解，需要将肯定变成否定之否定，需要多多练习示例：检索学过001号教师主讲的所有课程的所有同学的姓名123456Select Sname From StudentWhere not exists //不存在( Select * From Course //有一门001教师主讲课程Where Course.T# = ‘001’ and not exists //该同学没学过( Select * From SCWhere S# = Student.S# and C# = Course.C# ) );过程:首先从Student表中第一元组开始代入，查询Where语句，not exists（子查询）为真时即子查询无返回结果时保留该元组，进入中间层判断，选择Course表第一个元组开始代入，进入Where语句，当Course.T# = ‘001’和not exists（子查询）都为真即Course.T# = ‘001’并且子查询无返回结果时为真，该中间层元组进入结果表，进入内层判断，取SC表第一个元组代入，进入Where语句，只有满足 S# = Student.S# and C# = Course.C#才为真具有返回结果。而内层为真，则中间层的not exists为假，并且，对SC表遍历只要有一个为真，则就有返回结果，则中间层的not exists就为假了，则本次中间层无返回结果，course继续下一个元组代入，同理进行检测后，只有所有元组检测完毕都没有返回结果才能判断外层的not exists为真，这样才能保留该元组，并且选择Sname。也就是说，三层循环嵌套，最外层只是选择层，中间和内两层循环为判断是否选择，中间层全部为假则选择该元组，而保证中间层为假，则必须保证Course.T# = ‘001’和not exists不能同时为真。示例：列出没学过李明老师讲授任何一门课程的所有同学的姓名12345Select Sname From StudentWhere not exists //不存在( Select * From Course, SC, Teacher //学过一门课程Where Tname=‘李明’ and Course.T# =Teacher.T#and Course.C# = SC.C# and S# = Student.S# );示例：列出至少学过98030101号同学学过所有课程的同学的学号123456Select DISTINC S# From SC SC1Where not exists //不存在( Select * From SC SC2 //有一门课程Where SC2.S# = ‘98030101’ and not exists //该同学没学过( Select * From SCWhere C# = SC2.C# and S# = SC1.S# ) );关系代数和元组演算的表达:(4)BETWEENBETWEEN 运算符用于 WHERE 表达式中，选取介于两个值之间的数据范围。BETWEEN 同 AND 一起搭配使用，语法如下：12WHERE column BETWEEN value1 AND value2WHERE column NOT BETWEEN value1 AND value22、结果计算与聚集计算(1)结果计算Select-From-Where语句中，Select子句后面不仅可是列名，而且可是一些计算表达式或聚集函数，表明在投影的同时直接进行一些运算expr可以是常量、列名、或由常量、列名、特殊函数及算术运算符构成的算术运算式。特殊函数的使用需结合各自DBMS的说明书agfunc()是一些聚集函数示例：求有差额(差额&gt;0)的任意两位教师的薪水差额123Select T1.Tname as TR1, T2.Tname as TR2, T1.Salary – T2.SalaryFrom Teacher T1, Teacher T2Where T1.Salary &gt; T2.Salary;示例：依据学生年龄求学生的出生年份，当前是2015年12Select S.S#, S.Sname, 2015 – S.Sage+1 as SyearFrom Student S;(2)聚集计算常用内置聚集函数：COUNT([ALL|DISTINCT] [列名])：求个数SUM([ALL|DISTINCT] [列名])：求 和AVG([ALL|DISTINCT] [列名])：求平均MAX([ALL|DISTINCT] [列名])：求最大MIN([ALL|DISTINCT] [列名])：求最小聚集函数是不允许用于Where子句中的：Where子句是对每一元组进行条件过滤，而不是对集合进行条件过滤示例：求教师的工资总额1Select Sum(Salary) From Teacher;示例：求计算机系教师的工资总额12Select Sum(Salary) From Teacher T, DeptWhere Dept.Dname = ‘计算机’ and Dept.D# = T.D#;示例：求数据库课程的平均成绩12Select AVG(Score) From Course C, SCWhere C.Cname = ‘数据库’ and C.C# = SC.C#;3、分组查询与分组过滤(1)分组查询分组：SQL可以将检索到的元组按照某一条件进行分类，具有相同条件值的元组划到一个组或一个集合中，同时处理多个组或集合的聚集运算。示例： 求每一个学生的平均成绩12Select S#, AVG(Score) From SCGroup by S#;示例：求每一门课程的平均成绩12Select C#, AVG(Score) From SCGroup by C#(2)分组过滤分组过滤：若要对集合(即分组)进行条件过滤，即满足条件的集合/分组留下，不满足条件的集合/分组剔除。Having子句，又称分组过滤子句。需要有Groupby子句支持，换句话说，没有Groupby子句，便不能有Having子句。示例：求不及格课程超过两门的同学的学号123Select S# From SCWhere Score &lt; 60Group by S# Having Count(*)&gt;2;示例：求不及格课程超过两门的同学的学号123Select C# From SCWhere Score &lt; 60Group by C# Having Count(*)&gt;10;分组查询仍需要注意语义问题示例：求有两门以上不及格课程同学的学号及其平均成绩123Select S#, Avg(Score) From SCWhere Score &lt; 60Group by S# Having Count(*)&gt;2;这样写是错误的，求出的是“该同学那几门不及格课程的平均成绩”，而不是“该同学所有课程的平均成绩”正确写法:123456Select S#, Avg(Score) From SCWhere S# in( Select S# From SCWhere Score &lt; 60Group by S# Having Count(*)&gt;2 )Group by S# ;4、实现关系代数操作SQL语言：并运算 UNION, 交运算INTERSECT, 差运算EXCEPT。通常情况下自动删除重复元组：不带ALL。若要保留重复的元组，则要带ALL.假设子查询1的一个元组出现m次，子查询2的一个元组出现n次，则该元组在：子查询1 Union ALL 子查询2 ，出现m + n次子查询1 Intersect ALL 子查询2 ，出现min(m,n)次子查询1 Except ALL 子查询2 ，出现max(0, m – n)次UNION运算符是Entry-SQL92的一部分、INTERSECT、EXCEPT运算符是Full-SQL92的一部分。它们都是Core-SQL99的一部分，但有些DBMS并不支持这些运算，使用时要注意！1、并运算 UNION示例：求学过002号课的同学或学过003号课的同学学号123Select S# From SC Where C# = ‘002’UNIONSelect S# From SC Where C# = ‘003’;它等同于1Select S# From SC Where C# = ‘002’ OR C# = ‘003’;但有时UNION不能转换掉示例：已知两个表Customers(CID, Cname, City, Discnt)、Agents(AID, Aname, City, Percent)求客户所在的或者代理商所在的城市123Select City From CustomersUNIONSelect City From Agents ;2、交运算INTERSECT示例：求既学过002号课，又学过003号课的同学学号123Select S# From SC Where C# = ‘002’INTERSECTSelect S# From SC Where C# = ‘003’;它等同于12Select S# From SC Where C# = ‘002’ and S# IN(Select S# From SC Where C# = ‘003’);交运算符Intersect并没有增强SQL的表达能力，没有Intersect， SQL也可以用其他方式表达同样的查询需求。只是有了Intersect更容易表达一些，但增加了SQL语言的不唯一性。3、差运算EXCEPT示例： 假定所有学生都有选课，求没学过002号课程的学生学号123Select DISTINCT S# From SCEXCEPTSelect S# From SC Where C# = ‘002’;它等同于123Select DISTINCT S# From SC SC1Where not exists ( Select * From SCWhere C# = ‘002’ and S# = SC1.S#);差运算符Except也没有增强SQL的表达能力，没有Except， SQL也可以用其他方式表达同样的查询需求。只是有了Except更容易表达一些，但增加了SQL语言的不唯一性。5、空值的处理在SQL标准中和许多现流行的DBMS中，空值被用一种特殊的符号Null来标记，使用特殊的空值检测函数来获得某列的值是否为空值。示例：找出年龄值为空的学生姓名12Select Sname From StudentWhere Sage is null ;注意：上例条件不能写为Where Sage = null; 空值是不能进行运算的现行DBMS的空值处理小结除is[not]null之外，空值不满足任何查找条件如果null参与算术运算，则该算术表达式的值为null如果null参与比较运算，则结果可视为false。在SQL-92中可看成unknown如果null参与聚集运算，则除count(*)之外其它聚集函数都忽略null6、内连接、外连接https://www.cnblogs.com/pcjim/articles/799302.html连接类型：inner [outer] join：即关系代数中的θ-连接运算left [outer] join：左外连接right [outer] join：右外连接full [outer] join：全外连接连接条件:natural：出现在结果关系中的两个连接关系的元组在公共属性上取值相等，且公共属性只出现一次on 连接条件：出现在结果关系中的两个连接关系的元组取值满足连接条件，且公共属性出现两次using (Col1, Col2, …, Coln)：(Col1, Col2, …, Coln)是两个连接关系的公共属性的子集，元组在(Col1, Col2, …, Coln)上取值相等，且(Col1, Col2, …, Coln)只出现一次其实就是natural的部分，natural是全部公共属性，而这个是其公共属性的子集示例: 求所有教师的任课情况并按教师号排序(没有任课的教师也需列在表中)1234Select Teacher.T#, Tname, CnameFrom Teacher Inner Join CourseON Teacher.T# = Course.T#Order by Teacher.T# ASC;示例: 求所有教师的任课情况(没有任课的教师也需列在表中)1234Select Teacher. T#, Tname, CnameFrom Teacher Left Outer Join CourseON Teacher.T# = Course.T#Order by Teacher.T# ASC ;7、视图及其应用对应概念模式的数据在SQL中被称为基本表(Table),而对应外模式的数据称为视图(View)。视图不仅包含外模式，而且包含其E-C映像。基本表是实际存储于存储文件中的表，基本表中的数据是需要存储的视图在SQL中只存储其由基本表导出视图所需要的公式，即由基本表产生视图的映像信息，其数据并不存储，而是在运行过程中动态产生与维护的对视图数据的更改最终要反映在对基本表的更改上。(1)定义视图如果视图的属性名缺省，则默认为子查询结果中的属性名；也可以显式指明其所拥有的列名。with checkoption指明当对视图进行insert，update，delete时，要检查进行insert/update/delete的元组是否满足视图定义中子查询中定义的条件表达式示例：定义一个视图 CompStud 为计算机系的学生，通过该视图可以将Student表中其他系的学生屏蔽掉12345Student表中其他系的学生屏蔽掉Create View CompStud AS( Select * From StudentWhere D# in ( Select D# From DeptWhere Dname = ‘计算机’ ) );示例：定义一个视图Teach为教师任课的情况，把Teacher表中的个人隐私方面的信息，如工资等屏蔽掉，仅反映其教哪门课及其学分等。1234Create View Teach AS( Select T.Tname, C.Cname, CreditFrom Teacher T, Course CWhere T.T# = C.T# ) ;(2)使用视图使用视图：定义好的视图，可以像Table一样，在SQL各种语句中使用示例：检索主讲数据库课程的教师姓名，我们可使用Teach12Select T.Tname From Teach TWhere T.Cname = ‘数据库’ ;视图究竟有什么作用?答：定义视图，有时可方便用户进行检索操作。示例：定义视图StudStat, 描述学生的平均成绩、最高成绩，最低成绩等1234Create View StudStat(S#, Sname, AvgS, MinS, MaxS, CNT)as ( Select S#, Sname, AVG(Score), MIN(Score), Max(Score), Count(*)From Student S, SC Where S.S# = SC.S#Group by S.S# ) ;示例：基于视图StudStat检索某一学生平均成绩1Select Sname, AvgS From StudStat Where Sname = ‘张三’ ;(3)更新视图SQL视图更新：是比较复杂的问题，因视图不保存数据，对视图的更新最终要反映到对基本表的更新上，而有时，视图定义的映射不是可逆的。SQL视图更新的可执行性如果视图的select目标列包含聚集函数，则不能更新如果视图的select子句使用了unique或distinct，则不能更新如果视图中包括了groupby子句，则不能更新如果视图中包括经算术表达式计算出来的列，则不能更新如果视图是由单个表的列构成，但并没有包括主键，则不能更新例如：123456create view ClassStud(Sname, Sclass)as ( select Sname, Sclassfrom Student );Insert into ClassStudValues ( ‘张三’, ‘980301’ );无法更新，缺失主键。(4)撤销视图示例：撤消视图Teach1Drop View Teach;]]></content>
      <categories>
        <category>数据库系统概论</category>
      </categories>
      <tags>
        <tag>数据库系统概论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机体系结构【二】]]></title>
    <url>%2Fposts%2F925c12fd%2F</url>
    <content type="text"><![CDATA[三、流水线技术1、流水线的基本概念把一个重复的过程分解为若干个子过程，每个子过程由专门的功能部件来实现。把多个处理过程在时间上错开，依次通过各功能段，这样，每个子过程就可以与其他的子过程并行进行。流水线中的每个子过程及其功能部件称为流水线的级或段，段与段相互连接形成流水线。流水线的段数称为流水线的深度。(1)时空图时空图从时间和空间两个方面描述了流水线的工作过程。时空图中，横坐标代表时间，纵坐标代表流水线的各个段。(2)流水线技术的特点流水线把一个处理过程分解为若干个子过程（段），每个子过程由一个专门的功能部件来实现。流水线中各段的时间应尽可能相等，否则将引起流水线堵塞、断流。时间长的段将成为流水线的瓶颈。流水线每一个功能部件的后面都要有一个缓冲寄存器（锁存器），称为流水寄存器。作用：在相邻的两段之间传送数据，以保证提供后面要用到的数据，并把各段的处理工作相互隔离。流水技术适合于大量重复的时序过程，只有在输入端不断地提供任务，才能充分发挥流水线的效率。流水线需要有通过时间和排空时间。通过时间：第一个任务从进入流水线到流出结果所需的时间。排空时间：最后一个任务从进入流水线到流出结果所需的时间。流水线级数不是越深越好。（1）每一级流水线都由寄存器组成，更多的流水线级数意味着消耗更多的寄存器，产生更大的面积开销，功耗也会增大。（2）每一级流水线需要握手，流水线的最后一级反压信号可能会一直串扰到最前一级造成严重的时序问题。（3）流水线的取指阶段得知条件跳转的结果是到底跳还是不跳，因此只能进行预测，而到了流水线的末端才能通过实际运算得知该分支是真的该跳还是不该跳。如果发现真实的结果与预期的结果不一致，意味着预测失败，需要将所有的预取指令全部丢失。流水线越深，则意味着浪费和损失越严重；流水线越浅，则浪费和损失越少。(3)流水线分类1、按完成的功能分类单功能流水线：只能完成一种固定功能的流水线。多功能流水线：流水线的各段可以进行不同的连接，以实现不同的功能。多功能流水线可按照同一时间内各段之间的连接方式对多功能流水线做进一步的分类静态流水线：在同一时间内，多功能流水线中的各段只能按同一种功能的连接方式工作。动态流水线：在同一时间内，多功能流水线中的各段可以按照不同的方式连接，同时执行多种功能。从时空图中可以看出，动态流水线的同一时间可以有不同功能。但是一定不能对某一段产生共用的冲突2、按照流水的级别来进行分类部件级流水线（运算操作流水线）：把处理机的算术逻辑运算部件分段，使得各种类型的运算操作能够按流水方式进行。处理机级流水线（指令流水线）：把指令的解释执行过程按照流水方式处理。把一条指令的执行过程分解为若干个子过程，每个子过程在独立的功能部件中执行。处理机间流水线（宏流水线）：它是由两个或者 两个以上的处理机串行连接起来，对同一数据流进行处理，每个处理机完成整个任务中的一部分。3、按照流水线中是否有反馈回路来进行分类线性流水线：流水线的各段串行连接，没有反馈回路。数据通过流水线中的各段时，每一个段最多只流过一次。非线性流水线：流水线中除了有串行的连接外，还有反馈回路。非线性流水线的调度问题十分重要。它需要确定什么时候向流水线引进新的任务，才能使该任务不会与先前进入流水线的任务发生冲突——争用流水段。方法有很多，可自行查阅了解4、根据任务流入和流出的顺序是否相同来进行分类顺序流水线：流水线输出端任务流出的顺序与输入端任务流入的顺序完全相同。每一个任务在流水线的各段中是一个跟着一个顺序流动的。乱序流水线：流水线输出端任务流出的顺序与输入端任务流入的顺序可以不同，允许后进入流水线的任务先完成（从输出端流出）。也称为无序流水线、错序流水线、异步流水线乱序流水线：例如第一个任务中途暂停，第二个任务能够继续执行，最终结果是第二个任务先出去。5、按照处理的数据分类把指令执行部件中采用了流水线的处理机称为流水线处理机。标量处理机：处理机不具有向量数据表示和向量指令，仅对标量数据进行流水处理。向量流水处理机：具有向量数据表示和向量指令的处理机。是向量数据表示和流水技术的结合2、流水线的性能指标(1)吞吐率吞吐率：在单位时间内流水线所完成的任务数量或输出结果的数量。1、各段时间均相等的流水线：实际吞吐率：TP=n/(k+n-1)△t第一个任务使用k△t时间，后面n-1个任务都是每一个△t出一个结果。最大吞吐率：TPmax=1/△t当n-&gt;∞时流水线的实际吞吐率小于最大吞吐率，它除了与每个段的时间有关外，还与流水线的段数k以及输入到流水线中的任务数n等有关。2、各段时间不完全相等的流水线：各段时间不等的流水线的实际吞吐率：第一个任务使用的时间+剩下n-1个任务。每隔一个max（△t1、△t2、△t3…）就会得出一个结果流水线的最大吞吐率为：同样当n-&gt;∞时3、解决流水线瓶颈问题的常用方法：①细分瓶颈段例如：把瓶颈段占3△t的S3细分为3个占1△t子流水线段：S3a，S3b，S3c。TPmax由1/3△t变为1/△t缺点：有时候实在不好分②重复设置瓶颈段同样的TPmax由1/3△t变为1/△t。缺点：控制逻辑比较复杂，所需的硬件增加了重复设置瓶颈段后的时空图：(2)加速比加速比：完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比。1、流水线各段时间相等加速比S=n*k/(k+n-1)原来不使用流水线：Ts= nk△t使用流水线：Tk = (k＋n-1)ΔtS=Ts/Tk最大加速比：当n&gt;&gt;k时，S ≈ k2、流水线的各段时间不完全相等时(3)效率效率：流水线中的设备实际使用时间与整个运行时间的比值，即流水线设备的利用率。从时空图上看，效率就是n个任务占用的时空面积和k个段总的时空面积之比。当n&gt;&gt;k时n最高效率为1当流水线各段时间相等时，流水线的效率与吞吐率成正比。TP=n/(k+n-1)△tE=n/(k+n-1)流水线的效率是流水线的实际加速比S与它的最大加速比k的比值S=n*k/(k+n-1)E=n/(k+n-1)最大加速比：当n&gt;&gt;k时，S ≈ k(4)流水线的性能分析举例总结：E=TP*一个程序的时间/k=S/k(5)流水线设计中的若干问题1.瓶颈问题在设计流水线时，要尽可能使各段时间相等。前面已经举过例子2.流水线的额外开销流水寄存器延迟。例如3△t的过程分成3个△t，每个过程中间需要加一个流水寄存器保存中间值。时钟偏移开销。虽然电流很快，但是还是需要时间的。3.流水寄存器需要建立时间和传输延迟时钟信号来临和执行是需要时间的。上面分成3个△t实际上还需要两个流水寄存器接受时钟时刻的作用等待时间T。4.时钟偏移开销流水线中，时钟到达各流水寄存器的最大差值时间。（时钟到达各流水寄存器的时间不是完全相同）因为电路到达每个寄存器的长度是不同的，即路程不同所以耗费时间就不同。几个问题：流水线并不能减少（而且一般是增加）单条指令的执行时间，但却能提高吞吐率。增加流水线的深度（段数）可以提高流水线的性能。流水线的深度受限于流水线的额外开销。当时钟周期小到与额外开销相同时，流水已没意义。因为这时在每一个时钟周期中已没有时间来做有用的工作。3、相关与流水线冲突(1) 一个经典的5段流水线取指令周期（IF）IR ← Mem[PC] 。PC值加4。（假设每条指令占4个字节）指令译码/读寄存器周期（ID）译码。用IR中的寄存器编号去访问通用寄存器组，读出所需的操作数。执行/有效地址计算周期（EX）:不同指令所进行的操作不同存储器访问指令：ALU把所指定的寄存器的内容与偏移量相加，形成用于访存的有效地址。寄存器－寄存器ALU指令：ALU按照操作码指定的操作对从通用寄存器组中读取的数据进行运算。寄存器－立即数ALU指令：ALU按照操作码指定的操作对从通用寄存器组中读取的第一操作数和立即数进行运算。分支指令：ALU把偏移量与PC值相加，形成转移目标的地址。同时，对在前一个周期读出的操作数进行判断，确定分支是否成功。存储器访问／分支完成周期（MEM）该周期处理的指令只有load、store和分支指令。 其他类型的指令在此周期不做任何操作。load指令：用上一个周期计算出的有效地址从存储器中读出相应的数据。store指令：把指定的数据写入这个有效地址所指出的存储器单元。分支指令：分支“成功”，就把转移目标地址送入PC。写回周期（WB）ALU运算指令和load指令在这个周期把结果数据写入通用寄存器组。在这个实现方案中：分支指令需要4个时钟周期（如果把分支指令的执行提前到ID周期，则只需要2个周期）。store指令需要4个周期。其他指令需要5个周期才能完成。（ALU只是MEM不做事情依旧需要执行WB所以等5个周期）它的执行方式如下：由图中我们可以看出具有很多冲突，例如不同指令的阶段同时访存等。所以采用流水线方式实现时，应解决以下几个问题：①要保证不会在同一时钟周期要求同一个功能段做 两件不同的工作。例如，不能要求ALU同时做有效地址计算和算术运算。②避免IF段的访存（取指令）与MEM段的访存（读/写数据）发生冲突。可以采用分离的指令存储器和数据存储器；一般采用分离的指令Cache和数据Cache。③ID段和WB段都要访问同一寄存器文件。把写操作安排在时钟周期的前半拍完成，把读操作安排在后半拍完成。④考虑PC的问题PC值的加4操作，并保留新的PC值。这种操作必须在IF段完成，以便为取下一条指令做好准备。（需设置一个专门的加法器）但分支指令也可能改变PC的值，而且是在MEM段进行，这会导致冲突。(2)相关与流水线冲突相关：两条指令之间存在某种依赖关系。如果两条指令相关，则它们就有可能不能在流水线中重叠执行或者只能部分重叠执行。①数据相关（也称真数据相关）：某指令的运行需要前一个指令的结果，且具有传递性即该语句就不能连续执行流水指令，产生了数据相关②名相关：同时使用一个寄存器，它分为反相关：一个读一个写，输出相关：两个都写;名相关的两条指令之间并没有数据的传送。换名技术：通过改变指令中操作数的名（寄存器换名）来消除名相关。既可以用编译器静态实现，也可以用硬件动态完成。③控制相关：由分支指令引起的相关为了保证程序应有的执行顺序，必须严格按控制相关确定的顺序执行。与一条分支指令控制相关的指令不能被移到该分支之前，否则这些指令就不受该分支控制了。如果一条指令与某分支指令不存在控制相关，就不能把该指令移到该分支之后。例如两个if语句之间有一个其他语句，这个语句就不能移动流水线冲突指对于具体的流水线来说，由于相关的存在，使得指令流中的下一条指令不能在指定的时钟周期执行我们约定：当一条指令被暂停时，在该暂停指令之后流出的所有指令都要被暂停，而在该暂停指令之前流出的指令则继续进行（否则就永远无法消除冲突）。①结构冲突：因硬件资源满足不了指令重叠执行的要求而发生的冲突。例如同时执行浮点加法，硬件只有一个设施结构冲突的解决办法：插入暂停周期设置相互独立的指令存储器和数据存储器或设置相互独立的指令Cache和数据Cache。注意：有时流水线设计者允许结构冲突的存在因为需要减少硬件成本②数据冲突：当指令在流水线中重叠执行时，因需要用到前面指令的执行结果而发生的冲突。例如：后面指令用前面的结果根据指令读访问和写访问的顺序，可以将数据冲突分为3种类型。写后读冲突（RAW）(数据相关)： 在 i 写入之前，j 先去读。 j 读出的内容是错误的。这是最常见的一种数据冲突，它对应于真数据相关。写后写冲突（WAW）（输出相关）：在 i 写入之前，j 先写。最后写入的结果是 i 的。错误！这种冲突对应于输出相关。写后写冲突仅发生在这样的流水线中：流水线中不只一个段可以进行写操作、当先前某条指令停顿时，允许其后续指令继续前进。*前面介绍的5段流水线不会发生写后写冲突。（因为只在WB段写寄存器） *读后写冲突（WAR）(反相关) ：在 i 读之前，j 先写。i 读出的内容是错误的！这种冲突仅发生在这样的情况下：有些指令的写结果操作提前了，而且有些指令的读操作滞后了、令被重新排序了。读后写冲突在前述5段流水线中不会发生。（读操作（在ID段）在写结果操作（在WB段）之前）数据冲突的解决办法：通过定向技术减少数据冲突引起的停顿. 因为某些数据在存入前其实已经产生了，我们可以之前在临时存储中直接导出。但是要注意：不能隔节拍导入，因为是流水线不断变化的（T3节拍产生的结果不可能保存到第5节拍不要被图迷惑了），而且注意不能是后节拍导入前节拍，这是不可能的。实际上定向是同时间不同空间的传递。停顿等待并不是所有的数据冲突都可以用定向技术来解决。依靠编译器解决数据冲突。编译器在编译成机器指令的时候进行相应的调换顺序使得不需要停顿③控制冲突：流水线遇到分支指令和其他会改变PC值的指令所引起的冲突。分支等改变PC值的冲突控制冲突的解决办法冻结”或者“排空”流水线 。减少分支延迟。在流水线中尽早判断出分支转移是否成功；尽早计算出分支目标地址。通过软件（编译器）来减少分支延迟的方法预测分支失败，若真的分支失败则就分支指令看作是一条普通指 令允许分支指令后的指令继续在流水线中流动。相当于什么都没发生预测分支失败，若实际分支成功，流水线就把在分支指令之后取出的所有指令转化为空操作，并按分支目地重新取指令执行。若能够先知道分支目标地址，后知道分支是否成功。则假设分支转移成功时，直接分支目标地址处取指令执行。然而前述5段流水线中，这种方法没有任何好处。要保证：分支结果出来之前不会改变处理机的状态，以便一旦猜错时，处理机能够回退到原先的状态。延迟分支：在延迟槽中放入有用的指令。从前调度从目标处调度从失败处调度要求编译器实现时尽量判断哪些指令确实可以调度，不会改变原程序结果进一步改进：分支取消机制当分支的实际执行方向和事先所预测的一样时，执行分支延迟槽中的指令，否则就将分支延迟槽中的指令转化成一个空操作（这里我们假设了结果会在ID段出现即使用了尽早计算出分支目标地址。）。4、MIPS流水线实现参考机组的MIPSCPU设计课程设计，对照课本理解。5、向量处理机(1)介绍在流水线处理机中，设置向量数据表示和相应的向量指令，称为向量处理机。不具有向量数据表示和相应的向量指令的流水线处理机，称为标量处理机。向量实际上就可以看成个数组，对其计算计算对每其一个内容进行相应计算。横向计算就是每一位上都需要对一个计算过程全部计算完毕再进行下一位直至结束纵向计算就是对每一种计算方式，从前往后全部计算完毕，在进行下一个计算方式从前往后，直到结束。由于向量过长，每一次计算方式计算完毕后想要寄存保持就需要很大的寄存器，这样成本太高，只适合存储器-存储器。纵横计算，就是将向量分组，例如512位向量分成8*64段，若不是恰好的向量则最后剩余的也为一段。对每一段中的内容进行纵向计算，段与段之间横向计算。这样64位就很好储存了，可用寄存器=寄存器结构。注：向量处理中的每一位，不是1bit，通常是1字节，数据处理加减乘除也是和我们平时相同。(2)提高向量处理机性能的方法1、设置多个功能部件2、链接技术链接特性的实质：把流水线定向的思想引入到向量执行过程的结果四、指令级并行1、tomsulo算法注意load出来的result填写是使用Mem[regs[]+]类型而不是Regs[Fxx]2、循环展开]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>计算机体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法设计与分析【三】]]></title>
    <url>%2Fposts%2F73c5b00f%2F</url>
    <content type="text"><![CDATA[推荐阅读：https://www.cnblogs.com/chihaoyuIsnotHere/category/1286665.html一、分治介绍转载：五大常用算法之一：分治算法1、基本思想及策略分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。2、分治法适用的情况分治法所能解决的问题一般具有以下几个特征：​ 1) 该问题的规模缩小到一定的程度就可以容易地解决​ 2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。​ 3) 利用该问题分解出的子问题的解可以合并为该问题的解；​ 4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；、第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。3、分治法的基本步骤分治法在每一层递归上都有三个步骤：​ step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；​ step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题​ step3 合并：将各个子问题的解合并为原问题的解。它的一般的算法设计模式如下：​ Divide-and-Conquer(P)​ 1. if |P|≤n0​ 2. then return(ADHOC(P))​ 3. 将P分解为较小的子问题 P1 ,P2 ,…,Pk​ 4. for i←1 to k​ 5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi​ 6. T ← MERGE(y1,y2,…,yk) △ 合并子问题​ 7. return(T)​ 其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。4、分治法的复杂性分析5、可使用分治法求解的一些经典问题（1）二分搜索（2）大整数乘法（3）Strassen矩阵乘法（4）棋盘覆盖（5）合并排序（6）快速排序（7）线性时间选择（8）最接近点对问题（9）循环赛日程表（10）汉诺塔6、依据分治法设计程序时的思维过程实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。1、一定是先找到最小问题规模时的求解方法2、然后考虑随着问题规模增大时的求解方法3、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。二、分治的练习1、最大子数组问题2、逆序对计数问题3、第K个小的数次序选择问题]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>算法设计与分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程【二】]]></title>
    <url>%2Fposts%2Faa053f21%2F</url>
    <content type="text"><![CDATA[二、结构化设计1、结构化分析概述核心思想：分解简化问题、物理（实现细节）与逻辑（是什么、做什么）表示分开、进行数据与逻辑抽象具体步骤：(1)发现需求发现需求方法：与用户交谈，向用户提问题；参观用户的工 作流程，观察用户的操作；向用户群体发调查问卷；与同行、专家交谈，听取他们的意见；分析已经存在的同类软件产品，提取需求；从行业标准、规则中提取需求；从Internet上搜查相关资料等。(2)求精​ 由于需求非常庞杂，所以需要对初步需求反复求精多次细化。(3)建模​ 语言描述会使得不同人阅读产生不同的想法，所以需要建立模型，用图形符号和组织规则书面描述事物。不同的软件开发方法建立的模型不同。在结构化分析中我们一般使用数据模型、功能模型、行为模型模型核心：数据字典描述软件使用和产生的所有数据对象。数据模型：E-R图表达描述数据对象间关系 图中数据对象属性用“数据对象描述”表达。 功能模型：DFD表达描绘数据在软件中移动、变换及相应功能 图中功能用“处理规格说明”表达。行为模型：状态转换图描绘系统状态和在不同状态间转换方式。 图中软件控制附加信息用“控制规格说明”表达。图+说明=模型。因为图的信息不够详细，还需要一定的说明(4)规格说明书写软件需求规格说明，作为分析阶段最终成果。具有国标模板等，它是开发和交付的依据。(5)复审2、数据模型数据模型由数据对象、数据对象间关系、属性组成数据对象：软件必须理解的复合信息表示，复合信息是具有一系列不同性质或属性的事物。例如：事务（报表）、地点（仓库）、角色（教师、学生）单位（会计科）、行为（打电话）等属性：定义数据对象性质。例如：数据对象学生的属性可为学号、姓名、班级等。关系：对象彼此间相互连接方式，也称联系。例如：教师和学生间存在“教”的联系。分三类，1：1 (一对一) 、 1:N (一对多) 、 M:N(多对多)。实体用矩形框表示、属性用圆角矩形表示、关系用菱形例如：某校教学管理系统E-R图例题：请为某仓库的管理设计一个ER模型，该仓库主要管理零件的订购和供应等事项。仓库向工程项目供应零件，并且根据需要向供应商订购零件。“零件”的主要属性是：零件编号，零件名称，颜色，重量。 “工程项目”的属性主要是：项目编号，项目名称，开工日期。“供应商”的属性主要有：供应商编号，供应商名称，地址。3、功能模型数据流图是一种图形化技术，它描绘信息流和数据从输入移动到输出的过程中所经受的变换，表达了信息加工处理的过程。它没具体的物理元素，只描绘信息在系统中流动处理情况。数据流图是结构化分析的主要工具之一它是逻辑模型，它不考虑怎么做，只考虑做什么！符号表示：为了表达数据处理过程的数据加工情况，用一个数据流图是不够的，为了表达稍为复杂的实际问题，需要按照问题的层次结构进行逐步分解，并以分层的数据流图反映这种结构关系。一些原则：数据流图上所有图形符号只限于前述四种基本图形元素数据流图的主图必须包括前述四种基本元素，缺一不可数据流图的主图上的数据流必须封闭在外部实体之间每个加工至少有一个输入数据流和一个输出数据流在数据流图中，需按层给加工框编号。编号表明该加工所处层次及上下层的亲子关系规定任何一个数据流子图必须与它上一层的一个加工对应，两者的输入数据流和输出数据流必须一致。即父图与子图的平衡图上每个元素都必须有名字局部数据存贮：在子图中出现的数据存贮，可以不出现在父图中，画父图时只需画出处理逻辑之间的联系，不必画出各个处理逻辑内部的细节。命名规则数据流（数据存储）命名（1）用名词，区别于控制流。（2）代表整个数据流（数据存储）内容，不仅仅反映某些成分。（3）不用缺乏具体含义名字，如“数据”、“信息”。处理命名（1）用动宾词组，避免使用“加工”、“处理”等笼统动词。（2）应反映整个处理的功能，不是一部分功能。（3）通常仅包括一个动词，否则分解。数据源点／终点命名不属于数据流图的核心内容，可能是人员、计算机外部设备或传感器装置。采用它们在问题域中习惯使用的名字（如“采购员”、“仓库管理员’等）。(1)画数据流图的方法范例：工厂采购部采购员每天需一张定货报表，按零件编号排序列出所需定货零件。对定货零件列下述数据：零件编号、名称、定货数量、目前价格，主次要供应者等。零件入库或出库称事务，通过仓库终端把事务报告定货系统。零件库存量少于库存临界值需订货。①从问题描述提取数据流图四种成分源点:仓库管理员终点:采购员处理:处理事务、产生报表等数据流：事务、订货信息、订货报表等数据存储：订货信息、库存信息②画数据流图的基本系统模型。③把基本系统模型细化，描绘系统主要功能④主要功能进一步细化⑤结束，进一步分解涉及如何具体实现功能时，不应再分解。总结：一.从问题描述提取数据流图四种成分先考虑源点和终点再考虑处理最后考虑数据流和数据存储二.画数据流图的基本系统模型。只有一个处理过程，这一步主要是为了划定边界方便进一步细分。三.把基本系统模型细化，描绘系统主要功能。将系统的主要的各种功能呈现。四.主要功能进一步细化。对每一种功能进行细细划分五.结束，进一步分解涉及如何具体实现功能时，不应再分解。因为数据流图不涉及怎么做，所以当再分解时涉及到如何具体实现功能时，不应再分解。(2)数据流图的应用1、作为交流信息的工具作为用户和系统分析员之间交流的工具。不需要专业培训就能看懂。文字表述容易引发歧义且不直观。相比之下数据流图就是个很好的工具2、作为分析和设计的工具用数据流图辅助物理系统设计时，可在数据流图上画出许多组自动化边界，每组自动化边界可能意味着不同的物理系统。例如：这样相比较之下，联机方式更好，批量方式无法确定后来的订货信息能否满足条件，因为它是等待一批后处理。(3)数据流图练习工资计算系统包含如下功能：计算工资根据人事部门给出的出勤表和业绩表计算奖金和缺勤扣款，通过生成的奖金发放表及工资基本信息库的信息计算应发工资，根据应发工资表计算所得税，根据后勤部门给出的水电扣款及缺勤扣款表和所得税款计算出实发工资，生成实发工资表和工资清单。打印工资清单根据工资清单完成工资条的打印，给职工工资转存根据实发工资表生成职工工资存款清单并将其发送到银行①从问题描述提取数据流图四种成分起点：人事部门、后勤部门终点：职工、银行处理：计算奖金、计算缺勤扣款、计算所得税、计算出实发工资、生成实发工资表和工资清单、打印工资清单、工资转存数据流：出勤表、业绩表、奖金、缺勤扣款、奖金发放表、工资基本信息库的信息、所得税、水电扣款、实发工资、工资表和工资清单数据存储：奖金发放表、工资基本信息库的信息、工资表和工资清单②画数据流图的基本系统模型确立边界③把基本系统模型细化，描绘系统主要功能。④主要功能进一步细化⑤结束，进一步分解涉及如何具体实现功能时，不应再分解4、行为模型状态：被观察到的系统行为模式。事件：引起状态转换的外界事件抽象。箭头表示，箭头上标事件名。后跟〔条件〕，表状态转换条件。行为：进入某状态所作动作。状态框内do:行为名。初始状态（一般一个）——》若干中间状态——》若干初始状态(1)实例：电话系统状态转换图5、数据字典数据字典是对系统使用的所有数据元素定义的集合，半形式化（介于事实和形式化直接）方法表达。数据字典对四类元素定义：数据流、数据元素、数据存储、处理(1) 数据流的描述数据流名：说明：简要介绍作用即它产生的原因和结果。数据流来源：即该数据流来自何方。数据流去向：去向何处。数据流组成：数据结构。每个数据量流通量：数据量、流通量。(2)数据元素的描述数据元素名:类型:数字（离散值、连续值），文字（编码类型）长度:取值范围:相关的数据元素及数据结构：(3)数据存储的描述数据存储名：简述：存放的是什么数据。输入数据:输出数据:数据文件组成:数据结构。存储方式:顺序，直接，关键码。(4)处理的描述处理名:处理编号:反映该处理的层次简要描述:加工逻辑及功能简述输入数据流:输出数据流:加工逻辑： 简述加工程序、加工顺序(5)定义符号定义数据方法：对数据自顶向下分解。由数据元素组成数据的方式：①顺序： 以确定次序连接两个或多个数据元素；②选择： 从两个或多个可能元素中选一个；③重复： 把指定数据元素重复零次或多次； ④可选： 一个数据元素可有可无的。例如:航班信息文件＝｛航空公司名称＋航班号＋起点＋终点＋日期＋起飞时间＋降落时间}航空公司名称＝2｛字母}8航班号＝3｛十进制数字}3字母＝”a”..”z”十进制数字＝”0”..”9”起点＝终点＝1｛汉字}5起飞时间＝降落时间＝时＋分时＝”00”..”23”分＝”00”..”59”日期＝年＋月＋日年＝[2010｜2011｜2012｜2013]月＝”01”..”12“日＝”01”..”31”]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP程序设计【三】]]></title>
    <url>%2Fposts%2F90888114%2F</url>
    <content type="text"><![CDATA[一、JSP内置对象1、什么是内置对象注意程序片、JSP标记等对应的所在位置2、request对象当用户请求一个JSP页面时，JSP页面所在的Web服务器会将用户的请求信息封装到内置对象request。request对象主要用于接收客户端通过HTTP协议传送给服务器端的数据(1)获取通过表单提交的信息getParameter(String name) ：用于获取客户端传送给服务器端的指定请求参数的值，返回值是字符串对象，若指定请求参数不存在，返回null。getParameterValues(String name)： 用于获取客户端传送给服务器端的指定请求参数的所有值，返回值是字符串数组。单值：多值：(2)获取通过URL（如超链接）提交的信息(3)一些异常处理①使用表单时出现 NullPointerException 异常原因:在本页面处理本页面中的表单提交的数据,客户端还未有机会提交，页面已经执行了一遍获取得到的对象值为 null在未判断的情况下使用该对象则抛出 NullPointerException 异常解决办法：添加判断语句②中文乱码问题Post和Get都是表单属性Method的可选值，Method的默认值为Get表单使用 post 方式提交表单使用 get 方式提交通过URL形式（如超链接）传递的信息(4)request对象存储数据在本页面、include、forward的页面中有效3、response 对象response对象封装了对客户的响应信息，通过response对象可以对请求做出动态响应、向用户端发送数据。它与request组成了一对接收、发送数据的对象(1)动态响应contentType属性void setContentType(String s)(2)设置响应的HTTP文件头动态添加新的响应头及其值，并将它们发送给客户浏览器,如果添加的头已经存在，则先前的头会被覆盖void setHeader(String head ,String value)void addHeader(String head,String value)String getHeader(String name)Collection&lt; String &gt; getHeaderNames()Collection&lt; String &gt; getHeaders(String name)(3)页面重定向浏览器改变访问地址，重定向（请求）到由location指定的网址void sendRedirect(String location) //任意网址forward转发与sendRedirect重定向的区别：(4)修改响应状态行当JSP引擎对用户请求进行响应时，它发送的首行称做状态行状态行包括3位数字的状态代码和对状态代码的描述可通过response修改状态行，但通常不需要这么做例如：设置response.setStatus(408);访问就会显示4044、out 对象out对象是一个输出流对象，用来向客户端输出数据来自：out instanceof javax.servlet.jsp.JspWriter extends java.io.Writer5、session 对象(1)session会话HTTP（Hyper Text Transfer Protocol）是无状态的服务器对客户端发出的请求响应后连接就关闭了，服务器端不保留连接的相关信息，每次请求之间都是独立的。然而，很多应用是需要“保留和跟踪客户状态”的，如教务系统、购物系统、邮件系统等从客户端连接到服务器的一个Web服务目录开始，直到客户端与服务器端断开连接为止的一个过程，称为一次会话，使用session对象表示。服务器会为每个客户自动创建一个session对象，并为该对象分配一个String类型的唯一标识id，用于区分不同客户，服务器将该id发送到客户端，存放在客户的Cookie中session对象是按照区别不同的用户和Web服务目录分配的同一用户在同一Web服务目录中的session都相同同一用户在不同Web服务目录中的session不相同不同用户的session都是不同的（无论服务目录是否相同）由于cookie可以被人为禁止，必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器String encodeRedirectURL(String url) //可以跨Web服务目录，输入url返回新url包含session idString encodeURL(String url)//限于本Web服务目录，输入url返回新url包含session id表单隐藏字段实现服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器(2)session对象存储数据(3)session对象的生存期限客户是否关闭浏览器session对象是否调用invalidate()方法使session无效session对象是否达到设置的最长“发呆”时间（默认30min）设置发呆时间的方法6、application 对象application对象保存Web应用程序中公有的数据，可存放全局变量。服务器启动后自动创建application对象，此对象将一直有效，直到服务器关闭。不同用户可以对该对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此对象的访问。因此，application对象可以实现多客户间的数据共享 如网站访问量计数等(1)application对象存储数据二、JavaBean1、什么是JavaBeanJavaBean是一个遵循特定写法的Java类，它通常具有如下特点：提供一个默认的无参构造函数。需要被序列化并且实现了 Serializable 接口。可能有一系列可读写属性，一般是私有的。可能有一系列的 getter 或 setter 方法。注意，由于需要实例化，所以JavaBean不支持抽象类JavaBean的属性可以是任意类型，并且一个JavaBean可以有多个属性。每个属性通常都需要具有相应的setter、 getter方法，setter方法称为属性修改器，getter方法称为属性访问器。一个JavaBean的某个属性也可以只有set方法或get方法，这样的属性通常也称之为只写、只读属性。2、JSP中使用JavaBean(1)直接当做普通类使用直接当做普通类使用,导入包使用即可(2)通过JSP动作标记使用主要有三种动作标签&lt;jsp:useBean&gt;：声明并创建对象。&lt;jsp:setProperty&gt;：设置指定属性的值。&lt;jsp:getProperty&gt;：获取指定属性的值。①useBean&lt;jsp:useBean id=”对象名” class/type=”类名” scope=”有效范围”/&gt;scope默认值是pageScope属性有page, requese, session, application四个可选值，分别代表页面，请求，会话，应用4种范围。class和type的区别就是，若名为id的对象为空则class方式会创建，而type不会，它会抛出异常也就是说使用class时，它是先判断拿不拿得到实例的bean，若拿不到就使用new关键字实例化一个，而使用的是type时，它只是查找指定的范围中是否存在，在不存在时又没使用class，beanName 指定type，就会抛出异常，因此在使用type时就需要注意这点。②getProperty&lt;jsp:getProperty name=” 对象名” property=” 属性名”/&gt;注意，该动作标记的结果是直接显示在页面上！！！③setProperty&lt;jsp:setProperty name=” 对象名” property=”属性名” value=”指定值”/&gt;设置的几种方法，这几种变型主要处理form表单提交时的属性赋值：&lt;jsp:setProperty name=” beanname “ property=” propertyname” /&gt;将propertyname的值提交给beanname中的属性名称相同的属性。&lt;jsp:setProperty name=” beanname” property=” propertyname” param=” paramname”/&gt;将请求参数名称为paramname的值提交给propertyname属性。&lt;jsp:setProperty name=” beanname” property=”*” /&gt;将所有的属性与请求参数关联，实现自动复制并自动转换数据类型。注意：设置值的时候，value若填写字符串则会自动转换为property填写的Bean属性的相应的类型，而若value填写value=&quot;&lt;%=XX%&gt;&quot;则不会自动转换，而是保留原形式(3)动作标记和程序片结合使用因为动作标记最终还是转换成Java类，所以可以配合程序片使用。例如声明使用动作标记，之后程序片就可以直接使用生成的对象]]></content>
      <categories>
        <category>JSP程序设计</category>
      </categories>
      <tags>
        <tag>JSP程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法设计与分析【二】]]></title>
    <url>%2Fposts%2F3edb135d%2F</url>
    <content type="text"><![CDATA[一、算法分析的数学基础1、几类重要的函数的阶阶的高低至少指数级： 2n, 3n, n!, …注意阶乘至少是指数级多项式级： n, n2, nlogn, n1/2, …对数多项式级： logn, log2n, loglogn, …2、对数函数的一些性质有关性质(1)的证明有关性质(2)(3)的证明性质二的证明在性质一的基础上使用了有关函数渐近的界的定理产生的重要结论：对数函数的阶&lt;幂函数的阶&lt;指数函数的阶性质三的证明则是两边都进行 logb运算3、指数函数与阶乘阶乘比nn增长慢，比一般的指数函数增长块，且其去对数后是一个多项式同阶的，证明如下：斯特林公式的应用：4、取整函数的性质二、算法分析的一些数学方法1、序列求和或者估计和(1)一些级数求和公式求和过程中还有一些如拆项、变限等方法需要灵活运用例如：更多的算法分析级数(2)估计和式上界的放大法例如：(3)用积分做和式的渐近的界就是灵活运用积分，例如：2、递推方程的求解设序列 a0, a1, … , an, … , 简记为 { an },一个把 an与某些个 ai ( i &lt; n ) 联系起来的等式叫做关于序列 { an } 的递推方程例如：Fibonacci数递推方程：f(n)=f(n-1)+f(n-2)初值：f(0)=1, f(1)=1(1)迭代法求解迭代法求解：不断用递推方程的右部替换左部，直到出现初值停止迭代，将初值代入并对和式求和，可用数学归纳法验证解的正确性例如：对于某些递推方程，直接迭代比较困难，可以尝试对递推方程和初值进行换元，然后求和，求和后进行相反换元，得到原始递推方程的解例如：解的正确性-归纳验证：(2)差消法求解对于高阶递推方程先要用差消法化简为一阶方程，再迭代求解例如：最后迭代求解:(3)递归树递归树是迭代的图形表述,递归树的生成过程与迭代过程一致。*递归树上所有项恰好是迭代之后产生和式中的项.对递归树上的项求和就是迭代后方程的解. *生成方法：应用实例:用变化最慢的，也就是深度最深的，计算层数k。3、求解递推方程的主定理及其应用主定理：主定理证明通过递归树这一个视角解释主定理的含义：为什么每一行都要加起来？因为这个递归方程，转化为程序理解，那个a就是说明有a个递归调用语句！n/b代表规模改变。f(n)可以理解为规模n的函数，代表一个程序函数中，规模n使得需要运行的基本语句次数。为什么要在把所有的加起来？所有的节点都代表一个程序段的执行，算法的总基本语句次数肯定要加起来。最后一行的alogbn通过对数转换成nlogba一个Tn这样形式的式子，通过递归树的计算，得到了叶子节点耗费的计算量和各层根节点之和耗费的计算量，两者加起来就是Tn的计算量。而主定理，就是判断这两部分以那部分为主。情况1：表示f(n)的阶比第一部分的阶小，以第一部分为主，由于是多项式阶上的差距，所以第二部分直接忽略情况2：表示f(n)的阶和第一部分等阶，由于有logbn+1层，加和后经过换底公式得到结果情况3：表示f(n)的阶比第一部分大，以第二部分为主，而再加上第二个约束条件，①是保证了根节点一定大于下一层节点计算代价之和。af(n/b)/f(n)&lt;c,c&lt;1所以分母大于分子，再从递归树中就很明显得出结果②是保证级数收敛，是正则条件。这样就得到以f(n)的阶为主注意：logn不是一个多项式阶ne所以情况1哪怕是logn的加和也不会在多项式上超过第一部分的阶拓展形式：应用：不能使用主定理时，可考虑使用递归树求解。]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>算法设计与分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web系统设计【三】]]></title>
    <url>%2Fposts%2F0%2F</url>
    <content type="text"><![CDATA[一、（续）CSS样式1、单位描述(1)尺寸px：像素 (计算机屏幕上的一个点)em：1em 等于当前的字体尺寸。2em 等于当前字体尺寸的两倍。例如，如果某元素以 12pt 显示，那么 2em 是24pt。在 CSS 中，em 是非常有用的单位，因为它可以自动适应用户所使用的字体。%：百分比百分比是一个相对的概念，相对它当前的百分比，由于继承性，所以他是不固定的。(2)颜色所有颜色是由红R绿G蓝B三种颜色重叠形成的，分配其各自强度就能产生不同颜色，产生了四种表示方法直接使用颜色名rgb(x,x,x)RGB 值 (比如 rgb(255,0,0))rgb(x%, x%, x%)RGB 百分比值 (比如 rgb(100%,0%,0%))#rrggbb十六进制数 (比如 #ff0000)，每两位代表一个颜色的强度，两位2进制数可以代表0~255其他详细:CSS 单位2、文字样式通过设置装饰线，可以设置出删除线、下划线、超链接去下划线等效果补充：属性text-transform， CSS属性指定如何将元素的文本大写。它可以用于使文本显示为全大写(uppercase)或全小写(lowercase)或者首字母大写(capitalize)，默认为nonefont-family 属性应该使用若干种字体名称作为回退系统，以确保浏览器/操作系统之间的最大兼容性。如果浏览器不支持第一个字体，则会尝试下一个。font属性可以简化说明，在font中声明，但是要遵循一定的顺序，字体大小和字体类型顺序不能改，前面的其他属性可以任意更多文本属性:https://www.w3school.com.cn/css/css_text.asp3、背景与超链接（1）背景对于背景来说，需要先定义空元素的高度和宽度，否则无法定义背景例如：背景常用的三个属性：颜色、图片、填充方式。若颜色和图片均声明，则被图片覆盖，图片无法显示则显示颜色。背景色不继承，是由于默认设置为透明所以才显得是背景色一致填充方式分别为，原大小均匀铺满背景、横向填充、纵向填充、不重复填充只用一张但是拉伸图片作为背景补充：背景附加方式：background-attachment该属性允许当其他内容滚动时背景固定在一个位置属性值：scroll | fixed默认值：scroll背景位置：background-position。属性指定背景中原图的位置，可以将原图想像成背景中放置的第一个图，从原图开始延伸拼图属性值：长度计量值|百分比值| left | center | right | top | bottom默认值：0% 0%（同left top）描述背景位置的方法：背景的常用属性，也可以在background：中声明，且无顺序，需要注意的是，当用坐标值表示background-position属性时，横坐标要放在前面，紧跟着的是纵坐标(2)超链接注意：这里不是设置的属性，它是一种选择器,当然如果你想让这四种都一样，直接设置a标签选择器就可以了1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;a:link &#123;color:#FF0000;&#125; /* 未被访问的链接 */a:visited &#123;color:#00FF00;&#125; /* 已被访问的链接 */a:hover &#123;color:#FF00FF;&#125; /* 鼠标指针移动到链接上 */a:active &#123;color:#0000FF;&#125; /* 正在被点击的链接 */&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;&lt;a href="/index.html" target="_blank"&gt;这是一个链接&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;为了使定义生效，a:hover 必须位于 a:link 和 a:visited 之后！！&lt;/p&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;为了使定义生效，a:active 必须位于 a:hover 之后！！&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;为了使定义生效，a:hover 必须位于 a:link 和 a:visited 之后，而a:active 必须位于 a:hover 之后助记符：通过设置我们能还够实现鼠标悬停时，放大超链接字体的功能，只需要设置a:hover内字体大小即可4、列表和表格样式(1)列表多个值可以直接填入list-style中属性描述list-style简写属性。用于把所有用于列表的属性设置于一个声明中。list-style-image将图象设置为列表项标志。list-style-position设置列表中列表项标志的位置。可设置位于文本片内还是对对齐list-style-type设置列表项标志的类型。具体类型list-style-position的值：值描述inside列表项目标记放置在文本以内，且环绕文本根据标记对齐。outside默认值。保持标记位于文本的左侧。列表项目标记放置在文本以外，且环绕文本不根据标记对齐。inherit规定应该从父元素继承 list-style-position 属性的值。list-style-type的部分值：值描述none无标记。disc默认。标记是实心圆。circle标记是空心圆。square标记是实心方块。decimal标记是数字。decimal-leading-zero0开头的数字标记。(01, 02, 03, 等。)lower-roman小写罗马数字(i, ii, iii, iv, v, 等。)(2)表格调整表格大小和边框粗细颜色调整表格边框和数据边框融合二、CSS布局和定位1、盒子模型CSS中，HTML文档中的每个元素都会生成一个或多个矩形框，这称为元素框。各元素框中心有一个内容区，这个内容区周围有可选的内边距、边框和外边距一个盒子可以视为内容和边框+内容和边框之间的内边距+边框之外的外边距组成。外边距用来分隔盒子与盒子一个盒子的实际宽度、高度:content+padding+border+margin内容的大小：width、height内边距的大小：padding、padding-top、padding-bottom、padding-left、padding-right边框：border，border-top、border-bottom、border-left、border-right外边距：margin、margin-top、margin-bottom、margin-left、margin-right①border属性border-width：px、 thin、medium、thick（常用单位为px，不同浏览器会对thick表示的粗等类似表示解释不同）border-style：dashed（虚线）、dotted（点组成的线）、solid（实线）、double（两个实线）border-color：颜色border：width style color（可使用width直接安装顺序设置）border属性适用于border-top等类似的子属性②overflow属性当内容溢出盒子框时，overflow属性取值决定内容的处置visible(默认值)：内容会呈现在元素框之外hidden：超出部分不可见scroll：显示滚动条auto：如果有超出部分，显示滚动条③padding属性和margin属性浏览器中padding属性和margin属性具有默认值，我们自行设置的时候最好先将其清零​ 取值:px，%(外层盒子的宽度和高度)可以在padding和margin属性中写四个方向的值，排序分别为上右下左，即顺时针排序。省略情况如下：这个规律同样适用于border等其他属性注意事项：margin的合并：垂直方向合并取最大值，水平方向不合并注意事项：水平居中，将左右的margin值设置为auto案例：1234567891011#newsimglist&#123;text-align:center;font-size:0; /*否则图间有空隙*/&#125;#newsimglist img&#123;height:100px;width:100px;margin-left:5px;border:1px solid #0cf;padding:5px;&#125;注意事项:图片的放置就像文字一样，受到text-align，font-size等的控制2、CSS定位机制分为文档流定位、浮动定位、层定位，默认为文档流定位文档流定位：从上到下从左到右，只是有的元素会单独占一行，有些元素在一行中显示浮动定位：打破文档流定位的排版。float属性设置。层定位：希望当前网页元素具有层次，上面的层会遮蔽掉下面的层。position属性设置。3、文档流定位元素分类：block、inline、inline-block。其他的值不常用可百度display的取值block：①独占一行、②元素的height、width、margin、padding都可设置所以它从上到下独占一行常见的block元素：12&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;table&gt;、&lt;form&gt;inline：①不单独占用一行②width、height不可设置③width就是它包含的文字或图片的宽度，不可改变所以inline从左到右占据一行常见的inline元素：1&lt;span&gt;、&lt;a&gt;inline-block：①不单独占用一行②元素的height、width、margin、padding都可设置。同时具备inline元素、block元素的特点常见的padding元素：1&lt;img&gt;display属性可以强制转换某个元素称为block、inline、inline-block，而且若为none则元素不会被显示（默认值：inline）4、浮动定位float属性:left—左浮动、right—右浮动、none—不浮动clear属性：可理解为保证那边没有浮动的元素both，清除左右两边的浮动。left清除向左的浮动。right清除向右的浮动。none 是默认值，只在需要移除已指定的清除值时用到。浮动的使用：例如div元素在不设置浮动的情况下默认为文档流定位，则两个div从上到下排列，而设置了浮动后则会改变文档流原来位置浮动的几种特点清除浮动的用法5、层定位position属性static：默认值。没有定位，元素出现在正常的流中。top, bottom, left, right ,z-index 无效fixed 固定定位。相对于浏览器窗口进行定位。top, bottom, left, right ,z-index 有效例如网页中两侧的广告不会随着滚动条改变位置relative 相对定位。相对于其直接父元素进行定位。top, bottom, left, right ,z-index 有效absolute 绝对定位。相对于 static 定位以外的第一个父元素 进行定位。若找不到任何定位则定位body。top, bottom, left, right ,z-index 有效注意：relative相对定位为relative的元素脱离正常的文档流中，但其在文档流中的原位置依然存在absolute 绝对定位脱离正常文本流，但与relative的区别:其在正常流中的原位置不再存在left属性right属性top属性bottom属性z-index属性设置大小值为数字，越大的越在上层。top, bottom, left, right的值的设置都是根据相应的参照物，以参照物左上角为原点，向→和向↓为正方向的坐标系，可设正负值6、网页布局液态网页：随着浏览器窗口缩放不要企图控制内容宽度或换行文本允许按需要重新流动通过指定百分比值宽度或不指定，来创建液态布局固定网页：将内容放在一个保持指定元素宽的网页区域内，而不管浏览器的尺寸选择固定布局需要决定的两件事：选择网页宽度：通常基于普通浏览器分辨率，多数都设计为800*600像素决定固定宽度布局将处于浏览器窗口的什么位置如何创建固定布局通过用像素单位指定width属性值来创建固定宽度布局通常，将整个网页内容放到1个div元素中，并设置具体像素值；各栏元素的宽度也用像素值表示弹性网页：当文本缩放时，弹性网页的区域会放大或缩小通过用em单位指定宽度，来创建弹性布局上述布局需查阅学习]]></content>
      <categories>
        <category>Web系统设计</category>
      </categories>
      <tags>
        <tag>Web系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【持续添加】VSCode的一些使用技巧和插件]]></title>
    <url>%2Fposts%2F8d9b982c%2F</url>
    <content type="text"><![CDATA[一、配置VScode使用C++如何配置VScode开发C++：十五分钟快速搭建vscode c/c++环境使用VS Code+MinGW64+CMake 搭建轻量美观的 C/C++开发环境https://www.bilibili.com/video/av82829076?t=5851、debug在调试的时候调试端可以显示进入作用域的所有变量的属性，地址、值等。鼠标放在代码中的变量上也能看到2、控制台可以改为false这样就会在VS端中输出3、格式化代码手动：自动：二、其他插件优化优化Visual Studio Code的自动补全1、自动生成js文档注释安装Document This自动生成js文档注释，只需要按下两次Ctrl+Alt+D 组合键就可以了其他更多：编辑器VSCode个人常用配置实用的vscode插件推荐Visual Studio Code 十大必备拓展VSCode插件推荐（Web前端开发均适用）三、VSCode自带常用快捷键操作快捷键删除当前行Ctrl+Shift+K、或Ctrl+X(利用了剪切)代码不折行另起一行（向下）ctrl + enter (回车)代码不折行另起一行（向上）ctrl + shift+enter (回车)选中代码块shift+方向键移动代码alt + 方向键（适合选中代码块使用）复制一行代码shift+ alt + 方向键（适合选中代码块使用）行视图上下偏移Ctrl+Up/Down屏视图上下偏移Alt+PageUp/PageDown打开新窗口Ctrl+Shift+N关闭窗口Ctrl+W拆分编辑器（最多拆分为三块）Ctrl+\切换焦点在不同的拆分窗口Ctrl+1/2/3删除部分ctrl + delete（退格键）VSCode 常用快捷键]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP程序设计【二】]]></title>
    <url>%2Fposts%2Fdd962246%2F</url>
    <content type="text"><![CDATA[一、JSP页面的基本结构1、Java成员变量和方法声明标记符&lt;%! %&gt;例如：12345678&lt;%! Date date; int sum; public int getFactorSum(int n) &#123; for(int i=1;i&lt;n;i++) &#123; if (n%i==0) sum=sum+i; &#125; return sum; &#125;%&gt;在“&lt;%!”和“％&gt;”之间声明的变量和方法属于成员级的，它们在整个JSP页面中都有效。原因在JSP文件转化为Java文件时的原理中变量声明必须以“；”结尾，因为就是写的Java程序内容2、Java程序片声明标记符&lt;% %&gt;例如：123456&lt;% int s=0; for (int i=1; i&lt;=100; i++) &#123; s+=i; &#125;%&gt;程序片中声明的变量属于JSP页面的局部变量。多个客户请求一个JSP页面时 , Java程序片将被执行多次，分别在不同的线程中执行。标记符&lt;%! %&gt;与&lt;% %&gt;声明的变量具有很大差别，&lt;%! %&gt;相当于一个”全局变量“，&lt;% %&gt;是局部变量，&lt;%! %&gt;声明的成员变量第一次在服务器上编译后就不会重新赋值了，&lt;% %&gt;每次都会重新赋值，原因在JSP文件转化为Java文件时的原理中3、Java表达式声明标记符&lt;%= %&gt;，将某个结果作为字符串在网页上输出例如：123456789&lt;%@ page contentType="text/html;charset=GBK" %&gt;&lt;html&gt; &lt;body bgcolor=cyan&gt; &lt;font size=4&gt; &lt;% int n = 1234; %&gt; &lt;p&gt;&lt;%= n %&gt;的平方根是：&lt;%= Math.sqrt(n) %&gt;。&lt;/p&gt; &lt;/font&gt; &lt;/body&gt;&lt;/html&gt;注意使用Java程序片和Java表达式分别表达输出，是不同的&lt;% System.out.println() %&gt;将会显示在控制台&lt;%= i %&gt;在浏览器页面显示4、JSP中的注释HTML注释格式：&lt;!-- 注释内容 --&gt;JSP中的注释:&lt;%-- 注释内容 --%&gt;Java程序片中添加Java注释&lt;%//内容%&gt;或者&lt;%/*内容*/%&gt;HTML注释会在浏览器原码中出现，并且可以在其中填写JSP表达式，内容会输出到浏览器原码中，使用相关类如Date效果也会显现JSP注释不会在浏览器原码中出现Java程序片中添加Java注释和JSP效果相同注释不会在浏览器原码中出现二、JSP到Java的转换import java.util.Date忘了在图中标示&lt;%! %&gt;内容作为类内成员变量和成员函数&lt;% %&gt;内容作为_jspService函数的局部变量和内容&lt;%= %&gt;会被作为_jspService函数中的out.print()的内容&lt;%-- --%&gt;不会被读取html标记内容会通过out.write()原封不动输出给浏览器三、JSP的标记和动作指令1、JSP指令标记描述JSP文件转换成JSP服务器所能执行的Java代码的控制信息，用于指定整个JSP页面的相关信息，并设置JSP页面的相关属性。(1)page指令page指令用来设置JSP页面的某些属性和属性值。page指令对整个JSP页面有效，与书写位置无关。(通常把page指令写在页面的最前面。)在使用多个page指令时，其中的属性除import属性外只能使用一次。语法格式：123456属性可写在一个指令中:&lt;%@ 指令 属性1="值1" 属性2="值2" …… %&gt;也可以分开写：&lt;%@ 指令 属性1="值1" %&gt;&lt;%@ 指令 属性2="值2" %&gt;括号内是默认值123456789101112131415&lt;%@page [ language=“scriptingLanguage” ] //处理页面使用的语言(java) [ extends=“package.class” ] //产生的Servlet类型(HttpJspBaseHTTPServlet) [ contentType=“mimeType[; charset=characterSet ]” ] //页面内容的类型(text/html; ISO-8859-1) [ pageEncoding=“characterSet” ] //JSP页面的编码(ISO-8859-1) [ import=“package.class | package.*, ...” ] //需要导入的类(lang, servlet, jsp, http) [ session=“true | false” ] //是否使用session对象(true) [ buffer=“none | 8kb | sizekb” ] //输出缓冲区(8kb) [ autoFlush=“true | false” ] //缓冲区自动刷新(true) [ isThreadSafe=“true | false” ] //是否可多线程访问(true) [ info=“text” ] //指定一个常用信息字符串(…) [ errorPage=“relative_url” ] //出错时转向的页面(…) [ isErrorPage=“true | false” ] //本页面是否是一个出错页面(false) [ isELIgnored=“true | false” ] //是否忽略EL表达式(true)%&gt;一般取默认值即可，下面介绍常用三个属性①contentType 属性用于指定内容MIME类型和JSP页面的编码方式。对于普通JSP页面，默认的contentType属性值为”text/html;charset=ISO-8859-1”。对于JSP文档，默认的contentType属性值为”text/html;charset=ISO-8859-1 “。②pageEncoding 属性设置保存JSP页面文件本身使用的编码注意：设置pageEncoding和contentType中的字符集必须一致，否则乱码且若只设置一个或者不设置，会根据设置情况，设置两个默认字符集一致③import属性为JSP页面导入所需要的类默认导入：java.lang.javax.servlet.javax.servlet.jsp.*javax.servlet.http.*(2)include指令将由“URL”指定的文件（该文件可以说txt、html等文本文件）包含到含有该指令标记的JSP页面中。语法：&lt;%@ include file= &quot;URL&quot; %&gt;静态包含（翻译阶段）：该指令使用指定的文件内容，与原JSP页面一起翻译成一个Java文件。被包含的文件在语法和逻辑上依赖于当前的JSP页面。可理解为将另外一个内容插入到该位置,之后编译执行2、JSP动作标记(1)include动作标记语法：&lt;jsp:include page=&quot;URL&quot; /&gt;动态包含（运行阶段）：原JSP页面执行到该指令时，就会执行指定的页面，然后把执行结果包含进来，与原JSP页面的执行结果一起发送到浏览器。被包含的文件在语法和逻辑上可以独立于当前的JSP页面。可理解为执行第一个文件的时候遇到该标记执行第二个文件结果返回给第一个文件再执行，最终将结果发送给浏览器由此特性我们也知道，指令标记文本可以是任意的可查看文本，二动作标记需要是一个jsp文本(2)forward动作标记语法：&lt;jsp:forward page=&quot;URL&quot; /&gt;遇到该指令会转向执行由“URL”指定的页面，发送执行结果，并停止执行当前页面。但地址栏仍然是原JSP页面的访问地址。常用于不同情况下的页面跳转效果。(3)param动作标记语法：&lt;jsp:param name=&quot;参数名&quot; value=&quot;参数值&quot; /&gt;不能单独使用。应用到动作标记中，用于从原页面向动作页面传递参数。123&lt;jsp:include page="come.jsp"&gt;//加载come.jsp &lt;jsp:param name="number" value="&lt;%=i%&gt;" /&gt;//传递参数&lt;/jsp:include在动作页面中获取参数值的方法：String value = request.getParamter(name);(4)问题解析为何JSP标签这样可以使用:但是这样写不行：因为JSP标记也是要转录成java程序然后再编译的。在图一中，按照程序片第一个标签结束后遇到了JSP标记，于是服务器将该标记继续转录为java程序，这样就正好在控制语句的括号中。之后在接上程序片，里面的java程序再接上尾括号和分支语句。这样才形成了一个完整的表达程序，之后生成对象执行，结果发送给客户端。而第二种，只是把JSP标记作为字符发给了客户端，但是将标记转为java程序是服务器干的事情，客户端的浏览器无法解析，故而不行。四、如何解决JSP页面中的错误1、JSP源文件JSP页面中的JSP语法格式有问题，导致其不能被翻译成Servlet源文件，JSP引擎将提示这类错误发生在JSP页面中的位置以及相关信息。2、Java源文件JSP页面中的JSP语法格式没有问题，但被翻译成的Servlet源文件中出现了Java语法问题，导致JSP页面翻译成的Servlet源文件不能通过编译，JSP引擎也将提示这类错误发生在JSP页面中的位置以及相关信息。3、运行错误JSP页面翻译成的Servlet程序在运行时出现异常，这与普通Java程序的运行时错误完全一样，Java虚拟机将提示错误发生在Servlet源文件中的位置以及相关信息。]]></content>
      <categories>
        <category>JSP程序设计</category>
      </categories>
      <tags>
        <tag>JSP程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法设计与分析【一】]]></title>
    <url>%2Fposts%2Fecdff85%2F</url>
    <content type="text"><![CDATA[一、基本概念1、什么是算法算法是为求解一个问题所需要遵循的、被清楚指定的简单指令集合。每条指令的意义都是确定的具有零个或多个输入产生若干个输出执行时间是有限的 (终止性)2、算法和程序的区别及描述方法（1）算法和程序的区别程序是某个算法或过程的在计算机上的一个具体的实现。程序是依赖于程序设计语言的，甚至依赖于计算机结构的。例如C++和Python的排序算法，可能由于Python的特性而语法上有所不同，算法是脱离具体的计算机结构和程序设计语言的。（2）描述方法自然语言表示算法贴近人类思维，易于理解主旨，但是表述不够精准，存在模糊歧义，编程语言表示算法精准表达逻辑，规避表述歧义，但是受限语法细节，增大理解难度。故引入伪代码，关注算法本质，便于书写阅读学会写伪代码3、算法的复杂性和分析算法的复杂性是指算法运行时所需要的计算机资源的量多少，所需资源量越多则复杂性越高，反之所需资源量越少则复杂性越低。其中最为重要的是：时间复杂性：需要时间的资源量空间复杂性：需要空间的资源量这里人们通常更为关注的是时间复杂性算法的复杂性取决于：求解问题的规模（倾向于数的大小、数字的量）、具体的输入数据（倾向于数据的状态对于算法的影响）、算法本身的设计若令N、I、和A分别表示问题的规模、具体的输入和算法本身，则C = F(N, I, A)或 C = F( N, I)其中：ti为执行抽象计算机的第i种指令一次所需要的时间，这里假定抽象计算机共有k种指令。ei(N, I)为经过统计后得到的执行抽象计算机的第i种指令的次数。对于具体的输入数据带来的影响，（倾向于数据的状态对于算法的影响）我们又划分出最坏、最好、平均三种分析。最好情况使用价值不大，平均分析需要概率相关知识和多重复杂运算，暂时不做分析。所以我们一般只考虑最坏情况问：分析算法的时间复杂度，不是应该考虑时间吗?那么加法乘法除法等运算不同的运算不是时间不一样吗？为什么都按一次基本运算考虑？答：因为我们是比较算法的效率，所以可以假设在同一台机上跑，且假设这台机器的性能永远不出现一丝变化。对于所有算法，每次执行这些基本操作的时间都相同。我们就控制了变量问：加减法和乘除法的操作怎么都能化为1呢？乘法不应该比加法慢很多吗？假如一个算法乘法多一个算法加法多怎么能够都按照“1”来想呢？答：这是从某种角度上来说的一个解释，提供某种程度上的合理性：根据上一个假设：同一台机上跑，且假设这台机器的性能永远不出现一丝变化。而CPU的频率是固定的，所以在这个抽象计算机上，所有操作都是根据消耗的周期来想的。而由于工艺改进，和其他编译器等等其他因素，所以我们可以这样想。例：在九十年代奔腾处理器出现之前是加法比乘法快，但是奔腾处理器及之后的某些处理器，这两种操作是一样快的。其次编译器的优化，你写的代码编译后不一定是按照你编的执行的。​ 正常解释:要精确计算算法执行时所消耗的资源是非常繁琐，代价较大，甚至说不太切于实际的。而在排除掉机器影响，且我们只专注最坏情况下，影响因素就只有规模了,我们以后将它称为T(n)，对于输入规模足够大的时候，我只要关心算法所消耗的增加量级，也就是研究算法的渐进效率。我们都知道当问题规模足够大的时候，算法的运行时间将主要取决于时间表达式的最高次项，而上图就是这样分析复杂度的数学基础支撑，也就是渐进分析，这样我们分析，只用分析规模n的最高阶就可以了，并且不用关系它的常数因子，而它的表示方法O(n)是一种渐进符号，关于渐进表示法，这篇文章写的很好。同时到了这里一定要明确:大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的问：为什么要分析算法的渐进效率，而不是直接按照输入规模直接计算效率进行比较？答：很直观的原因就是，当输入规模小的时候，各种算法间的差距并不会太大，对于大部分应用程序来讲，这些差距都可以被忽略。现实原因是，要精确计算算法执行时所消耗的资源是非常繁琐，代价较大，甚至说不太切于实际的。4、关于渐进符号推荐文章:算法的渐进效率分析 和 渐进符号大O、大Ω、大θ、小o、小ω算法导论——渐近记号Θ、Ο、o、Ω、ω详解算法分析与设计的高等数学基础这里摘要一些:渐进符号描述的表达式 表示 一个函数集合。而在渐进分析中的 ”=“更倾向于“∈ ”的意思。打个比方：渐进表达式 f(n) = O（g(n)）所表达的意思是，O(g(n)) = [ f(n),h(n)…..g(n) ]; f(n) ∈ O(g(n))通俗的:对 O的定义是为了数学语言精确说明：n满足一定条件范围内，函数f(n)的阶不高于函数g(n)。同样的，对其他符号也是如此。但是需要注意，对于一般的函数，确实好分析，但是大多存在一些级数和LOG的情况，这就要从定义出发进行论证了记号含义通俗理解(1)Θ（西塔）紧确界。相当于”=”(2)O （大欧）上界。相当于”&lt;=”(3)o（小欧）非紧的上界。相当于”&lt;”(4)Ω（大欧米伽）下界。相当于”&gt;=”(5)ω（小欧米伽）非紧的下界。相当于”&gt;”问：为什么含有常数倍数C可以代表它的上界呢？答：因为在趋于无穷的时候，倍数C的影响相对于n的影响微乎及微问：为什么使用O(n)而不用Ω(n)呢？答：因为我们分析最差情况，Ω(n)是渐进下界，并不能说明算法的最坏复杂度，所以没意义。5、有关函数渐近的界的定理(1)定理1重要结论：可证明多项式函数的阶低于指数函数的阶重要结论：对数函数的阶低于幂函数的阶(2)定理2(3)定理3(4)小结1、估计函数的阶的方法：计算极限阶具有传递性2、对数函数的阶&lt;幂函数的阶&lt;指数函数的阶.3、算法的时间复杂度是各步操作时间之和，在常数步的情况下取最高阶的函数即可.]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>算法设计与分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机体系结构【一】]]></title>
    <url>%2Fposts%2Fa24afe25%2F</url>
    <content type="text"><![CDATA[一、体系结构基础知识1、什么是计算机体系结构计算机体系结构是从传统机器级语言程序员的角度所看到的系统的属性，是概念上的结构和功能上的行为。本课程的主线就是在amdahl定律的指导下通过指令系统对数据进行处理、存储和传输。传统机器级语言程序员所看到的主要属性是该机器指令集的功能特性，而高级语言程序员看到的主要属性是该机器配置的高级语言的功能特性计算机体系结构的基础：理论基础：图灵机结构基础：冯诺依曼结构物质基础：摩尔定律2、计算机系统的层次3、体系结构和组成和实现的关系具有相同系统结构的计算机可以采用不同的组成，一种计算机组成可以采用多种不同的计算机实现。4、计算机系统结构的分类（1）冯氏分类法（2）Flynn分类法Flynn分类法，是基于指令流和数据流的数量对计算机进行分类的方法。一系列修改那些流经数据处理单元的数据（数据流）的命令，可以被认为是一个指令流。单指令流单数据流（SISD）——传统的计算机包含单个CPU，它从存储在内存中的程序那里获得指令，并作用于单一的数据流（本例中就是一个指令处理一条数据）。单指令流多数据流（SIMD）——单个的指令流作用于多于一个的数据流上。例如有数据4、5和3、2，一个单指令执行两个独立的加法运算：4+5和3+2，就被称为单指令流多数据流。SIMD的一个例子就是一个数组或向量处理系统，它可以对不同的数据并行执行相同的操作。多指令流单数据流（MISD）——用多个指令作用于单个数据流的情况实际上很少见。这种冗余多用于容错系统。多指令流多数据流（MIMD）——这种系统类似于多个SISD系统。实际上，MIMD系统的一个常见例子是多处理器计算机，如Sun的企业级服务器。5、定量分析技术（1）以经常性事件为重点​ 经常性事件就是经常发生的事件，这类事件往往占用时间较多，设计的时候往往要提高这类事件的处理效率，从而缩短时间蓝色部分为经常型时间，很明显加快经常性事件带来的效率提升更高（2）Amdahl定律​ 推导过程:本质上，该定律就是求比原来快了多少倍，其中加入Fe的时间占比作为变量，这样就能够便于数学分析通过数学分析，我们发现，①找到占比最大的经常性事件Fe②提高该事件的加速比Se是提高总效率的两个因素，只顾其一是不行的，需要统筹兼顾，但是现实中，一般提高Fe的效果要好些实际上①②都是在缩短Fe蓝色条（3）CPU性能公式CPU时间：一个程序在 CPU 上运行的时间。(不包括I/O时间)主频、时钟频率：CPU 内部主时钟的频率，表示1秒可以完成多少个周期。时钟周期 = 1 / 频率指令周期：取出并执行一条指令的时间；CPI：平均每条指令耗费的时钟周期数，CPI = 执行程序所需的时钟周期数 / 所执行的指令条数我们约定 IC ：程序所执行的指令条数所以CPU时间 = CPI * IC * 时钟周期时间=（IC*CPI ） / 频率（4）局部性原理转自：局部性原理局部性通常有两种不同的形式：时间局部性和空间局部性。①时间局部性在一个具有良好的时间局部性的程序中，被访问过一次的存储器位置很可能在不远的将来会被再次访问。②空间局部性在一个具有良好空间局部性的程序中，如果一个存储器位置被访问了一次，那么程序很可能在不远的将来访问附近的一个存储器位置。③局部性原理的应用局部性原理对硬件和软件的设计都有着极大的影响，从硬件到操作系统、再到应用程序，它们的设计都用到了局部性原理。正是由于局部性原理的存在，在硬件层通过引入高速缓存存储器能够在很大程度上提升程序运行的速度。操作系统的虚拟地址空间的技术，以及缓存磁盘文件系统中最近被使用的磁盘块等都用到了局部性原理。在应用程序设计中应用到的缓存思想。④局部性简单原则重复引用同一个变量的程序有良好的时间局部性。做顺序访问的程序具有良好的空间局部性。循环结构具有良好的空间局部性和时间局部性。循环体越小，循环迭代次数越多，局部性越好。6、并行性发展(1)定义在同一时间或同一时间间隔完成两种或两种以上工作同时性：指两个或两个以上事件在同一时刻发生。并发性：指两个或两个以上事件在同一时间间隔发生。(2)从处理数据的角度看并行性等级从低到高可分为：字串位串：同时只对一个字的一位进行处理。这是最基本的串处理方式，不存在并行性。字串位并：同时对一个字的全部位进行处理，不同字之间是串行的。这里已开始出现并行性。字并位串：同时对许多字的一位进行处理。这种方式有较高的并行性。全并行：同时对许多字的全部位进行处理。这是最高一级的并行性。(3)从执行程序的角度看并行性等级从低到高可分为：指令内部并行：一条指令执行时各微操作之间并行。指令级并行：并行执行两条或多条指令。线程级并行：并行两个或两个以上的线程，通常是一个进程内控制派生的多个线程为调度单位任务级或过程级并行：并行执行两个以上过程或任务（程序段）。作业或程序级并行：并行执行两个以上作业或程序。(4)提高并行性的方法（1）时间重叠。在并行性概念中引入时间因素，即多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，以加快硬件周转时间而赢得速度。例如：流水线技术（2）资源重复。在并行性概念中引入空间因素，以数量取胜的原则，通过重复设置硬件资源，大幅度提髙计算机系统的性能。随着硬件价格的降低，这种方式在单处理机中广泛使用，而多处理机本身就是实施“资源重复”原理的结果。因此资源重复可称为空间并行技术。例如：加入多个加法器、乘法器，多体存储器，阵列处理机等（3）资源共享。这是一种软件方法，它使多个任务按一定时间顺序轮流使用同一套硬件设备。例如多道程序、分时系统就是遵循“资源共享”原理而产生的，资源共享既降低了成本，又提高了计算机设备的利用率。上述三种并行性反映了计算机系统结构向高性能发展的自然趋势：一方面在单处理机内部广泛运用多种并行性措施，另一方面发展各种多计算机系统。例如：分时操作系统二、计算机指令集结构1、指令集结构的各种分类方法区别不同指令集结构的主要因素: CPU中用来存储操作数的存储单元的类型CPU中用来存储操作数的存储单元的主要类型有：堆栈结构累加器结构通用寄存器组根据操作数的来源不同，又可进一步分为:寄存器-存储器结构（RM结构）寄存器-寄存器结构（RR结构） 也称为load-store结构，这个名称强调：只有load指令和store指令能够访问存储器。对于不同类型的指令集结构，操作数的位置、个数以及操作数的给出方式（显式或隐式）也会不同。显式给出：用指令字中的操作数字段给出隐式给出：使用事先约定好的存储单元灰色块：操作数 黑色块：结果 TOS（Top Of Stack）：栈顶现代指令集结构的主流：通用寄存器结构在灵活性和提高性能方面有明显的优势。跟其他的CPU内部存储单元一样，寄存器的访问速度比存储器快。对编译器而言，能更加容易、有效地分配和使用寄存器，有效地利用寄存器来计算表达式的值。 针对（AB)-(CD)-(E*F)乘法运算任意次序，但堆栈不可以。寄存器可以用来存放变量。（1）减少对存储器的访问，加快程序的执行速度；（因为寄存器比存储器快）（2）用更少的地址位（相对于存储器地址来说）来对寄存器进行寻址，从而有效地减少程序的目标代码的大小。2、寻址方式采用多种寻址方式可以显著地减少程序的指令条数，但可能增加计算机的实现复杂度以及指令的CPI。立即数寻址方式和偏移寻址方式的使用频度最高。程序所使用的偏移量大小分布十分广泛主要是因为在存储器中所保存的数据并不是十分集中，需要使用不同的偏移量才能对其进行访问。 较小的偏移量和较大的偏移量均占有相当大的比例最常用的是较小的立即数；有时也会用到较大的立即数（主要是用于地址计算）。在指令集结构设计中，至少要将立即数的大小设置为8～16位。3、指令集结构的功能设计指令集结构的功能设计是确定软、硬件功能分配，即确定哪些基本功能应该由硬件实现，哪些功能由软件实现比较合适。在确定哪些基本功能用硬件来实现时，主要考虑3个因素：速度、成本、灵活性硬件实现的特点： 速度快、成本高、灵活性差软件实现的特点：速度慢、价格便宜、灵活性好*对指令集的基本要求：完整性、规整性、高效率、兼容性 *完整性：在一个有限可用的存储空间内，对于任何可解的问题，编制计算程序时，指令集所提供的指令足够用。规整性：主要包括对称性和均匀性。对称性：所有与指令集有关的存储单元的使用、操作码的设置等都是对称的。均匀性：指对于各种不同的操作数类型、字长、操作种类和数据存储单元，指令的设置都要同等对待。例如：在存储单元的使用上，所有通用寄存器都要同等对待。在操作码的设置上，如果设置了A-B的指令，就应该也设置B-A的指令。例如：如果某机器有5种数据表示，4种字长，两种存储单元，则要设置5×4×2=40种同一操作的指令。高效率：指指令的执行速度快、使用频度高。兼容性在设计指令集结构时，有两种截然不同的设计策略CISC和RISC(1)CISC（Complex Instruction Set Computer复杂指令集计算机）增强指令功能，把越来越多的功能交由硬件来实现，并且指令的数量也是越来越多。强化指令功能，减少程序的指令条数，以达到提高性能的目的。增强指令功能主要是从以下几个方面着手：①面向目标程序增强指令功能②面向高级语言的优化实现来改进指令集③面向操作系统的优化实现改进指令集①面向目标程序增强指令功能目标：（1）缩短程序的长度，即减少程序的空间开销（2）缩短程序的执行时间，即减少程序的时间开销途径：增强运算型指令的功能增强数据传送指令的功能增强程序控制指令的功能②面向高级语言的优化实现来改进指令集缩小高级语言与机器语言的语义差距。 高级语言与一般的机器语言的语义差距非常大，为高级语言程序的编译带来了一些问题。（1）编译器本身比较复杂。（2）编译生成的目标代码比较难以达到很好的优化。上图即改进的各种方式增强对高级语言和编译器的支持 1、对源程序中各种高级语言语句的使用频度进行统计与分析，对使用频度高、执行时间长的语句，增强有关指令的功能，加快这些指令的执行速度，或者增加专门的指令，可以达到减少目标程序的执行时间和减少目标程序长度的目的。2、增强系统结构的规整性，减少系统结构中的各种例外情况。3、间接执行高级语言机器：高级语言成为机器的汇编语言，这时高级语言和机器语言是一一对应的。用汇编的方法把高级语言源程序翻译成机器语言程序。4、直接执行高级语言的机器：直接把高级语言作为机器语言，直接由固件/硬件对高级语言源程序的语句逐条进行解释执行。这时既不用编译，也不用汇编。③面向操作系统的优化实现改进指令集缩短操作系统与计算机系统结构之间的语义差距，减少运行操作系统的时间和节省操作系统软件所占用的存储空间。改进途径：(1)通过统计操作系统中的指令和指令串的使用频度来改进（2）增设专用于操作系统的新指令(2)RISC（Reduced Instruction Set Computer精简指令集计算机）尽可能地把指令集简化，不仅指令的条数少，而且指令的功能也比较简单。CISC带来的问题：指令集庞大，指令条数很多，许多指令的功能又 很复杂，使得控制器硬件非常复杂。占用了大量的芯片面积（如占用CPU芯片总面积的一半以上），给VLSI设计造成很大的困难；增加了研制时间和成本，容易造成设计错误。RISC设计原则：指令条数少而简单。只选取使用频度很高的指令，在此基础上补充一些最有用的指令。采用简单而又统一的指令格式，并减少寻址方式；指令字长都为32位或64位。指令的执行在单个机器周期内完成。(采用流水线机制)采用load-store结构。只有load和store指令才能访问存储器，其他指令的操作都是在寄存器之间进行。大多数指令都采用硬连逻辑来实现。强调优化编译器的作用，为高级语言程序生成优化的代码。充分利用流水技术来提高性能。控制指令：控制指令是用来改变控制流的。跳转：当指令是无条件改变控制流时，称之为跳转指令。分支：当控制指令是有条件改变控制流时，则称之为分支指令。常用的3种表示分支条件的方法及其优缺点 ：转移目标地址的表示最常用的方法：在指令中提供一个偏移量，由该偏移量和程序计数器（PC）的值相加而得出目标地址。过程调用和返回：除了要改变控制流之外，可能还要保存机器状态，至少也得保存返回地址（放在专用的链接寄存器或堆栈中）。过去有些指令集结构提供了专门的保存机制来保存许多寄存器的内容。现在较新的指令集结构则要求由编译器生成load和store指令来保存或恢复寄存器的内容。4、操作数的类型和大小数据表示：计算机硬件能够直接识别、指令集可以直接调用的数据类型。所有数据类型中最常用、相对比较简单、用硬件实现比较容易的几种。数据结构：由软件进行处理和实现的各种数据类型。研究：这些数据类型的逻辑结构与物理结构之间的关系，并给出相应的算法。表示操作数类型的方法有两种：由指令中的操作码指定操作数的类型。带标志符的数据表示。给数据加上标识，由数据本身给出操作数类型。（由于需要在执行过程中动态检测标志符，动态开销比较大，所以采用这种方案的机器很少见。）操作数的大小：操作数的位数或字节数。主要的大小：字节（8位）、半字（16位）、字（32位）、双字（64位）5、指令格式的设计如何设计合适的指令格式，适用于体系结构设计。由于指令由两部分组成：操作码、地址码，所以主要的设计方法为确定指令字的编码方式，包括操作码字段和地址码字段的编码和表示方式。操作码的编码比较简单和直观：Huffman编码法：减少操作码的平均位数，但所获得的编码是变长的，不规整，不利于硬件处理。固定长度的操作码：保证操作码的译码速度。两种表示寻址方式的方法：将寻址方式编码于操作码中，由操作码描述相应操作的寻址方式。适合：处理机采用load-store结构，寻址方式只有很少几种。设置专门的地址描述符，由地址描述符表示相应操作数的寻址方式。 适合：处理机具有多种寻址方式，且指令有多个操作数。设计考虑因素：1、机器中寄存器的个数和寻址方式的数目对指令平均字长的影响以及它们对目标代码大小的影响。2、所设计的指令格式便于硬件处理，特别是流水实现。3、指令字长应该是字节（8位）的整数倍，而不能是随意的位数。指令集的3种编码格式：变长编码格式、定长编码格式、混合型编码格式6、MIPS指令集介绍MIPS64的一个子集，简称为MIPS。(1)MIPS的寄存器1、32个64位通用寄存器（GPRs）R0，R1，…，R31也被称为整数寄存器R0的值永远是02、32个64位浮点数寄存器（FPRs）F0，F1，…，F31用来存放32个单精度浮点数（32位），也可以用来存放32个双精度浮点数（64位）。存储单精度浮点数（32位）时，只用到FPR的一半，其另一半没用。3、一些特殊寄存器它们可以与通用寄存器交换数据。例如，浮点状态寄存器用来保存有关浮点操作结果的信息。(2)MIPS的数据表示1、MIPS的数据表示整数：字节（8位）、半字（16位）、字（32位）、双字（64位）浮点数：单精度浮点数（32位） 双精度浮点数（64位）2、字节、半字或者字在装入64位寄存器时，用零扩展或者用符号位扩展来填充该寄存器的剩余部分。装入以后，对它们将按照64位整数的方式进行运算。(3)MIPS的数据寻址方式1、立即数寻址与偏移量寻址(立即数字段和偏移量字段都是16位的。)2、寄存器间接寻址是通过把0作为偏移量来实现的3、16位绝对寻址是通过把R0（其值永远为0）作为基址寄存器来完成的4、MIPS的存储器是按字节寻址的，地址为64位5、所有存储器访问都必须是边界对齐的(4)MIPS的指令格式寻址方式编码到操作码中、所有的指令都是32位的、操作码占6位、3种指令格式①I类指令包括所有的load和store指令、立即数指令、分支指令、寄存器跳转指令、寄存器链接跳转指令。立即数字段为16位，用于提供立即数或偏移量。②R类指令包括ALU指令、专用寄存器读/写指令、move指令等。③J类指令包括跳转指令、跳转并链接指令、自陷指令、异常返回指令。在这类指令中，指令字的低26位是偏移量，它与PC值相加形成跳转的地址。(5) MIPS的操作MIPS指令可以分为四大类:load和store、ALU操作、分支与跳转、浮点操作符号的意义：下标：表示字段中具体的位例如：Regs[R4]0：寄存器R4的符号位、Regs[R4]56..63：R4的最低字节Mem：表示主存上标：用于表示对字段进行复制的次数。例如：0 32：一个32位长的全0字段符号##：用于两个字段的拼接，并且可以出现在数据传送的任何一边。具体指令：https://www.jianshu.com/p/ac2c9e7b1d8f(6)MIPS的控制指令由一组跳转和一组分支指令来实现控制流的改变①跳转指令根据跳转指令确定目标地址的方式不同以及跳转时是否链接，可以把跳转指令分成4种。确定目标地址的方式:把指令中的26位偏移量左移2位（因为指令字长都是4个字节）后，替换程序计数器的低28位。间接跳转：由指令中指定的一个寄存器来给出转移目标地址。跳转的两种类型：简单跳转：把目标地址送入程序计数器。跳转并链接：把目标地址送入程序计数器，把返回地址（即顺序下一条指令的地址）放入寄存器R31。②分支指令（条件转移）分支条件由指令确定。例如：测试某个寄存器的值是否为零提供一组比较指令，用于比较两个寄存器的值。例如：“置小于”指令有的分支指令可以直接判断寄存器内容是否为负，或者比较两个寄存器是否相等。分支的目标地址。由16位带符号偏移量左移两位后和PC相加的结果来决定一条浮点条件分支指令：通过测试浮点状态寄存器来决定是否进行分支。(7)MIPS的浮点操作由操作码指出操作数是单精度（SP）或双精度（DP）,包括加、减、乘、除，分别有单精度和双精度指令。后缀S：表示操作数是单精度浮点数后缀D：表示是双精度浮点数浮点数比较指令：根据比较结果设置浮点状态寄存器中的某一位，以便于后面的分支指令BC1T（若真则分支）或BC1F（若假则分支）测试该位，以决定是否进行分支。]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>计算机体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web系统设计【二】]]></title>
    <url>%2Fposts%2Ffa91900c%2F</url>
    <content type="text"><![CDATA[一、前端技术三大基础HTML：决定网页的结构CSS：决定网页的样式JavaScript：增加与用户的交互二、HTML1、HTML结构(1)doctype 声明它告诉浏览器以下文件用html哪个版本解析例如：&lt;!DOCTYPE html&gt;代表HTML5版本声明(2)元素一对标签和中间的内容称为一个元素(3)head元素它元素包含描述文档本身的 metadata 信息，以及相关的资源，比如 JS 脚本和 CSS样式。除了title元素之外,head 还可以包含:base 定义了页面上的链接或资源的 baseURL, 打开链接内容所对应的基地址。link 指向某种类型的资源, 通常是CSS样式表, 提供了如何展示网页上各种元素的说明。meta 提供了额外的信息; 例如, 字符编码, 页面的内容摘要, 指示搜索引擎是否应该索引内容, 等等。object 代表一个通用的、多功能的媒体对象容器script 用于嵌入脚本, 或者引入外部脚本.style 用于嵌入样式(页面内).这些元素都是可选的, 可以是任意顺序。注意, 这里的元素不会展示在页面内, 但他们可以影响页面上展示的内容, 这些内容都在 body 元素内定义。(4)body 元素就是网页的主题显示内容2、标签html 标签对应的英文(1)标题、段落、段内换行、段内分组、预留格式、水平线标题(headline)：&lt;h1~h6&gt;&lt;/h1~h6&gt;h1~h6具有默认的标题大小，但是我们也可以通过CSS样式进行改变段落(paragraph)：&lt;p&gt;&lt;/p&gt;段落的文字自动分行会随着浏览器改变大小而改变段落后自带一个空行段落中多个空格和换行都会被省略为一个空格段内换行(break):&lt;br/&gt;预留格式(preformatted)：&lt;pre&gt;&lt;/pre&gt;预留格式内容显示会原封不动显示出来，不会省略换行和空格段内组合(span)&lt;span&gt;&lt;span/&gt;组合内的内容可通过CSS进行设计水平线(rorizontal rule):&lt;hr&gt;&lt;/hr&gt;(2)超链接、图片超链接(anchor)：&lt;a&gt;&lt;/a&gt;重要属性hrefHypertext Reference连接到本站其它网页&lt;a href=&quot;网页文件&quot;&gt;&lt;/a&gt;连接到其它站点&lt;a href=&quot;http:XXX&quot;&gt;&lt;/a&gt;虚拟超链接&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;常用于尚未准备好链接到哪儿，等待后需添加内部可嵌套图片标记，代表图片作为超链接使用id属性和#id设置文章的跳转锚点target属性，选择新建窗口跳转，还是本页面跳转等图片(image):&lt;img src=&quot;&quot; alt=&quot;&quot;/&gt;src表示图片路径，alt表示图片未加载显示的文字绝对路径插入图片，就是从盘符开始的图片文件地址相对路径插入图片：从网页所在目录为默认地址..表示向前一个文件夹以此查找文件,若开始即为/则从网站根目录开始当然也可以通过URI来定位图片在CSS中设置img样式，使用img标签，需要特指就配合后代选择器等其他选择器使用例如:注意是img 不是image！！跳转书写：../代表该文件所在目录的上一级文件夹，可多次使用以/开始，代表根目录文件夹开始以文件名开始，代表本目录下文件或者文件夹(3)区域、列表、表格区域(division):&lt;div&gt;&lt;/div&gt;列表无序列表(Unordered List):&lt;ul&gt;&lt;/ul&gt;+&lt;li&gt;&lt;/li&gt;有序列表(Ordered List):&lt;ol&gt;&lt;/ol&gt;+&lt;li&gt;&lt;/li&gt;可在列表中使用的表格标签：dl dt ddlist-style-type：选择标记符号的类型none|disc|circle|square|decimal|decimal-leading-zero|lower-alpha|upper-alpha|lower-latin|upper-latin|lower-roman|upper-roman|lower-greeklist-style-position：inside | outside属性允许将圆点拉回内容区域list-style-image：&lt;url&gt; | none属性将自己的图像作为圆点自定义列表(Definition List)、自定义条目(Definition Term):&lt;dl&gt;&lt;/dl&gt;+&lt;dt&gt;&lt;dt&gt;表格(table):&lt;table&gt;&lt;/table&gt;表格标题(table headline):&lt;th&gt;&lt;/th&gt;表格行(table row):&lt;tr&gt;&lt;/tr&gt;表格数据(table data):&lt;td&gt;&lt;/td&gt;单元格中内容的外观和对齐方式，使用格式化文本和背景等属性处理表格和单元格本身样式，使用padding、margin和border等属性cellpadding 属性:表格单元边界与单元内容之间的间距, 设置为0则无边距empty-cells：show | hide 设置空单元格，决定没有可见内容的单元格的边框和背景是否隐藏掉。border-collapse：定表格的边框是分开的还是合并的合并（collapsed ）分隔（separated）：当相邻单元格边框样式不同时如果任意一个单元格的border-style属性被设置为hidden值，那么边框将不会显示边框的宽度：宽边优于窄边如果所有其他属性值都相等，就要归结为样式的问题了，边框样式按优先级从大到小排列：double, solid, dashed, dotted, ridge, outset, groove和insetborder-spacing：指定相邻单元格边框之间的距离，只适用于border-collapse是separate时有两个长度值，其中水平值在前，并应用于列间，垂直值在后，并应用于行间；如果只提供一个值，那么该值用于水平和垂直两个方向(4)表单和表单元素表单是一个区域，采集用户信息。他可以包括文本框、按钮、单选、复选、下拉框、文本域等表单元素。通过input、select、textarea三大表单元素构成表单中有一个重要的属性action，它将收集的数据交由哪个页面处理，当然这是后端的页面。表单(form):&lt;form&gt;&lt;/form&gt;&lt;input/&gt;元素通过设置该元素的type属性，可以将表单表示为文本框、密码框、单选框等等该元素中含有一个name属性，在传送到后端处理的时候，可通过name区分到底是哪个表单元素传过来的内容文本框text：&lt;input type=&quot;text&quot; name=&quot;A&quot;/&gt;placeholder属性设置未输入时文本密码框password&lt;input type=&quot;password&quot; name=&quot;B&quot;/&gt;提交按钮submit&lt;input type=&quot;submit&quot; name=&quot;C&quot; value=&quot;提交&quot;/&gt; 这里value=”提交”将会设置按钮的文字，同理重置按钮也一样,这里也需要注意，提交按钮是指提交所有该表单内的数据给后端;提交方式get和post，数据多时一般使用post，get方式数据会显示在URL中，post不会，它是封装的重置按钮reset&lt;input type=&quot;reset&quot; name=&quot;D&quot; value=&quot;重置&quot;/&gt;单选框radio&lt;input type=&quot;radio&quot; name=&quot;E&quot; value=&quot;1&quot;/&gt; 而这里value=””的内容是提交到后端的数据,同理，复选框也是这样复选框checkbox&lt;input type=&quot;checkbox&quot; name=&quot;F&quot; value=&quot;2&quot;/&gt;注意：单选框中，若要将几个单选框设置为一组，只能选一个，则要把name属性设置为相同对于需要设置默认选择的选择项可以添加checked=&quot;checked&quot;属性下拉列表框&lt;select&gt;&lt;/select&gt;+&lt;option&gt;&lt;/option&gt;实现option的selected选项可设置为select=&quot;selected&quot;表示默认被选中项表单的传输中若不设置value则默认传输中间的内容，否则按照value的值传输文本域&lt;textarea rols=&quot;行数&quot; cols=&quot;列数&quot;&gt;默认文本&lt;/textarea&gt;，中间的文字会被作为默认显示处理按钮&lt;button&gt;按钮名称&lt;/button&gt;设置按钮，可以使用点击即可传递值的功能还可以通过 onclick属性等实现点击互动三、CSS样式CSS（Cascading Style Sheets，层叠样式单）是W3C协会为弥补HTML在显示属性设定上的不足而制定的一套扩展样式标准,最新版为CSS3（IE9以上支持)我们可以用CSS来控制网页显示的格式。字体大小、位置、颜色、文字对齐方式、图片长宽、鼠标的形状等网页显示的格式，它们也是网页的重要内容。1、 CSS的语法选择器属性值2、CSS的添加方法（1）行内添加就是使用style属性,将css直接写在html标签中例如：1&lt;p style="color:red"&gt;这行段落将显示为红色。&lt;/p&gt;(2)嵌入式样式使用&lt;style&gt;&lt;/style&gt;标签嵌入到html文件的头部注意：内嵌样式只作用于本页面1234567&lt;head&gt; &lt;style type="text/css"&gt; .class&#123; color:red; &#125; &lt;/style&gt;&lt;/head&gt;(3)外部式表①（常用）使用&lt;link/&gt;标签及其属性添加外部CSS文件123&lt;head&gt;&lt;link href="文件名.css" rel="stylesheet" type="text/css"&gt;&lt;/head&gt;rel：relationship定义链接的文件和HTML文档之间的关系。type:规定被链接文档的 MIME 类型,该属性最常见的 MIME 类型是 “text/css”，该类型描述样式表。媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式。分号前面表示文件的大类，后面属于这个大类的何种类型。text/css表示文本文件，以css方式读取处理.浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理URL，因此Web服务器在响应头中添加正确的MIME类型非常重要。如果配置不正确，浏览器可能会曲解文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。详细MIME类型一般情况下rel=”stylesheet” type=”text/css” 是固定写法不可修改②使用import在style标签中导入css文件。12345&lt;style type="text/css"&gt; @import url(demo.css); 或者 @import "demo.css";&lt;/style&gt;多重样式可以重叠，可以覆盖，原则是“就近原则”可以在.css文档中通过@import引用其他的.css文档可导入多个样式表，后面的规则优先于前面的，也就是覆盖，或者说就近3、基本CSS选择器(1)标签选择器它会作用在所有的该标签上123p&#123; background-color:yellow;&#125;(2)【常用】类选择器类选择器是指定类的所有元素的样式定义为.+名称+{属性：值}使用时，在标签中加入class=&quot;选中类&quot;(3)ID选择器id选择器指定具有ID的元素的样式。和类选择器的区别就是ID选择器只能使用一次定义为#+名称+{属性：值}使用时，在标签中加入id=&quot;选中id&quot;4、复杂选择器(1)后代选择器(层次选择器)语法：标签+空格+标签+主题属性和值，可嵌套多重，只有满足这种嵌套关系的标签元素才会使用该样式12345678&lt;style type="text/css"&gt; p span&#123; color:red; &#125;&lt;/style&gt;&lt;p&gt;&lt;span&gt;天使投资&lt;/span&gt;是投资方式的一种&lt;/p&gt;&lt;div&gt;&lt;span&gt;天使投资&lt;/span&gt;是投资方式的一种&lt;/div&gt;(2)子选择器语法：标签+&gt;+标签+主题属性和值 与后代选择器相比，子选择器只能选择作为某元素直接子元素的元素缩小了范围例如：12345 &lt;style type="text/css"&gt; h1 &gt; strong &#123; color : red ; &#125; &lt;/style&gt;&lt;h1&gt;This is &lt;strong&gt;very&lt;/strong&gt; &lt;strong&gt;very&lt;/strong&gt; important. &lt;h1&gt; &lt;h1&gt;This is &lt;em&gt; really &lt;strong&gt; very &lt;/strong&gt; &lt;/em&gt; important.&lt;/h1&gt;只有第一行会有效。(3)相邻兄弟选择器语法：标签+++标签+主题属性和值 选择紧接在另一元素后的元素，且二者有相同父元素,用一个+只能选择两个相邻兄弟中的第二个元素12345678910111213&lt;style type="text/css"&gt; li + li &#123; font-weight : bold ; &#125; &lt;/style&gt;&lt;ul&gt; &lt;li&gt;List item 1&lt;/li&gt; &lt;li&gt;List item 2&lt;/li&gt; &lt;li&gt;List item 3&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;List item 1&lt;/li&gt; &lt;li&gt;List item 2&lt;/li&gt; &lt;li&gt;List item 3&lt;/li&gt; &lt;/ol&gt;根据特性，列表的第一行不会实现样式(4)交集选择器交集选择器是由两个选择器直接连接构成，其中第1个必须是标记选择器，第2个必须是类别选择器或者ID选择器，两个选择器要连续书写，中间不加空格结果是二者各自元素范围的交集。如：标签1标签2标签3{属性：值；} 最终找到同时满足标签1，标签2，标签3的标签。1234567891011121314&lt;style type="text/css"&gt; *&#123;margin:0;&#125; div&#123; border-style:solid; border-width:8px; border-color:blue; margin:20px; &#125; div.al&#123;border-color:green; background:#ccc; &#125;.al&#123; border-style:dashed; &#125; &lt;div&gt;普通效果&lt;/div&gt; &lt;div class="al"&gt;交集选择器效果&lt;/div&gt; &lt;p class="al"&gt;类选择器效果&lt;/p&gt;(5)并集选择器语法：标签+逗号+标签+主题属性和值可设置多个，这两种或者多种标签，都使用后面的相同样式123456789&lt;style type="text/css"&gt; h1,p &#123; text-align:center; &#125; &lt;/style&gt;&lt;body&gt; &lt;h1&gt;欢迎访问论坛&lt;/h1&gt; &lt;p&gt;欢迎访问论坛&lt;/p&gt; &lt;/body&gt;(6)属性选择器属性选择器可以根据元素的属性及属性值来选择元素 ,属性选择器把所需属性列在方括号([ ])中例如：1234a[title] &#123;color: red;&#125; /*包含标题的所有元素变为红色 */ a[href] &#123;color: red;&#125; /*只对有href属性的a元素应用样式*/ a[href][title] &#123;color: red;&#125; /*将同时有href和title属性的a设置为红色*/ a[href=“http://www.w3school.com.cn/about_us.asp”] &#123;color: red;&#125;/*根据具体属性值来选择该元素*/ a[href=“http://www.w3school.com.cn/”][title=“W3School”] &#123;color: red;&#125; /*多个属性-值选择器链接在一起选择该元素*/(7)伪类选择器在CSS中，可以给每一种状态的链接应用样式，只需通过使用叫做伪类选择器的选择器进行设置。伪类用冒号:表示例如：对超链接的各种状态进行设置。(8)伪元素选择器伪类不是唯一的伪选择器，为了满足排版的需要，可以将虚拟元素插入到文档中.伪元素也用冒号: 表示1、首行伪元素:first-line该选择器在特定元素的首行应用样式规则，能应用的属性只有：color font background word-spacing letter-spacing text-decoration vertical-align text-transform line-height123456789p:first-line &#123;color: #ff0000;font-variant: small-caps&#125;&lt;p&gt;You can use the :first-line pseudo-element to add a special effect to the first line of a text!&lt;/p&gt;2、首字母伪元素:first-letter该选择器在特定元素的首字母应用样式规则，能应用的属性只有：color font text-decoration text-transform vertical-align background margin padding border float word-spacing letter-spacing12345678p:first-letter &#123;color: #ff0000;font-size:xx-large&#125;&lt;p&gt;You can use the :first-letter pseudo-element to add a special effect to the first letter of a text!&lt;/p&gt;3、before伪元素:before用于在被选元素的内容前面插入内容，必须配合content属性来指定要插入的具体内容。12345678&lt;style type="text/css"&gt;h1:before &#123;content:url(images/heart.png)&#125;&lt;/style&gt;&lt;h1&gt;This is a heading&lt;/h1&gt;&lt;p&gt;The :before pseudo-element inserts content before an element.&lt;/p&gt;&lt;h1&gt;This is a heading&lt;/h1&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;如果已规定 !DOCTYPE，那么 Internet Explorer 8 （以及更高版本）支持 content 属性。4、after伪元素:afterafter伪元素选择器用于在某个元素之后插入一些内容，使用方法与:before选择器相同。(9)其他~：p~ul选择前面有&lt;p&gt;元素的每个&lt;ul&gt;元素，即选择p之后出现的所有ul，两种元素必须拥有相同的父元素，但ul不必紧随p。:nth-child() 选择器，选择规定属于其父元素的第n个子元素Odd 和 even 是可用于匹配下标是奇数或偶数的子元素的关键词。p:nth-child(odd)、p:nth-child(even)p:nth-child(an+b)：a表示周期的长度，n 是计数器（从 0 开始），b 是偏移值。p:nth-child(3n+0)指定了下标是 3 的倍数的所有 p 元素:nth-of-type(n) 选择器匹配属于父元素的特定类型的第 N 个子元素的每个元素.n 可以是数字、关键词或公式。5、选择器的多种声明用法(1)全局声明语法：*+主题属性和值,对本网页中所有标签都使用该样式1234567891011&lt;style type="text/css"&gt; * &#123; text-align:center; &#125; &lt;/style&gt;body&gt; &lt;h1&gt;欢迎访问论坛&lt;/h1&gt; &lt;p&gt;欢迎访问论坛&lt;/p&gt; &lt;h2&gt;欢迎访问论坛&lt;/h2&gt; &lt;/body&gt;(2)混合使用6、继承和优先级(1)继承当使用 p 元素作为选择器编写一个字体相关的样式规则时，规则将应用于文档中所有的段落和这些段落包含的内联文本与字体相关的属性不能应用于图像有些样式表属性能继承，有些不行，比如边框应用于具体元素的任何属性将覆盖该属性的继承值(2)优先级根据样式表的使用判断优先级:就近原则:内联样式表（由开标签中的 style 属性添加）》文档样式表（由style元素添加）》导入的样式表（使用 @import 功能添加）》链接的外部样式表（用 link 元素添加）同一个样式表中的两个规则冲突时，可根据选择器的类型决定优先级越特殊的样式，优先级越高：内联样式 &gt; ID选择器 &gt; 类选择器 &gt; 后代选择器 &gt; 元素选择器若选择器优先级也相同，则最终按照就近原则判断。即样式表和选择器优先级相同且冲突则列表中最后出现的规则起作用例如:12345&lt;style type="text/css"&gt; p &#123;color:red;&#125; p &#123;color:blue;&#125; p &#123;color:green;&#125; &lt;/style&gt;最终生效的是p {color:green;}]]></content>
      <categories>
        <category>Web系统设计</category>
      </categories>
      <tags>
        <tag>Web系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统概论【一】]]></title>
    <url>%2Fposts%2F6f848aeb%2F</url>
    <content type="text"><![CDATA[一、初识数据库1、数据库的4个基本概念(1) 数据（Data）定义:描述事物的符号记录例如：数字、文字、图形、图像、音频、视频、学生的档案记录等。因为是描述事物的符号记录，所以数据的含义和语义是不可分的就像数字93在不同语句能代表不同含义(2)数据库（Database，DB）定义：长期储存在计算机内、有组织的、可共享的大量数据的集合(3)数据库管理系统（DataBase Management System，DBMS）本质：软件位于用户与操作系统之间的一层数据管理软件，是基础软件，是一个大型复杂的软件系统通过各种语言实现数据库的定义（DDL）、操纵（DML）、控制（DCL）、维护功能DDL（Data Definition Languages）语句：数据定义语言，这些语句定义了不同的数据段、数据库、表、列、索引等数据库对象的定义。常用的语句关键字主要包括 create、drop、alter等。DML（Data Manipulation Language）语句：数据操纵语句，用于添加、删除、更新和查询数据库记录，并检查数据完整性，常用的语句关键字主要包括 insert、delete、udpate 和select 等。(增添改查）DCL（Data Control Language）语句：数据控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括 grant、revoke 等。一条数据库语言相当于高级语言的一个或多个循环程序(4）数据库系统（DataBase System,DBS）定义：指在计算机系统中引入数据库后的系统构成。在不引起混淆的情况下常常把数据库系统简称为数据库。包含：数据库数据库管理系统（及其应用开发工具）应用程序数据库管理员（DataBase Administrator，DBA）计算机基本环境2、数据库系统的特点(1) 数据结构化数据的整体结构化是数据库的主要特征之一不再仅仅针对某一个应用，而是面向整个企业或组织不仅数据内部结构化，整体是结构化的，数据之间具有联系数据记录可以变长数据的最小存取单位是数据项数据用数据模型描述，无需应用程序定义(2) 数据的共享性高，冗余度低且易扩充数据面向整个系统，可以被多个用户、多个应用共享使用(3) 数据独立性高物理独立性 指用户的应用程序与数据库中数据的物理存储是相互独立的。当数据的物理存储改变了，应用程序不用改变。逻辑独立性指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，应用程序不用改变。数据独立性由数据库管理系统的二级映像功能来保证。(4) 数据由数据库管理系统统一管理和控制3、数据模型数据模型是对现实世界数据特征的抽象。通俗地讲数据模型就是现实世界的模拟。它是数据库系统的核心和基础数据模型分为两类（两个不同的层次）概念模型、逻辑模型和物理模型注意！是数据模型分为这两类，和数据模型的组成要素要分清(1) 概念模型（信息模型）它是按用户的观点来对数据和信息建模，用于数据库设计。概念模型的一种表示方法：实体-联系方法（Entity-Relationship Approach）用E-R图来描述现实世界的概念模型 E-R方法也称为E-R模型。(2) 逻辑模型和物理模型逻辑模型：按计算机系统的观点对数据建模，用于DBMS实现。逻辑模型主要包括网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型等。物理模型：描述数据在系统内（磁盘上）的表示方式和存取方法。由现实的使用的机器设计和操作系统控制，计算机通过DBMS自动存储。在信息世界中，我们对一个实体的抽象：(3)两个层次之间的 关系4、数据模型的组成要素由于数据模型是对现实世界数据特征的抽象，所以数据模型是严格定义的一组概念的集合，它精确地描述了系统的静态特性、动态特性和完整性约束条件(Integrity Constraints)。这也就是数据模型的三大组成要素(1) 数据结构–描述系统的静态特性数据结构是刻画数据模型性质的重要方面，用来描述数据库的组成对象–对象的类型、内容、性质和描述对象之间的联系一般用数据结构的类型来命名数据模型，例如:层次结构-层次模型、网状结构–网状模型、关系结构—关系模型(2)数据操作–描述系统的动态特性数据操作是对数据库中各种对象的实例允许执行的操作的集合包括操作及有关的操作规则(3)完整性约束完整性约束:给定的数据模型中数据及其联系所具有的制约和依存规则。通俗的讲，就是根据现实，我们的数据和联系需要一定的约束条件，例如一个人年龄不可能大于300等，但是注意约束不仅仅指的是值约束，比如厨师实体型不能插入教师实体集中，就需要有这种限制。总之就是符合实际和我们的使用需要，以及符合相应的数据模型设定5、常用数据模型上个世纪七八十年代使用层次和网状模型，由于逐渐复杂，且使用趋于程序化，当关系模型出现后很多应用很快被关系模型替代，现在最常用的是关系模型(1)层次模型层次模型用树形结构来表示各类实体以及实体间的联系，用记录类型描述每个结点表示一个记录类型（实体）用字段描述每个记录类型可包含若干个字段，用结点之间的连线表示记录类型（实体）之间的一对多的父子联系类比我们现在面对对象的树设计，对象、属性、方法层次模型的定义：满足下面两个条件的基本层次联系的集合为层次模型有且只有一个结点没有双亲结点，这个结点称为根结点根以外的其它结点有且只有一个双亲结点特点：结点的双亲是唯一的只能直接处理一对多的实体联系任何记录值只有按其路径查看没有一个子女记录值能够脱离双亲记录值而独立存在层次模型的完整性约束条件无相应的双亲结点值就不能插入子女结点值如果删除双亲结点值，则相应的子女结点值也被同时删除更新操作时，应更新所有相应记录，以保证数据的一致性(2)网状模型网状数据库系统采用网状结构来表示各类实体以及实体间的联系，用记录类型描述每个结点表示一个记录类型（实体）用字段描述每个记录类型可包含若干个字段，用结点之间的连线表示记录类型（实体）之间的一对多的父子联系。（表示方法与层次模型相同）类比我们现在面对对象的图设计，对象、属性、方法网状模型的定义：满足下面两个条件的基本层次联系的集合允许一个以上的结点无双亲一个结点可以有多于一个的双亲特点：允许多个结点没有双亲结点，允许一个结点有多个双亲结点允许两个结点之间有多种联系，要为每个联系命名并指出与该联系有关的双亲记录和子女记录表示多对多的方法将多对多联系分解成一对多联系间接表示多对多联系网状模型的完整性约束条件不严格允许插入尚未确定双亲结点值的子女结点值允许只删除双亲结点值但是实际的网状数据库系统提供了一定的完整性约束(3)关系模型关系模型最大的进步，就是摆脱了层次、网状中需要的冗杂指针系统。关系模型的数据结构在用户观点下，关系模型中数据的逻辑结构是一张二维表。关系必须是规范化的，满足一定的规范条件！最基本的规范条件：关系的每一个分量必须是一个不可分的数据项，不允许表中还有表。下图就是不规范的，不符合关系模型要求关系术语一般表格的术语关系名表名关系模式表头（表格的描述）关系（一张）二维表元组记录或行属性字段、列属性名列名属性值列值分量一条记录中的一个列值非规范关系表中有表（大表中嵌有小表）关系模型的操纵与完整性约束关系模型的数据操作是集合操作（增删改查），操作对象和操作结果都是关系存取路径对用户隐蔽，用户只要指出“找什么”，不必详细说明“怎么找”。这样就提高了数据的独立性，提高了用户生产率。但是设计DBMS的人员也就要对用户的查询请求进行优化，增加了开发数据库管理系统的难度，层次和网状数据库这两类系统虽然有它们的缺点，但是执行效率高是他们的显著优点关系的完整性约束条件：【实体完整性、参照完整性】—》关系的两个不变性（在详细介绍关系模型时进行深入了解）用户定义的完整性二、数据库系统的结构和组成1、数据库系统的结构（1）模式的概念数据模型组成要素：数据结构、数据操纵、约束，所以数据模型包含模式，但是这里模式并不是单指静态特征，更像是静态特征+部分约束数据模型是对模式本身结构的抽象，模式是对数据本身结构形式的抽象（2）三级模式①模式（这里指逻辑模式，中间模式）它是数据库中全体数据的逻辑结构和特征的描述DBMS提供模式描述语言（模式DDL）来严格地定义模式。②外模式（子模式或用户模式）数据库用户使用的局部数据的逻辑结构和特征的描述外模式通常是模式的子集、一个模式可以有多个外模式 反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求DBMS提供外模式定义语言（外模式DDL）来严格定义外模式。③内模式（存储模式）数据物理结构和存储方式的描述例如，记录的存储方式是顺序存储、按照B树结构存储还是按hash方法存储;索引按照什么方式组织;数据是否压缩存储，是否加密;数据的存储记录结构有何规定注意：不同的方法存储，数据在硬件上的存储方式是不一样的。内模式的物理性主要体现在操作系统及文件级上，它还不深入到设备级上(如磁盘及磁盘操作)，但近年来有向设备级发展的趋势(如原始磁盘、磁盘分块技术等)DBMS提供内模式描述语言（内模式DDL/存储模式DDL）来严格定义内模式。推荐阅读：数据库模式数据库模式（三级模式+两级映射）（3）两层映像①外模式到模式的映像​ 外模式到概念模式的映射给出了外模式与概念模式的对应关系，这种映射一般由DBMS实现(SQL实现)。②模式到内模式的映像该映射给出了概念模式中数据的全局逻辑结构到数据的物理存储结构间的对应关系，此种映射一般由DBMS实现(内部算法实现)。③理解例如，我们的外模式下想找数据A，通过某一映射F(x)，能在模式中找到B，而数据B通过映射F(y)，能够找到在物理上存储的数据C。当然F(x)F(y)都是打比方（4）三级模式两层映像和数据独立性的关系数据的独立性是由DBMS的二级映像功能来保证的。数据的独立性包括数据的物理独立性和数据的逻辑独立性。①数据的物理独立性数据的物理独立性是指当数据库的内模式发生改变时，数据的的逻辑结构不变。由于应用程序处理的只是数据的逻辑结构，这样物理独立性可以保证，当数据的物理结构改变了，应用程序不用改变。但是，为了保证应用程序能够正确执行，需要修改概念模式/内模式之间的映像。数据C的存储方式变了，只需要修改F(y)②数据的逻辑独立性数据的逻辑独立性是指用户的应用程序与数据库结构是相互独立的。数据的逻辑结构发生变化后，用户程序也可以不修改。但是，为了保证应用程序能够正确执行，需要修改外模式/概念模式之间的映像。数据B的存储方式变了，只需要修改F(x)2、数据库系统的组成包含：数据库数据库管理系统（及其应用开发工具）应用程序数据库管理员（DataBase Administrator，DBA）计算机基本环境不同的人员涉及不同的数据抽象级别，具有不同的数据视图三、总结]]></content>
      <categories>
        <category>数据库系统概论</category>
      </categories>
      <tags>
        <tag>数据库系统概论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程【一】]]></title>
    <url>%2Fposts%2F9a13d3f9%2F</url>
    <content type="text"><![CDATA[一、软件工程的基本概念1、软件危机的出现软件=程序+数据+文档软件危机指在计算机软件的开发和维护过程中所遇到的一系列严重问题。2、如何消除软件工程：管理+技术软件工程是：1把系统的、规范的、可度量的途径应用于软件开发、运行和维护过程，也就是把工程应用于软件；2研究1中提到的途径3、软件工程的基本原理和知识体系1.用分阶段的生命周期计划严格管理2.坚持进行阶段评审3.实行严格的产品控制4.采用现代程序设计技术5.结果应能清楚的审查6.开发小组的人员应少而精7.承认不断改进软件工程实践的必要性4、软件工程方法学软件工程方法学包含三个要素：方法、工具、过程方法和过程区别：方法指的是大方向我们怎么做，更多倾向于技术性，过程是指的是一系列任务框架，规定工作步骤，倾向于管理性、计划性目前使用得最广泛的软件工程方法学是传统方法学和面向对象方法学（1）传统方法学传统方法学也称为生命周期方法学或结构化范型。它采用结构化技术(结构化分析、结构化设计和结构化实现)来完成软件开发的各项任务，并使用适当的软件工具或软件工程环境来支持结构化技术的运用。传统方法学的特点：传统方法学把软件生命周期的全过程依次划分为若干个阶段，然后顺序地完成每个阶段的任务。每个阶段的开始和结束都有严格标准，对于任何两个相邻的阶段而言，前一阶段的结束标准就是后一阶段的开始标准。（2）面向对象方法学与传统方法相反，面向对象方法把数据和行为看成是同等重要的，它是一种以数据为主线，把数据和对数据的操作紧密地结合起来的方法。它尽量模拟人类习惯的思维方式，使开发软件的方法与过程尽可能接近人类认识世界、解决问题的方法与过程，从而使描述问题的问题空间(也称为问题域)与实现解法的解空间(也称为求解域)在结构上尽可能一致。（3）敏捷软件开发个体和交互 胜过 过程和工具可以工作的软件 胜过 面面俱到的文档客户合作 胜过 合同谈判响应变化 胜过 遵循计划敏捷编程即软件行业力图适应现代商业环境的具体表现！以“瀑布模型”为代表的传统软件开发模型针对软件生命周期的各个阶段提供了一套规范,这种基于计划的生命周期的软件开发方法曾极大地促进了软件行业的发展，但现如今却愈感“有心无力”。为了适应现代的商业环境与之对应的“敏捷编程”的开发方法提了出来。包括诸如“极限编程”、自适应软件开发和功能驱动开发等。5、软件生命周期软件生命周期由软件定义、软件开发和运行维护(也称为软件维护)3个时期组成，每个时期又进一步划分成若干个阶段。6、软件过程（软件开发过程）实际从事软件开发工作时，软件规模、类型、开发环境及技术方法等因素会影响到阶段划分，及各阶段的执行顺序，不可能完全准确就是上述8个阶段，由此了形成不同生存周期模型，又称过程模型。软件过程模型是为了获得高质量软件所需要完成的一系列任务框架，它规定了完成各项任务的工作步骤。通常使用生命周期模型简洁地描述软件过程（1）瀑布模型现在仍是应用最广泛的过程模型，主要用于传统软件工程方法学的软件过程特点：阶段间具有顺序性和依赖性必须前一工作做完才能进行后一工作前一阶段的输出为后一阶段的输入推迟实现的观点瀑布模型在编码之前设置了系统分析与系统设计的各个阶段，分析与设计阶段的基本任务规定，在这两个阶段主要考虑目标系统的逻辑模型，不涉及软件的物理实现。可以将编码测试等物理实现推迟保证前期工作扎实质量保证的观点合格文档的完成是阶段结束的标志,必须完成规定的文档，且每个阶段结束前都要评审所完成的文档。毕竟万一后期有错，修改成本太高实际上不可能这么理想，所以是带反馈环的，发现不妥就要重新返回修复后再继续优点：瀑布模型的成功在很大程度上是由于它基本上是一种文档驱动的模型，质量有较大保证缺点：由于瀑布模型完全依赖于书面的规格说明，很可能导致最终开发出的软件不能真正满足用户的需要。瀑布模型适用于功能明确、无变化的系统开发，如操作系统、财务系统等（2）快速原型模型快速原型是快速建立起来的可以在计算机上运行的程序，它所能完成的功能往往是最终产品能完成的功能的一个子集。特点：线性开发模型、无反馈环快速建立一个大致符合要求的可运行程序——》用户评定给出意见修改完善细节需求——》不断重复完善和评定阶段直到认可——》整体实现，维护快速原型模型使用于需求动态变化，事先难以确定系统（3）增量模型使用增量模型开发软件时，把软件产品作为一系列的增量构件来设计、编码、集成和测试。每个构件由多个相互作用的模块构成，并且能够完成特定的功能。使用增量模型时，第一个增量构件往往实现软件的基本需求，提供最核心的功能。特点：模块化结构化更具风险的增量模型：（4）螺旋模型螺旋模型将瀑布模型和快速原型结合起来强调了其他模型忽视的风险分析。螺旋模型是一种演化软件开发过程的模型，它兼顾了快速原型的迭代特征和瀑布模型的系统化与严格监控。特点：风险分析缺点：对风险分析的依赖程度较高（5）极限编程(eXtreme Programming，XP)首先，项目组针对客户代表提出的“用户故事” 进行讨论，提出隐喻，在此项活动中可能需要对体系结构进行“试探” 。然后，项目组在隐喻和用户故事的基础上，根据客户设定的优先级制订交付计划。接下来开始多个迭代过程（通常每个迭代历时1~3周），在迭代期内产生的新用户故事不在本次迭代内解决，以保证本次开发过程不受干扰。开发出的新版本软件通过验收测试之后交付用户使用。几种模型间的对比：传统的瀑布式开发，也就是从需求到设计，从设计到编码，从编码到测试，从测试到提交大概这样的流程，要求每一个开发阶段都要做到最好。特别是前期阶段，设计的越完美，提交后的成本损失就越少。迭代式开发，不要求每一个阶段的任务做的都是最完美的，而是明明知道还有很多不足的地方，却偏偏不去完善它，而是把主要功能先搭建起来为目的，以最短的时间，最少的损失先完成一个“不完美的成果物”直至提交。然后再通过客户或用户的反馈信息，在这个“不完美的成果物”上逐步进行完善。螺旋开发，很大程度上是一种风险驱动的方法体系，因为在每个阶段之前及经常发生的循环之前，都必须首先进行风险评估。敏捷开发，相比迭代式开发两者都强调在较短的开发周期提交软件，但是，敏捷开发的周期可能更短，并且更加强调队伍中的高度协作。敏捷方法有时候被误认为是无计划性和纪律性的方法，实际上更确切的说法是敏捷方法强调适应性而非预见性。（6）其他模型喷泉模型:无缝，可同步开发，提高开发效率，节省开发时间， 适应面向对象软件Rational统一过程微软过程二、可行性研究摘录：可行性分析【软件工程总结】软件工程之可行性研究1、什么是可行性研究可行性研究是软件开发生命周期中的第一个阶段，是一种分析、评价各种建设方案和生产经营决策的科学方法。它通过对建设项目的主要问题，如市场需求、资源条件、原料、燃料、动力供应条件、建设规模、设备选型等，从技术、经济、工程等方面进行调查研究，分析比较，并对这个项目建成后可能取得的技术经济效果进行预测，从而提出该项目是否值得投资和怎样进行建设的意见，为项目决策提供可靠的依据，进而避免人力、物力和财力上的浪费。可行性研究的目的：可行性研究的目的不是解决问题，而是确定问题是否值得去解决。用最小的代价在尽可能短的时间内确定问题是否能够解决。简单说，就是它能不能做，值不值得做，怎么做以小换大。主要研究内容：（1）经济可行性，经济可行性研究主要进行成本效益分析（2）技术可行性， 现有的技术能不能实行现在得开发，是否有相应的开发人员（3）操作的可行性，系统能不能实现客户的要求（4）法律可行性，例如是否侵权（5）时间可行性，规定时间内是否能够完成尤其需要注意技术和经济以及法律三方面的分析2、可行性研究的过程1.复查系统规模与目标:确保分析员解决的问题正是要求他解决的问题。2.研究目前正在使用的系统:花费适当的时间，分析新旧系统的优缺点，现有系统的文档资料和使用手册。3.导出新系统的高层逻辑模型:使用数据流图和数据字典定义新系统的模型，建造新的物理系统。4.进一步定义系统:确保分析员对问题没有误解，以及没有用户曾经遗漏的要求。5.导出和评价供选择的解法:为每个在技术、操作和经济等方面都可行的系统制定实现大致的进度表。6.推荐行动方针:分析员对于所推荐的系统进行比较详细的成本/效益分析。7.草拟开发计划:分析员为推荐的方案草拟一份开发计划,具有工程进度表、估计各类开发人员、各种资源需要情况和使用时间、估计系统生命周期每个阶段的成本、给出需求分析的详细进度表和成本估计8.书写文档提交审查:把上述可行性研究各个步骤的工作结果写成清晰的文档，请用户、客户组织的负责人及评审组审查，以决定是否继续这项工程及是否接受分析员推荐的方案。3、可行性分析方法(1)系统流程图在进行可行性研究的时候，需要了解和分析现有的系统，系统流程图是概括地描绘物理系统的传统工具。它的基本思想是用图形符号以黑盒子形式描绘组成系统的每个部件（程序、文档、数据库、人工过程）等。系统流程图表达的是数据在系统各部件之间流动的情况，而不是对数据进行加工处理的控制过程，因此，尽管系统流程图的某些符号和程序流程图的符号形式相同，但它是物理数据流图而不是程序数据流图。程序流程图表示对信息进行加工处理的控制过程，也称为控制流系统流程图表达的是信息在系统各部件之间的流动情况，也称为数据流常用标记：其他存储标记：例如：零件器材的发放和接受称为变更记录，由键盘输入到计算机中。系统中库存清单程序对变更记录进行处理，更新存储在磁盘上的库存清单主文件，并且把必要的订货信息记录写在联机存储上。最后，每天由报告生成程序读一次联机存储，并且打印出订货报告(2)数据流图（Data Flow Diagram）数据流图是一种图形化技术，它描绘信息流和数据从输入移动到输出的过程中所经受的变换，表达了信息加工处理的过程。数据流图是结构化分析的主要工具之一符号表示：为了表达数据处理过程的数据加工情况，用一个数据流图是不够的，为了表达稍为复杂的实际问题，需要按照问题的层次结构进行逐步分解，并以分层的数据流图反映这种结构关系。一些原则：数据流图上所有图形符号只限于前述四种基本图形元素数据流图的主图必须包括前述四种基本元素，缺一不可数据流图的主图上的数据流必须封闭在外部实体之间每个加工至少有一个输入数据流和一个输出数据流在数据流图中，需按层给加工框编号。编号表明该加工所处层次及上下层的亲子关系规定任何一个数据流子图必须与它上一层的一个加工对应，两者的输入数据流和输出数据流必须一致。即父图与子图的平衡图上每个元素都必须有名字初画时可以忽略琐碎的细节，以集中精力于主要数据流(3)数据字典（Data Dictionary）数据流图实例是关于数据的信息集合，是对数据流图中包含的所有元素(数据流、数据元素、数据存储、处理/加工)定义的集合。它的任务是 对于数据流图中出现的所有被命名的图形元素在字典中作为一个词条加以定义，使得每一个图形元素的名字都有一个确切的解释。数据字典中记录数据元素的下列信息一般信息（名字、别名、描述）定义（数据类型、长度、结构）使用特点（指的范围、使用频率、使用方式）控制信息（来源、用户、程序的改变和使用权）分组信息（父结构、从属结构、物理位置）(4)成本/效益分析方法成本估计代码行技术任务分解技术自动估计成本技术成本/效益分析的方法货币的时间价值投资回收期纯收入投资回收率4、可行性研究报告]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web系统设计【一】]]></title>
    <url>%2Fposts%2Fca877cd4%2F</url>
    <content type="text"><![CDATA[一、基本概念1、URL统一资源定位系统（uniform resource locator;URL）用来指明文件在互联网中的位置例如https://www.baidu.com/分别为:协议：HTTPS主机地址（服务器地址、域名）www.baidu.com其它很多网址主机地址后面还会有文件路径和文件名，百度之所以没有文件名可以显示是因为在Web服务器配置中可以设定一个或多个默认文件名，浏览器会自动查找这些文件名file:///C:/windows/Sandstone.html也是一个URL地址“file://”指采用的直接文件方式访问； “/C:/windows/Sandstone.html”表示文件从根目录开始的路径URL和URI的区别统一资源标识符URI是一个用于标识某一互联网资源名称的字符串。 Web上可用的每种资源 -HTML文档、图像、视频片段、程序等都可由URI来定位。URL网址只是属于URI的一种，用来定位所需访问的网页地址。​ URI、URL：http://www.yahoo.com.cn/index.html​ URI: http://www.yahoo.com.cn/gif/stone.jpg2、HTTP超文本传输协议:HyperText Transfer Protocol,用于浏览网站的基本约束或规则3、IP地址和DNS浏览服务器上的资源，必须知道服务器在网络中的地址，这是通过IP地址来实现的。为了实现IP地址的易理解、易识别，又引入了域名的概念域名解析系统：Domain Name System，域名通过域名解析系统保证每台主机的域名和IP地址一一对应。例如：我们访问域名www.baidu.com，DNS解析后的地址可能为111.11.111.11(四组十进制数)所以我们也由此得知：DNS故障后，我们通过IP地址访问是不影响的4、Web和Internet的关系Web不等于Internet，它只是Internet中的一个部分，而且和浏览器有关。以后只要提到Web，就一定是和浏览器有关的应用或其他事项。可以说Web是Internet中的一个子集或者说Web是互联网提供信息的一种手段。5、Web服务器Web服务器实际上就是一个软件系统。但它必须安装在一台高性能和高可靠性的计算机上，所以人们通常将那台计算机就叫做Web服务器。Microsoft IISOracle WebLogicIBM WebSphere金蝶公司 ApusicApache 开源Tomcat 开源Jboss 开源要使一台计算机成为Web服务器，必须安装上述专门的信息服务程序，并且安装UNIX、Linux或Windows 2003/2008/2012 Server等网络操作系统。一台计算机可以安装多个Web服务器。为什么有些Web服务器需要花钱购买？IIS、Tomcat、Apache和Jboss等，支持的并发访问用户数有限，适合作中小型网站系统的Web服务器，而WebLogic、WebSphere和金蝶Apusic等专业Web服务器，在并发用户大量增加的情况下，仍可保持较高的处理性能，适合作大型网站系统的Web服务器。购买专业版时又区分5用户、10用户、25用户、100用户的Web服务器，是指Web服务器最大支持的并发用户数。6、Web页面Web在提供信息服务之前，所有信息都必须以文件方式事先存放在Web服务器所管辖磁盘中某个文件夹下，其中包含了由超文本标记语言（HyperText Markup Language，HTML）组成的文本文件，这些文本文件称为超链接文件，又称网页文件或Web页面文件（Web page）。同一个Web页面在不同的浏览器中可能具有不同的显示效果，为什么？这是因为Web页面中可能使用了该浏览器不支持的属性或方法，或者浏览器所支持的技术在版本上有差异。有些浏览器使用的是独有的内核，有些浏览器内核是一样的，只是改头换面，变得更加符合用户需求。网站和网页的区别：网站就是文件夹，网页就是文件二、开发环境原理上，任何文本编辑工具都可以用来开发，这里配置了VSCode的环境SublimeVSCodenotepad++1、Web主流开发平台Microsoft .NET开发平台Oracle Java EE开发平台LAMP开发平台（Linux+Apache+MySQL+PHP）2、VSCode环境配置和使用技巧下载、中文切换自行百度（1）Live Server插件用于预览html若出现Open a folder or workspace... (File -&gt; Open Folder）解决:把html文件放进一个文件夹里面，用vscode打开文件夹（2）Emmet快速编写Emmet 语法（3）主题和图标和字体更改可以在商店搜索其他主题修改Tiny Light推荐One Dark Pro图标：vscode-icons字体：在设置中可更改大小和其他设置使用技巧html文件中英文！可自动配置初始的代码其他：Vscode 常用快捷操作三、Web前端技术1、HTML用HTML 4.0编写的网页一般可在当前流行的浏览器中正常显示，但用HTML5.0编写的网页只能在支持HTML5的浏览器中显示。只要安装各大浏览器的最新版本就能正常浏览器HTML5网页。IE8.0及以下版本不支持HTML5，由于Windows XP不能升级到IE9，所以在XP中只能用FireFox、Chrome等浏览器浏览HTML5网页。2、CSSCSS（Cascading Style Sheets，层叠样式单）是W3C协会为弥补HTML在显示属性设定上的不足而制定的一套扩展样式标准,最新版为CSS3（IE9以上支持)我们可以用CSS来控制网页显示的格式。字体大小、位置、颜色、文字对齐方式、图片长宽、鼠标的形状等网页显示的格式，它们也是网页的重要内容。3、DHTML/JavaScriptDHTML即动态的HTML语言(Dynamic HTML)。除了具有HTML语言的一切性质外，还可在下载网页后仍能实时变换页面元素效果，使人们在浏览网页时看到网页动态效果。DHTML并不是一门新的语言，它是以下技术、标准或规范的一种集成：1）HTML2）CSS （Cascading Style Sheets，层叠样式单）3）CSSL（Client-Side Scripting Language，客户端脚本语言）4）HTML DOM（HTML文档对象模型，Document Object Model）JavaScript是目前使用最广泛的脚本语言，它是一种介于Java与HTML之间、基于对象的事件驱动的编程语言。使用JavaScript，不需要Java编译器，而是直接在Web浏览器中解释执行。VBScript脚本语言是Visual Basic Script（VBS）的简称，它是Microsoft Visual Basic的一个子集，可看作是VB语言的简化版。VBS和Javascript一样都用于创建客户方的脚本程序，并处理页面上的事件及生成动态内容。HTML DOM是W3C建议的Web技术标准之一，它将网页中的所有HTML标记抽象成对象，每个对象拥有各自的属性（Properties）、方法（Method）和事件（Events），它们可以通过JavaScript语言来进行控制。所有HTML标记中的元素（包括文本和属性）都可以通过DOM访问，可以动态创建新的HTML元素，页面显示内容可以被删除或修改。4、ActiveX技术微软ActiveX控件技术是一种可重用的软件技术。将一个或一组功能封装起来，以对象方式供开发者使用，例如将文件加密和解密做成一个ActiveX控件，网上银行将密码输入框做成一个ActiveX控件，防止木马读取密码等。有大量商用或免费ActiveX控件供开发人员使用，也可用VC、VB等来开发一个ActiveX控件。ActiveX控件可在页面中直接使用，例如ActiveMovie控件可用于播放声音与视频，只需在控件的属性中指定参数值，就可在Web页面中控制其播放。 IE、Netscape、Firefox等浏览器都支持ActiveX技术。厂家在生产电脑时，CPU、内存、硬盘、电源、机箱等直接原厂定制（OEM）购买，仅仅生产主板和一些配件，组装成计算机测试后作为产品销售。同样地，在开发一个软件产品时，开发人员不需要编写所有功能，可使用免费或开源的插件或者ActiveX控件，也可购买一些控件，组装到你所开发的代码中，如利用ActiveX控件Windows Media player完成声视频的播放，以加快软件开发速度，降低软件开发成本。所以软件开发的效率取决于你发现可重用软件的能力。当浏览的网页遇到ActiveX控件时，会检查用户本地系统的注册表，查看其是否已安装在本地机上。若已安装，浏览器显示该网页并激活控件。若未在用户本地安装，浏览器将查找并安装到本地。下载控件时，浏览器会缺省地显示一个消息框，通知用户将要开始下载，用户可以选择终止下载或继续下载（浏览器的Internet选项中设置）。5、XML （eXtensible Markup Language，可扩展的标记语言）HTML的不足：HTML不能适应信息检索和存档要求；无法描述矢量图形、科技符号和一些其他特殊显示效果；文档结构混乱而缺乏条理，导致浏览器的设计越来越复杂。XML弥补了HTML的不足，将网络上传输的文档规范化，并赋予标记一定的含义，与此同时，还要保留其简捷、适于网上传输和浏览的优点。XML是标记语言，可根据需要自定义新的标记。XML已在文件配置、数据存储、异构数据交换等众多方面得到广泛应用。四、Web后端开发技术1、CGICGI是公共网关接口（Common Gateway Interface）的缩写，是用于连接WEB页面和应用程序的接口。可用VB、VC、Delphi、 Perl语言开发Web Server端运行的可执行程序，由网页的一个超链接激活进行调用，并对该程序的返回结果进行处理后，显示在页面上。 CGI编程困难且效率低，每一次修改程序代码后还须重新编译。另外每一个网上客户在访问CGI程序时，Web服务器都要单独建立应用进程，加重了服务器的负荷。CGI多用在安全级别要求高的Web应用中。2、PHPPHP，Hypertext Preprocessor，超文本预处理器用开源和跨平台的PHP技术可创建动态网站，它包括完整的编程语言、支持因特网的各种协议、提供与MYSQL、SQL SERVER、ORACLE等多种数据库的访问能力，支持ODBC数据库连接方式。在Unix、GUN/Linux和微软Windows平台上均可运行。PHP的优点是安装方便、学习过程简单、数据库连接方便、兼容性强、扩展性强。PHP程序需在Apache、Tomcat等Web服务器上运行Linux+PHP+MySQL+Tomcat+Apache+Dreamweaver是开发中小型企业网站系统的黄金组合，网站的运行效率佳，安全性高，可靠性和稳定性也非常好，受到广大开发者的青睐。3、JSPJava Server PageJSP可用于建立先进、安全和跨平台的动态网页。JSP技术是以Java语言作为脚本语言的，使用JSP标识或者Java Servlet小脚本来生成页面上的动态内容。JSP可通过JDBC技术连接数据库。JSP代码被编译成Servlet并由Java虚拟机执行，这种编译操作仅在对JSP页面的第一次请求时发生。跨平台应用是JSP的最大特色。作为Java平台的一部分，JSP拥有Java编程语言“一次编写，各处运行”的特点。不少大型企业使用Java EE平台提供的JSP技术构建Web应用系统。4、ASP/ASP.NET*Active Server Pages *微软1996年11月推出ASP技术，可用VBScript或JavaScript脚本语言，结合HTML代码，快速完成服务器端动态网页的开发。Web服务器后台解释执行ASP动态网页，运行效率不高。2002年微软将ASP和.NET技术结合，推出了全新的ASP.NET技术，提供基于组件、事件驱动的可编程Web窗体，大大简化了编程，还可以用于建立Web服务。ASP.NET与ASP有着本质的不同，ASP.NET完全基于模块与组件，具有更好的可扩展性与可定制性，数据处理方面引入了许多新技术，技术上远远超越了ASP，ASP.NET与Windows Server 家族的完美组合为各种的Web应用提供了一个更为稳定、高效、安全的运行环境。5、ADO/ADO.NETMicrosoft ActiveX Data ObjectADO技术使得客户端应用程序可通过ODBC（Open DataBase Connectivity）、OLE DB等方式来访问和操作DB Server，易于使用、速度快、内存支出少、占用磁盘空间少，但它是面向连接的数据访问方式，即在操作数据库时，必须与数据库服务器进行联机操作。当并发用户操作时，会影响数据库性能。ADO.NET技术是.NET平台上的全新数据访问方式，数据源的数据可作为XML文档进行传输和存储。在访问数据的时候ADO.NET会利用XML制作数据的一份副本，用户可断开与数据库服务器的连接直接在副本上进行操作，最后根据需要再将副本中的数据更新到数据库服务器,以大大提高数据访问性能。6、Web ServiceWeb Service可以是一个小粒度的组件完成一个简单功能，也可是一个大粒度的应用程序。不管是作为组件还是应用程序，它都会向外界暴露一个能够通过Web进行调用的API，这就是说，能够用编程的方法通过Web访问来使用它。试设想，很多公司可以将某一具有独立功能的软件形成Web服务放在Web上，当某用户需要开发一个大型软件时，很多功能不需要自己开发，这部分功能可直接通过某种方式连接提供Web服务的主机得到。这样一来，你的应用系统会在开发人力、开发周期、开发成本、维护成本等方面大大减少或降低。其实网上已存在大量Web服务可供使用，例如发送和接收短消息功能、专业加密和解密功能、专业报表处理功能、微软的MapPoint Web服务等，当然或许你得为使用这些Web服务而付费。用户在调用这些Web服务时，只需要提供输入数据就可得到返回的结果，然后对返回的结果进行加工即可。在Web应用程序中无需下载安装Web服务可直接调用Web服务提供的方法来实现某个功能，而通过ActiveX控件来实现某个功能时，必须将它下载到客户端，在客户端安装后才可使用。所以Web服务可实现分布式应用。7、WCFWindows Communication Foundation，Windows通讯接口WCF是由微软发展的一组数据通信的应用程序开发接口，它是.NET框架的一部分，由.NET Framework 3.0开始引入，与Windows Presentation Foundation及Windows Workflow Foundation并列为新一代Windows操作系统的三大重要应用程序开发类库。WCF集合了几乎由.NET Framework所提供的所有通讯方法，可利用WCF来创建面向服务的应用程序。WCF具有以下优点：统一性、互操作性、安全和可信赖、兼容性。五、Web发展中的其他应用1、AJAXAjax（Asynchronous JavaScript and XML，异步JavaScript和XML）最早由Jesse James Garrett提出。区别于传统的Web应用，Ajax应用的主要目的就是提高用户体验：不刷新整个页面，在页面内与服务器通信；使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的的响应能力；应用系统不需要由大量页面组成。大部分交互在页面内完成，不需要切换整个页面。由此可见，Ajax使得Web应用更加动态，带来了更高的智能，并且可以提供表现能力丰富的Ajax UI组件。这样一类新型的Web应用叫做RIA(Rich Internet Application)应用。2、BlogBlog的全名是Web log，后来缩写为Blog，中文意思是“网络日志”,一般人们喜欢称之为“博客”。Blog是一个易于使用的网站，您可以在其中迅速发布想法、与他人交流以及从事其它活动，所有这一切都是免费的。3、WikiWiki一词来源于夏威夷语“wee kee wee kee”“快点快点”的意思，译为“维客”或“维基”。它是一种多人协作的写作工具。Wiki站点可以有多人，甚至任何访问者维护，每个人都可以发表自己的意见，或者对共同的主题进行扩展或者探讨。 Wiki指一种超文本系统。这种超文本系统支持面向社群的协作式写作，同时也包括一组支持这种写作的辅助工具。]]></content>
      <categories>
        <category>Web系统设计</category>
      </categories>
      <tags>
        <tag>Web系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP程序设计【一】]]></title>
    <url>%2Fposts%2Fed80ce9e%2F</url>
    <content type="text"><![CDATA[一、基础概念1、JSP在计算机软件知识学习中的位置2、目标3、内容4、什么是JSP(1)三大开发模式B/S（Browser/Server，浏览器/服务器模式）在B/S模式中，服务器上必须有所谓的Web应用程序，服务器通过运行这些Web应用程序来响应用户的请求。C/S（Client/Server,客户端/服务器模式）移动端开发(2)webWeb是一种基于超文本和HTTP协议的、全球性的、动态交互的、跨平台的分布式图形信息系统，是建立在Internet上的一种网络服务，帮助我们在网络上方便地进行信息的查找和浏览。Web就是World Wide Web，它是建立在Internet上的一种网络服务，Web！=Internet编写静态网页（.htm、.html）动态网页（ASP、JSP、PHP）Web服务端技术（后端）+Web客户端技术（前端）=Web技术，主流技术有：JSPHTMLDHTMLPHPASP/ASP.NETCGIServlet(3)JSP(Java Server Pages)JSP是基于Java 语言的一种Web应用开发技术。利用这一技术可以建立安全、跨平台、易维护的Web 应用程序。是一种开发动态网站的重要技术HTML + Java ≈ JSP一种 Web 服务器端的开发技术简化的Servlet在静态页面中加入各种程序和逻辑控制，实现动态和个性化的网页（.jsp）JSP页面在被服务器执行前已经被编译好，而且通常只进行一次编译，即第一次访问编译，若后续没有修改则不再编译，显著提高访问效率例如：123456789101112131415&lt;%@ page contentType="text/html;charset=GB2312" %&gt;&lt;html&gt; &lt;body bgcolor=cyan&gt; &lt;h3&gt;这是一个简单的JSP页面&lt;/h3&gt; &lt;% int i, sum=0; for(i=1;i&lt;=100;i++) &#123; sum=sum+i; &#125; %&gt; &lt;h5&gt; 1到100的连续和是： &lt;%= sum %&gt; &lt;/h5&gt; &lt;/body&gt;&lt;/html&gt;二、配置JSP环境1、JSP引擎(JSP容器)一个服务器上可以有很多基于JSP的Web应用程序，以满足各种用户的需求。这些Web应用程序必须有一个软件来统一管理和运行，这样的软件被称作JSP引擎或JSP容器。安装JSP引擎的计算机被称作一个支持JSP的Web服务器。Tomcat是一个免费的开源JSP引擎，也称作Tomcat服务器。2、配置三步(1) 安装JDK（JAVAEE），并且配置环境变量（1）设置系统变量JAVA_HOME。右击【计算机】图标，选择【属性】→【高级系统设置】→【高级】选项卡→【环境变量】菜单项，弹出“环境变量”对话框。在【系统变量】中单击【新建】按钮，弹出“新建系统变量”对话框，在“变量名”文本框中输入“JAVA_HOME”，“变量值”文本框中输入JDK的安装路径“C:\Program Files\Java\jdk1.8.0_162”，单击【确定】按钮完成配置。（2）设置系统变量Path。在【系统变量】中找到变量名为“Path”的变量，单击【编辑】按钮，不要删掉原来“Path”的变量值，在最前面输入JDK到bin的目录： “%JAVA_HOME%\bin；”，单击【确定】按钮完成配置。为什么配置JAVA_HOME：JAVA_HOME指向jdk的安装目录，Eclipse/NetBeans/Tomcat等软件就是通过搜索JAVA_HOME变量来找到并使用安装好的jdk.(2) 安装支持WEB开发的IDEEclipse (企业版)NetBeans （javaEE）(3) 安装JSP引擎，构建Web服务器启动：Tomcat安装目录/bin/startup.bat停止：Tomcat安装目录/bin/shutdown.bat测试：http://localhost:8080 或 http://127.0.0.1:8080注意端口问题，若8080端口被占用则网页不会显示。打开位于conf文件夹中下列文件server.xml 找到以下内容Connector port=“8080”将其中的 8080 改为其他值，如：9090、80、……重新启动Tomcat服务器生效同时修改glassfish的端口，进入目录glassfish4\glassfish\domains\domain1\config\domain.xml,找到8080端口，修改为你要的端口即可改为8084：Tomcat目录结构：eclipse需要手动配置tomcat，其他说明请看文档：其他配置说明三、JSP页面1、JSP页面文件在传统的HTML页面文件中加入Java程序片和JSP标记就构成了一个JSP页面文件，按文本格式保存，扩展名为：jsp特点：1、文件名区分大小写2、属于纯文本文件JSP文件名为什么区分大小写？JSP文件最终会被编译成类，编译成的类名使用的就是JSP文件名，而类名是区分大小写的。2、Web服务目录(部署web 项目三种方式)由上面我们知道webapps是Tomcat的主要Web发布目录，我们通过eclipse等开发的WEB项目可通过多种方式进行部署(1)根目录：Tomcat安装路径/webapps/ROOT直接通过文件名访问（http://localhost:8080/index.jsp）(2)webapps 下的目录（如 lyxf）根据目录名和文件名访问：http://localhost:8080/lyxf/index.jsp(3)非 webapps 下的目录需要配置 server.xml 和重新启动在&lt;/Host&gt;前加入（原来是没有这句话的）：&lt;Context path=&quot;/xxx&quot; docBase=&quot;yyy&quot; /&gt;path：虚拟路径：在地址中输入的路径，可空，但不建议空。如：/lyxftestdocBase：实际路径：在计算机中的项目文件夹（网站）所在路径，如：d:\lyxf注意：Context不可以写成context还有一种方式是在conf\Catalina\localhost下新建文件xx.xml，在其中添加&lt;ContextdocBase=&quot;yyy&quot;/&gt;,路径就是文件名。3、JSP运行原理JSP转译成的java文件为Servlet文件，JSP引擎再将其编译为class文件，执行后的结果以HTML发送给客户端Servlet就是编写在服务器端创建对象的Java类，习惯上称之为Servlet类，Servlet类的对象习惯上称之为一个servlet。4、WEB-INF目录WEB-INF是Java的WEB应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。如果想在页面中直接访问其中的文件，必须通过 web.xml 文件对要访问的文件进行相应映射才能访问。所以HTML或者JSP文件不能建在META-INF和WEB-INF这两个 文件夹中，否则文件就不能运行了，一般会提示404错误， 表示找不到文件，因为放错了位置。更多：WEB-INF目录与META-INF目录详解]]></content>
      <categories>
        <category>JSP程序设计</category>
      </categories>
      <tags>
        <tag>JSP程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构【AVL树的实现和应用】]]></title>
    <url>%2Fposts%2Fb26d4bc3%2F</url>
    <content type="text"><![CDATA[推荐阅读：AVL树(二)之 C++的实现AVL树详解 AVL 树（基础篇）重点理解四种调整方式和失衡的判断方法四种旋转1234567891011121314151617181920void BSTree::llTypeRotation(Node *&amp;ptr)&#123;//LL型旋转 Node *t=ptr; ptr=ptr-&gt;left; t-&gt;left=ptr-&gt;right; ptr-&gt;right=t;&#125;void BSTree::rrTypeRotation(Node *&amp;ptr)&#123;//RR型旋转 Node *t=ptr; ptr=ptr-&gt;right; t-&gt;right=ptr-&gt;left; ptr-&gt;left=t;&#125;void BSTree::rlTypeRotation(Node *&amp;ptr)&#123;//RL型旋转 llTypeRotation(ptr-&gt;right); rrTypeRotation(ptr);&#125;void BSTree::lrTypeRotation(Node *&amp;ptr)&#123;//LR型旋转 rrTypeRotation(ptr-&gt;left); llTypeRotation(ptr);&#125;结合推荐博文图片理解失衡判断充分利用递归回溯判断何种失衡再调整可以使用一个树的高度函数，在判断中调用该函数计算高度差再结合其它控制语句判断可以直接在树的结点设置高度选项，创建的同时更新高度，判断只需要判断结点属性即可不需要使用高度递归函数。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构【零】总概述]]></title>
    <url>%2Fposts%2Ffa28adca%2F</url>
    <content type="text"><![CDATA[一、绪论数据结构是一门研究非数值计算的程序设计问题时处理的操作对象以及它们之间的关系和操作等等的学科。1.1数据结构的基本概念和术语==数据：==数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。数据的分类：数值性数据计算机的应用：数值计算解决数值计算问题的中心: 建立适当的数学模型。非数值性数据计算机的应用：非数值计算解决非数值计算问题的中心: 寻找适当的数据结构。例如：最短路径问题==数据元素、数据项：==数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。它是一个数据整体中相对独立的单位。数据项分两种初等项：数据处理时不能分割的最小单位组合项：可以继续划分成更小的项==数据对象==是具有相同性质的数据元素的集合，是数据的一个子集。==数据结构==是相互之间存在一种或多种特定关系的数据元素的集合。Data_Structure = {D, R}D 是某一数据元素的集合R 是该集合中所有数据元素之间的关系的有限集合。建议不要管这个二元组，冲突太多了。数据结构是数据的组织形式数据元素间的逻辑关系，即数据的逻辑结构；数据元素及其关系在计算机存储内的表示， 即数据的物理结构(存储结构)；数据的运算，即对数据元素施加的操作。理解：数据：客观世界存在的事物的属性的抽象表示。数据对象：车数据元素：哪种车？拖拉机、跑车、公交车？数据项：重量、速度等描述一个车的属性。==数据类型==: 是一个值的集合和定义在这个值集上的一组操作的总称。例，整型: 整数的集合，定义在其上的操作包括(加减乘除)按值的不同性质，数据类型可以分为两类原子类型: 值是不可分解的、非结构的。例，C语言中的基本类型(整型、实型、字符型)结构类型。其值可以再分解为若干成分（分量）的数据类型。结构类型还可以包括结构类型。==抽象数据类型(Abstract Data Type)==抽象数据类型(Abstract Data Type 简称ADT)是指一个数学模型以及定义在此数学模型上的一组操作。抽象数据类型是由基本的数据类型组成，并包括一组相关的操作。抽象数据类型是由用户定义，用以表示应用问题的数据模型。抽象数据类型可用三元组表示（D, S, P）D 是数据元素的集合(简称数据对象)S 是 D上的关系集合P 是对 D 的基本操作集合。在这种理解上：抽象数据类型=逻辑结构+在其上的操作 数据结构：是计算机中存储、组织数据的方式。抽象数据类型：数据模型在维基百科中：抽象数据类型一个ADT可以用特定数据类型或数据结构实现数据结构可透过编程语言所提供的数据类型、引用及其他操作加以实现。在抽象数据类型和数据结构之间，有一个实现上的微妙差别。例如，列表的抽象数据类型可以数组为基础、或者使用链表来实现。列表即是一种具良好运算（加入元素、移除元素等等）定义的抽象数据类型。链表是以指针为基础的数据结构，且可用来创建一个列表。链表常用于列表的抽象数据类型。抽象数据结构抽象数据结构即根据所要运算的数据以及其计算复杂性所定义的抽象存储区，而不关心具体的数据结构的实现。就实现高效率的算法而言，对数据结构的选择相当重要。抽象数据结构的选择，决定了高效率的算法的设计，和估计其计算复杂性。这个概念与编程语言理论中所使用的抽象数据类型非常接近，大致上抽象数据结构和抽象数据类型的名称，和具体的数据结构的名称一致。这也在某种程度上解释了为什么ADT和DS中都有栈、堆这种名称。内置抽象数据类型一部分抽象数据类型在程序设计中相当普遍且实用，所以在某些编程语言中，成为原生类型、或加进标准库中。例如，Perl 的数组可以用列表或双端队列之类的抽象数据类型来实现，散列表也可以用 Map 或 Table 来做。C++ 标准库和 Java 库也提供了列表、堆栈、队列、Map、优先权队列和字符串。查了一下国外怎么理解的，大多数就是如下：ADT: ListDS: ArrayList, LinkedList…ADT: MapDS: HashMap, TreeMap…==抽象和具体的区别。====类似于接口和类==对于严蔚敏的书首先说数据类型和数据结构的混乱。它里面说数据结构是二元组DS，数据类型是三元组DSP(D指元素，S指结构或关系，P指操作)，但后面又说数据结构包括逻辑结构，存储结构，数据的运算。但数据的运算就是操作啊，也就是说数据结构就也成了三元组DSP了，这就和前面说的自相矛盾了。再说关于数据类型和ADT的混乱。严书里说int型是ADT。于是我就理解为ADT即是数据类型的逻辑特性。但严书后面又说ADT和数据类型的一个重要区别就是ADT不只包括固有数据类型，还包括用户自定义的类型(可见这句话的隐含意思是用户自定义的类型不是数据类型，excuse me？)。维基百科英文版：数据结构：数据值、关系、操作In computer science, a data structure is a data organization, management, and storage format that enables efficient access and modification.More precisely, a data structure is a collection of data values, the relationships among them, and the functions or operations that can be applied to the data.a collection ofdata valuesrelationships among themoperations that can be applied to the data.抽象数据类型：值和操作Formally, an ADT may be defined as a “class of objects whose logical behavior is defined by a set of values and a set of operations”;它们的关系：Data structures serve as the basis for abstract data types (ADT). The ADT defines the logical form of the data type. The data structure implements the physical form of the data type.数据结构是抽象数据类型(ADT)的基础。ADT定义数据类型的逻辑形式。数据结构实现了数据类型的物理形式。The term data structure often refers to data stored in a computer’s main memory.数据结构这一术语通常指存储在计算机主存储器中的数据。==有时间，我TM一定翻翻国外的网课，教材，书本。国内的“天书概念”真的服气了。==北大的数据结构基础课程是这么描述的：数据结构：逻辑+存储+运算ADT：把逻辑和运算抽象出来。并且解释ADT其产生是随着模块化思想发展而来的，隐藏底层细节。即和外网百科的数据结构、数据类型描述类似。也验证==抽象和具体的区别。====类似于接口和类==这种理解。同时也是和王道讲述的意思差不多。最后总结ADT和DS：==数据结构就是逻辑+存储+运算====ADT是逻辑+运算，没有用计算机物理实现。====我们写出一个ADT只是”定义”了一种数据结构的规范或者标准、接口描述。====ADT是抽象的，DS是具体的==1.2算法(1)定义算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。算法和数据结构是两个不可分割的统一体程序 = 数据结构 + 算法数据结构通过算法实现操作算法根据数据结构设计程序(2)算法的特性有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。注：算法必须是有穷的，而程序可以是无穷的确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。可行性。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。输入。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。输出。一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。(3)“好”算法的特质正确性。算法应能够正确地解决求解问题。可读性。算法应具有良好的可读性，以帮助人们理解。健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。高效率与低存储量需求。效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问题的规模有关。(4)算法的度量让算法先运行，事后统计运行时间？存在什么问题？和机器性能有关，如：超级计算机 v.s. 单片机和编程语言有关，越高级的语言执行效率越低和编译程序产生的机器指令质量有关能否排除与算法本身无关的外界因素？有些算法是不能事后再统计的，如：导弹控制算法能否事先估计？时间复杂度事前预估算法时间开销T(n)与问题规模 n 的关系（T 表示 “time”）==加法规则和乘法规则：==我们用大O记法表示(其实在高等数学中就是同阶无穷小。)T(n)和O(n)比值的极限是一个常数k，他们是同阶无穷小。我们用O(n)来描述算法的开销。这样我们解决了如果有好几千行代码，不需要一行一行数的问题。高等数学说明：如果，就说是比高阶的无穷小，记作；（这个是小o）如果，就说是比低阶的无穷小；==如果，就说是与同阶的无穷小；记作β=O(α)（这个是大O）==如果，就说与是等价无穷小，记作。常用阶数：证明略，就是求极限，符合无穷小的定义。==常对幂指阶==循环==结论1：顺序执行的代码只会影响常数项，可以忽略====结论2：只需挑循环中的一个基本操作分析它的执行次数与 n 的关系即可==算法的四种基本操作是逻辑运算 、算术运算 、数据比较、数据传送 。多重循环不相关==结论3：如果有多层嵌套循环，只需关注最深层循环循环了几次==多重循环相关==结论3：如果有多层嵌套循环，只需关注最深层循环循环了几次==执行次数不确定的情况最坏时间复杂度：最坏情况下算法的时间复杂度平均时间复杂度：所有输入示例等概率出现的情况下，算法的期望运行时间最好时间复杂度：最好情况下算法的时间复杂度空间复杂度空间复杂度：空间开销（内存开销）与问题规模 n 之间的关系和时间复杂度一样，我们用O(n)来描述空间复杂度S(n)。S 表示 “Space”。加法原则、乘法原则、常用阶比较依旧适用。原地工作==算法原地工作——算法所需内存空间为常量S(n) = O(1)==非递归和规模有关 常数递归每一次调用程序，都是常数空间。调用规模n所以为O(kn)=O(n)==S(n) = O(n)空间复杂度 = 递归调用的深度==规模有关递归总结==①找到一个基本操作（最深层循环）====②分析该基本操作的执行次数x与问题规模n的关系x=f（n）====③ x的数量级O（x）就是算法时间复杂度T（n）====①找到所占空间大小与问题规模相关的变量====②分析所占空间x与问题规模n的关系x=f（n）====③x的数量级O（x）就是算法空间复杂度S（n）==]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构【二叉排序树实现和应用】]]></title>
    <url>%2Fposts%2F980b4487%2F</url>
    <content type="text"><![CDATA[前言此程序是数据结构课程设计（运气好抽了个最简单的emmm^^）,但是从这个相对简单的课设也学到了不少东西，下面做下记录1、C++中指针的指针和引用（1）首先再次深入了解指针和指针的指针实际上，指针保存的就是我们存放数据的存储空间地址，指针的指针就是保存的存放指针的存储空间地址，通过指针保存的地址，我们通过*p能够对该指针指向的地址的空间的内容进行操作由此，我们能够得到一个结论1、实际上指针的指针也是归于指针变量的范畴，他不是多层概念，指针是我们希望通过地址对一个数据进行操作而引入的，指针和指针指向的数据就是一个两层概念，指针的指针只不过是我们希望通过地址对指针变量进行修改而创建的 ，以此类推我们希望通过地址对指针的指针进行修改，就需要创建相应类型的指针的指针的指针。。。。往后也一样。（2）引用我们都知道引用就是变量的别名，操作一个变量的引用也就相当于操作变量本身但是引用是在编译的过程中被处理的，实际上就是在编译层面对程序员进行的一个比较友好的语法，而在实现上是由编译器完成了地址的传递，实质上还是指针讲人话，第二个结论：使用一个引用变量操作，就相当于使用一个指向原数据的指针来对原数据进行操作，只不过过程被隐藏了，同时创造引用的人封装这个过程的同时还增加了一些，引用不能为空，引用不能更改等等的规定，防止使用中不必要的错误”例如：123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;void test1(int *a)&#123; *a=2;&#125;void test2(int &amp;a)&#123; a=3;&#125;int main()&#123; int b=0; cout&lt;&lt;b&lt;&lt;endl; test1(&amp;b);//因为通过上一部分，我们知道指针就是存储数据存储单元的地址的，这里我们直接使用&amp;取地址 cout&lt;&lt;b&lt;&lt;endl; test2(b); cout&lt;&lt;b&lt;&lt;endl;&#125;/*输出为：023*/也就是说，使用引用变量a=b,就是*a=b，但是创建指针，使用时带星花，都省略了，表面理解就是“起了个别名”规定引用不能为空，也是为了概念上契合“起个别名”，没有赋值，去给谁起别名操作呢？，引用不能改变，“别名”强制绑定一个对象，不能更改。这里再添加一个误区说明，在C++中NULL的设定不是我们理解上的“空”而是：12345#if defined(__cplusplus)# define NULL 0 // C++中使用0作为NULL的值#else# define NULL ((void *)0) // C中使用((void *)0)作为NULL的值#endif所以一般来说NULL就是地址为0的概念，不是“空”，而大多机器中地址0中的内容一般是不准许用户更改的。一般用于系统或者硬件调用。所以NULL可以赋予给引用变量，编译通过但是一般不要对其进行操作（3）函数返回引用值问题：函数内部创建的变量都是局部变量，即私有的，作用域就在函数之内，为什么却可以把值传出去呢呢？根本就在于实现机制中，类似于形式参数，函数结束返回时，将局部变量值拷贝给一个临时变量，然后将这个临时变量返回给调用函数，这样即使局部变量在返回时已经释放内存，也不影响返回的变量值既然类似于形式参数，那么我们返回值能不能类似的使用引用呢？答案是肯定可以的一个函数的返回值定义为引用形式，就相当于真的“返回了它本身”没有副本的概念。然而实际上，它的实现依旧是指针。实际上封装的的操作就是用指针接受返回的&amp;a，再用这个指针去操作其对应值。所以对应的，我们想要使用这个引用值，必须要使用引用变量，否则和返回非引用效果相同。同时，我们也明确到，这个引用返回必须不能是局部变量，否则函数结束，释放空间，我们引用返回封装中本质上返回的地址所存储的值也就不明确了。虽然编译可以通过只是给予警告，有时该局部空间也没有被重新分配保持原值，但是这样是没有保障的，风险极大，故我们一般不能使用。当然如果非要返回一个局部变量的引用，可以new 类型(初值) 申请一个堆内存的临时变量，这样只要不delete释放，那么在程序退出之前内存就不会被释放，直到不再使用时便可delete掉.通常情况下，我们希望做到通过一个函数，真的对外部原数据进行操作，而不是局部数据，这样使用引用参数或者指针参数是足够的，但是，若我们想对函数得到的返回值结果再次进入一个函数进行操作，且仍然实际上是操作这个返回值（前提已经是这个返回值变量不是局部变量了），那么我们就必须使用返回引用同时使用引用变量接受或者返回地址同时使用指针接受，然后再进入另一个参数为引用或者指针的函数进行操作才可以例如本次的二叉排序树的查询和插入操作：我们希望使用查询的结果作为插入的输入，进行对以root为根的树的操作，我们查找不到某数据后必定为结果NULL，这也是我们希望插入的位置，但是NULL是我们希望插入节点的父节点的指针域，我们希望链接上父节点，即将父节点的NULL修改后指向我们新插入的节点，就必须使用返回指针的指针或者返回指针引用（前面讲过，这是两层概念，而非多层，我们希望对指针内容原数据修改，就使用指针的指针），这样再进入插入函数操作我们才能真正意义上的做到父节点链接新节点，否则我们只是创建副本接受了NULL的这个值，做不到真正的使用父结点的指针域使用指针：123456789101112131415template &lt;class T&gt;Node&lt;T&gt;** BSTree&lt;T&gt;::search(T data,Node&lt;T&gt; *&amp;ptr)&#123; if(ptr==NULL) return &amp;ptr; //指针为空，说明没有找到该节点 返回&amp;ptr。此时ptr的值为NULL而&amp;ptr不为NULL; else if(data&lt;ptr-&gt;data) search(data,ptr-&gt;left);//查找数据小于该节点数据，进入左子树查找 else if(data&gt;ptr-&gt;data) search(data,ptr-&gt;right);//查找数据大于该节点数据，进入右子树查找 else return &amp;ptr; //查找数据等于该节点数据，返回指向该节点的指针的指针。 &#125;template &lt;class T&gt;bool BSTree&lt;T&gt;::insertMain(T data,Node&lt;T&gt; *&amp;ptr)&#123; Node&lt;T&gt; **p=search(data,ptr);//使用search函数，根据查找原理，可以查找到该节点的插入位置 if(*p==NULL)&#123; //若为*p为空则说明找到了插入位置 *p=new Node&lt;T&gt;; //申请空间 (*p)-&gt;data=data; //存储数据 &#125;else return false;&#125;使用引用：123456789101112131415template &lt;class T&gt;Node&lt;T&gt;*&amp; BSTree&lt;T&gt;::search(T data,Node&lt;T&gt; *&amp;ptr)&#123; if(ptr==NULL) return ptr; //指针为空，说明没有找到该节点 返回&amp;ptr。此时ptr的值为NULL而&amp;ptr不为NULL; else if(data&lt;ptr-&gt;data) search(data,ptr-&gt;left);//查找数据小于该节点数据，进入左子树查找 else if(data&gt;ptr-&gt;data) search(data,ptr-&gt;right);//查找数据大于该节点数据，进入右子树查找 else return ptr; //查找数据等于该节点数据，返回指向该节点的指针的引用。 &#125;template &lt;class T&gt;bool BSTree&lt;T&gt;::insertMain(T data,Node&lt;T&gt; *&amp;ptr)&#123; Node&lt;T&gt; *&amp;p=search(data,ptr);//使用search函数，根据查找原理，可以查找到该节点的插入位置 if(p==NULL)&#123; //若为p为空则说明找到了插入位置 p=new Node&lt;T&gt;; //申请空间 p-&gt;data=data; //存储数据 &#125;else return false;&#125;（4）总结：1、引用其实本质就是地址2、当函数返回值类型为引用时，一般就用引用类型去接收，或者就使用了引用的作用，如果用非引用类型接受，就等于将函数返回的引用的数据值，复制给了该接收对象，和函数返回非引用类型是一样的效果。3、当函数返回值类型为引用时，如果不考虑接收问题，则有一个特性，则是可以直接操作该函数返回的引用，如放在=左面 +=等.4、错象:当在函数内部定义了局部变量(本质就是为一段内存取了一个名字，并占用)，出了这个函数，这个局部变量不可再使用，也就是这个局部变量并不指向 任何一个内存了，但是这个局部变量原来所指的内存如果没有被系统重新分配，里面的值仍然没有变,如果有一个引用指向该局部变量，在局部变量被释放内存以 后，如果没有被系统重新将这段内存分配，那么其值仍可用。5、不可以将常引用当作函数返回值返回.6、用引用作函数参数和返回值类型的好处。直接是地址操作，不需要将值一一复制给形参，7、返回值不需要有临时变量的存在，也不需要调用任何构造函数。节省了开销8、一般当函数形参需要复杂类型的数据时，最好用引用，可以节省系统开销，9、能用常引用的地方尽量用常引用。10、如果非要返回一个局部变量的引用，可以new 类型(初值) 申请一个堆内存的临时变量，这样只要不delete释放，那么在程序退出之前内存就不会被释放，直到不再使用时便可delete掉.推荐详细阅读：总结选自：https://blog.csdn.net/tlxxm/article/details/8860760C++引用的实现2、封装一棵树我们希望“定义一棵树”，真的就是定义一棵树，它的操作就是默认对本树操作，所以我们将很多递归程序或者具有使用根节点的程序分成两部分，主实现函数放入private域，不予公开，而添加调用函数，内容就是使用主实现函数，但是我们认为固定设定参数，例如树根指针就是本树的root类似的操作我们在本次二叉树封装中进行了很多：主实现函数：1234567891011private: //节点数 Node&lt;T&gt;* root; //根节点 bool insertMain(T data,Node&lt;T&gt; *&amp;ptr); //插入节点主函数 void destroyTreeMain(Node&lt;T&gt; *p);//销毁树主函数 int deepthMain(Node&lt;T&gt; *p);//计算树的高度主函数 void inOrderMain(Node&lt;T&gt; *ptr);//中序遍历主函数 void outputLevelMain(Node&lt;T&gt; *p);//层次遍历主函数 void outPutTreeByGraphMain(Node&lt;T&gt; *t,int h);//可视化遍历主函数; void sortedArrayToLowestBST_Main(T data[],int min,int max);//根据一有序序列创建高度最小的BSTree主函数 void getPNumInEvrDeepth(int deepth,int num[],Node&lt;T&gt; *ptr); //获取每一层次的节点个数存入数组num中，方便计算AVL；调用函数：12345678public: bool insert(T data)&#123;insertMain(data,root);&#125;; //插入节点调用函数 void sortedArrayToLowestBST();//根据一有序序列创建高度最小的BSTree调用函数 void inOrder()&#123;inOrderMain(root);cout&lt;&lt;endl;&#125;;//中序遍历调用函数 void outputLevel()&#123;outputLevelMain(root);cout&lt;&lt;endl;&#125;; //层次遍历调用函数 int deepth()&#123;return deepthMain(root);&#125;;//计算树的高度调用函数 void destroyTree()&#123;destroyTreeMain(root);root=NULL;&#125;;//销毁树调用 void outPutTreeByGraph()&#123;outPutTreeByGraphMain(root,0);&#125;; //树的图像输出调用这样从外部看，我们定义一个二叉排序树，对其进行创建、增删改查都是默认对这一个树进行操作，不再需要树根指针等参数了。3、图形化输出一棵树其实很简单：就是利用了右子树—&gt;父结点—&gt;左子树遍历，根据结点所处的层数和指针域状况中间夹杂着一些符合的判断添加1234567891011121314151617template&lt;class T&gt;void BSTree&lt;T&gt;::outPutTreeByGraphMain(Node&lt;T&gt; *t,int h)&#123; if(t!=NULL)&#123; outPutTreeByGraphMain(t-&gt;right,h+1);//右子树输出，h变量说明深度控制之后的空格输出 for(int i=0;i&lt;h;i++) //根据深度说明输出层数相适应的空格，使每一层节点在一竖列 cout&lt;&lt;" "; cout&lt;&lt;t-&gt;data; //空格输出完才输出数据 if(t-&gt;left!=NULL&amp;&amp;t-&gt;right!=NULL) //输出完才输出数据，根据子节点，左右都有则输出'&lt;' +换行 cout&lt;&lt;"&lt;"&lt;&lt;endl; else if(t-&gt;left==NULL&amp;&amp;t-&gt;right!=NULL)//只有右子树则输出'/' +换行 cout&lt;&lt;"/"&lt;&lt;endl; else if(t-&gt;left!=NULL&amp;&amp;t-&gt;right==NULL)//只有左子树则输出'\' +换行 cout&lt;&lt;"\\"&lt;&lt;endl; else cout&lt;&lt;endl; //左右子树为空则输出换行 outPutTreeByGraphMain(t-&gt;left,h+1); //输出左子树 &#125;&#125;这样我们就能横向打印一个树了（结点数少的时候慢清晰的，能够直观根据树形判断自己的树功能是否正确，代码也不复杂，挺实用的）4、本树的模板类的进一步封装体会功能较多，为了使用更方便，于是在main函数中设计了一个菜单功能，但是，在这个设计中，不同类型的树，对于停止标记符号也不同，因为停止符号也设计成了模板T类符号，没有进行统一化，这样相关函数中输入才好设计，否则若设计了固定停止符号为‘#’，在一个int型的树中，我们万一有数据就是‘#’代表的ASCII码，就会停止，所以这样设计不是很好。而固定输入数据个数，万一个数打错了又要从新来过。最好还是设计一个停止标记，每种树设计一种对应类型的停止标记。而这样设计带来了一个问题，那就是菜单中是固定的调用，我们如何确认是哪种树呢？只是为了不同类型树使用不同标记而再次复制粘贴修改一两句代码显然是不合理的。于是，我们将这个菜单功能也进行模板化，参数就是类型树和对应的停止标志，这样就合理了！最终，我们的主函数只有寥寥几句123456789int main()&#123; BSTree&lt;int&gt; intTree; BSTree&lt;char&gt; charTree; BSTree&lt;double&gt; floatTree; function(intTree,-1); function(charTree,'#'); function(floatTree,-1.0); &#125;不同的树使用不同的模板类型的function即可，封装的很漂亮5、switch case和{}总结一句话：只要case中带变量不带括号，编译器都会报错，使用switch case的时候建议每个匹配选项后的执行区域推荐使用{}括起来，或者干脆不要将变量带入case中。6、其他小坑找合法序列时候使用单个读取而不是真的读取一个序列，导致有时一个序列中途就判断是错误的，那么后续的字符会被输入流读入菜单选项中，尽管使用了非正确功能序号不予相应的循环，但是若万一系列中多余的数据就符合菜单功能序号，就会出现非法调用功能的严重BUG，所以最终还是使用了动态数组存储然后删除7、最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385#include&lt;iostream&gt;#include &lt;algorithm&gt; using namespace std;template &lt;class T&gt;//创建节点 struct Node&#123; T data; Node&lt;T&gt;* left=NULL; Node&lt;T&gt;* right=NULL; &#125;;//创建BSTree类 template &lt;class T&gt;class BSTree&#123; public: BSTree(); Node&lt;T&gt;* getRoot()&#123;return root;&#125;; Node&lt;T&gt;** search(T data,Node&lt;T&gt; *&amp;ptr);//在以ptr为根的二叉排序树中查询节点返回指向该节点的指针的指针 void creatBSTree(T stopSign);//以root为根创建BSTree； bool remove(T data); //删除节点 double getAVL();//获取查询的平均查找长度 bool judgeLegalSequence(T stopSign);//判断某序列是否是合法查找序列 bool insert(T data)&#123;insertMain(data,root);&#125;; //插入节点调用函数 void sortedArrayToLowestBST();//根据一有序序列创建高度最小的BSTree调用函数 void inOrder()&#123;inOrderMain(root);cout&lt;&lt;endl;&#125;;//中序遍历调用函数 void outputLevel()&#123;outputLevelMain(root);cout&lt;&lt;endl;&#125;; //层次遍历调用函数 int deepth()&#123;return deepthMain(root);&#125;;//计算树的高度调用函数 void destroyTree()&#123;destroyTreeMain(root);root=NULL;&#125;;//销毁树调用 void outPutTreeByGraph()&#123;outPutTreeByGraphMain(root,0);&#125;; //树的图像输出调用 private: //节点数 Node&lt;T&gt;* root; //根节点 bool insertMain(T data,Node&lt;T&gt; *&amp;ptr); //插入节点主函数 void destroyTreeMain(Node&lt;T&gt; *p);//销毁树主函数 int deepthMain(Node&lt;T&gt; *p);//计算树的高度主函数 void inOrderMain(Node&lt;T&gt; *ptr);//中序遍历主函数 void outputLevelMain(Node&lt;T&gt; *p);//层次遍历主函数 void outPutTreeByGraphMain(Node&lt;T&gt; *t,int h);//可视化遍历主函数; void sortedArrayToLowestBST_Main(T data[],int min,int max);//根据一有序序列创建高度最小的BSTree主函数 void getPNumInEvrDeepth(int deepth,int num[],Node&lt;T&gt; *ptr); //获取每一层次的节点个数存入数组num中，方便计算AVL；&#125;;template &lt;class T&gt;BSTree&lt;T&gt;::BSTree()&#123; root=NULL;&#125;template &lt;class T&gt;Node&lt;T&gt;** BSTree&lt;T&gt;::search(T data,Node&lt;T&gt; *&amp;ptr)&#123; if(ptr==NULL) return &amp;ptr; //指针为空，说明没有找到该节点 返回&amp;ptr。此时ptr的值为NULL而&amp;ptr不为NULL; else if(data&lt;ptr-&gt;data) search(data,ptr-&gt;left);//查找数据小于该节点数据，进入左子树查找 else if(data&gt;ptr-&gt;data) search(data,ptr-&gt;right);//查找数据大于该节点数据，进入右子树查找 else return &amp;ptr; //查找数据等于该节点数据，返回指向该节点的指针的指针。 &#125;template &lt;class T&gt;bool BSTree&lt;T&gt;::insertMain(T data,Node&lt;T&gt; *&amp;ptr)&#123; Node&lt;T&gt; **p=search(data,ptr);//使用search函数，根据查找原理，可以查找到该节点的插入位置 if(*p==NULL)&#123; //若为*p为空则说明找到了插入位置 *p=new Node&lt;T&gt;; //申请空间 (*p)-&gt;data=data; //存储数据 &#125;else return false;&#125;template &lt;class T&gt;void BSTree&lt;T&gt;::creatBSTree(T stopSign)&#123; destroyTree(); //摧毁原有的树 T data; cin&gt;&gt;data; while(data!=stopSign)&#123; insert(data); //创建一个BSTree的过程就是从空树开始不断插入节点的过程 cin&gt;&gt;data; &#125;&#125;template &lt;class T&gt;bool BSTree&lt;T&gt;::remove(T data)&#123; Node&lt;T&gt; **p=search(data,root); if(*p!=NULL)&#123; //若*p不为空，则查找该节点成功，准备删除该节点 if((*p)-&gt;left!=NULL&amp;&amp;(*p)-&gt;right!=NULL)&#123; //对左右子树都不为空的情况进行删除 Node&lt;T&gt; *temp=(*p)-&gt;right; while(temp-&gt;left!=NULL) //找到右子树的中序遍历的第一个节点 temp=temp-&gt;left; T data=temp-&gt;data; //保存该值，否则删除右子树的中序遍历的第一个节点后，该值会消失，无法赋给*p节点 remove(temp-&gt;data);//由于右子树的中序遍历的第一个节点一定无左子树，我们可以直接用右子树链接，remove函数中已经定于了该操作，我们直接调用，提高代码复用率 (*p)-&gt;data=data;//右子树的中序遍历的第一个节点的值替换该节点的值 &#125;else&#123; Node&lt;T&gt; *temp=*p; //备份该节点 if((*p)-&gt;left==NULL) *p=(*p)-&gt;right;//如果该需要删除的节点左子树为空，则删除后使用该节点的右子树替代； else *p=(*p)-&gt;left; //如果该需要删除的节点右子树为空，则删除后使用该节点的左子树替代； 并且这种处理方式包含了都为空的处理，即赋值NULL delete temp; //删除该节点 return true; &#125; &#125;else return false; //若*p为空，则查找该节点失败 ，返回false &#125;//实际上，删除一个点，若是左右子树至少有一个为空，则备份被删除的节点的指针，然后直接子树链接上其父节点指向删除节点的指针（，// 判左空则使用右子树链接，判右空则使用左子树链接，这样就包括了双空的情况了。）最后使用备份指针释放空间即可。//若是该左右子树全不是空则实际上转为使用 右子树的中序遍历的第一个节点 或者左子树中序遍历最后一个节点的值替换该节点的值//然后删除只有右子树（或者左子树，取决于使用哪个作为替换节点）的替换节点，而这种删除左右子树至少有一个为空的操作，直接在此调用remove就可以完成，提高代码复用率 template &lt;class T&gt;void BSTree&lt;T&gt;::getPNumInEvrDeepth(int deepth,int num[],Node&lt;T&gt; *ptr)&#123; if(ptr!=NULL)&#123; num[deepth]++;//该节点不为空，则该层数节点数+1； getPNumInEvrDeepth(deepth+1,num,ptr-&gt;left);//本层深度+1进入左子节点， getPNumInEvrDeepth(deepth+1,num,ptr-&gt;right);//本层深度+1进入右子节点， &#125;&#125;template &lt;class T&gt;double BSTree&lt;T&gt;::getAVL()&#123; int *num=new int[20];//创建数组用于存储各个层次的节点数 int sum=0,pointNumber=0;//sum用于存储各个层次的节点数×层数，pointNumber存储节点个数； for(int i=0;i&lt;20;i++)//初始化数组全为0 num[i]=0; getPNumInEvrDeepth(1,num,root);//使用 getPNumInEvrDeepth函数获取每一层次的节点个数存储到num数组中； cout&lt;&lt;"("; for(int i=1;i&lt;20;i++) if(num[i]!=0)&#123; sum+=num[i]*i; //加和各个层次的节点数×层数 cout&lt;&lt;num[i]&lt;&lt;"×"&lt;&lt;i; if(num[i+1]!=0) cout&lt;&lt;"+"; pointNumber+=num[i];//加和各个层次的节点数 &#125; cout&lt;&lt;")"&lt;&lt;"×1/"&lt;&lt;pointNumber&lt;&lt;"="; delete num; //删除辅助数组 if(pointNumber==0) return 0;//若 pointNumber==0，则为空树，我们选择AVL置0 return (double)sum/pointNumber;//根据AVL的定义可以推算出，成功查找的AVL= (double)sum/pointNumber; &#125; template &lt;class T&gt;bool BSTree&lt;T&gt;::judgeLegalSequence(T stopSign)&#123; //该方法判断一个序列，查找该序列最后一个数据所形成的通路是否正好是该序列 T *data=new T[20]; for(int i=0;i&lt;20;i++)&#123; cin&gt;&gt;data[i]; if(data[i]==stopSign) break; &#125; Node&lt;T&gt; *ptr=root; int t=0; while(data[t]!=stopSign&amp;&amp;root!=NULL)&#123;//data[t]!=stopSign用来判断空序列，ptr！=NULL来判断序列超长情况的错误序列 if(data[t++]!=ptr-&gt;data) //如果数据不等于该节点的数据则不是合法序列。直接跳出判断循环，进入非正确查找序列处理阶段 ,若正确相当于执行了t++进入下一个判断； break; if(data[t]==stopSign)&#123; //遇到终止标志，序列判断结束，到这里说明没有不合法数据，进入正确找序列处理阶段，删除动态存储数组并return true。 delete data; return true; &#125; if(data[t]&lt;ptr-&gt;data) //没有遇到终止标志进入下一个数据判断，数据比本节点数据小，则进入左节点判断 ptr=ptr-&gt;left; else //数据比本节点数据大，则进入左节点判断 ，这里必不可能等于，因为上一个节点等于ptr-&gt;data,而二叉排序树无相同节点 ptr=ptr-&gt;right; &#125; delete data;//失败时的删除data动态数组 return false;//说明为空序列或者序列超长或序列数据的确非正确的查找序列，返回错误序列 &#125;template &lt;class T&gt;void BSTree&lt;T&gt;::sortedArrayToLowestBST()&#123; destroyTree(); //摧毁原有的树 int n; cout&lt;&lt;"输入有序序列包含的数据个数："; cin&gt;&gt;n; cout&lt;&lt;"依次输入"&lt;&lt;n&lt;&lt;"个数据："; T *data=new T [n]; //动态创建存储数据的数组，创建树后之后可以删除节省空间； for(int i=0;i&lt;n;i++) cin&gt;&gt;data[i]; //存入数据 sortedArrayToLowestBST_Main(data,0,n-1);//进入根据有序序列建立高度最小的二叉排序树主函数 delete data; //建立完成删除存储数组 &#125;template &lt;class T&gt;void BSTree&lt;T&gt;::sortedArrayToLowestBST_Main(T data[],int min,int max)&#123; if(min&lt;=max)&#123; insert(data[(max+min)/2]); //若min&lt;max则取下标mid=(max+min)/2即区间的中间值进行插入树操作。 sortedArrayToLowestBST_Main(data,min,(max+min)/2-1);//再从mid往左的区间进行递归 sortedArrayToLowestBST_Main(data,(max+min)/2+1,max);//从mid的往右的区间进行递归 &#125;&#125;template &lt;class T&gt;void BSTree&lt;T&gt;::inOrderMain(Node&lt;T&gt; *ptr)&#123; if(ptr!=NULL) &#123; inOrderMain(ptr-&gt;left); cout&lt;&lt;ptr-&gt;data&lt;&lt;" "; inOrderMain(ptr-&gt;right); &#125;&#125;template &lt;class T&gt; void BSTree&lt;T&gt;::outputLevelMain(Node&lt;T&gt; *p)&#123; Node&lt;T&gt; *Queue[100]; //建立一个容量100的结点指针数组作为队列 int front=0,rear=0; //建立队首和队位指针 if(root!=NULL) //判空 &#123; Queue[rear++]=p; //1、先将根入队 while(front!=rear) //2、设置队列非空循环条件 &#123; cout&lt;&lt;Queue[front]-&gt;data&lt;&lt;" "; //3、输出结点的值 if(Queue[front]-&gt;left!=NULL) //4、若该结点左子树不为空则入队列 &#123; Queue[rear]=Queue[front]-&gt;left; //补充:注意先存数据再将尾指针加1 rear=(rear+1)%100; //5、为了充分使用空间，我们使用循环队列，队尾+1取余 &#125; if(Queue[front]-&gt;right!=NULL) //6、若该结点右子树不为空则入队列 &#123; Queue[rear]=Queue[front]-&gt;right; rear=(rear+1)%100; //7、同理队尾+1取余 &#125; front=(front+1)%100; //8、将输出过的结点出队列 &#125; &#125; &#125; template &lt;class T&gt; int BSTree&lt;T&gt;::deepthMain(Node&lt;T&gt; *p)&#123; if(p==NULL) return 0; int leftDeepth=deepthMain(p-&gt;left); //计算左子树高度 int rightDeepth=deepthMain(p-&gt;right); //计算右子树高度 return max(leftDeepth,rightDeepth)+1; //取左右子树的最高高度再+1，max()函数需要头文件#include &lt;algorithm&gt; &#125;template &lt;class T&gt; void BSTree&lt;T&gt;::destroyTreeMain(Node&lt;T&gt; *p)&#123; if(p!=NULL)&#123; destroyTreeMain(p-&gt;left); //若有左子树则进入摧毁左子树递归 destroyTreeMain(p-&gt;right); //若有右子树则进入摧毁右子树递归 delete p; //删除该节点 &#125; &#125;template&lt;class T&gt;void BSTree&lt;T&gt;::outPutTreeByGraphMain(Node&lt;T&gt; *t,int h)&#123; if(t!=NULL)&#123; outPutTreeByGraphMain(t-&gt;right,h+1); for(int i=0;i&lt;h;i++) cout&lt;&lt;" "; cout&lt;&lt;t-&gt;data; if(t-&gt;left!=NULL&amp;&amp;t-&gt;right!=NULL) cout&lt;&lt;"&lt;"&lt;&lt;endl; else if(t-&gt;left==NULL&amp;&amp;t-&gt;right!=NULL) cout&lt;&lt;"/"&lt;&lt;endl; else if(t-&gt;left!=NULL&amp;&amp;t-&gt;right==NULL) cout&lt;&lt;"\\"&lt;&lt;endl; else cout&lt;&lt;endl; outPutTreeByGraphMain(t-&gt;left,h+1); &#125;&#125;void menu()&#123; cout&lt;&lt;"应用选择:"&lt;&lt;endl; cout&lt;&lt;" 0:退出"&lt;&lt;endl; cout&lt;&lt;" 1*:创建：输入待排序序列,创建排序二叉树"&lt;&lt;endl; cout&lt;&lt;" 2*:删除：输入一个数据,在本树中查找该数据,若查找到则删除,若没有查找到则输出提示信息"&lt;&lt;endl; cout&lt;&lt;" 3*:求AVL：计算本树的平均成功查找长度"&lt;&lt;endl; cout&lt;&lt;" 4*:判断合法查找序列：输入一个序列,判断该序列是否是二叉排序树的合法查找序列"&lt;&lt;endl; cout&lt;&lt;" 5*:输入一个有序序列,创建高度最小的二叉排序树"&lt;&lt;endl; cout&lt;&lt;" 6:查找：输入数据,在本树中查询是否含有该数据"&lt;&lt;endl; cout&lt;&lt;" 7:插入：输入数据,在本树中插入数据为该数据的新结点"&lt;&lt;endl; cout&lt;&lt;" 8:中序遍历输出"&lt;&lt;endl; cout&lt;&lt;" 9:层次遍历输出"&lt;&lt;endl; cout&lt;&lt;" 10:树的高度输出"&lt;&lt;endl; cout&lt;&lt;" 11:销毁树"&lt;&lt;endl; cout&lt;&lt;" 12:图像打印本树"&lt;&lt;endl; cout&lt;&lt;" 13:调出菜单"&lt;&lt;endl;&#125;template&lt;class T&gt;void function(BSTree&lt;T&gt; tree,T stopSign)&#123; menu(); int option; bool select=true; while(select)&#123; cout&lt;&lt;"请输入正确选择功能序号，非正确功能信号不会响应："; while(1)&#123; cin&gt;&gt;option; if(option&gt;=0&amp;&amp;option&lt;=13) break; &#125; switch(option)&#123; case 0 :&#123; select=false; break; &#125; case 1 :&#123; cout&lt;&lt;"输入数据序列,以"&lt;&lt;stopSign&lt;&lt;"为结束标志：" ; tree.creatBSTree(stopSign); cout&lt;&lt;"创建完毕"&lt;&lt;endl; break; &#125; case 2 :&#123; cout&lt;&lt;"输入待删除数据：" ; T t1; cin&gt;&gt;t1; if(tree.remove(t1)) cout&lt;&lt;"删除成功"&lt;&lt;endl; else cout&lt;&lt;"删除失败,树中无该数据"&lt;&lt;endl; break; &#125; case 3 :&#123; if(tree.getRoot()==NULL)&#123; cout&lt;&lt;"空树！AVL=0"&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;"本树的平均成功查找长度为："&lt;&lt;endl; cout&lt;&lt;tree.getAVL()&lt;&lt;endl; &#125; break; &#125; case 4 :&#123; cout&lt;&lt;"输入序列,以"&lt;&lt;stopSign&lt;&lt;"为结束标志："; if(tree.judgeLegalSequence(stopSign)) cout&lt;&lt;"该查找序列合法"&lt;&lt;endl; else cout&lt;&lt;"该查找序列不合法"&lt;&lt;endl; break; &#125; case 5:&#123; cout&lt;&lt;"该操作会摧毁之前的树,进行重新建树,继续请输入1,取消输入0："; int t; cin&gt;&gt;t; if(t==1)&#123; tree.sortedArrayToLowestBST(); cout&lt;&lt;"创建成功"; break; &#125; cout&lt;&lt;"创建失败"&lt;&lt;endl; break; &#125; case 6 :&#123; cout&lt;&lt;"输入待查找数据：" ; T t2; cin&gt;&gt;t2; Node&lt;T&gt; *root=tree.getRoot(); Node&lt;T&gt; **p=tree.search(t2,root); if(*p!=NULL) cout&lt;&lt;"查找成功"&lt;&lt;endl; else cout&lt;&lt;"查找失败,树中无该数据"&lt;&lt;endl; break; &#125; case 7 :&#123; cout&lt;&lt;"输入待插入数据：" ; T t3; cin&gt;&gt;t3; if(tree.insert(t3)) cout&lt;&lt;"插入结点成功"&lt;&lt;endl; else cout&lt;&lt;"已有该节点，插入失败"&lt;&lt;endl; break; &#125; case 8 :&#123; tree.inOrder(); cout&lt;&lt;"输出完毕"&lt;&lt;endl; break; &#125; case 9 :&#123; tree.outputLevel(); cout&lt;&lt;"输出完毕"&lt;&lt;endl; break; &#125; case 10 :&#123; cout&lt;&lt;"本树的高度为："&lt;&lt;tree.deepth()&lt;&lt;endl; break; &#125; case 11 :&#123; tree.destroyTree(); cout&lt;&lt;"摧毁完毕"&lt;&lt;endl; break; &#125; case 12:&#123; if(tree.getRoot()==NULL) cout&lt;&lt;"空树！打印失败"&lt;&lt;endl; else tree.outPutTreeByGraph(); break; &#125; case 13:&#123; menu(); break; &#125; &#125; &#125; cout&lt;&lt;"该树的功能调用程序结束"&lt;&lt;endl;&#125; int main()&#123; BSTree&lt;int&gt; intTree; BSTree&lt;char&gt; charTree; BSTree&lt;double&gt; floatTree; function(intTree,-1); function(charTree,'#'); function(floatTree,-1.0); &#125;/*测试数据：建树序列：25 18 46 2 53 39 32 4 74 67 21 -1判断合法1：25 46 39 -1判断合法2：25 14 53 -1有序序列建立高度最低的树：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15*/]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构【九】排序]]></title>
    <url>%2Fposts%2Fa05558a1%2F</url>
    <content type="text"><![CDATA[部分转载：数据结构与算法系列–十大排序（附动态图解）数据结构 —— 排序算法总结数据结构常见的八大排序算法（详细整理）总体概述稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；内排序：所有排序操作都在内存中完成；外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；时间复杂度： 一个算法执行所耗费的时间。空间复杂度：运行完一个程序所需内存的大小。https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html==直观看排序==五类排序1、插入排序（1）直接插入排序方法：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过。时间性能：平均情况下排序的时间复杂度为 O(n2)。最好：O(n)——已经是正序的，比较 n-1 次，没有移动n-1次是对因为从低2个元素到底n个元素都是比较1次，求和为n-1最坏：最坏的情况：O(n^2)——正好是逆序的，比较(n+2)(n-1)/2次，移动n(n-1)/2次比较(n+2)(n-1)/2次，是因为从第2个元素开始，每个元素都是比较i次（i从2到n）的，使用等差数列求和。而比较的移动次数比比较次数少1，即从第2个元素开始每个元素比较i-1次，同样等差数列求和空间性能： O(1),仅需一个记录的辅助空间稳定性：稳定一次排序后元素不能确定其最终位置（2）折半插入排序核心思想：分治法方法：设元素序列 V[0], V[1], …, V[n-1]，其中, V[0], V[1], …, V[i-1] 是已经排好序的元素，在插入V[i] 时, 利用折半查找寻找V[i] 的插入位置，从该位置到V[i-1]的元素依次向后移动，最后将V[i]插入其实和直接插入本质区别就在于，根据插入排序的特点，前部分的数据是已经有序的，所以在前面查找插入位置可以使用二分查找法，提高查找效率时间性能： 平均情况下排序的时间复杂度为 O(n2)最好情况：排序前元素已按排序码从小到大有序，但是总排序码比较次数多于直接插入排序。没有移动。最坏情况：最坏情况，排序前元素逆序， 总排序码比较次数为nlog2n优于直接插入排序的（n+2)(n-1)/2次，移动n(n-1)/2次空间性能：O(1),仅需一个记录的辅助空间稳定性：稳定一次排序后元素不能确定其最终位置直接插入和折半插入的区别： 差距只在比较次数上，其他均相同。最好情况（全部有序）比较次数，折半插入反而比直接插入多，但是不会多很多，毕竟是nlog2n级，而最坏情况（逆序）比较次数折半插入nlog2n比直接插入的(n+2)(n-1)/2次要少的多。而移动次数、空间复杂度、稳定性不变，所以我们说折半插入排序的平均性能比直接插入排序要快（3）希尔排序推荐阅读：排序：希尔排序（算法）希尔排序实际上是对插入排序的一种改进，但是提高了效率的同时也变得不稳定希尔排序：**先追求表中元素部分有序，再逐渐逼近全局有序**方法：将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。不难发现一点，那么就是gap是几那么本次的排序组数就是几实现：第一层循环：将gap依次折半，对序列进行分组，直到gap=1，第二、三层循环：也即直接插入排序所需要的两次循环。时间性能：平均情况下排序的时间复杂度为 O（n1.3）空间性能：O(1),仅需一个记录的辅助空间稳定性：稳定一趟结束后元素不能确定其最终位置关于gap 的数值：图象转自：图解排序算法(二)之希尔排序2、选择排序选择排序核心思想：每一趟都选出一个最大或最小的元素，并放在合适的位置。（1）直接选择排序①在一组元素 V[i]～V[n-1] 中选择具有最小排序码的元素②若它不是这组元素中的第一个元素, 则将它与这组元素中的第一个元素对调③在这组元素中剔除这个具有最小排序码的元素。在剩下的元素V[i+1] ～ V[n-1]中重复执行第①、②步, 直到剩余元素只有一个为止。时间性能：平均情况下排序的时间复杂度为 O(n²)时间性能与初始排序序列顺序无关空间性能： O（1）稳定性：不稳定*一趟结束后会有一个元素确定其最终位置 *（2）锦标赛排序（树型选择排序）转载：树形选择排序有n个待排序的元素，把它们两两一组进行比较，取出较小的，然后在这n/2个较小者中再两两一组进行比较，取出较小的，重复上述步骤，直到取出最小元素。 这个过程用一棵满二叉树表示，在选出最小关元素后，将这个元素对应的叶子节点的值置为∞，然后把不为∞的兄弟节点移到父节点的位置。一直重复这个过程就可以了时间性能：O(nlogn)空间性能：需要占用大量空间（因为只有叶子节点是我们的数据，其他节点是为了筛选最值而创建）稳定性：稳定*一趟结束后会有一个元素确定其最终位置 *（3）堆排序定义:堆是一种完全二叉树，对于任意一个结点来说，其值都大（小）于其任意一个子节点的值，称为最大（小）堆因为完全二叉树有其非常卓越的性质：对于任意一个父节点的序号n来说（这里n从0算），它的子节点的序号一定是2n+1,2n+2，因此我们可以直接用数组来表示一个堆插入:在堆中插入一个结点就是将该元素插入到堆的尾部，然后不断上浮调整位置，直至满足堆的条件。POP根结点:删除堆顶元素后，用末尾元素补上，个数减1(这样才能用数组表示删除了一个节点)，然后不断下沉，直至满足堆的条件。删除其他节点：一样用末尾元素补上，个数减1(这样才能用数组表示删除了一个节点)，然后不断下沉，直至满足堆的条件。初始化: 首先：数据输入，构建完全二叉树​ 一个单独的节点就可以看成是一个最大堆了，如果我们用数组存放，那么由完全二叉树特点，后n/2个数为叶子。所以我们从第n/2个数据往前开始向上到根结点，我们可以将其最为一个子树的根，将这个子树视为刚刚删除一个根节点的堆，用POP根节点后的操作进行该子堆重构（需要该子堆不断判断下沉），这样操作保证了每一个子树都是堆，然后由小到大，保证了最终构成了堆，这样就不用再次检验是否是堆了，若对从2/n到1的节点只判断节点和左右子节点是否要交换，最后还需要再次判断是否是堆，并继续调整1、 将待排序序列构造成一棵完全二叉树2、把这棵完全二叉树改造成堆，则堆顶元素为最小值3、输出最小值4、删除根结点，将剩余的二叉树改造成堆，便可获取次小值5、输出次小值6、重复改造，直至输出所有结点，得到一个有序序列*堆的构造和POP根节点请查看数据结构：堆 *时间性能：为O(nlog2n)空间性能：O(1)稳定性：不稳定*一趟结束后会有一个元素确定其最终位置 *将数据改造为最大堆或者最小堆，不断重复输出根节点（但是操作换为最后一个元素和根元素互换），重新构建堆（也就是POP根节点操作）这样下去，最终就能在原有数组得到一个有序序列根据特性我们能推出：升序使用大顶堆，降序使用小顶堆==因为大根堆输出后跟和叶互换，成为最后一个。同理小根堆。==详解：[图解排序算法(三)之堆排序] ==建堆的过程，关键字对⽐次数不超过 4n，建堆时间复杂度= O(n)==3、交换排序（1）冒泡排序方法：设待排序元素序列中的元素个数为 n。最多作 n-1 趟，i = 1, 2, ……, n-1。在第 i 趟中从后向前，j = n-1, n-2, ……, i，顺次两两比较V[j-1].key和V[j].key。如果发生逆序，则交换V[j-1]和V[j]。图片转自：https://zhuanlan.zhihu.com/p/52884590值得注意的是冒泡排序有很多个版本，若第二个循环为例如：int j = 0; j &lt; array.length - 1 - i; j++即从前往后来，则每一轮排序都有一个数根据排序规则放到第array.length - 1 - i个位置上固定，即不断将数冒到后面依次从后往前有序化若为：for(int j=array.length-1;j&gt;=i;j--)即从后往前来，则每一轮都有一个数根据排序规则找到固定位置低i个元素上，即不断将数冒到前面从前往后有序化一般情况下，更倾向于第二种写法改进版：通过添加一个标记，如果某轮排序没触发交换动作，则说明已经有序，此时停止即可，这样可以提高效率时间性能：平均情况下排序的时间复杂度为 O（n2）空间性能： O(1)稳定性：稳定*一趟结束后会有一个元素确定其最终位置 *（2）快速排序方法：①以首元素作为基准元素（ 枢轴），从前、后双向扫描序列，通过交换，实现大值记录后移，小值记录前移，最终将基准元素安置在一个适当的位置。(小值记录在前、大值记录在后)②基准元素将原序列分割成两部分，依次对前后两部分重新设定轴记录，继而分别再进行快速排序。③直至整个序列有序。为什么我们要从右向左找小于基准元素的值，然后交换，再从左向右找大于基准元素的值再交换呢？因为这样可以很巧妙的一次遍历且只用一个交换存储空间就能达到我们的目的。就如同本例：基准元素为38，第一次交换后38后的数据由于我们从后向左比较，已经确定都是大于38的了，此时从左向右找大于基准元素的再交换，同理这样38左侧就一定都是小于38的了，这样知道low=high，遍历完毕，比基准元素小的都在左侧了，比基准元素大的也就都在右侧了。然后再对左侧序列和右侧序列进行快速排序，直到结束分析过程我们得到：它是一个递归程序（但是有非递归实现）时间性能：均情况下排序的O(nlog2n)由于是枢轴分割的思想，每趟都是一分为二，故快速排序需进行 log2n 趟。每趟的排序由于都是前、后同时进行，且一遍扫描就完成，可知每趟的时间复杂度为 O(n)，所以时间复杂度为 O(nlog2n)最坏情况：O(n2) 当输入序列基本有序时快速排序退化为冒泡排序最好的情况：O(nlog2n)快速排序算法优化思路：尽量选择可以把数据中分的枢轴元素。①选头、中、尾三个位置的元素，取中间值作为枢轴元素；②随机选⼀个元素作为枢轴元素空间性能：需栈空间以实现递归最坏情况：S(n)=O(n)一般情况：S(n)=O(log2n)稳定性：不稳定*一趟结束后会有一个元素确定其最终位置，就是每次的枢轴量最终位置 *程序递归栈等运行细节见视频。==408中的一趟可以看做是对一行进行处理。≠一次划分==4、归并排序基本思想： 假设初始序列含有 n 个记录，则可以看成是 n 个有序的子序列，每个子序列的长度为 1，然后两两归并，得到 x （一个不小于 n/2 的整数）个长度为 2 或 1 的有序子序列，再两两归并，……，如此重复，直至的代一个长度为 n 的有序序列为止；由于是折半分割的思想，归并排序需进行 log2n 趟。每趟的归并都需扫描全部记录，且一遍即可完成，由算法 可知时间复杂度为 O(n)。2-路归并排序算法的时间复杂度为 O(nlog2n)时间性能：O(nlog2n)空间性能：占用的附加存储空间较多, 需要一个与原待排序元素数组同样大小的辅助数组O（n）稳定性：稳定*一趟结束不能确定一个元素的最终位置 *这里我们使用的是二路归并排序:归并时，需要两个移动下标，从左向右比较两个序列的值，小的添入新序列，然后将原指向该数的下标+1再次比较，直到结束。多路归并同理，只是比较时是比较多个序列中的最值> 5、基数排序（1）LSD基数排序LSD基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。例如：设有 n 个待排序元素，每个元素的排序码有 d 位，每个排序码的取值范围为 radix每1趟分配需要扫描n 个元素，时间为O(n)每1趟收集需要对radix队列进行，时间为O(radix)整个排序需要进行d 趟LSD基数排序的时间复杂度为：O( d(n+radix) )基数排序是稳定的排序方法。注意这里分析是链式，所以是n+radix时间性能：O( d(n+radix) )空间性能：O (radix*d )稳定性：稳定*一趟结束不能确定一个元素的最终位置 *（2）MSD基数排序LSD从低位开始排到高位，每排一位都是把各个桶合并，再按下一位排序；MSD从高位开始排到低位，排完一位后不合并桶，相同的高位划分子桶继续分配，最后再合并详细了解MSD基数排序查看：基数排序：LSD 与 MSD排序算法分析一次排序能够缺点一个元素位置的算法：*各种选择排序+冒泡排序 *(1)平均时间性能快速排序最佳,但最坏情况下的时间性能O（n2）不如堆排序和归并排序O（nlogn）.（2)简单排序以“直接插入排序”最简单,当序列“基本有序”或n较小时,它是最佳排序方法,通常用它与“先进的排序方法”结合使用.(3)基数排序最适合n很大而关键字较小的序列(4)从稳定性看,归并排序,基数排序和“简单排序法”是稳定的;而快速排序,堆排序和SHELL排序，直接选择排序是不稳定的.(5)稳定性由方法本身决定,不稳定的方法总能举出使其不稳定的实例.外部排序1、多路归并进行排序(1)初始归并段(两个块归并) (2)第⼀趟归并(四个块(两个段)归并) ==很关键的一点，就是一旦一个缓冲区空下来了，就要用相应段的下一个归并块的块立即补上==(3)第⼆趟归并(八个块(两个段)归并)==把4个有序⼦序列（归并段）两两归并== (4)第三趟归并(十六个块(两个段)归并)(5)时间开销分析==相比于内存，外存的时间开销才是占比最高的。====外存的时间开销，主要是文件的总块树和归并的次数。====可以从归并的次数下手，减少所需时间。==(6)优化：多路归并和减少初始归并段数量 ==k越⼤，r越⼩，归并趟数越少，读写磁盘次数越少====多路归并带来的负⾯影响：====①k路归并时，需要开辟k个输⼊缓冲区，内存开销增加。====②每挑选⼀个关键字需要对⽐关键字（k-1）次，内部归并所需时间增加==⽣成初始归并段的“内存⼯作区”越⼤，初始归并段越⻓==注意，是初始归并段。就是你第一次准备完后。==谬误纠正 2、败者树==简单来说，败者树就是用已经比较过的信息节省之后的比较。== ==对于这八个归并段的比较。第一次比较了7次。====最小的是来自三号归并段的关键字1.====于是下一次选第二个小的的时候，三号归并段的6替补上去进行比较就行了，只用比较三次。==3、置换选择排序(减少归并段数量，构造更长的归并段) ==不断选出能放到同一归并段末尾的元素。若工作区均不满足，则开辟下一归并段进行上述操作。直到待排序文件读取运行完毕。== 注意的是，实际上运行的时候，我们并不是直接输出文件。而是放到缓冲区，缓冲区成一个块了，或者满了才输出到外存4、最佳归并树4.1归并树的读写==归并过程中的磁盘I/O次数 = 归并树的WPL * 2====要让磁盘I/O次数最少，就要使归并树WPL最⼩——哈夫曼树！==4.2路归并的最佳归并树4.3多路归并的情况 如果减少⼀个归并段==正确的做法====注意：对于k叉归并，若初始归并段的数量⽆法构成严格的 k 叉归并树，则需要补充⼏个⻓度为 0 的“虚段”，再进⾏ k 叉哈夫曼树的构造。== 删除归并段30得到添加虚段的数量==①若（初始归并段数量 -1）% （k-1）= 0，说明刚好可以构成严格k叉树，此时不需要添加虚段====②若（初始归并段数量 -1）% （k-1）= u ≠ 0，则需要补充 (k-1) - u 个虚段==]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python随记【三】]]></title>
    <url>%2Fposts%2F38f0351c%2F</url>
    <content type="text"><![CDATA[文件操作打开文件打开文件的方法open(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)file参数：指定了被打开的文件名称mode参数：指定了打开文件后的处理方式，默认为r读模式buffering参数：指定了读写文件的缓存模式。0表示不缓存，1表示缓存，如大于1则表示缓冲区的大小。默认值是缓存模式encoding参数：指定对文本进行编码和解码的方式，只适用于文本模式，可以使用Python支持的任何格式，如GBK、utf8、CP936等等。open()函数返回1个文件对象，通过该文 件对象可以对文件进行读写操作。如果指定文件不存在、 访问权限不够、磁盘空间不足或其他原因导致创建文件对 象失败则抛出异常。即使写了关闭文件的代码，也无法保证文件一定能 够正常关闭。例如，如果在打开文件之后和关闭文件之前 发生了错误导致程序崩溃，这时文件就无法正常关闭。在 管理文件对象时推荐使用with关键字例如：123with open('data.txt', 'r') as f: data = f.read() print('context: &#123;&#125;'.format(data))打开文件的方式文件的常用属性例如:123with open('test.txt') as f: print(f.mode) f.close()输出为r文件的常用方法read([size])： 从文本文件中读取size个字符（Python 3.x）的内容作为结果返回，或从二进制文件中读取指定数量的字节并返回，如果省略size则表示读取所有内容write(s) ：把s的内容写入文件writelines(s) ：把字符串列表写入文本文件，不添加换行符readline() ：从文本文件中读取一行内容作为结果返回readlines() ：把文本文件中的每行文本作为一个字符串存入列表中，返回该列表，对于大文件会占 用较多内存，不建议使用seek(offset[, whence])： 把文件指针移动到新的字节位置，offset表示相对于whence的位置。whence为0表示从 文件头开始计算，1表示从当前位置开始计算，2表示从文件尾开始计算，默认为0tell() ：返回文件指针的当前位置flush() ：把缓冲区的内容写入文件，但不关闭文件close()：关闭文件关于于seek()方法的是把 文件指针定位到文件中指定字节的位置，所以若为中文，则注意一个汉字两个字节其他文件操作查看:Python文件文件级操作Python的多种文件模块如果需要处理文件路径，可以使用os.path模块中的对象和 方法；如果需要使用命令行读取文件内容可以使用fileinput模块；创建临时文件和文件夹可以使用tempfile模块；OS模块常用方法os.path模块常用方法shutil模块常用方法os模块目录操作Python对图像文件的处理安装Pillow库import PIL #引入PIL中的所有类from PIL import Image #单独引入Image类PIL库的Image类常用方法Image类的打开或创建图片方法描述Image.open(filename)根据参数加载图像文件Image.new(mode,size,color)根据给定参数创建一个新图像Image.open(StringIO.StringIO(buffer))从字符串中获取图像Image.frombytes(mode,size,data)根据像素点data创建图像Image.verify()对图像文件完整性进行检查，返回异常Image类的4个处理图片的常用属性属性描述Image.format标识图像格式和来源，如果图像不是从文件读取，值为NoneImage.mode图像的色彩模式，”L”为灰度图像，“RGB”为真彩色图像，“CMYK”为出版图像Image.size图像的宽度和高度，单位为像素(px)，返回值为二元元组Image.pallette调色板属性，返回一个ImagePallete类型Image还能读取序列图像，包括GIF、FLI、FLC、TIFF等格式，open()方法打开时自动加载序列中的第一帧，使用seek()和tell()方法可以在不同帧之间移动Image类的图像转换和保存方法方法描述Image.save(filename,format)将图像保存为名为filename的文件，format是图片格式Image.convert(mode)使用不同的参数，转换图像为新的模式Image.thumbnail(size)创建图像的缩略图，size是缩略图尺寸的二元元组Image类的图像旋转和缩放方法描述Image.resize(size)按size大小调整图像，生成副本Image.rotate(angle)按angle角度逆时针旋转图像，生成副本Image类的图像像素和通道处理方法方法描述Image.point(func)根据函数func的功能对每个元素进行运算，返回图像副本Image.split()提取RGB图像的每个颜色通道，返回图像副本Image.merge(mode,bands)合并通道，其中mode表示色彩，bands表示新的色彩通道Image.blend(im1,im2,alpha)将两幅图片im1和im2按照如下公式插值后生成新的图像：im1×(1,0-alpha)+im2×alphaPIL的ImageFilter类提供了10种图像过滤方法方法描述ImageFilter.BLUR图像的模糊效果ImageFilter.CONTOUR图像的轮廓效果ImageFilter.DETAIL图像的细节效果ImageFilter.EDGE_ENHANCE图像的边界加强效果ImageFilter.EDGE_ENHANCE_MORE图像的阈值加强效果ImageFilter.EMBOSS图像的浮雕效果ImageFilter.FIND_EDGES图像的边界效果ImageFilter.SMOOTH图像的平滑效果ImageFilter.SMOOTH_MORE图像的阈值平滑效果ImageFilter.SHARPEN图像的锐化效果利用Image类的filter()方法可以使用ImageFilter类，格式Image.filter(ImageFilter.function)PIL的ImageEnhance类提供了5种图像增强和滤镜方法方法描述ImageEnhance.enhance(factor)对选择属性的数值增强factor倍ImageEnhance.Color(im)调整图像的颜色平衡ImageEnhance.Contrast(im)调整图像的对比度ImageEnhance.Brightness(im)调整图像的亮度ImageEnhance.Sharpness(im)调整图像的锐度NumPy库参考：官方中文文档Numpy教程CS231n课程笔记翻译：Python Numpy教程数组ArraysNumPy数组是通常的Python数组的扩展。NumPy数组配备了大量的函数和运算符，可以帮助我们快速编写上面讨论过的各种类型计算的高性能代码。创建数组常用属性常用形态操作切片和索引切片：和Python列表类似，numpy数组可以使用切片语法。因为数组可以是多维的，所以你必须为每个维度指定好切片。123456789101112131415161718192021222324252627282930313233import numpy as npa=np.random.rand(5,3)print(a)print(a[2])print()print(a[1:3])print()print(a[-5:-2:2])print()print(a[:3,:2])#索引print()print(a[[0,1,2],[2,1,0]])#数组中(0,2)，(1,1)和(2,0)位置处的元素#输出:# [[0.44761556 0.81326569 0.79004551]# [0.57454174 0.39755703 0.48081083]# [0.68405094 0.74275781 0.90948634]# [0.8489756 0.56085858 0.87524095]# [0.14517911 0.79332683 0.67406689]]# [0.68405094 0.74275781 0.90948634]# # [[0.57454174 0.39755703 0.48081083]# [0.68405094 0.74275781 0.90948634]]# # [[0.44761556 0.81326569 0.79004551]# [0.68405094 0.74275781 0.90948634]]# # [[0.44761556 0.81326569]# [0.57454174 0.39755703]# [0.68405094 0.74275781]]# # [0.79004551 0.39755703 0.68405094]高级索引numpy库的算术运算函数numpy库的比较运算函数图像和数据处理图像和数组的转换图像的数组表示和转换1、将图像转换为数组：im=Image.open(filename)arr=np.array(im)2、将数组存储为图像：pil_im=Image.fromarray()matplotlib库的使用NumPy Matplotlibmatplotlib库是提供数据绘图功能的第三方库，其pyplot字库主要用于实现各种数据展示图形的绘制。matplotlib画图可以总结为3个步骤：获取数据——画出基本图形——设置细节使用汉字Matplotlib 默认情况不支持中文,我们需要这样设置：12matplotlib.rcParams['font.family']='SimHei'matplotlib.rcParams['font.sans-serif']='SimHei'常用绘图函数绘图区域函数plt和pillow的结合使用]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】程序中断方式]]></title>
    <url>%2Fposts%2F1e6e907a%2F</url>
    <content type="text"><![CDATA[原文地址：程序中断方式程序中断方式概述计算机在执行程序得过程中，当出现异常情况或特殊请求时，计算机停止现行程序（（正在运行的程序）），转向对这些异常情况或特殊请求得处理，处理后再返回到现行程序的间断处。由于CPU和IO设备速度的不匹配，CPU通常要等待一段时间，才能实现主机与IO设备之间的信息交换。所以当CPU启动了IO设备之后，就转去执行现行程序，让IO设备准备好后主动通知（中断）CPU，CPU转去执行中断程序，进行数据交换。这就是IO中断。打印机的中断中断方式的电路中断请求触发器和中断屏蔽触发器每台外部设备都必须配置一个中断请求触发器INTR，当其为“1”时，表示该设备向CPU提出中断请求。同时也需要一个配对的 中断屏蔽器，用于屏蔽一些低优先级的中断请求（面对多个中断请求时），当它为“1”时，表示封锁其中断源。其电路逻辑图如下所示接口电路中D、INTR、MASK和中断查询信号的关系当设备准备就绪D为“1”、且该设备MASK不为“0”时，由CPU在指令执行结束阶段时，由CPU发出中断查询信号，将INTR设置为“1”排队器当多个中断源同时向CPU发出请求时，CPU会根据中断源的不同性质对其排队，给予不同等级的优先权，并按优先级等级给予响应。通常来说速度越快的IO设备，优先级越高，因为不及时响应高速的IO请求，信息可能会发生丢失。排队器分为硬件排队器和软件排队器：这里只介绍硬件排队器，下图是硬件排队器的电路链式排队器当各个中断源无请求时，各个INTR-均为高电平。一旦某个中断源提出中断请求时，就会让优先级低的中断源变为低电平，封锁其中的中断请求。比如当2、3号中断源同时有请求时（INTR2-、INTR3-均为0），流程如图所示链式排队器距离图INTRi- 没有提出请求时均为高电平，根据例子，二、三号中断源提出请求，二、三号输入低电压，由于二号经过与非门输出高电压，经过三号的非门，输出低电压，让三号无法被选。此时因为INTP1‘和INTP2‘输出都为高电压，又通过INTPi来和输出信号进行与运算，最终输出INTP2中断向量地址形成部件（设备编址器）CPU一旦响应了IO中断，就要暂停现行程序，转去执行该设备的中断服务程序。不同的设备有不同的中断服务程序，每个服务程序都有一个入口，而CPU需要通过设备编址码找到中断服务程序实际所在的位置。设备编址码的输入是来自排队器的输出INTPi，它的输出是中断源的位置设备编码器比如编址器输出12H，CPU就能从主存的12H的位置查找（假设是统一编址），找到对应的中断服务程序的入口地址IO中断处理过程中断的条件和时间CPU中的EINT(允许中断触发器)为“1”，该触发器用开中断置位，用关中断使其复位CPU响应中断的时间一定是在每条指令执行阶段的结束时刻接下来以输入设备为例，结合流程示意图进行讲解，流程图如下所示中断流程图当选中设备后，设备选择电路发出SEL信号CPU发出启动命令，将触发器B置为“1”，D为“0”接口启动输入设备，设备开始工作IO设备将数据送入数据缓冲寄存器当输入设备发出设备工作结束信号后，D被置为“1”，B被置为“0”，标志设备准备就绪当设备准备就绪，且本设备未被屏蔽时，在指令执行结束阶段，CPU会发出中断查询信号设备中断请请求触发器INTR被置为“1”，向CPU提出中断请求，INTR送至排队器，进行中断判优若CPU允许中断（ENIT=1），设备又被排队选中，即进入中断响应阶段，由中断响应信号INTA将排队器输出送至编码器形成的向量地址向量地址送至CPU，作为下一条指令的地址向量地址里存放的是无条件转移指令（看中断流程图），待转移指令执行完毕，就转去对应设备的服务程序入口地址，开始执行中断服务程序，通过输入指令将数据缓冲寄存器的输入数据送至CPU的通用寄存器，再存入主存相关单元中断服务程序的最后一条指令是中断返回指令，当其执行结束时，中断返回至原程序的断点处。中断服务程序的流程总共分为四个阶段保护现场中断服务恢复现场中断返回保护现场其一是保存程序的断点，其二是保存通用寄存器和状态寄存器的内容。前者涉及到中断隐指令，后者由中断服务程序完成。中断服务程序会在程序的起始部分安排若干条存数指令，将寄存器的内容存至存储器中保存；或者用进栈指令将各个寄存器的内容压入堆栈中保存。中断服务不同的设备中断服务不一样，比如打印机要求CPU将需要打印的字符代码送入打印机的缓冲器内；显示器设备要求CPU将需要显示的字符代码送入显示存储器中恢复现场在中断服务程序退出前，将中断的现行程序恢复回来。通常可用取数指令或出栈指令，将保存在存储器中的信息送回到原来的寄存器中中断返回中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处单重中断和多重中断当CPU响应了一个中断源的中断请求后，EINT会被置为“0”，无法让其他中断源继续请求。对于单重中断，在保护完现场后，即刻去执行设备服务，直到恢复完现场后，才将EINT置为“1”并返回。而对于多重中断来说，在保护完现场后，就立刻将EINT设置为“1”，允许其他中断源插入中断请求。示意图如下所示单重中断和多重中断多重中断就和方法里面再调用其他方法一样，如下图所示嵌套调用总结从宏观上看，中断方式克服了程序查询方式的原地踏步，CPU和IO设备是并行操作的，提高了CPU的资源利用率从微观上看，CPU在处理中断服务程序时仍然需要暂停原程序的运行，尤其是当高速IO或辅助存储器频繁地与主存交换信息时，需要不断打断CPU执行主程序而执行中断服务程序。主程序和服务程序抢占CPU资源为了完善中断程序，人们提出了DMA控制方式。]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】DMA方式]]></title>
    <url>%2Fposts%2Fc7c5a73a%2F</url>
    <content type="text"><![CDATA[DMA方式概述DMA方式是IO接口的控制方式之一。DMA和其他控制方式相比，它拥有专门的数据通路，所 以主存和设备交换信息时，可以不经过CPU，也不需要CPU参与数据交换（程序中断需要CPU参与中断服务），那么就省去了 保护现场、恢复现场的流程。由于DMA接口的速度很快，所以经常用于高速IO设备，因为高速IO设备如果不及时交互信息，很可能产生数据丢失。上面所有的优势均建立在 主存和IO设备直接交换信息，不需要经过CPU这个条件之上，而当CPU和IO设备同时访问主存时，就会发生冲突。为了解决冲突，通常会采用以下几个方法：停止CPU访存周期挪用（又称周期窃取）交替访问停止CPU访存假设IO设备要发送一些数据，DMA接口会向CPU发出一个停止信号，要求CPU放弃总线控制前，DMA接口获得总线控制权后，开始进行数据传送，在数据传输结束后，DMA接口通知CPU可以使用主存，并把总线使用权交给CPU。其时序图如下所示停止CPU访问主存这种方式的缺陷主要在于 CPU失去总线控制权的这段时间里，DMA接口也并不是百分百利用这段时间，因为IO设备传输数据给接口的数据缓冲器这段时间也总大于一个存期周期。换句话来说，当IO设备还在准备数据的时候，CPU也仍然处于空闲状态。周期挪用（周期窃取）当IO设备发出DMA请求时，IO设备便挪用或窃取总线占用权一个或几个周期，而DMA不请求时，CPU仍可继续访问。而IO设备请求DMA时，会有三种状况：CPU不访问主存，那么DMA接口和CPU不会发生主存CPU正在访问主存，那么DMA接口需要等待该次存储周期结束DMA和CPU同时要访问主存时，DMA接口发出请求占用几个存取周期（即在CPU执行访存指令过程中插入DMA请求，使CPU延迟了几个周期再访问）周期挪用时序图IO设备每挪用一个主存周期都要申请总线控制权、建立总线控制权和归还总线控制权。因此，对于主存来说，虽然只传一个字只占用一个周期，但对DMA接口来说，要处理包括申请、建立、传输、归还等阶段，实质上DMA接口要占好几个周期。因此周期挪用适合IO设备的读/写周期大于主存周期的情况。DMA与CPU交替执行这种方式不需要总线使用权的申请、建立、归还过程，总线使用权分别由C1、C2控制的。CPU和DMA接口各自有独立的访存地址寄存器、数据寄存器、读写信号。实际上总线变成了C1、C2控制下的多路转换器，其总线控制权的转移几乎不需要时间，具有很高的DMA传送速率。交替访问时序图DMA接口的功能和组成DMA接口应该具有以下几个功能：向CPU申请DMA传送在CPU允许DMA工作时，处理总线控制权的转交，避免引起总线竞争在DMA期间管理系统总线，控制数据传输确定数据传送的起始地址和数据长度，更新数据传输过程中的数据地址和数据长度在数据块传输结束时，给出DMA操作完成的信号DMA接口的组成原理如下图所示DMA接口的组成DMA数据传输的流程DMA的数据传送过程分为 预处理、数据传送、后处理三个阶段。其示意图如下所示：DMA传输过程概览预处理在DMA接口开始工作之前，CPU必须给它预置如下信息：给DMA控制逻辑指明数据传送方向给设备地址寄存器（DAR）送入设备信号向主存地址寄存器（AR）送入交换数据的起始地址对字计数器赋予交换数据的个数当这些工作完成后，程序初始化结束。数据传输等IO设备准备好数据 或 处理完输出的数据后，就让DMA接口向CPU提出总线获取控制权，如果有多个DMA请求，则按轻重缓急排队等待。当IO设备获取到总线控制权后，数据的传输就由DMA进行管理。DMA数据传输过程概览DMA传输过程详情数据读取过程：IO设备发送数据到数据缓冲区内IO设备发送DREQ请求给DMA控制逻辑DMA控制逻辑发送HRQ给总线申请获取总线控制权获取成功后，DMA控制逻辑收到HLDA响应，将总线控制权交给DMA接口将DMA主存地址寄存器的主存地址送到地址总线，并命令存储器写通知设备已被授予一个DMA周期（DACK），并为下一个字做准备将DMA数据缓存寄存器的内容送至数据总线主存将数据总线上的信息写到地址总线指定的存储单元修改AR和WC判断数据块是否结束，若未结束继续传输；否则向CPU申请程序中断，标志数据传输完毕输出数据过程：当DMA的BR已将数据送至IO设备后，表示BR已空设备向DMA接口发请求DREQDMA接口向CPU申请总线控制权HRQCPU发回HLDA信号，允许交出总线控制权将DMA主存地址寄存器中的主存地址送到地址总线，并命令存储器读通知设备已经被授予一个DMA周期（DACK），并为交换下一个字做准备主存将相应地址单元的内容通过数据总线读入DMA的BR中将BR的内容送到输出设备修改AR和WC判断数据块是否结束，若未结束继续传输；否则向CPU申请程序中断，标志数据传输完毕后处理当DMA的中断请求得到响应后，CPU停止原程序的执行，转去执行中断服务程序，做一些DMA的结束工作，包括校验数据的正确性、决定是否继续用DMA传送其他数据块、测试传输过程中是否发生错误。]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构【八】散列（哈希）]]></title>
    <url>%2Fposts%2F26b589a7%2F</url>
    <content type="text"><![CDATA[转载原文：数据结构（查找-散列表（哈希表）的查找）什么是散列表（哈希表）散列表是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。散列函数1、散列函数需要的性质得到的散列值是一个非负整数两个相同的键，通过散列函数计算出的散列值也相同两个不同的键，计算出的散列值不同对于第三条来说，想要找到不同的 key 对应的散列值都不一样的散列函数是不可能的。2、散列冲突（collision）冲突：两个不同的键分配的位置相同（映射到了同一个数字上）。3、常见散列函数（1）数字分析法通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。数字分析法仅适用于事先明确知道表中所有关键码每一位数值的分布情况、它完全依赖于关键码集合(2)平方取中法假设关键字是1234，平方之后是1522756，再抽取中间3位227，用作散列地址。平方取中法比较适合于不 知道关键字的分布，而位数又不是很大的情况。因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。一般取散列地址为8的某次幂（3）折叠法将关键字从左到右分割成位数相等的几部分，最后一部分位数不够时可以短些，然后将这几部分叠加求和， 并按散列表表长，取后几位作为散列地址。比如关键字是9876543210，散列表表长是3位，将其分为四组，然后叠加求和：987 + 654 + 321 + 0 = 1962，取后3位962作为散列地址。折叠方式除了直接相加还有来回反转相加的分界法，987+456+321+0折叠法适合关键码位数较多，且关键码每一位上数字分布比较均匀的情况（4)留取余数法f(key) = key mod p (p≤m)，m为散列表长。这种方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。根据经验，若散列表表长为m，通常p为小于或等于表长（最好接近m）的最小质数，可以更好的 减小冲突。4、处理冲突的方法(1)开放地址法(闭散列法)开放地址就是一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并且记录它。至于如何寻找下一个空的散列地址，有三种方法①线性探查法f(key)=(f(key)+d)%m ,其中d取（0，1,2,3,4.....，m-1），m为散列表的长度线性探测来解决冲突问题，会造成冲突堆积。例如：本来是属于下标1的元素，现在却占用了下标为2的空间，这会造成待会我们需要存放本来要放在下标为2的元素时，再次发生冲突，这个冲突会一直传播下去，造成查找和插入效率都大大减低。②二次探测法f（key）=（f(key)+d）%m, ,其中d取（0^2，1^2,-1^2,2^2,-2^2,3^2,-3^2,4^2,-4^2...,q^2,-q^2），q&lt;=m/2,m为散列表的长度其实，这个是对线性探测的一个优化，增加了平方可以不让关键字聚集在某一块区域。③随机探测法（双散列法）f（key）=（f(key)+d）%m, d为随机数列，而m为表长(2)链地址法(开散列法)其实就是当发生冲突时，我还是把它存放在当前的位置，只是每个位置都是使用链表来存放同义词，这个思路和图的邻接表存储方式很相似。（3）良好的装填因子装填因子：a=n/m 其中n 为关键字个数，m为表长。**当a处于0.6~0.9之间较为良好，否则建议我们修改表长**平均查找成功和不成功长度一定要先理解ASL概念设数据表中有 n 个元素，搜索第 i 个元素的概率为 pi搜索到第 i 个元素所需比较次数为 ci，则搜索成功的平均搜索长度:一般情况下我们认为pi是相同的，就像有n个小球随记抽取一个，概率为1/n，我们查找某个数的概率也是1/n线性探查法ASL成功=（探查每个元素的次数求和）/表中元素的个数理解：既然能查询成功，说明一定是表中元素，所以计算每个元素的查找长度求和后乘查找每个元素的概率1/5ASL不功=（对从0~MOD-1的地址逐个求出分别离他们按顺序查找最近的空元素位置的长度再求和）/MOD长之所以查询到空就是探查失败，因为若有该数据，则该空位置是可以存放的理解：既然查找不成功，说明一定不表是中元素，这时候可能对散列函数值任意一个查找，若使用留取余数法则一共有MOD种查找可能，每种可能查找的概率为1/MOD，再对每种可能的查询分析查找长度再求和，注意查询失败的条件是查询倒空而不是查询到表尾]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理【八】输入输出系统]]></title>
    <url>%2Fposts%2F1e96f95%2F</url>
    <content type="text"><![CDATA[导图IO指令和通道指令的区别转载：I/O指令与通道指令的区别I/O指令是CPU指令系统的一部分，是CPU用来控制输入/输出操作的指令，由CPU译码后执行。在具有通道结构的机器中，I/O指令不实现I/O数据传送，主要完成启，停I/O设备、查询通道和I/O设备的状态及控制通道进行一些操作等。通道指令是通道本身的指令，用来执行I/O操作，如读、写、磁带走带和磁盘找道等操作接口的组成和功能1、总线连接方式的IO接口电路2、接口的功能和组成部分转载：漫谈计算机组成原理（七）I/O系统如上图所示，I/O接口由数据缓冲寄存器、设备选择电路、设备状态标记、命令寄存器和命令译码器组成。之所以说I/O接口起到了桥梁的作用，是指它一端连接了CPU，另一端则连接了I/O设备，能够有效的保证设备和CPU间 正确的数据交换。 接下来说一下各个模块的作用：设备选择电路：这个电路是一种比较器，简单可以理解为CPU向接口发送了一个设备地址，而比较器就是拿着这个设备地址去判断究竟那个I/O设备的地址和这个地址相同，如果找到则建立连接。命令寄存器和命令译码器：起到了传送命令的作用 ，只有设备选择信号有效，才接收命令线上的命令码数据缓冲寄存器：缓冲从I/O设备中读取到的信息，或者是把CPU中传给I/O设备的数据缓存。设备状态标记：可以用于标记设备的工作状态、标记设备是否准备完成、标记是否可以向CPU发送中断请求等功能：选址功能：设备选择电路实现传送命令功能：命令寄存器和命令译码器实现传送数据功能：数据缓冲寄存器实现反应IO设备工作状态的功能：设备状态标记实现当D=0，B=0，表示设备处于暂停状态当D=1，B=0，表示设备处于准备完毕状态当D=0，B=1，表示设备处于准备状态INTR为1则表示该设备向CPU发出中断请求MASK和中断请求配合使用完成设备的屏蔽功能I/O设备与主机信息传送的控制方式转载：漫谈计算机组成原理（七）I/O系统1、程序查询方式（1）程序查询方式的介绍程序查询方式就是利用CPU向I/O设备发送读取指令，然后再检查I/O设备的状态，如果I/O设备已经准备就绪，则一个一个字节的将数据传输到CPU中；如果I/O设备没有准备就绪，则CPU将会不断的向I/O设备发送查询请求，直到I/O设备准备好了。 注意，在CPU不断查询的过程中，原有的程序是被打断了的，如果I/O设备没有准备好，那么原来执行的程序就不会执行，直到I/O设备就绪，且数据读取完毕，程序才会恢复。 上面说的是只有一个设备的情况，CPU会采取踏步查询的方式查询I/O设备是否准备好了。那么如果一个接口连接着多个I/O设备又当如何呢？如下图，当一个设备没有准备好的时候，就向下查询，然后如果还是没有准备好，则循环这个过程。可以看到，这种方式存在非常鲜明的优先级问题，极端一些，如果第一个设备请求完成一次，接着就进行下一次请求，那么后面的设备可能永远也没有办法得到CPU的“临幸”。（2）程序查询方式的程序流程CPU先保存自己的寄存器情况（因为这种方式传输数据需要占用CPU寄存器）设置计数器，即要读取多少次（因为传送往往是一批数据）设置要存放的位置的起始位置（最终我们是从内存中读取或者写数据的设置起始位置）CPU启动IO设备获取IO设备状态标志到CPU，检查IO设备是否准备就绪：如果准备就绪，开始读取数据，反之原地踏步CPU执行IO指令，或从IO接口中的数据缓冲寄存器中读取一个数据，或者写入数据到IO接口的数据缓冲寄存器内修改主存地址（修改主存地址才能读取或者写入下一个数据，CPU的寄存器只是个暂存我们最终还是要写入内存的）修改计数器（比如从正数递减到0，或从负数递增到0）结束IO传输（3）程序查询方式的接口电路1.CPU通过IO指令启动输入设备时，指令的设备字段通过地址线送至设备选择器电路2.若该接口设备码吻合，则输出SEL有效，其他部件才允许工作3.IO指令的启动命令将’B’置1，”D“置04.B触发器启动设备工作5.输入设备将数据送至数据缓冲寄存器6.设备发设备工作结束信号，“D”置1，“B”置0，表示准备完毕7.D触发器以准备就绪状态通知CPU表示外设准备就绪8.CPU执行输入指令将数据缓冲寄存器的数据送入CPU通用寄存器在存入主存相关单元2、程序中断方式（1）程序中断方式介绍这种方式就要比第一种方式聪明了，上一种方式是由CPU占据主导地位，而这种方式是由I/O设备占据主导。 只有当I/O设备准备好了以后，才会向CPU发送一个中断请求，表示我已经准备好了，然后CPU执行中断，与I/O设备进行数据交互。 图示如下：这种方式没有CPU的“原地踏步”式的查询，即CPU不会去等待设备准备好，而是设备准备好了，你直接通知CPU就好了，这无疑大大提高了效率。（2）补充推荐阅读：程序中断方式为了提高计算机效率关于排队器效果：优先级从高到低，第一个中断请求之前和自己的所有INTP`的输出全为1，之后的全为0，之后再与自身INTR（中断请求）链接与非门再链接非门输出，就能确定优先级最高的中断请求了.关于中断隐指令转载：https://blog.csdn.net/jxq0816/article/details/52623797这些操作是由硬件直接实现的，把它称为中断隐指令。中断隐指令并不是指令系统中的一条真正的指令，它没有操作码。所以中断隐指令是一种不允许、也不可能为用户使用的特殊指令。它完成的操作是：①关中断。在中断服务程序中，为了保护中断现场（即CPU主要寄存器的内容）期间不被新的中断所打断，必须关中断，从而保证被中断的程序在中断程序服务程序完毕之后能接着正确地执行下去。②保存断点。为了保证在中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来程序的断点（即程序计数器（PC）的内容）保存起来。③引出中断服务程序。取出中断服务程序的入口地址(中断向量)并传送给程序计数器（PC）3、DMA方式DMA方式就如同一开始讲的那样，DMA直接与主存进行数据交互，不占用CPU的时钟周期，直接I/O设备之间建立通路，再次提升了效率。 我们来看一下DMA方式传送数据的过程：DMA传输数据的过程包括三个过程。 首先是预处理，找到I/O设备输入的数据要存放在主存中的地址，然后找到I/O设备的地址，接着设定数据传送的个数。 接着是数据传送，因为DMA方式并不占用CPU，所以可以在主程序执行的过程中，完成I/O设备的数据传送。虽然说是不占用CPU但是若出现CPU和DMA想同时访问主存，则优先DMA访问，此时CPU只能做其他的不访问存储器的工作4、三种方式CPU工作效率比较]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理【七】:系统总线]]></title>
    <url>%2Fposts%2F1279ec38%2F</url>
    <content type="text"><![CDATA[导图兆赫（Mega Hertz, MHz）是波动频率单位之一。波动频率的基本单位是赫兹，采千进位制；1兆赫相当于1000千赫（KHz），也就是10^6赫兹。值得注意的是，兆赫只是一定义上的名词，在量度单位上作100万解。MIPS每秒百万指令推荐阅读：总线控制题外话:串行通信速度一定比并行通信速度“更快”吗？并行接口速度比串行接口速度快，这是若干年前的情况了。在实际时钟频率比较低的情况下，并口因为可以同时传输若干比特，速率确实比串口快。但是，随着技术的发展，时钟频率越来越高，并行导线之间的相互干扰越来越严重。并行接口因为有多条并行且紧密的导线，但时钟频率提高的一定程度时，传输的数据已经无法恢复。而串口因为导线少，线间干扰容易控制，反而可以通过不断提高时钟频率来提高传输速率。而且串口的端子也会比较小。这就是为什么现在高速传输都采用串行方式的原因。]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理【六】:控制单元的设计]]></title>
    <url>%2Fposts%2F76c8bb7f%2F</url>
    <content type="text"><![CDATA[导图组合逻辑设计组合逻辑控制单元框图首先我们再次分析CU的外特性（再第九章，我们曾分析过）：输入: 节拍发生器信号、操作码译码信号、标志位信号输出：操作码对应阶段需要的发送到CPU内部或者系统总线的控制信号注意CU输出位为K位，根据设计的实际情况而来，因为虽然是2n条指令，每一条指令所完成需要的微操作就那么几种，设计的CU微操作只有K种，通过不同组合完成不同操作，这和操作码的数量无关这里强调几点：1、节拍的宽度应该保证能使得数据信息通过数据总线从源到目的地的时间，这样才能保证微指令的操作成功。因为最花时间的也就是访存等操作了如果在节拍中访存操作微指令例如M(MAR)-&gt;MDR能够完成，那么对CPU内部操作的指令也一定能完成，因为他们更快。2、节拍发生器用来控制指令的顺序性。我们通过设计将某个节拍作为某个微指令控制信号的产生条件，这样就能控制微指令的执行顺序。3、标志位也是用来控制信号的产生，例如条件跳转信号的标志，处于哪个工作周期的标志。通过这样层层条件控制，我们最终能够达到微指令执行的顺序性指令由操作码控制，一条指令再被分成多个机器周期执行这由工作钟周期标志控制，每个工作周期干什么活由节拍序列控制，每个节拍长度能够支撑完成控制信号所代表微操作的执行。每个指令都可以这样划分，然后最终落实到某个节拍发出某个控制信号，然后对应部件执行微操作微操作的节拍安排有些微操作的次序是不容改变的，故安排微操作节拍时必须注意微操作的先后顺序。凡是被控制对象不同的微操作，若能在一个节拍内执行，应尽可能安排在同一个节拍内，以节省时间。如果有些微操作所占时间不长，应该将它们安排在一个节拍内完成，并且允许这些微操作有先后次序。组合逻辑设计步骤1、列出微操作命令的操作时间表2、写出微操作命令表达式3、画出微操作命令逻辑图组合逻辑设计缺点指令系统功能越全，微操作命令越多，线路越复杂，调试就更困难。微程序设计微程序控制单元的基本框图以及工作原理点划线框内的控制存储器（简称控存）是微程序控制单元的核心部件，用来存放全部微程序；CMAR是控存地址寄存器，用来存放欲读出的微指令地址；CMDR是控存数据寄存器，用来存放从控存读出的微指令；顺序逻辑是用来控制微指令序列的，具体就是控制形成下一条微指令的地址，其输入与微地址形成部件、微指令的下地址字段以及外来的标志有关。微指令的基本格式共分为两个字段，一个为操作控制字段，该字段发出各种控制信号；另一个为顺序控制字段，它可指出下条微指令的地址，以控制微指令序列的执行顺序。CU框图的输入和组合逻辑设计一致（但是这里我们不再对节拍信号具有强要求，只要是节拍信号能够作为时钟信号输入即可因为不同程序运行过程已经是顺序储存好了的了不必再根据节拍区分某时间段执行什么），输出也一致，所以如果我们把CU视为一个黑盒，那么这两种设计产生的结果一致只是内部运行机制的不同程序运行过程见课本，值得注意的是初始化的时候，我们需要将该机器指令主存所在地址送入PC再将微程序从取址微程序开始启动。控存只需要读出所以可以使用ROM]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理【五】:控制单元的功能]]></title>
    <url>%2Fposts%2Fb67e1f92%2F</url>
    <content type="text"><![CDATA[导图关于指令周期、机器周期、时钟周期其实在了解了第十章之后才能对机器周期以及其分配有更深刻的了解，这里是学习第十章后的复盘我们其实设置机器周期的最终目的还是为了保证指令能够有序成功执行机器周期的设置使得每个指令，都能分层执行，同时节省时间，提高效率。试想，若没有机器周期的划分，计算机指令纯靠节拍、操作译码信号、标志位来生成控制，为了指令执行完全，我们必须使节拍设置成最复杂操作的所需要的节拍数，我们每个指令都要经历这么多的节拍使得某些简单操作执行后依旧有大量的空闲时间，造成时间的浪费，其实这也可以看作是一个不合理的超长机器周期，它使得灭个指令都能在一个机器周期内完成。我们设置了正常机器周期，就可以把一个指令分成多个机器周期执行，每个机器周期中包含的节拍我们设置成能够满足完成一个基本操作的节拍数量，再给每个机器周期设置标志，每条指令根据各自的机器周期划分进入不同机器周期完成操作，这样能大大提高效率。一般机器周期我们设置成访问能完成从一次存储器所需要全部操作的节拍数量，这样能够保证时间浪费的减少，在存储字长等于指令字长也就是我们一直学习的例子下，取指周期也就是一个机器周期。]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构【七】:图]]></title>
    <url>%2Fposts%2F7dc31fbc%2F</url>
    <content type="text"><![CDATA[需要知道的图的相关基本概念无向图有向图权度、出度、入度边和弧：无向图中边就叫边，有向图中边叫做弧，还有弧头和弧尾之分，带箭头一端为弧头。路径和回路：从一个顶点到另一顶点途径的所有顶点组成的序列（包含这两个顶点），称为一条路径。如果路径中第一个顶点和最后一个顶点相同，则此路径称为”回路”（或”环”）。简单路径（回路）：顶点不重复的路径（回路）完全图:无向图中任意两个点之间都有边，有向图中任意两个点有互相通往对方的弧具有 n 个顶点的完全图，图中边的数量为 n(n-1)/2；而对于具有 n 个顶点的有向完全图，图中弧的数量为 n(n-1)。稀疏图和稠密图：边数e&lt;nlogn为稀疏图反之为稠密图简单图：无重复的边或顶点到自身的边连通图：无向图中，如果任意两个顶点之间都能够连通连通分量：若无向图不是连通图，但图中存储某个极大子图符合连通图的性质，则称该子图为连通分量。强连通图：有向图中，任意两个顶点之间能够连通强连通分量：若有向图不是连通图，但图中存储某个极大子图符合强连通图的性质，则称该子图为强连通分量。网：图上的边或弧带有权则称为网。生成树:无向图中连通且n个顶点n-1条边称为生成树。有向图中一顶点入度为0其余顶点入度为1的叫有向树。一个有向图由若干棵有向树构成生成森林。图的存储结构1.邻接矩阵存储（1）图象理解（2）语言构造根据图象理解，我们可以在类中动态定义一个一维数组存储节点，一个二维数组存储邻接矩阵2.邻接表存储（1）图象理解若为有权图，则需要在结点中添加代表权值的变量根据图象理解，我们先定义两个结构体节点，一个为邻接表的结点，一个为邻接表中存储其联通关系的链表结点。参考文章：数据结构—图的详细介绍大话数据结构-图图的遍历（DFS和BFS）1、Depth First Search深度优先探索所以我们DFS分两个函数主要是因为这个辅助数组一般方式下不能放入递归函数体中，不然每次都会创建2、Breadth First Search广度优先探索BFS可以在一个过程中完成，分两部分是为了解决多连通分量的情况，利用同DFS注意:1、DFS和BFS的主函数其实是一样的,区别在于子过程2、判断结点信息只需要在主过程判断一次传进来的点位置就可以了，因为子过程调用一定是正确的存在的点位置#### 3、补充无论是BFS还是DFS，设n个点e个边，用邻接矩阵作存储结构，查找每一个顶点的邻接点所需时间为O(n)，遍历图的时间复杂度为O(n2)。用邻接表作存储结构，查找所有的邻接点所需时间为O(e)，每个顶点仅被访问1次即所需时间为O(n)遍历图的时间复杂度为O(n+e) 。- 利用 DFS 或 BFS 可以获取图的生成树推荐阅读图的遍历之 深度优先搜索和广度优先搜索最小生成树Kruskal算法Prim算法推荐阅读最小生成树-Prim算法和Kruskal算法最短路径1、求一点到其他点的最短路径（单源最短路径）①Dijkstra算法复杂度O(n2)注意：Dijkstra算法不能允许权值为负推荐阅读深入理解 Dijkstra 算法实现原理最短路径问题—Dijkstra算法详解②bellman-ford算法注意：bellman-ford算法允许权值为负3、求任意两点的最短路径①Floyd算法傻子也能看懂的弗洛伊德算法（转）复杂度O(n3)注意： 通常可以在任何图中使用，包括有向图、带负权边的图。但是不能有带负权的边组成的回路AOV（Activity On Vertices）网络和拓扑排序1、AVO网络活动网络可以用来描述生产计划、施工过程、生产流程、程序流程等工程中各子工程的安排问题。 一般一个工程可以分成若干个子工程，这些子工程称为活动（Activity）。完成了这些活动，整个工程就完成了。我们可以用上图的有向图来表示课程之间的先修关系。在这种有向图中，顶点表示课程学习活动，有向边表示课程之间的先修关系。例如顶点C1到C8有一条有向边，表示课程C1必须在课程C8之前先学习完。实际上，在这种有向图中，用顶点表示活动，用有向边表示活动u必须先于活动v进行。这种有向图叫做活动网络（Activity on Vertices），记做AOV网络。前驱与后继：在AOV网络中，如果存在有向边，则称活动u必须在活动v之前进行，并称u是v的直接前驱，v是u的直接后继。如果存在有向路径，则称u是v的前驱，v是u的后继。有向环与有向无环图：从前驱与后继的传递性和反自反性可以看出，AOV网络中不能出现有向回路（或称为有向环）。不含有向回路的有向图称为有向无环图(DAG, Directed Acyclic Graph)。在AOV网络中如果出现了有向回路，则意味着某项活动以自己作为先决条件，这是不对的。2、拓扑排序1、判断有向无环图的方法是对AOV网络构造它的拓扑有序序列（Topological Order Sequence）；2、构造这种AOV网络全部顶点的拓扑有序序列的运算称为拓扑排序，即将各个顶点排列成一个线性有序的序列，使得AOV网络中所有存在的前驱和后继关系都能得到满足。3、一个AOV网络的拓扑有序序列可能不是唯一的；4、拓扑排序实现方法：（1）从AOV网络中选择一个入度为0（即没有直接前驱）的顶点并输出；（2）从AOV网络中删除该顶点及该顶点发出的所有边；（3）重复步骤（1）和（2），直至找不到入度为0的顶点。经过上述步骤后，有两种结果：（1）所有的顶点都被输出，也就是整个拓扑排序完成了；（2）仍有顶点没有被输出，只剩下入度不为0的顶点，即存在有环图。摘选自：AOV网络和Kahn算法拓扑排序AOV网络与拓扑（一）AOE（Activity On Edge）网络与关键路径1、AOE网络AOE网的基础概念定义:如果在无环的带权有向图中用有向边表示一个工程中的活动用边上的权值表示活动的持续时间用顶点表示事件则这样的有向图叫做用边表示活动的网络，简称AOE网络一定要注意：AOV网中，点代表活动，AOE网中边代表活动两者是不同的。实践和活动的理解，AOE网中边为活动，点为事件，可理解事件是一个“检查点”，它是一种“状态”，只有“检查”到通向该事件的活动全部完成的状态，才能进入下面的活动AOE网中没有入边的顶点称为始点AOE网中没有出边的顶点称为终点AOE网的性质1、只有进入某顶点的各活动都结束，该顶点所代表的事件才能发生2、只有某顶点所代表的事件发生后，从该顶点出发的各活动才能开始AOE网的应用AOE在工程方面非常有用：例如：（1）完成整个工程至少需要多少时间（假设没有环）；（2）为缩短完成工程所需时间，应当加快那些活动？因为在工程当中，很多活动是并行的，所以有些活动是导致工期长短的关键活动，不能拖延，而有些活动是可以在一定范围内延迟的，这是计算关键路径的原因！2、关键路径关键路径的相关概念从源点到各个顶点，以至从源点到汇点的有向路径可能不止一条。这些路径的长度也可能不同，完成不同路径的活动所需时间不同，但只有各条路径上所有活动都完成了，整个工程才完成。完成整个工程所需时间取决于从源点到汇点的最长路径长度，即在该路径上所有活动的持续时间之和，给路径称为关键路径。为了找出关键路径，必须找出关键活动，即不按期完成就会影响整个工程完成的活动。关键路径上的所有活动都是关键活动。四个和计算关键路径相关的量事件最早可能开始时间Ve[k]：求法为源点到该顶点的最大长度，需要正向计算取大得出事件最迟允许开始时间Vl[k]：需要逆向计算取小得到活动最早开始时间e[i]：活动代表的是边，它的最早开始时间和它作为某个点出度的事件的最早开始时间相同活动的最晚开始时间l[i]：通过该边作为入度指向的事件的最晚触发事件逆向计算得到计算关键路径计算各个活动的时间余量l[k]-e[k]，时间余量为0即（l[k]=e[k]）者为关键活动多个或一个活动的完成才能决定一个事件的触发，它取决于触发事件的活动中最长的一个，我们从始点开始计算每个事件的最早开始时间，也就是计算每个点相对始点的最大路径，一直计算到终点，就计算出了完成工程的最早时间，通过工程完成的最早时间我们能逆推每个事件完成的最晚时间，然后通过每个事件得出每个工程的最晚开始时间**通过最大路径计算得到每个事件的最早发生时间-->最终得到工程完成最早时间（终点事件的触发时间）-->逆推每个事件的最晚触发时间-->通过每个事件的最晚触发时间能逆推每个活动的最晚开始时间-->比较每个活动的最早开始时间（由相关量性质可知，计算过事件的最早发生时间，活动的最早发生时间也就确定了）和最晚开始时间，没有时间余量的活动为关键活动-->解决为缩短工期能够加快那些活动的问题**只有加快关键活动才能加快进程，但是值得注意的是，我们只能在现实中尽快督促完成，若是理想化直接提前很长时间完成关键活动，实际上AOE网就会改变，关键路径也就不一定是原样了其次，可能有多条关键路径，只提⾼⼀条关键路径上的关键活动速度并不能缩短整个⼯程的⼯期，只有加快那些包括在所有关键路径上的关键活动（所有关键路径都有出现的活动）才能达到缩短⼯期的⽬的。例：第一步：事件a最早发生时间：0 同时得到：活动(a,b)最早发生时间=活动(a,c)最早发生时间=事件a最早发生时间=0事件b最早发生时间：4 同时得到：活动(b,d)最早发生时间=事件b最早发生时间=4事件c最早发生时间：3 同时得到：活动(c,d)最早发生时间=事件c最早发生时间=3事件d最早发生时间：8第二步(没有体现出一个事件引起多个活动的情况的最晚时间，但是我们要知道肯定是取最晚时间中最早的那个)：事件d最晚发生时间：8事件b最晚发生时间：6事件c最晚发生时间：3第三步：活动(b,d)最晚发生时间：6活动(c,d)最晚发生时间:3活动(a,b)最晚发生时间:2活动(a,c)最晚发生时间:0第四步：活动(a,c)最晚发生时间-活动(a,c)最早发生时间=0-0=0活动(a,b)最晚发生时间-活动(a,b)最早发生时间=2-0=2活动(c,d)最晚发生时间-活动(c,d)最早发生时间=3-3=0活动(b,d)最晚发生时间-活动(b,d)最早发生时间=6-4=2所以，关键路径为a-&gt;c-&gt;d,关键活动为(a,c)、(c,d)注意：1、关键路径可能有多条2、并不是改变任何一个关键活动的时间都可以改变总时间补充6.1图的相关基本概念无向图圆括号（x,y）表示无向边有向图尖括号&lt;x,y&gt;表示有向边权度、出度、入度无向图：度数=边数×2有向图：①度数=边数×2=出度+入度②出度=入度=边数边和弧：无向图中边就叫边，有向图中边叫做弧，还有弧头和弧尾之分，带箭头一端为弧头。路径和回路：从一个顶点到另一顶点途径的所有顶点组成的序列（包含这两个顶点），称为一条路径。如果路径中第一个顶点和最后一个顶点相同，则此路径称为”回路”（或”环”）。简单路径（回路）：顶点不重复的路径（回路）==常见考点：n个顶点的图，若 |E|&gt;n-1，则一定有回路==完全图:无向图中任意两个点之间都有边，有向图中任意两个点有互相通往对方的弧具有 n 个顶点的完全图，图中边的数量为 n(n-1)/2；即而对于具有 n 个顶点的有向完全图，图中弧的数量为 n(n-1)。即稀疏图和稠密图：边数e&lt;nlogn为稀疏图反之为稠密图简单图：无重复的边或顶点到自身的边连通图：无向图中，如果任意两个顶点之间都能够连通连通分量：若无向图不是连通图，但图中存储某个极大子图符合连通图的性质，则称该子图为连通分量。极大：子图必须连通，且包含尽可能多的顶点和边强连通图：有向图中，任意两个顶点之间能够连通强连通分量：若有向图不是连通图，但图中存储某个极大子图符合强连通图的性质，则称该子图为强连通分量。极大：子图必须连通，且包含尽可能多的顶点和边网：图上的边或弧带有权则称为网。生成树:连通图中连通且n个顶点n-1条边称为生成树。有向图中一顶点入度为0其余顶点入度为1的叫有向树。生成森林:在非连通图中，连通分量的生成树构成了非连通图的生成森林。一个有向图由若干棵有向树构成生成森林。子图和生成子图的区别生成子图和原图的点集是一样的。而子图的点集可以是原图的点集子集6.1.1关于连通图和强连通图第一行如何理解？第二行如何理解 ？排除一个点，其他的点两两组合都直接连通（即n-1个点组成完全图，x(x-1)/2，当然此时x是n-1）。如何理解？就是n个顶点连成一个环。6.2图的存储结构6.2.1邻接矩阵存储（1）图象理解注：有时候也把子集到自己设为0即主对角线为0。0或∞都代表无弧（2）语言构造根据图象理解，我们可以在类中动态定义一个一维数组存储节点，一个二维数组存储邻接矩阵n个点的图信息的空间复杂度：O(n^2^)O(n)的点信息O(n^2^)的边信息O(n)+O(n^2^)=O(n^2^)适合用于存储稠密图无向图的邻接矩阵是对称矩阵，可以压缩存储（只存储上三角区/下三角区）（3）题目求度如何求无向图中某个节点的度？该行或列中有几个非0元素就是几度。如何求有向图中某个节点的出度、入度、度？出度：该行中有几个非0元素就是几出度。入度：该列中有几个非0元素就是几入度。度=出度+入度邻接矩阵法的性质邻接矩阵法求顶点的度/出度/入度的时间复杂度为 O(|V|)6.2.2邻接表存储（1）图象理解若为有权图，则需要在结点中添加代表权值的变量根据图象理解，我们先定义两个结构体节点，一个为邻接表的结点，一个为邻接表中存储其联通关系的链表结点。（2）题目无向图：边结点的数量是2|E|，整体空间复杂度为O(|V| + 2|E|)*每条边对应两份冗余信息，删除顶点、删除边等操作时间复杂度高有向图：边结点的数量是|E|，整体空间复杂度为O(|V| + |E|)结点相邻的边存储顺序可任意。所以存储方式不唯一思考：如何求顶点的度、入度、出度？无向图：遍历边链表，找到与该点相邻的所有的边有向图出度：遍历该节点的边链表入度：把所有节点的边链表都遍历一遍度=出度+入度6.2.3十字链表存储有向图如何理解？顶点节点：分为弧头和弧尾。弧头：指向该点的弧弧尾：该点指出的弧边节点：弧头和弧尾编号、相同弧头和弧尾的链指向。沿着相同弧头的链(橙色)：得到入度沿着相同弧尾的链(绿色)：得到出度空间复杂度：O(|V|+|E|)==如何找到指定顶点的所有出边？——顺着绿色线路找====如何找到指定顶点的所有入边？——顺着橙色线路找==注意：十字链表只用于存储有向图6.2.4邻接多重表存储无向图理解：一个边节点可以看做两个点节点。颜色相同的看做一类。例如A指出去之后，按照橙色的继续往下找即可找出所有A相连的边。B指出去之后，按照绿色的继续往下找即可找出所有与B相连的边。删除一个边AB：只需要把指针顺着往下指就可以了。删除一个点：例如E，删除该点和连接的边即可。？对于指向该链中的节点的节点需要修改也不方便啊？？应该例如删除结点E，需要删除后面两个边节点，而指向这两个边节点的节点，我需要从节点编号为1、2、4的都查一遍。？空间复杂度：O(|V|+|E|)删除边、删除节点等操作很方便注意：邻接多重表只适用于存储无向图总结6.3图的基本操作Adjacent(G,x,y)：判断图G是否存在边&lt;x, y&gt;或(x, y)。无向图=有向图邻接矩阵:O(1)邻接表：O(1)~O(|V|)Neighbors(G,x)：列出图G中与结点x邻接的边。无向图邻接矩阵：O(|V|)邻接表：O(1)~O(|V|)有向图邻接矩阵：O(|V|)邻接表：出边：O(1)~O(|V|)入边：O(|E|)InsertVertex(G,x)：在图G中插入顶点x。无向图邻接矩阵O(1) （节点数组和边二维数组并无溢出的情况）邻接表O(1)有向图也类似DeleteVertex(G,x)：从图G中删除顶点x。无向图邻接矩阵：O(|V|)在顶点节点增加bool判断结点是否有效。删除直接置位false，然后修改该行和列的数据为0.这样避免了大量的数据挪移。邻接表：O(1)~O(|E|)最好：没有连接任何边O(1)最坏：该节点和其他所有点都有边，需要遍历所有边结点O(E)有向图邻接矩阵 :O(|V|) 和无向图一样邻接表删出边：O(1)~O(|V|)删入边：O(|E|)AddEdge(G,x,y)：若无向边(x, y)或有向边&lt;x, y&gt;不存在，则向图G中添加该边。无向图邻接矩阵：O(1) ，改两个邻接表：O(1) ，添两个有向图邻接矩阵：O(1) ，改一个邻接表：O(1) ，添一个FirstNeighbor(G,x)：求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1。无向图邻接矩阵：O(1)~O(|V|)，需要找到第一个非0元素邻接表：O(1)，第一个若有就是有向图邻接矩阵：O(1)~O(|V|)，出边扫行，入边扫列，和上面一样。邻接表找出边邻接点：O(1)找入边邻接点：O(1) ~O(|E|)NextNeighbor(G,x,y)：假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。无向图邻接矩阵：O(1)~O(|V|)，往后面扫描，需要找到第一个非0元素邻接表：O(1)，往后面扫描，第一个若有就是有向图邻接矩阵：O(1)~O(|V|)，出边扫行，入边扫列，和上面一样。邻接表找出边邻接点：O(1)找入边邻接点：O(1) ~O(|E|)Get_edge_value(G,x,y)：获取图G中边(x, y)或&lt;x, y&gt;对应的权值。Set_edge_value(G,x,y,v)：设置图G中边(x, y)或&lt;x, y&gt;对应的权值为v等同于找边。Adjacent(G,x,y)：判断图G是否存在边&lt;x, y&gt;或(x, y)。无向图=有向图邻接矩阵:O(1)邻接表：O(1)~O(|V|)6.4图的⼴度优先遍历BFS(Breadth First Search)6.4.1算法解释⼴度优先遍历（Breadth-First-Search, BFS）要点：找到与⼀个顶点相邻的所有顶点标记哪些顶点被访问过需要⼀个辅助队列==队列循环用来处理队列中的每一个结点。====for循环用来处理每一个结点的相邻结点，判断是否访问过，没访问过则访问然后入队。==增加一个函数，主要是为了解决非连通图的问题（多个连通分量，对每一个连通分量调用BFS函数）是通过辅助数组，查看BFS后是否有没访问过的节点,若有则再BFS==对于⽆向图，调⽤BFS函数的次数=连通分量数==6.4.2遍历序列的可变性同⼀个图的邻接矩阵表示⽅式唯⼀，因此⼴度优先遍历序列唯⼀同⼀个图邻接表表示⽅式不唯⼀，因此⼴度优先遍历序列不唯⼀就是同一层，谁先入队的问题。6.4.3复杂度分析空间复杂度：最坏情况，辅助队列⼤⼩为 O(|V|)邻接矩阵存储的图：访问 |V| 个顶点需要O(|V|)的时间查找每个顶点的邻接点都需要O(|V|)的时间，⽽总共有|V|个顶点O(|V|^2^)+O |V| = O(|V|^2^)==时间复杂度= O(|V|^2^)==邻接表存储的图：访问 |V| 个顶点需要O(|V|)的时间查找各个顶点的邻接点共需要O(2|E|)=O(|E|)的时间，⽆向图O(2|E|)，约去系数成O(|E|)有向图直接就是O(|E|)O(|V|)+O(|E|)=O(|V|+|E|)==时间复杂度= O(|V|+|E|)==6.4.4⼴度优先⽣成树和⼴度优先⽣成森林⼴度优先生成树是以第一次访问该节点的顺序构成的树⼴度优先生成树由⼴度优先遍历过程确定。由于邻接表的表示⽅式不唯⼀，因此基于邻接表的⼴度优先⽣成树也不唯⼀。例如以2为初始节点的广度优先生产树对⾮连通图的⼴度优先遍历，可得到⼴度优先⽣成森林6.4.5练习：有向图的BFS过程5次和1次6.5图的深度优先遍历6.5.1算法解释6.5.2复杂度分析空间复杂度：来⾃函数调⽤栈，最坏情况，递归深度为O(|V|)空间复杂度：最好情况，O(1) 可以看出DFS和BFS的复杂度一样6.5.3遍历序列的可变性同⼀个图的邻接矩阵表示⽅式唯⼀，因此深度优先遍历序列唯⼀同⼀个图邻接表表示⽅式不唯⼀，因此深度优先遍历序列不唯⼀6.5.4深度优先⽣成树和深度优先⽣成森林 6.5.5图的遍历与图的连通性对⽆向图进⾏BFS/DFS遍历==调⽤BFS/DFS函数的次数=连通分量数==对于连通图，只需调⽤1次 BFS/DFS对有向图进⾏BFS/DFS遍历调⽤BFS/DFS函数的次数要具体问题具体分析若起始顶点到其他各顶点都有路径，则只需调⽤1次BFS/DFS 函数对于强连通图，从任⼀结点出发都只需调⽤1次 BFS/DFS6.6最⼩⽣成树6.6.1生成树的概念连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为n，则它的生成树含有 n-1 条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。之前我们学习过：⼴度优先⽣成树、深度优先⽣成树现在我们学习最⼩⽣成树（最⼩代价树）对于⼀个带权连通⽆向图G = (V, E)，⽣成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设R为G的所有⽣成树的集合，若T为R中边的权值之和最⼩的⽣成树，则T称为G的最⼩⽣成树（Minimum-Spanning-Tree, MST）。最⼩⽣成树可能有多个，但边的权值之和总是唯⼀且最⼩的最⼩⽣成树的边数 = 顶点数 - 1。砍掉⼀条则不连通，增加⼀条边则会出现回路如果⼀个连通图本身就是⼀棵树，则其最⼩⽣成树就是它本身只有连通图才有⽣成树，⾮连通图只有⽣成森林6.6.2Prim 算法（普⾥姆）选点Prim 算法（普⾥姆）：从某⼀个顶点开始构建⽣成树；每次将代价最⼩的新顶点纳⼊⽣成树，直到所有顶点都纳⼊为⽌。推荐阅读最小生成树-Prim算法和Kruskal算法6.6.3Kruskal 算法（克鲁斯卡尔）选边Kruskal 算法（克鲁斯卡尔）：每次选择⼀条权值最⼩的边，使这条边的两头连通（原本已经连通的就不选）直到所有结点都连通6.6.4对比时间复杂度是如何得到的？介绍算法的实现思想，并加以分析。(1)Prim 算法的实现思想 再次循环遍历，更新还没加⼊的各个顶点的lowCost值其实就是看看对于新加入的结点，谁和它相连并且还没有加入生成树，并且若代价低则更新。可见，加入V3后，有V1、V2、V4、V5与其相连，并且更新连接代价更小的。由6、5、∞、∞变成5、4、6、4一直执行到结束。不再赘述详见课件或视频。分析：其实就是：需要n-1轮处理，每一轮处理需要遍历两次，O(n-1)×O(2n)=O(n^2^)(2)Kruskal 算法的实现思想初始：将各条边按权值排序第1轮：检查第1条边的两个顶点是否连通（是否属于同⼀个集合）………….第6轮：检查第6条边的两个顶点是否连通（是否属于同⼀个集合）共执⾏ e 轮，每轮判断两个顶点是否属于同⼀集合，需要 O(log 2 e)总时间复杂度 O(elog 2 e)6.7最短路径6.7.1单源最短路径(1)BFS算法（无权图）初始化：本节点的d[]为0，其他为∞，path[]为-1以2为根节点，遍历到1和6，修改相应d[w]=d[u]+1，path[w]=u.则1和6的d[]变为1，path变为2，代表原点到本节点的长度为1，和上一个路径来源为2。BFS继续运作，以此类推得到： ==局限性：BFS算法求单源最短路径只适⽤于⽆权图，或所有边的权值都相同的图==(2)Dijkstra算法（带权图、无权图）此时，只有V0到V1和V4的路径，我们取最短，V4。置final为true然后看和V4相连并且其 final 值为false的点，看看从V4到它们的路径是不是比原来小，是就更新dist[]和path[]的值。可见第一轮更新了V2和V3的信息。下面进行第二轮。可见更新了V2的信息。以此类推直到结束分析其实就是：需要n-1轮处理，每一轮处理需要遍历两次，一次求最小结点一次遍历相邻结点，O(n-1)×O(2n)=O(n^2^)可以看出，和之前我们学的普里姆算法非常相似！两者的区别在于，每次更新路径的不一样prim更新的是未标记集合到已标记集合之间的距离比较的是当前结点到新节点的权和之前相应的dist大小，更新的就是边的权Dijkstra更新的是源点到未标记集合之间的距离比较的是(当前结点的dist+到新节点的权)和之前相应的dist大小，更新的是结点的dist+到新节点的权，注意：Dijkstra算法不能允许权值为负6.7.2各顶点间的最短路径(1)Floyd算法（带权图、无权图）使⽤动态规划思想，将问题的求解分为多个阶段对于n个顶点的图G，求任意⼀对顶点 Vi —&gt; Vj 之间的最短路径可分为如下⼏个阶段：#初始：不允许在其他顶点中转，最短路径是？#0：若允许在 V 0 中转，最短路径是？#1：若允许在 V 0 、V 1 中转，最短路径是？#2：若允许在 V 0 、V 1 、V 2 中转，最短路径是？…#n-1：若允许在 V 0 、V 1 、V 2 …… V n-1 中转，最短路径是？对于路径矩阵A某个元素，此时是假设允许在某个节点中转。则比较某两点之间的路径值，和以某个节点中转得到的路径值。若中转的值小，则更新这个路径值。并且在path矩阵中标记中转点，表示两点之间需要中转。例如上面的V2到V1若以V0为中转点：∞&gt;5+6=11所以更新A[V2] [V1]为11.并且在path[V2] [V1]中更新中转点0。以此类推以V0为中转点的时候，按此算法扫描整个数组再以V1为中转点，按此算法扫描整个数组可知：13&gt;6+4=10所以更新A[V0] [V2]为11.并且在path[V0] [V2]中更新中转点1。再以V2位中转点…..最终：如何找具体路径？利用上述算法结果如上：我们找V0到V4 最短路径⻓度首先：V0 V4因为path[0] [4]=3，所以为 V0 V3 V4path[3] [4]=-1，所以V3 V4之间无中转。path[0] [3]=2，所以V0 V3之间有中转V2。即V0 V2 V3 V4再看V0和V2之间、V2和V3之间，得到：V0 V2 V1 V3 V4再看V2和V1之间、V1和V3之间，得到：V0 V2 V1 V3 V4分析核心代码：注意： 通常可以在任何图中使用，包括有向图、带负权边的图。但是不能有带负权的边组成的回路因为每跑一圈，路径就-2。(2)n次Dijkstra 算法也可⽤ Dijkstra 算法求所有顶点间的最短路径，重复 |V| 次即可==，总的时间复杂度也是O(|V| 3 )==总结6.8有向⽆环图（DAG）有向⽆环图：若⼀个有向图中不存在环，则称为有向⽆环图，简称DAG图（Directed Acyclic Graph）6.8.1有向⽆环图（DAG）描述表达式对于一个计算表达式用树的形式：我们发现有重复的子树，其实可以合并。可看出a+d依旧可以合并。b和b也可以合并，最终：解题⽅法 再给一个例子：合并后：6.8.2AOV（Activity On Vertices）网络和拓扑排序(1)AOV（Activity On Vertices）网络活动网络可以用来描述生产计划、施工过程、生产流程、程序流程等工程中各子工程的安排问题。 一般一个工程可以分成若干个子工程，这些子工程称为活动（Activity）。完成了这些活动，整个工程就完成了。我们可以用上图的有向图来表示课程之间的先修关系。在这种有向图中，顶点表示课程学习活动，有向边表示课程之间的先修关系。例如顶点C1到C8有一条有向边，表示课程C1必须在课程C8之前先学习完。实际上，在这种有向图中，用顶点表示活动，用有向边表示活动u必须先于活动v进行。这种有向图叫做活动网络（Activity on Vertices），记做AOV网络。前驱与后继：在AOV网络中，如果存在有向边，则称活动u必须在活动v之前进行，并称u是v的直接前驱，v是u的直接后继。如果存在有向路径，则称u是v的前驱，v是u的后继。AOV网络中不能出现有向回路（或称为有向环）。 在AOV网络中如果出现了有向回路，则意味着某项活动以自己作为先决条件，这是不对的。AOV网络是有向无环图。(2)拓扑排序1、判断有向无环图的方法是对AOV网络构造它的拓扑有序序列（Topological Order Sequence）；2、构造这种AOV网络全部顶点的拓扑有序序列的运算称为拓扑排序，即将各个顶点排列成一个线性有序的序列，使得AOV网络中所有存在的前驱和后继关系都能得到满足。3、一个AOV网络的拓扑有序序列可能不是唯一的；4、拓扑排序实现方法：（1）从AOV网络中选择一个入度为0（即没有直接前驱）的顶点并输出；（2）从AOV网络中删除该顶点及该顶点发出的所有边；（3）重复步骤（1）和（2），直至找不到入度为0的顶点。经过上述步骤后，有两种结果：（1）所有的顶点都被输出，也就是整个拓扑排序完成了；（2）仍有顶点没有被输出，只剩下入度不为0的顶点，即存在有环图。代码实现代码解释：初始化indegree数组省略了。它包含各个顶点的度的信息。扫描indegree数组把度为0的顶点需要压栈。当栈不为空{出栈一个顶点，并把序号输入到打印数组中。对该顶点的邻接表扫描 {把指向的节点的度数-1，在indegree数组中执行。若减1后该点度数为0则入栈。​ }}最后，数组的元素数量count等于结点数，则代表无剩余结点，拓扑排序成功。否则失败。==时间复杂度：O(|V|+|E|)====若采⽤邻接矩阵，则需O(|V| 2 )==例：初始化扫描indegree数组，把度为0的压栈。出栈2，写入print数组，扫描结点2的邻接表，对相应结点在indegree数组中的度数减1.发现并没有减1后为0的节点不需要压栈。之后的执行都和这差不多，除了减1为0就压栈有区别。详见课件或者视频。(3)逆拓扑排序其实就是和拓扑排序反过来，先找出度为0的顶点输出，删除该顶点和相关边。不断进行下去。最后没有顶点了就逆拓扑排序完成。若仍旧有顶点没有被输出，只剩下出度不为0的顶点，即存在有环图。实现实现和拓扑排序差不多，只不过我们需要的是outdegree数组。并且扫描入度边需要扫描整个边节点。邻接矩阵就方便很多，扫描列即可。但是，也可以用逆邻接表，这样就和拓扑排序几乎一致了，只需要初始化和使用outdegree数组，扫描逆邻接表。使用DFS算法实现逆拓扑排序。深度优先的最后一个结点肯定是没有再指向其他结点的节点，即出度为0的节点。再结合程序使用递归调用栈的特点。输出肯定是逆序的。就是逆拓扑排序。6.9AOE（Activity On Edge）网络与关键路径6.9.1AOE网络(1)概念定义:如果在无环的带权有向图中用有向边表示一个工程中的活动用边上的权值表示活动的持续时间用顶点表示事件则这样的有向图叫做用边表示活动的网络，简称AOE网络一定要注意：AOV网中，点代表活动，AOE网中边代表活动两者是不同的。事件和活动的理解，AOE网中边为活动，点为事件，可理解事件是一个“检查点”，它是一种“状态”，只有“检查”到通向该事件的活动全部完成的状态，才能进入下面的活动AOE网中没有入边的顶点称为始点（源点）AOE网中没有出边的顶点称为终点（汇点）(2)AOE网的性质1、只有进入某顶点的各活动都结束，该顶点所代表的事件才能发生,另外，有些活动是可以并⾏进⾏的2、只有某顶点所代表的事件发生后，从该顶点出发的各活动才能开始(3)AOE网的应用AOE在工程方面非常有用：例如：（1）完成整个工程至少需要多少时间（假设没有环）；（2）为缩短完成工程所需时间，应当加快那些活动？因为在工程当中，很多活动是并行的，所以有些活动是导致工期长短的关键活动，不能拖延，而有些活动是可以在一定范围内延迟的，这是计算关键路径的原因！6.9.2关键路径(1)关键路径的相关概念从源点到各个顶点，以至从源点到汇点的有向路径可能不止一条。这些路径的长度也可能不同，完成不同路径的活动所需时间不同，但只有各条路径上所有活动都完成了，整个工程才完成。完成整个工程所需时间取决于从源点到汇点的最长路径长度，即在该路径上所有活动的持续时间之和，给路径称为关键路径。为了找出关键路径，必须找出关键活动，即不按期完成就会影响整个工程完成的活动。关键路径上的所有活动都是关键活动。(2)四个和计算关键路径相关的量事件最早可能开始时间Ve[k]：求法为源点到该顶点的最大长度，需要正向计算取大得出事件最迟允许开始时间Vl[k]：需要逆向计算取小得到活动最早开始时间e[i]：活动代表的是边，它的最早开始时间和它作为某个点出度的事件的最早开始时间相同活动的最晚开始时间l[i]：通过该边作为入度指向的事件的最晚触发事件逆向计算得到(3)计算关键路径计算各个活动的时间余量l[k]-e[k]，时间余量为0即（l[k]=e[k]）者为关键活动多个或一个活动的完成才能决定一个事件的触发，它取决于触发事件的活动中最长的一个，我们从始点开始计算每个事件的最早开始时间，也就是计算每个点相对始点的最大路径，一直计算到终点，就计算出了完成工程的最早时间，通过工程完成的最早时间我们能逆推每个事件完成的最晚时间，然后通过每个事件得出每个工程的最晚开始时间通过最大路径计算得到每个事件的最早发生时间–&gt;最终得到工程完成最早时间（终点事件的触发时间）–&gt;逆推每个事件的最晚触发时间–&gt;通过每个事件的最晚触发时间能逆推每个活动的最晚开始时间–&gt;比较每个活动的最早开始时间（由相关量性质可知，计算过事件的最早发生时间，活动的最早发生时间也就确定了）和最晚开始时间，没有时间余量的活动为关键活动–&gt;解决为缩短工期能够加快那些活动的问题（只有加快关键活动才能加快进程，但是值得注意的是，我们只能在现实中尽快督促完成，若是理想化直接提前很长时间完成关键活动，实际上AOE网就会改变，关键路径也就不一定是原样了）==我们按照按拓扑排序序列进行上述操作。==]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构【五】树]]></title>
    <url>%2Fposts%2F54ce560e%2F</url>
    <content type="text"><![CDATA[五、树5.1基本概念1、 结点拥有的子树数称为结点的度（Degree）。树的度是树内各结点度的最大值。也是该节点有几个子节点2、树的深度（Depth）或高度是树中结点的最大层次数值。3、祖先结点：从根结点到该结点所经分支上的所有结点。4、子孙节点：某一结点的子女以及这些子女的子女。5、树中描述路径只能从上往下深度：上往下数高度：：下往上数关于层，有些书或者题目会说从0层开始。即根节点算0层。但是若不强调我们默认是从1开始。有序树和无序树有序树——逻辑上看，树中结点的各子树从左至右是有次序的，不能互换无序树——逻辑上看，树中结点的各子树从左至右是无次序的，可以互换具体看你用树存什么，是否需要用结点的左右位置反映某些逻辑关系森林森林。森林是m（m≥0）棵互不相交的树的集合5.2树的常考性质结点数=总度数+1（那个1就是根节点）度为m的树、m叉树 的区别度为m的树第 i 层至多有 m^i-1^个结点（i≥1）.(等比数列求和)常见考点5：高度为h的m叉树至少有 h 个结点。高度为h、度为m的树至少有 h+m-1 个结点。.5.3二叉树(1)二叉树的特点每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。左子树和右子树是有顺序的，次序不能任意颠倒。即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。注意结合上面的度为m的树、m叉树 的区别区分度为2的数和2叉树(2)二叉树五种基本形态空二叉树只有一个根结点根结点只有左子树根结点只有右子树根结点既有左子树又有右子树(3)几种特殊的二叉树斜树​ 又分为左斜树、右斜树。结点个数与二叉树深度相同​ 满二叉树除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。完全二叉树若设二叉树的深度为h，只看前1~（n-1)层则是满二叉树，第h层所有的结点都连续集中在最左边，这就是完全二叉树。注意完全二叉树的④一个具有n个节点的完全二叉树，其叶子节点的个数为?n1=0，n为奇数时：n0 = (n+1) / 2n1=1，n为偶数时：n0 = n / 2或者这么想：分支节点m=n / 2（忽略余数），叶子节点=n-m例如上式m=15/2=7，n-m=15-7=8为什么说n1=0，n为奇数，n1=1，n为偶数？首先，因为是完全二叉树，所以只有最后一个节点的父节点有可能产生度为1的节点,n1要么1要么0因为① n = n 0 + n 1 + n 2② n = n 1 + 2n 2 +1得：n 0 = n 2 + 1所以n0+n2=2n 2 + 1一定是奇数，n = n 0 + n 1 + n 2=2n 2 + 1+ n 1所以说n1=0，n为奇数，n1=1，n为偶数(4)二叉树的性质性质1：在二叉树的第i层上至多有2i-1个结点（i&gt;=1）性质2：深度为k的二叉树至多有2k-1个结点（k&gt;=1）—–a1=1 公比为2的等比数列求和性质3：对任何一棵二叉树T，如果其叶子数为n0,度为2的结点数为n2，则n0 = n2+1。① n = n 0 + n 1 + n 2② n = n 1 + 2n 2 +1得：n 0 = n 2 + 1另一种证明:一棵二叉树，除了终端结点（叶子结点），就是度为1或2的结点。假设n1度为1的结点数，则数T 的结点总数n=n0+n1+n2。我们再换个角度，看一下树T的连接线数，由于根结点只有分支出去，没有分支进入，所以连接线数为结点总数减去1。也就是n-1=n1+2n2，可推导出n0+n1+n2-1 = n1+2n2，继续推导可得n0 = n2+1。性质4：具有n个结点的完全二叉树的深度为[log2（n+ 1） ] (向上取整)或者[log2n ]+1（向下取整） 。性质5：如果对一颗有n个结点的完全二叉树（其深度为[log2n ] + 1）的结点按层序编号（从第1层到第[log2n ] + 1层，每层从左到右），对任一结点i(1&lt;=i&lt;=n)有：如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点[i/2]。如果2i&gt;n,则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点i。如果2i+1&gt;n,则结点i无右孩子；否则其右孩子是结点2i+1。结点i所在层次为[log2i ]+1（向下取整）性质5其实就是顺序储存下父子结点编号关系对于完全二叉树，可以由的结点数 n 推出度为0、1和2的结点个数为n 0 、n 1 和n 2(5)顺序结构实现二叉树利用性质5可以对数组下标操作完成二叉树储存二叉树的顺序存储结构缺点很明显：不能反应逻辑关系；对于特殊的二叉树（左斜树、右斜树），浪费存储空间。所以二叉树顺序存储结构一般只用于完全二叉树。对于右斜树，顺序存储结构浪费存储空间：^表示其中数据为空(6)链式结构实现二叉树​ 二叉链表:三叉链表：三叉链表在二叉链表的基础上添加一个返回指针指向父亲结点含n个结点的二叉链表有n+1个空链指针域n个结点：2n个域，只有n-1个头上有指向。2n-n+1=n+1含n个结点的三叉链表有n+2个空链指针域同理，3n-2（n-1）=n+25.4二叉树的遍历(1)遍历顺序前序遍历顺序：规则是先是根结点，再前序遍历左子树，再前序遍历右子树中序遍历顺序：规则是先中序遍历左子树，再是根结点，再是中序遍历右子树后序遍历顺序：规则是先后序遍历左子树，再是后序遍历右子树，再是根结点详细解释:1、对于每个节点，访问顺序为遍历顺序2、！对于每个节点，左子树的节点全部访问完，再能再根据遍历顺序访问右子树的节点。！！！！！！根据这两条规则我们就能够确定其中任意一种遍历的顺序了。前中后说的是根的位置！先左后右是不变的，就看根放在左右的哪儿了。根左右左根右左右根层次遍历：用队列(2)由遍历序列构造二叉树若只给出一棵二叉树的 前/中/后/层 序遍历序列中的一种，不能唯一确定一棵二叉树PS：缺少中序不能得到准确的二叉树！==Key：找到树的根节点，并根据中序序列划分左右子树，再找到左右子树根节点==其他序找根，确定根转到中序分左右子树集合递归进行==本质上是不断确定根的位置====其他序在集合中找根确定一个节点、通过中序划分左右子树集合==前序+中序 后序+中序 层序+中序 5.4线索二叉树(1)定义1、二叉树中没有利用的指针n个节点二叉树有n+1个没有利用的指针在N个节点的二叉树中，每个节点有2个指针，所以一共有2N个指针，除了根节点以外，每一个节点都有一个指针从它的父节点指向它，所以一共使用了N-1个指针，所以剩下2N-(N-1)也就是N+1个空指针；2、利用空指针指向前驱后驱原因:如果利用空指针直接记录前驱后驱结点，在遍历的时候会比递归速度要快还能减少建立递归程序的存储空间。若结点的左子树为空，则该结点的左孩子指针指向其前驱结点。若结点的右子树为空，则该结点的右孩子指针指向其后继结点。3、解决判断左右指针是为指向前后驱还是左右孩子添加标志位ltag，rtag，并定义规则如下：ltag为0时，指向左孩子，为1时指向前驱rtag为0时，指向右孩子，为1时指向后继==注意：前驱后继指的是，按照某种顺序进行遍历后得到的序列中，某个节点的前驱后继==(2)二叉树的线索化(以中序为例)把二叉树看成中序遍历序列，序列的第一个结点（最左下结点）的前驱为NULL，最后一个结点（最右下结点）的后继为NULL。通过设置pre的初始化为NULL和最后对pre（指向最后一个结点）的后继（右子树）设置为NULL来实现。pre：前驱指针。可以选择使用全局变量，或者引用参数传入都行想象一个指针，总是指向当前遍历指针的前驱结点。一直到遍历指针指到最后一个结点，pre先指向倒数第二个节点，最后也指到最后一个节点。流程：首先pre的初始化为NULL，进入中序遍历函数按照中序遍历的顺序，对节点进行顺序处理。判断该节点左孩子指针是否为空，若是，则左指针指向前驱结点pre，置ltag=1判断pre是否为空，判断pre的右孩子指针是否为空，若是，则pre的右指针指向当前结点q，置rtag=1.最后pre指向当前结点。作为下一次处理的前驱。最后处理最后一个节点的后继指针，置rtag=1因为我们是对当前左孩子和上一个的右孩子进行的操作。最后的话pre先指向倒数第二个节点，p指向倒数第一个结点，处理了最后一个的前驱和倒数第二个的后继，而倒数第二个的前驱前一步被处理了。最后，pre指向最后一个节点，但此时遍历也结束退出了。我们最后一个节点的后继没有处理。所以需要在creat函数调用线索化函数后再加一步，置rtag=1（中序遍历退出一定是因为右指针已经是NULL了不必修改，或者说你直接添加一步使得右指针=NULL也无所谓）注意，我们在一次处理中是处理当前左结点、前驱(上一个)的右节点，按照这样的顺序递归执行下去的，而不是对当前的左右结点处理注意，线索化之后，除了第一个结点的前驱和最后一个节点的后继为NULL其他均有所指向，而且就算是这两个NULL，其tag也被置为1，所以说，只要tag=0，就表明必定会有相应的指向孩子节点先序、后序同理，只不过是遍历顺序不一样。注意先序线索化中，会出现兜圈问题。例如图中，我们处理了结点3，使得其左孩子指向B，返回递归遍历后，我们会执行PreThread(T-&gt;lchild)；这就出问题了，我们刚刚把D-&gt;lchild作为前驱指针，指向了B，这下我们直接进入到B了，然后按照递归函数，B处理完后（而且这个处理本身也会出错，把D当初B的前驱了），又到了D这样无限循环下去。所以我们需要在先序递归遍历中加一个判断中序和后序不会出现兜圈问题，因为中序和后序遍历，当我们处理完该节点后一定是处理完左子树的，不会再用T-&gt;lchild了因为我们处理该节点只能处理该节点的前驱(和上一节点的后继)，所以不必担心T-&gt;rchild会有问题。(3)在线索二叉树中找前驱后继中序线索二叉树后继如果该节点已经被线索化,即 p-&gt;rtag==1，则 next = p-&gt;rchild否则 p-&gt;rtag==0,即有右孩子，则根据遍历的特点，下一个节点必定是右子树中最左下结点。进行循环查找。这样，我们的中序遍历可以不使用递归，而是循环了先找到中序遍历第一个节点（左子树的最左下节点）再根据该节点不断找后继节点前驱如果该节点已经被线索化,即 p-&gt;ltag==1，则 pre= p-&gt;lchild否则 p-&gt;ltag==0,即有左孩子，则根据遍历的特点，上一个节点必定是左子树中最右下结点。进行循环查找。应用：逆向中序遍历。先找的最后一个节点（右子树最右下节点）在通过该节点不断找到前驱结点先序线索二叉树后继若线索化了即p-&gt;rtag==1，则后继就是next = p-&gt;rchild否则若 p-&gt;rtag==0（则肯定有右孩子，因为是NULL的除了最后一个的后继和第一个的前驱都被化为线索了，但是就算是这两个标志位也置成1了！）有左孩子：后继就是左孩子（左子树中第一个被访问的节点）无左孩子：后继就是右孩子（右子树中第一个被访问的节点）前驱如果该节点已经被线索化,即 p-&gt;ltag==1，则 pre= p-&gt;lchild否则p-&gt;ltag==0,则找不到前驱，因为不论是左右子树都是后面的了，而之前的找不到(没有指向父节点的指针)。假设我们有指向父节点的指针。若本节点是父节点的左孩子：前驱就是父节点若本节点是父节点的右孩子，且父节点左孩子为空：前驱就是父节点若本节点是父节点的右孩子，且父节点左孩子不为空：前驱就是父节点左子树中最后一个被先序遍历的结点左子树中最后一个被先序遍历的结点：不断往右找，右边的路径没了开始往左找，左边的路径没了再往右找，直到左右都没路。若本节点是根节点，则无前驱。后序线索二叉树后继若线索化了即p-&gt;rtag==1，则后继就是next = p-&gt;rchild否则若 p-&gt;rtag==0（则肯定有右孩子）根据遍历特点，左子树右子树都是其前驱，找不到后继。办法：土办法，从头遍历但假设我们有指向父节点的指针。若本节点是父节点的右孩子：后继就是父节点若本节点是父节点的左孩子，且父节点右孩子为空：后继就是父节点若本节点是父节点的左孩子，且父节点右孩子不为空：前驱就是父节点右子树中第一个被后序遍历的结点右子树中第一个被后序遍历的结点：不断往左找，左边没路了往右找，右边没路的往左找，直到没路了。若本节点是根节点，则无后继。前驱如果该节点已经被线索化,即 p-&gt;ltag==1，则 pre= p-&gt;lchild否则p-&gt;ltag==0,则有左孩子。若有右孩子：就是右孩子没有右孩子：就是左孩子总结（不需要被，要会现推）5.5树的存储结构(1)双亲表示法（顺序存储）定义一个结构，其中包含data和parent用来表示当前结点数据和父亲结点位置然后用连续的结构体表示该树：优点： 可用parent直接找到双亲，并且很容易找到祖先。时间复杂度O（1）缺点：需要查找节点的孩子及其子孙时要遍历整个结构。时间复杂度O(n)如何增加？直接新增标记好父指针即可。如何删除？方案一：直接修改父指针为-1方案二（更好）：将最后一个节点移动到该节点（覆盖）删除的不是叶子节点怎么办？（删了一个子树）查询所有子孙节点。（把该节点入队列，把父指针为该节点的查询到，删除该节点，再查询依次以入队列的节点为父指针的结点，再依次删除）从这里也看出：我们若不用方案二删除，会不断遍历无效结点，浪费资源。(2)子女链表示法（顺序存储+链式存储）*把每个结点的 子女结点的位置以单链表的结构存储 ，则n个结点生成了n条单链表，再将 n 条单链表头指针以顺序线性表存储 *优点: 方便搜索孩子结点缺点: 查找父结点需要从头遍历整个顺序表(3)双亲子女表示法（顺序存储+链式存储）我们将父指针表示法和子女链表示法结合起来这样查找父亲和孩子结点都方便(4)子女兄弟链表示法（链式存储）以二叉链表作为树的存储结构，结点的两个链域分别指向该结点的第一个孩子和右边的第一个兄弟启示：一颗树可以转化为一个只有左子树的二叉树 5.6树和森林(1)树和森林的转换根据前面的子女兄弟链表示法我们可以进一步得出树、森林、二叉树的转换方法树、森林和二叉树的转换树、森林–》二叉树画线更方便二叉树—-》树、森林定义更方便==树到二叉树的转化：====森林到二叉树的转化：==森林中的各个树转为二叉树，在把根节点连接==二叉树到森林的转化：==(2)树的遍历1.树的先根遍历（深度优先遍历）若树不空，则先访问根结点，然后依次先序遍历各棵子树。子女兄弟链图中的树先根遍历为:R A D E B C F G H K树的先根遍历序列与该树对应的二叉树的先序遍历序列相同2.树的后根遍历（深度优先遍历）若树不空，则先依次后序遍历各棵子树，然后访问根结点。子女兄弟链图中的树后根遍历为:D E A B G H K F C R树的后根遍历序列与该树对应的二叉树的中序遍历序列相同3.树的层序遍历（广度优先遍历）若树不空，则自上而下自左至右访问树中每个结点。(3)森林的遍历1.森林的先根遍历（深度优先遍历）即依次对每一棵树进行先根遍历森林的先根遍历序列与其对应的二叉树的先序序列一致。2.森林的后根(中序)遍历（深度优先遍历）即依次对每一棵树进行后根遍历森林的后根遍历序列与其对应的二叉树的中序序列一致。先先、后中3.森林的广度优先遍历从第1层起，自顶向下，同一层自左向右，依次访问森林中各棵树的结点。5.7二叉排序树BST二叉搜索树或者是一棵空树；或者是具有下列性质的二叉树：(1) 左子树上所有结点的值均小于等于它的根结点的值；(2) 右子树上所有结点的值均大于它的根结点的值；(3) 根结点的左、右子树也分别为二叉排序树。按中序遍历该树所得到的中序序列是一个递增有序序列(1)二叉排序树的查找(2)二叉排序树的添加(3)二叉排序树的构造 (4)二叉排序树的删除① 叶结点：直接删除② 结点一棵左子树或右子树：让z的子树成为z父结点的子树，替代z的位置。③ 若结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。z的前驱 ：z的左子树中最右下结点（该节点一定没有右子树）z的后继：z的右子树中最左下结点（该节点一定没有左子树）例如：用60覆盖50，删除p指向的60。第三种转化为第二种。直接把右子树移上去就行。或者用30覆盖50，删除30，就是直接删除叶节点。(5)查找长度和效率分析在查找运算中，需要对比关键字的次数称为查找长度，反映了查找操作时间复杂度若树高h，找到最下层的一个结点需要对比 h 次对于有 n 个关键码的集合，其关键码有 n! 种不同排列，可构成不同二叉搜索树有（catalan函数）种所以对于一组数据，我们可以构成多个搜索二叉树，而且效率不定相同。查找成功的平均 查找长度 ASL （ Average Search Length ）对于树型结构的ASL计算我们根据树的特点和ASL定义，可以查找成功的平均查找长度ASL=对每个结点计算概率×层数再求和，而查询失败长度相当于查询到了叶子结点的下一个结点（NULL）我们对每个该结点计算概率×（层数-1）再求和就得到了查询失败长度，之所以是（层数减1，是因为实际上我们实际上是比较到叶子节点，只不过结果是比较失败而已，即在父节点比较失败后指向NULL就结束了该层没有比较）。概率相等时：成功概率=1/数据结点数失败概率=1/失败结点数（空指针域，也就是数据节点数+1）例如（默认概率相等）：对a：ASLsucc=1/3×3+1/3×2+1/3×1=6/3 ASLunsucc = 1/4×3×2+1/4×2+1/4×1 = 9/4对b：ASLsucc = 1/3×2×2+1/3×1 = 5/3 ASLunsucc = 1/4×2×4 = 8/4若不相等，则把给出的相应结点对于概率替换掉相等概率计算即可一般把平均搜索长度达到最小的扩充的二叉搜索树称作最优二叉搜索树。5.8二叉平衡树AVL(1)定义平衡二叉树首先是一棵二叉排序树平衡二叉树或者是一棵空树，或者是具有下列性质的二叉树:其左子树和右子树的高度之差的绝对值不超过 1 ；其左子树和右子树都是平衡二叉树 ；平衡因子 ( Balance Factor，BF)定义为该结点的左子树的深度减去右子树的深度，则平衡二叉树上所有结点的平衡因子只可能是-1、0和1。为了实现二叉排序树的平均查找长度和 log n 等数量级，需要对二叉排序树进行“平衡化”处理，即构造平衡二叉树。在二叉排序树中插入新结点后，如何保持平衡？从插入点往回找到第一个不平衡结点，调整以该结点为根的子树。在插入操作中，只要将最小不平衡子树调整平衡，则其他祖先结点都会恢复平衡。(2)构造 ==ll rr调整的是最小子树的孩子，====lr和rl调整的是孩子的孩子且调整的节点的方法和名称一致。==LL在A的左孩子的左子树中插入导致不平衡RR在A的右孩子的右子树中插入导致不平衡LR在A的左孩子的右子树中插入导致不平衡RL在A的右孩子的左子树中插入导致不平衡例题==核心就是找那个最小不平衡子树！！！再用四种类型的方法！====关于LR和RL型，手算可以不必算两次，我们知道那个节点一定会成为”根”，所以把它的左子树右子树都卸下来放到相应位置即可。==例如：(3)查找效率分析若树高为h，则最坏情况下，查找一个关键字最多需要对比 h 次，即查找操作的时间复杂度不可能超过 O(h)平衡二叉树——树上任一结点的左子树和右子树的高度之差不超过1。n0=0：空树n1=1：一个根节点n2=2：结点都在一侧公式：两个子树一个高度h-1且节点最少的子树，一个高度h-2且节点最少的子树，加上一个根节点根据公式：n3=4，n4=7，n5=12….所以假设一个AVL树，结点数为9，它的最大高度为4，因为n5=12代表高度为5的AVL数至少要12个结点。则该树查找一个关键字最多（最坏情况）需要对比 4次可以证明含有n个结点的平衡二叉树的最大深度为O(log 2 n) ，平衡二叉树的平均查找长度为O(log 2 n)5.9Huffman树及其应用参考文章:huffman树及其应用哈夫曼树(1)Huffman树概念路径：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径路径长度：路径中分支的数目称为路径长度。（经过的边数）根据路径长度定义和二叉树结构特点得到:n 个结点的二叉树的路径长度不小于下述数列前 n 项的和，即其最小路径长度=PL权值：在数学领域，权值指加权平均数中的每个数的频数，也称为权数或权重。树的路径长度：树根到每个结点的路径长度之和。树的路径长度可计算为对每一层:每层的节点数×（层数-1）的求和结点的带权路径长度：从根结点到该结点之间的路径长度与该结点的权的乘积。即路径长×该结点权树的带权路径长度（Weighted Path Length, WPL）:叶子结点的带权路径长度之和。主观上判断：权值最大的结点离根结点最近，权值最小的结点离根最远Huffman树，又称为最优二叉树，是加权路径长度WPL最短的二叉树。(2)哈弗曼树的构造==注：左右顺序任意==2n-1：n个结点会产生n-1次构造，每次构造新生1个结点，所以为n+n-1=2n-1(3)哈夫曼编码固定长度编码——每个字符用相等长度的二进制位表示可变长度编码——允许对不同字符用不等长的二进制位表示若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码哈夫曼编码是可变长的前缀编码哈夫曼编码可以用哈弗曼树来形成==前缀编码特点:读完就唯一确定====已经编码的就不能再有它开头的编码。==利用上述特性做题。]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构【六】:搜索]]></title>
    <url>%2Fposts%2F139108d8%2F</url>
    <content type="text"><![CDATA[搜索的分类静态搜索静态搜索 ：只是对表中元素进行检索，不更改表信息；检索到，则返回成功；检索不到，则返回失败。动态搜索动态搜索：对表中元素进行检索，同时通过检索过程来实现表的更新；检索到，则返回成功（或删除）；检索不到，则将新元素插入到表中适当位置。搜索算法的性能衡量衡量搜索算法的时间效率的标准：在搜索过程中 关键码的平均比较次数，也称为平均搜索长度ASL(Average Search Length)。设数据表中有 n 个元素，搜索第 i 个元素的概率为 pi搜索到第 i 个元素所需比较次数为 ci，则搜索成功的平均搜索长度:搜索算法Ⅰ、线性表查找1.顺序搜索从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。顺序查找算法的 时间复杂度 为O(n)。优点：算法简单，且对表的结构无任何要求，无论用顺序表还是链表来存放结点，也无论结点是否按关键字有序，都同样适用。缺点:查找效率低2.有序顺序表的折半搜索算法（二分搜索）有序表中的“有序”是逻辑意义上的有序，指表中的元素按某种规则已经排好了位置。顺序表中的“顺序”是物理意义上的采用折半查找的条件：要求顺序存储且关键字值有序1、待查找的值作为key2、比较表中Mid的值和Key的值，若相等查找成功，若不等根据有序表的关系，确定下一个查找区间3、重复上述操作直到查找完毕12345678910111213141516171819202122/** 二分查找 * @param arr : 带查找数组 * @param n ： arr[0]不做存储，待查数据产品那个arr[1]开始 * @param key ：待查关键字 * @return ：返回角标 */int binerySearch(int *arr,int n,int key)&#123; int low = 1; //从arr[1]开始查找 int high = n; int mid; while(low &lt;= high)&#123; mid = (low + high)/2; if(key &lt; arr[mid])&#123; high = mid-1; &#125;else if(key &gt; arr[mid])&#123; low = mid + 1; &#125;else&#123; return mid; &#125; &#125; return -1;&#125;代码源自:数据结构（四）查找时间复杂度为O(log2n)折半查找特别适用于那种一经建立就很少改动、而又需要经常查找的线性表。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。3.基于有序顺序表的其它搜索方法斐波那契搜索差值搜索Ⅱ、树表查找1.二叉搜索（排序）树①定义二叉搜索树或者是一棵空树；或者是具有下列性质的二叉树：(1) 左子树上所有结点的值均小于等于它的根结点的值；(2) 右子树上所有结点的值均大于它的根结点的值；(3) 根结点的左、右子树也分别为二叉排序树。按中序遍历该树所得到的中序序列是一个递增有序序列②二叉搜索树的插入和生成以及搜索二叉搜索树的结构是在搜索过程中逐步生成的，通过不断执行插入操作可以生成一棵二叉搜索树。根据搜索二叉树的特点，新插入的结点一定是一个叶子结点搜索过程和插入过程相差无几12345678910111213template &lt;class E, class K&gt;bool BST&lt;E, K&gt;::Insert (const E&amp; e1, BSTNode&lt;E, K&gt; *&amp; ptr) &#123; if (ptr == NULL) &#123; //新结点作为叶结点插入 ptr = new BstNode&lt;E, K&gt;(e1); //创建新结点 if (ptr == NULL) &#123; cerr &lt;&lt; "Out of space" &lt;&lt; endl; exit(1); &#125; return true; &#125; else if (e1 &lt; ptr-&gt;data) Insert (e1, ptr-&gt;left); //左子树插入 else if (e1 &gt; ptr-&gt;data) Insert (e1, ptr-&gt;right); //右子树插入 else return false; //x已在树中,不再插入&#125;;③搜索二叉树的删除在二叉搜索树中删除一个结点时，必须将因删除结点而断开的二叉链表重新链接起来，同时确保二叉搜索树的性质不会失去。为保证在删除后树的搜索性能不至于降低，还需要防止重新链接后树的高度增加。所以分为四种情况:删除叶结点：只需将其双亲结点指向它的指针清零，再释放它被删结点右子树为空：可以拿它的左子女结点顶替它的位置，再释放它被删结点左子树为空：可以拿它的右子女结点顶替它的位置，再释放它被删结点左、右子树都不为空：在右子树上找中序下第一个结点填补（或者左子树找中序最后一个结点填补，一定要注意，右子树中序下一个节点，不是右孩子节点的左节点，而是右子树中最深的左分支的最后一个点“通俗的就是右子树的最偏左的点”，同理“左子树的最偏右的点”）④N个结点二叉搜索树的种类和性能分析对于有 n 个关键码的集合，其关键码有 n! 种不同排列，可构成不同二叉搜索树有（catalan函数）种所以对于一组数据，我们可以构成多个搜索二叉树，而且效率不定相同。对于树型结构的ASL计算我们根据树的特点和ASL定义，可以对每个结点计算概率×层数再求和，而查询失败长度相当于查询到了叶子结点的下一个结点（NULL）我们对每个该结点计算概率×（层数-1）再求和就得到了查询失败长度，之所以是（层数减1，是因为实际上我们实际上是比较到叶子节点，只不过结果是比较失败而已）。概率相等时：成功概率=1/数据结点数 失败概率=1/失败结点数（空指针域，也就是数据节点数+1）例如（默认概率相等）：对a：ASLsucc=1/3×3+1/3×2+1/3×1=6/3 ASLunsucc = 1/4×3×2+1/4×2+1/4×1 = 9/4对b：ASLsucc = 1/3×2×2+1/3×1 = 5/3 ASLunsucc = 1/4×2×4 = 8/4若不相等，则把给出的相应结点对于概率替换掉相等概率计算即可一般把平均搜索长度达到最小的扩充的二叉搜索树称作最优二叉搜索树。##### ⑤二叉排序树和堆的区别结构上：二叉排序树：左子树小于根节点，根节点又小于右子树。堆（小堆）：根节点小于左右子树，但是左右子树没有大小之分。作用上：二叉排序树是用来做查找的，而堆是用来做排序的。2.平衡二叉树（AVL树）①定义平衡二叉树首先是一棵二叉排序树平衡二叉树或者是一棵空树，或者是具有下列性质的二叉树:其左子树和右子树的深度之差的绝对值不超过 1 ；其左子树和右子树都是平衡二叉树 ；平衡因子 ( Balance Factor，BF)定义为该结点的左子树的深度减去右子树的深度，则平衡二叉树上所有结点的平衡因子只可能是-1、0和1。为了实现二叉排序树的平均查找长度和 log n 等数量级，需要对二叉排序树进行“平衡化”处理，即构造平衡二叉树。##### ②平衡二叉树的构造什么是平衡二叉树（AVL）参考文章:数据结构与算法 - 查找数据结构与算法（10）：查找数据结构（四）查找什么是平衡二叉树（AVL）补充搜索的分类静态搜索(只查)静态搜索 ：只是对表中元素进行检索，不更改表信息；检索到，则返回成功；检索不到，则返回失败。动态搜索(有增删)动态搜索：对表中元素进行检索，同时通过检索过程来实现表的更新；检索到，则返回成功（或删除）；检索不到，则将新元素插入到表中适当位置。搜索算法的性能衡量衡量搜索算法的时间效率的标准：在搜索过程中 关键码的平均比较次数，也称为平均搜索长度ASL(Average Search Length)。设数据表中有 n 个元素，搜索第 i 个元素的概率为 pi搜索到第 i 个元素所需比较次数为 ci，则搜索成功的平均搜索长度:7.1顺序查找算法思想：从头到 jio 挨个找（或者反过来也OK）顺序查找算法的 时间复杂度 为O(n)。优点：算法简单，且对表的结构无任何要求，无论用顺序表还是链表来存放结点，也无论结点是否按关键字有序，都同样适用。缺点:查找效率低(1)无序表(2)有序表注意到最后一个节点查找失败是有两种可能的把被查概率大的放在靠前，能优化，但O(n)是改变不了的并且实际上你可能是一个经常查找失败的表，应该吧查找失败概率大的靠前，需要按实际情况设计。7.2折半查找折半查找，⼜称“⼆分查找”，仅适⽤于有序的顺序表。采用折半查找的条件：要求顺序存储且关键字值有序1、待查找的值作为key2、比较表中Mid的值和Key的值，若相等查找成功，若不等根据有序表的关系，确定下一个查找区间3、重复上述操作直到查找完毕(1)查找效率分析(2)折半查找判定树如果当前low和high之间有奇数个元素，则 mid 分隔后，左右两部分元素个数相等如果当前low和high之间有偶数个元素，则 mid 分隔后，左半部分⽐右半部分少⼀个元素==折半查找的判定树中，若 ，则对于任何⼀个结点，必有：右⼦树结点数-左⼦树结点数=0或1====折半查找的判定树⼀定是平衡⼆叉树====折半查找的判定树中，只有最下⾯⼀层是不满的====树⾼ h = ⌈log 2 (n + 1)⌉==判定树结点关键字：左&lt;中&lt;右，满⾜⼆叉排序树的定义==失败结点：n+1个（等于成功结点的空链域数量）== 7.3分块查找==“索引表”中保存每个分块的最⼤关键字和分块的存储区间==分块查找，⼜称索引顺序查找，算法过程如下：①在索引表中确定待查记录所属的分块（可顺序、可折半）②在块内顺序查找==若索引表中不包含⽬标关键字，则折半查找索引表最终停在 low&gt;high，要在low所指分块中查找====原因：最终low左边⼀定⼩于⽬标关键字，high右边⼀定⼤于⽬标关键字。⽽分块存储的索引表中保存的是各个分块的最⼤关键字====low超出索引表范围，查找失败==查找失败的情况更复杂…⼀般不考若查找表是“动态查找表”，有⽊有更好的实现⽅式？要增删的话，维护查找表的损耗很大。查找效率分析求导等于0即可。7.4B树7.4.1B树及其特性(1)如何保证查找效率为什么除了根节点？不够“平衡”，树会很⾼，要查很多层结点==策略：m叉查找树中，规定对于任何⼀个结点，其所有⼦树的⾼度都要相同。==最终得到： 总结：==策略：m叉查找树中，规定对于任何⼀个结点，其所有⼦树的⾼度都要相同。==(2)定义 (3)B树的核心特性(4)B树的⾼度最小高度==(m-1)每个节点最多有(m-1)个关键字。最多有m个分叉。====(1+m+…..)====1是什么？是根节点！不是根节点里面的关键字！根节点肯定只有一个啊！====第二层结点数就是根节点的分叉m个，第三层就是m^2^个。====总结起来就是总结点数×每个节点的最大关键字个数=总关键字个数==等比数列求和等，最终：最大高度最后一步利用==n个关键字的B树必有n+1个叶⼦结点==用这个结论去看关键字n和高度h的关系另一种思路：(5)总结7.4.2B树的插入和删除(1)插入根节点超出关键字数则新分两个节点 新元素⼀定是插⼊到最底层“终端节点”==新元素⼀定是插⼊到最底层“终端节点”，⽤“查找”来确定插⼊位置==插入90：错误：叶子节点超出关键字数则分给父节点和新节点插入99 插入87 插入99 终端节点的插入若影响到根节点满则根节点分插入75 总结(2)删除终端节点删除，则直接删。注意下限删60 非终端节点删除，用前驱或者后继代替==直接前驱：当前关键字左侧指针所指⼦树中“最右下”的元素====直接后继：当前关键字右侧指针所指⼦树中“最左下”的元素====即对⾮终端结点关键字的删除，必然可以转化为对终端结点的删除操作==删80 删77 下限不够，找兄弟借，最近的兄弟和父亲换借右兄弟最左的删38（借右兄弟最左的） ==兄弟够借。若被删除关键字所在结点删除前的关键字个数低于下限，且与此结点右（或左）兄弟结点的关键字个数还很宽裕，则需要调整该结点、右（或左）兄弟结点及其双亲结点（⽗⼦换位法）==而且界的也是“离得最近的”左兄弟最右的删90（借左兄弟最右的） 兄弟不够借，俩节点和其父关键字合并 总结==PS：理解了方法，其实最终怎么放都能根据特性推出来。==7.5B+树7.5.1定义==和分块查找进行类比。====分支节点其实是索引。叶子节点才是关键字。==7.5.2查找==注：B+树一直找到叶子节点才是找到。====而B树则是查找到即可。== B+树还可以顺序查找。7.5.3B+树和B树的对比子树数量不同 关键字数量限制不同 关键字出现的次数 节点作用和内容 总结小知识：B+树与MySql（不考）小知识：不考7.6散列查找散列表是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。散列表（Hash Table），⼜称哈希表。是⼀种数据结构，特点是：数据元素的关键字与其存储地址直接相关7.6.1散列函数1、散列函数需要的性质得到的散列值是一个非负整数两个相同的键，通过散列函数计算出的散列值也相同两个不同的键，计算出的散列值不同对于第三条来说，想要找到不同的 key 对应的散列值都不一样的散列函数是不可能的。2、散列冲突（collision）冲突：两个不同的键分配的位置相同（映射到了同一个数字上）。3、常见散列函数(0)直接定址法H(key) = key 或 H(key) = a*key + b其中，a和b是常数。这种⽅法计算最简单，且不会产⽣冲突。它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。（1）数字分析法通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。数字分析法仅适用于事先明确知道表中所有关键码每一位数值的分布情况、它完全依赖于关键码集合(2)平方取中法假设关键字是1234，平方之后是1522756，再抽取中间3位227，用作散列地址。平方取中法比较适合于不 知道关键字的分布，而位数又不是很大的情况。因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。一般取散列地址为8的某次幂（3）折叠法将关键字从左到右分割成位数相等的几部分，最后一部分位数不够时可以短些，然后将这几部分叠加求和， 并按散列表表长，取后几位作为散列地址。比如关键字是9876543210，散列表表长是3位，将其分为四组，然后叠加求和：987 + 654 + 321 + 0 = 1962，取后3位962作为散列地址。折叠方式除了直接相加还有来回反转相加的分界法，987+456+321+0折叠法适合关键码位数较多，且关键码每一位上数字分布比较均匀的情况（4)留取余数法f(key) = key mod p (p≤m)，m为散列表长。这种方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。根据经验，==若散列表表长为m，通常p为小于或等于表长（最好接近m）的最小质数，可以更好的 减小冲突。==4、处理冲突的方法(1)开放地址法(闭散列法)开放地址就是一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并且记录它。至于如何寻找下一个空的散列地址，有三种方法①线性探查法f(key)=(f(key)+d)%m ,其中d取（0，1,2,3,4.....，m-1），m为散列表的长度线性探测来解决冲突问题，会造成冲突堆积。例如：本来是属于下标1的元素，现在却占用了下标为2的空间，这会造成待会我们需要存放本来要放在下标为2的元素时，再次发生冲突，这个冲突会一直传播下去，造成查找和插入效率都大大减低。==注意：冲突处理后的落脚点可能会在哈希函数值域之外==查找操作 ==空位置的判断也要算作⼀次⽐较。和链表法不同，因为链表发起始为空是地址并非数据====越早遇到空位置，就可以越早确定查找失败。====所以删除操作就需要注意了==例如我们删掉1再查27==注意：采⽤“开放定址法”时，删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填⼊散列表的同义词结点的查找路径，可以做⼀个“删除标记”，进⾏逻辑删除==②二次探测法f（key）=（f(key)+d）%m, ,其中d取（0^2，1^2,-1^2,2^2,-2^2,3^2,-3^2,4^2,-4^2...,q^2,-q^2），q&lt;=m/2,m为散列表的长度其实，这个是对线性探测的一个优化，增加了平方可以不让关键字聚集在某一块区域。查找也是按照二次探测查找的⾮重点⼩坑：散列表⻓度m必须是⼀个可以表示成4j + 3的素数，才能探测到所有位置③随机探测法（双散列法）f（key）=（f(key)+d）%m, d为随机数列，而m为表长(2)链地址法(开散列法)其实就是当发生冲突时，我还是把它存放在当前的位置，只是每个位置都是使用链表来存放同义词，这个思路和图的邻接表存储方式很相似。链中的数值若是有序的则能够进一步提高查找效率。（3）良好的装填因子装填因子：a=n/m 其中n 为关键字个数，m为表长。当a处于0.6~0.9之间较为良好，否则建议我们修改表长7.6.2平均查找成功和不成功长度一定要先理解ASL概念设数据表中有 n 个元素，搜索第 i 个元素的概率为 pi搜索到第 i 个元素所需比较次数为 ci，则搜索成功的平均搜索长度:一般情况下我们认为pi是相同的，就像有n个小球随记抽取一个，概率为1/n，我们查找某个数的概率也是1/n线性探查法ASL成功=（探查每个元素的次数求和）/表中元素的个数理解：既然能查询成功，说明一定是表中元素，所以计算每个元素的查找长度求和后乘查找每个元素的概率1/5ASL不功=（对从0~MOD-1的地址逐个求出分别离他们按顺序查找最近的空元素位置的长度再求和）/MOD长之所以查询到空就是探查失败，因为若有该数据，则该空位置是可以存放的理解：既然查找不成功，说明一定不表是中元素，这时候可能对散列函数值任意一个查找，若使用留取余数法则一共有MOD种查找可能，每种可能查找的概率为1/MOD，再对每种可能的查询分析查找长度再求和，注意查询失败的条件是查询倒空而不是查询到表尾链地址法 有的教材也会把“空指针”的判定算作⼀次⽐较。看学校真题把。408或者一般都是按0算的。==因为链表发起始为空是地址并非数据。对于开放地址法中空位置的判断也要算作⼀次⽐较，因为其真的是和数值比较。====链表第一行的查找长度都是1，有6个，第二行是2，有4个………====ASL成功中的12是指数据个数。而ASL失败中的13是指表长或者MOD长更准==]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构【五-3】:树和森林]]></title>
    <url>%2Fposts%2F30e896a2%2F</url>
    <content type="text"><![CDATA[多叉树的表示多叉树每个结点的分支数量不固定，可能有多个可能没有1、父指针表示法定义一个结构，其中包含data和parent用来表示当前结点数据和父亲结点位置然后用连续的结构体表示该树：优点： 可用parent直接找到双亲，并且很容易找到祖先。时间复杂度O（1）缺点：需要查找节点的孩子及其子孙时要遍历整个结构。时间复杂度O(n)2、子女链表示法*把每个结点的 子女结点的位置以单链表的结构存储 ，则n个结点生成了n条单链表，再将 n 条单链表头指针以顺序线性表存储 *优点: 方便搜索孩子结点缺点: 查找父结点需要从头遍历整个顺序表3、双亲子女表示法我们将父指针表示法和子女链表示法结合起来这样查找父亲和孩子结点都方便4、子女兄弟链表示法以二叉链表作为树的存储结构，结点的两个链域分别指向该结点的第一个孩子和右边的第一个兄弟启示：一颗树可以转化为一个只有左子树的二叉树 树、森林、二叉树转换和遍历转换方法根据前面的子女兄弟链表示法我们可以进一步得出树、森林、二叉树的转换方法树、森林和二叉树的转换树、森林–》二叉树画线更方便二叉树—-》树、森林定义更方便树的遍历1.树的先根遍历（深度优先遍历）若树不空，则先访问根结点，然后依次先序遍历各棵子树。子女兄弟链图中的树先根遍历为:R A D E B C F G H K树的先根遍历序列与该树对应的二叉树的先序遍历序列相同2.树的后根遍历（深度优先遍历）若树不空，则先依次后序遍历各棵子树，然后访问根结点。子女兄弟链图中的树后根遍历为:D E A B G H K F C R树的后根遍历序列与该树对应的二叉树的中序遍历序列相同3.树的层序遍历（广度优先遍历）若树不空，则自上而下自左至右访问树中每个结点。森林的遍历1.森林的先根遍历（深度优先遍历）即依次对每一棵树进行先根遍历森林的先根遍历序列与其对应的二叉树的先序序列一致。2.森林的后根遍历（深度优先遍历）即依次对每一棵树进行后根遍历森林的后根遍历序列与其对应的二叉树的中序序列一致。先先、后中3.森林的广度优先遍历从第1层起，自顶向下，同一层自左向右，依次访问森林中各棵树的结点。Huffman树及其应用参考文章:huffman树及其应用哈夫曼树Huffman树概念路径：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径路径长度：路径中分支的数目称为路径长度。（线的条数）根据路径长度定义和二叉树结构特点得到:n 个结点的二叉树的路径长度不小于下述数列前 n 项的和，即其最小路径长度=PL权值：在数学领域，权值指加权平均数中的每个数的频数，也称为权数或权重。树的路径长度：树根到每个结点的路径长度之和。树的路径长度可计算为对每一层:每层的节点数×（层数-1）的求和结点的带权路径长度：从根结点到该结点之间的路径长度与该结点的权的乘积。树的带权路径长度（Weighted Path Length, WPL）:叶子结点的带权路径长度之和。主观上判断：权值最大的结点离根结点最近，权值最小的结点离根最远Huffman树，又称为最优二叉树，是加权路径长度最短的二叉树。应用:Huffman编码详见参考文章]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构【五-2】:堆]]></title>
    <url>%2Fposts%2F27b042e9%2F</url>
    <content type="text"><![CDATA[堆的定义和插入删除引用文章:详解数据结构——堆数据结构之堆(Heap)数据结构浅析(10)-树性结构：堆定义:堆是一种完全二叉树，对于任意一个结点来说，其值都大（小）于其任意一个子节点的值，称为最大（小）堆因为完全二叉树有其非常卓越的性质：对于任意一个父节点的序号n来说（这里n从0算），它的子节点的序号一定是2n+1,2n+2，因此我们可以直接用数组来表示一个堆插入:在堆中插入一个结点就是将该元素插入到堆的尾部，然后不断上浮调整位置，直至满足堆的条件。POP根结点:删除堆顶元素后，用末尾元素补上，个数减1(这样才能用数组表示删除了一个节点)，然后不断下沉，直至满足堆的条件。初始化: 首先：数据输入，构建完全二叉树​ 一个单独的节点就可以看成是一个最大堆了，如果我们用数组存放，那么由完全二叉树特点，后n/2个数为叶子。所以我们从第n/2个数据开始向上到根结点，我们可以将其最为一个子树的根，将这个子树视为刚刚删除一个根节点的堆，用POP根节点后的操作进行该子堆重构，这样操作保证了每一个子树都是堆，然后由小到大，保证了最终构成了堆，这样就不用再次检验是否是堆了，若对从2/n到1的节点只判断节点和左右子节点是否要交换，最后还需要再次判断是否是堆，并继续调整堆排序将数据改造为最大堆或者最小堆，不断重复输出根节点（但是操作换为最后一个元素和根元素互换），重新构建堆（也就是POP根节点操作）这样下去，最终就能在原有数组得到一个有序序列根据特性我们能推出：升序使用大顶堆，降序使用小顶堆详解：[图解排序算法(三)之堆排序]]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理【四】:CPU结构及功能]]></title>
    <url>%2Fposts%2Fd90d2b50%2F</url>
    <content type="text"><![CDATA[CPU结构及功能总导图![](https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/CPU 结构及功能.png)指令周期]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python日常笔记]]></title>
    <url>%2Fposts%2Ff0f635c6%2F</url>
    <content type="text"><![CDATA[range（）使用range（n）就代表n次循环想要达到C或者C++使用的感觉:当a&lt;brange(a,b) 就代表for(i=a;i&lt;b;i++)range(a,b+1) 就代表for(i=a;i&lt;=b;i++)ramge(a,b,c) 就代表for(i=a;i&lt;b;i+=c)ramge(a,b+1,c) 就代表for(i=a;i&lt;=b;i+=c)当a&gt;brange(a,b) 就代表for(i=a;i&gt;b;i–)range(a,b-1) 就代表for(i=a;i&gt;=b;i–)ramge(a,b,c) 就代表for(i=a;i&gt;b;i-=c)ramge(a,b-1,c) 就代表for(i=a;i&gt;=b;i-=c)输入整形数字1、a,b=map(int,input().split())使用map函数2、a,b=eval(input())使用eval函数一个下划线表示不关心的变量在程序中，可以使用一个下划线来表示不关心该变量的值123for _ in range(5):print(3, end=' ')#输出为3 3 3 3 3实际上’_’是最后一 次显示的内容或最后一次语句正确执行的输出结果常用函数sorted() 函数iterable – 可迭代对象。cmp – 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。reverse – 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。常用算法求最大公约数：定理：两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。最大公约数缩写为gcd。当分母为0时刻停止，分子就是最大公约数]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理【三】:指令系统]]></title>
    <url>%2Fposts%2Fa78497ca%2F</url>
    <content type="text"><![CDATA[总导图操作码扩展1、短操作码不能是长操作码的前缀，不然机器无法识别2、三地址指令操作码每减少一种最多可多构成 24 种二地址指令二地址指令操作码每减少一种最多可多构成24种一地址指令，注意是最多，也就是下一种地址码不再用来拓展的情况。3、一般常用操作用短操作吗，不常用的用长操作码数据在存储器中的存放方式理解大小端关于PC程序计数器的理解程序计数器 PC下面为引用文冯 ·诺伊曼计算机体系结构的主要内容之一就是“程序预存储，计算机自动执行”！处理器要执行的程序（指令序列）都是以二进制代码序列方式预存储在计算机的存储器中，处理器将这些代码逐条地取到处理器中再译码、执行，以完成整个程序的执行。为了保证程序能够连续地执行下去，CPU必须具有某些手段来确定下一条取指指令的地址。程序计数器（PC ）正是起到这种作用，所以通常又称之为‘指令计数器’。CPU总是按照PC的指向对指令序列进行取指、译码和执行，也就是说，最终是PC 决定了程序运行流向。故而，程序计数器（PC ）属于特别功能寄存器范畴，不能自由地用于存储其他运算数据。在程序开始执行前，将程序指令序列的起始地址，即程序的第一条指令所在的内存单元地址送入PC，CPU 按照 PC的指示从内存读取第一条指令（取指）。当执行指令时，CPU自动地修改PC 的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数（指令字节数），使 PC总是指向下一条将要取指的指令地址。由于大多数指令都是按顺序来执行的，所以修改PC 的过程通常只是简单的对PC 加“指令字节数”。]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[借助栈实现中缀表达式转后缀表达式并计算结果（限+-*/（）运算符）]]></title>
    <url>%2Fposts%2Fe0562e2c%2F</url>
    <content type="text"><![CDATA[原理整体过程：输入中缀字符串存入str1-&gt;中缀转后缀表达式存入字符串str2–&gt;利用后缀表达式字符串str2计算结果并输出1.中缀—&gt;后缀按照顺序扫描str1遇到数字或者小数点直接存入str2，这里我们使用循环一次性将数符输入再在其后添加标记符号这里我使用美元符号作为分隔，防止后面使用的时候若两个数符同时储存判别不出数符。遇到运算符，判断优先级，再只有+-*/（）的运算中我们根据中缀转后缀的方法提取出如下特点:左括号优先级最大，直接压入栈不必考虑其他，同时记录左括号个数*/优先级其次，对有无括号的分析后发现我们可以化简为一个操作*和/法则遇到同级别 运算符才出栈存入str2再入栈该符号，遇到+-（直接压栈即可+-运算符优先级最低，只要入栈就需要清栈存入str2再压栈，但是需要分为有括号和无括号两个操作有括号：清空左括号后的字符存入str2再压栈无括号：直接清空栈存入str2，再压栈遇到右括号则出栈最近的一个左括号所有右面的符号，同时左括号个数-1直到str1扫描完毕，str2的后缀表达式也就生成了2.后缀表达式计算按照顺序扫描str2，遇到数字字符或者小数点直接进入循环判断将一整个数字字符串存入一个临时数组，由于我们之前使用的分隔符，所以可以依靠分隔符很容易就扫描出每个数字字符串，之后我们直接调用c库中的atof()函数转为浮点型再压栈遇到运算符则出栈两个数字通过该运算符计算后再压栈，直到扫描结束，栈顶数据就是计算结果代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194 #include&lt;iostream&gt;#include&lt;string.h&gt;# include &lt;stdlib.h&gt;using namespace std;int defaultSize=500;int t=0; //用于数组下标，不用每次传入函数 int flag=0;//用于判断栈内是否有'(' template&lt;class T&gt;class stack&#123; public: stack(); T pop(); void push(T a); T getTop(); void cleanTokuohao(T str2[]);//用于括号清栈 void clean(T str2[]); //用于+-清栈 void clean2(T str2[]); //用于*/清栈 protected: T *data; int top=-1;&#125;;template&lt;class T&gt;stack&lt;T&gt;::stack()&#123; data=new T[defaultSize]; top=-1;&#125;template&lt;class T&gt;T stack&lt;T&gt;::pop()&#123; if(top&gt;-1) return data[top--];&#125;template&lt;class T&gt;void stack&lt;T&gt;::push(T a)&#123; if(top&lt;defaultSize-1) data[++top]=a;&#125;template&lt;class T&gt;T stack&lt;T&gt;::getTop()&#123; if(top&gt;-1) return data[top];&#125;template&lt;class T&gt;void stack&lt;T&gt;::cleanTokuohao(T str2[])//用于括号清栈 &#123; while(data[top]!='(') &#123; str2[t++]=pop(); &#125; top--;&#125;template&lt;class T&gt;void stack&lt;T&gt;::clean(T str2[])//用于+-清栈 &#123; while(top!=-1) &#123; str2[t++]=pop(); &#125;&#125;template&lt;class T&gt;void stack&lt;T&gt;::clean2(T str2[])//用于*/清栈&#123; while(data[top]=='/'||data[top]=='*') &#123; str2[t++]=pop(); &#125;&#125;char* ZhuanHuan(char str1[])&#123; stack&lt;char&gt; s1; //s1使用栈操作符号 char *str2; //str2储存后缀表达式 int len=strlen(str1)-1; //储存长度，节省循环调用strlen的时间 str2=new char[defaultSize]; for(int i=0;i&lt;len;i++) &#123; //cout&lt;&lt;str2&lt;&lt;endl; if((str1[i]&gt;='0'&amp;&amp;str1[i]&lt;='9')||str1[i]=='.') &#123; while((str1[i]&gt;='0'&amp;&amp;str1[i]&lt;='9')||str1[i]=='.') &#123; //扫描到数字时一次性将数字全部扫进去 str2[t++]=str1[i++]; &#125; str2[t++]='$'; //将美元符作为分割实数的符号方便分析 i--; //最后别忘了i需要退格 &#125; //数字或者'.'直接入后缀表达式str2 else if(str1[i]=='(') &#123; //左括号直接入符号栈因为左括号优先级最高不需要考虑 s1.push(str1[i]); //同时记录左括号个数方便其他出栈判断操作 flag++; &#125; else if(str1[i]==')') &#123; //遇到右括号开始出栈到左括号 s1.cleanTokuohao(str2); //括号标记减1； flag--; &#125; else if(str1[i]=='+'||str1[i]=='-') &#123; if(flag==0) &#123; s1.clean(str2); //无括号的时候，在本题只有四则运算的情况，+-优先级最低，清栈后将再将+或者-填进去 s1.push(str1[i]); &#125; else &#123; s1.cleanTokuohao(str2); //有括号相当于出栈该括号内的符号再将+填入左括号之后，这里直接调用括号清除函数，再手动添加'('和'+'或者'-'; s1.push('('); s1.push(str1[i]); &#125; &#125; else if(str1[i]=='*'||str1[i]=='/') &#123; //*和/法则遇到同级别 运算符才出栈再入栈，遇到+-（直接入栈即可， s1.clean2(str2); s1.push(str1[i]); &#125; &#125; s1.clean(str2); return str2; &#125;double houzhijisuan(char str[])&#123; stack&lt;double&gt; s1; //利用栈储存数字 char num[500]; //作为中转字符转数字 int len=strlen(str); double num1,num2; //作为中转计算数据 for(int i=0;i&lt;strlen(str);i++) &#123; if((str[i]&gt;='0'&amp;&amp;str[i]&lt;='9')||str[i]=='.') &#123; t=0; //静态变量t再次利用。 while(str[i]!='$') &#123; //扫描到数字时一次性将数字全部扫进去 num[t++]=str[i++]; &#125; num[t]='\0'; //别忘记加\0否则会误判数字 s1.push(atof(num)); //将数字入栈，这里利用了C库中的atof()函数帮我们省去了自己编写的工夫 &#125; //之后都是遇到运算符就出栈两个数据根据运算符计算结果再入栈，不再赘述. else if(str[i]=='+') &#123; num1=s1.pop(); num2=s1.pop(); s1.push(num2+num1); &#125; else if(str[i]=='-') &#123; num1=s1.pop(); num2=s1.pop(); s1.push(num2-num1); &#125; else if(str[i]=='*') &#123; num1=s1.pop(); num2=s1.pop(); s1.push(num2*num1); &#125; else if(str[i]=='/') &#123; num1=s1.pop(); num2=s1.pop(); s1.push(num2/num1); &#125; &#125; return s1.getTop();&#125; int main()&#123; char str[defaultSize]; cin&gt;&gt;str; cout&lt;&lt;houzhijisuan(ZhuanHuan(str));&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>-数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构【五-1】:二叉树（C++）]]></title>
    <url>%2Fposts%2F336f1d3d%2F</url>
    <content type="text"><![CDATA[树的一些易混相关概念1、 结点拥有的子树数称为结点的度（Degree）。树的度是树内各结点度的最大值。2、树的深度（Depth）或高度是树中结点的最大层次数值。3、祖先结点：从根结点到该结点所经分支上的所有结点。4、子孙节点：某一结点的子女以及这些子女的子女。二叉树参考文：图解数据结构-树数据结构中的各种树非递归构建二叉树理解前序中序后序遍历二叉树的特点每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。左子树和右子树是有顺序的，次序不能任意颠倒。即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。二叉树五种基本形态空二叉树只有一个根结点根结点只有左子树根结点只有右子树根结点既有左子树又有右子树几种特殊的二叉树斜树​ 又分为左斜树、右斜树。结点个数与二叉树深度相同​ 满二叉树除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。完全二叉树若设二叉树的深度为h，只看前1~（n-1)层则是满二叉树，第h层所有的结点都连续集中在最左边，这就是完全二叉树。一个具有n个节点的完全二叉树，其叶子节点的个数为?n1=0，n为奇数时：n0 = (n+1) / 2n1=1，n为偶数时：n0 = n / 2二叉树的性质性质1：在二叉树的第i层上至多有2i-1个结点（i&gt;=1）性质2：深度为k的二叉树至多有2k-1个结点（k&gt;=1）—–a1=1 公比为2的等比数列求和性质3：对任何一棵二叉树T，如果其叶子数为n0,度为2的结点数为n2，则n0 = n2+1。证明:一棵二叉树，除了终端结点（叶子结点），就是度为1或2的结点。假设n1度为1的结点数，则数T 的结点总数n=n0+n1+n2。我们再换个角度，看一下树T的连接线数，由于根结点只有分支出去，没有分支进入，所以连接线数为结点总数减去1。也就是n-1=n1+2n2，可推导出n0+n1+n2-1 = n1+2n2，继续推导可得n0 = n2+1。性质4：具有n个结点的完全二叉树的深度为[log2（n+ 1） ] (向上取整)或者[log2n ]+1（向下取整） 。性质5：如果对一颗有n个结点的完全二叉树（其深度为[log2n ] + 1）的结点按层序编号（从第1层到第[log2n ] + 1层，每层从左到右），对任一结点i(1&lt;=i&lt;=n)有：如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点[i/2]。如果2i&gt;n,则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点i。如果2i+1&gt;n,则结点i无右孩子；否则其右孩子是结点2i+1。结点i所在层次为[log2i ]+1（向下取整）性质5其实就是顺序储存下父子结点编号关系顺序结构实现二叉树利用性质5可以对数组下标操作完成二叉树储存二叉树的顺序存储结构缺点很明显：不能反应逻辑关系；对于特殊的二叉树（左斜树、右斜树），浪费存储空间。所以二叉树顺序存储结构一般只用于完全二叉树。对于右斜树，顺序存储结构浪费存储空间：^表示其中数据为空链式结构实现二叉树​ 二叉链表:三叉链表：三叉链表在二叉链表的基础上添加一个返回指针指向父亲结点含n个结点的二叉链表有n+1个空链指针域含n个结点的三叉链表有n+2个空链指针域关于遍历顺序前序遍历顺序：规则是先是根结点，再前序遍历左子树，再前序遍历右子树中序遍历顺序：规则是先中序遍历左子树，再是根结点，再是中序遍历右子树后序遍历顺序：规则是先后序遍历左子树，再是后序遍历右子树，再是根结点详细解释:1、对于每个节点，访问顺序为遍历顺序2、！对于每个节点，左子树的节点全部访问完，再能再根据遍历顺序访问右子树的节点。！！！！！！根据这两条规则我们就能够确定其中任意一种遍历的顺序了。代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251#include&lt;iostream&gt;#include &lt;algorithm&gt;int defaultSize=100; using namespace std;template &lt;class T&gt; struct Node&#123; T data; Node&lt;T&gt; *left=NULL,*right=NULL;&#125; ;template &lt;class T&gt; class Btree&#123; public: Btree(); void creatBtree_Qian(Node&lt;T&gt; *&amp;p,T t);//前序创建二叉树 ，这里以t为标志表示 参数必须为结点指针的引用 void output_Qian(Node&lt;T&gt; *p); //前序遍历 void output_Qian_Suojin(Node&lt;T&gt; *p,int n); //前序遍历的缩进输出表示 //用n来表示层数控制函数中的‘-’输出 该结点在第几次就输出几个 ‘-’ void output_Zhong(Node&lt;T&gt; *p); //中序遍历 void output_Hou(Node&lt;T&gt; *p); //后序遍历 void output_Level(Node&lt;T&gt; *p); //层次遍历 Node&lt;T&gt; * search_Qian(Node&lt;T&gt; *p,T x); //前序遍历查询函数并返回结点的地址 bool equal(Node&lt;T&gt; *p,Node&lt;T&gt; *q);//判断两棵树是否相同 Node&lt;T&gt;* getRoot(); //获取树根结点 bool isEmpty(); //判空函数 void destroy(Node&lt;T&gt; *p); //删除根为p的子树 int nodeNumbers(Node&lt;T&gt; *p); //计算结点个数 int deepth(Node&lt;T&gt; *p); //计算树的高度或者深度 void countPoint(Node&lt;T&gt; *p,int num[]);//计算二叉树度为0,1,2的结点个数保存在一个数组中 void countWidth(Node&lt;T&gt; *p,int num[],int a);//计算二叉树每一层结点个数保存在一个数组中a需要手动赋初始值0或者1 protected: Node&lt;T&gt; *root;&#125;;template &lt;class T&gt; Btree&lt;T&gt;::Btree()&#123; root=NULL;&#125;template &lt;class T&gt; void Btree&lt;T&gt;::creatBtree_Qian(Node&lt;T&gt; *&amp;p,T t) //参数必须为结点指针的引用 否则无法链接起来各个结点 &#123; T a; //我们的操作步骤如下： cin&gt;&gt;a; if(a==t) //1、根据输入字符 判断 是否按照相应顺序存入数据 return; p=new Node&lt;T&gt;; //2、若需要存入数据，我们需要创建并且链接一个结点 p-&gt;data=a; //3、之后根据我们相应的创建顺序，决定数据的存放顺序 creatBtree_Qian(p-&gt;left,t); //4、这里是前序，所以，我们存数据，对左结点继续操作 creatBtree_Qian(p-&gt;right,t); //5、确认左结点创建完毕后 对右结点操作 root=p; //6、将根结点赋给root; &#125;template &lt;class T&gt; void Btree&lt;T&gt;::output_Qian(Node&lt;T&gt; *p)&#123; if(p!=NULL) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;" "; output_Qian(p-&gt;left); output_Qian(p-&gt;right); &#125;&#125;template &lt;class T&gt; void Btree&lt;T&gt;::output_Qian_Suojin(Node&lt;T&gt; *p,int n) //用n来表示层数控制函数中的‘-’输出 该结点在第几次就输出几个 ‘-’&#123; if(p!=NULL) &#123; for(int i=0;i&lt;n;i++) cout&lt;&lt;"-"; cout&lt;&lt;p-&gt;data&lt;&lt;" "&lt;&lt;endl; output_Qian_Suojin(p-&gt;left,n+1); //进入递归，代表进入子结点，层数+1; output_Qian_Suojin(p-&gt;right,n+1); &#125;&#125;template &lt;class T&gt; void Btree&lt;T&gt;::output_Zhong(Node&lt;T&gt; *p)&#123; if(p!=NULL) &#123; output_Zhong(p-&gt;left); cout&lt;&lt;p-&gt;data&lt;&lt;" "; output_Zhong(p-&gt;right); &#125;&#125;template &lt;class T&gt; void Btree&lt;T&gt;::output_Hou(Node&lt;T&gt; *p)&#123; if(p!=NULL) &#123; output_Hou(p-&gt;left); output_Hou(p-&gt;right); cout&lt;&lt;p-&gt;data&lt;&lt;" "; &#125;&#125;template &lt;class T&gt; void Btree&lt;T&gt;::output_Level(Node&lt;T&gt; *p)&#123; Node&lt;T&gt; *Queue[defaultSize]; //建立一个容量100的结点指针数组作为队列 int front=0,rear=0; //建立队首和队位指针 if(!isEmpty()) //判空 &#123; Queue[rear++]=p; //1、先将根入队 while(front!=rear) //2、设置队列非空循环条件 &#123; cout&lt;&lt;Queue[front]-&gt;data&lt;&lt;" "; //3、输出结点的值 if(Queue[front]-&gt;left!=NULL) //4、若该结点左子树不为空则入队列 &#123; Queue[rear]=Queue[front]-&gt;left; //补充:注意先存数据再将尾指针加1 rear=(rear+1)%defaultSize; //5、为了充分使用空间，我们使用循环队列，队尾+1取余 &#125; if(Queue[front]-&gt;right!=NULL) //6、若该结点右子树不为空则入队列 &#123; Queue[rear]=Queue[front]-&gt;right; rear=(rear+1)%defaultSize; //7、同理队尾+1取余 &#125; front=(front+1)%defaultSize; //8、将输出过的结点出队列 &#125; &#125; &#125; template &lt;class T&gt; Node&lt;T&gt; * Btree&lt;T&gt;::search_Qian(Node&lt;T&gt; *p,T x) //bool型为查询到就终止准备 &#123; Node&lt;T&gt; * t=NULL; if(p!=NULL) &#123; if(p-&gt;data==x) return p; //查询到就返回 t=search_Qian(p-&gt;left,x); if(t==NULL) //只有当左子树没有查询到我们才进入右子树查询，节省空间。同时防止左子树查询到t=结点地址后进入右子树查询失败导致t=NULL的覆盖 t=search_Qian(p-&gt;right,x); &#125; return t; //最终返回t作为结果 &#125;template &lt;class T&gt; Node&lt;T&gt;* Btree&lt;T&gt;::getRoot()&#123; return root;&#125;template &lt;class T&gt; bool Btree&lt;T&gt;::isEmpty()&#123; if(root==NULL) return true; else return false;&#125;template &lt;class T&gt; void Btree&lt;T&gt;::destroy(Node&lt;T&gt; *p)&#123; if(p!=NULL) &#123; destroy(p-&gt;left); destroy(p-&gt;right); delete p; &#125; &#125;template &lt;class T&gt; int Btree&lt;T&gt;::nodeNumbers(Node&lt;T&gt; *p)&#123; if(p==NULL) return 0; return nodeNumbers(p-&gt;left) + nodeNumbers(p-&gt;right) + 1; //巧妙递归计算左子树节点数+右子树节点数+根=节点数 &#125;template &lt;class T&gt; int Btree&lt;T&gt;::deepth(Node&lt;T&gt; *p)&#123; if(p==NULL) return 0; int leftDeepth=deepth(p-&gt;left); int rightDeepth=deepth(p-&gt;right); return max(leftDeepth,rightDeepth)+1; //max()函数需要头文件#include &lt;algorithm&gt; &#125;template &lt;class T&gt; void Btree&lt;T&gt;::countPoint(Node&lt;T&gt; *p,int num[]) //计算二叉树度为0,1,2的结点个数保存在一个数组中&#123; if(p!=NULL) &#123; if(p-&gt;left!=NULL&amp;&amp;p-&gt;right!=NULL) //左右结点都不为空 2度结点+1 num[2]++; else if(p-&gt;left==NULL&amp;&amp;p-&gt;right==NULL) //左右结点都为空 0度结点+1 num[0]++; else //左否则 1度结点+1 num[1]++; countPoint(p-&gt;left,num); countPoint(p-&gt;right,num); &#125;&#125; template &lt;class T&gt; void Btree&lt;T&gt;::countWidth(Node&lt;T&gt; *p,int num[],int a) //计算二叉树每一层的结点数，最后保存在数组中。&#123; if(p!=NULL) &#123; num[a]++; countWidth(p-&gt;left,num, a+1); countWidth(p-&gt;right,num, a+1); &#125;&#125; template &lt;class T&gt; bool Btree&lt;T&gt;::equal(Node&lt;T&gt; *p,Node&lt;T&gt; *q)&#123; bool t=true; if(p!=NULL&amp;&amp;q!=NULL) &#123; if(p-&gt;data!=q-&gt;data) return false; t=equal(p-&gt;left,q-&gt;left); if(t==true) //当左子树相同的时候才比较右子树，提高效率，节省空间 t=equal(p-&gt;right,q-&gt;right); &#125; else if((p!=NULL&amp;&amp;q==NULL)||(p==NULL&amp;&amp;q!=NULL)) return false; return t;&#125; int main()&#123; Btree&lt;int&gt; test; //测试数据:1 2 3 -1 -1 4 -1 -1 5 -1 6 -1 -1 Node&lt;int&gt; *t; //test.getRoot()这个函数返回值不能直接作为参数放到 test.creatBtree_Qian();中会编译报错。 test.creatBtree_Qian(t,-1); //用t存起来再放进去就可以运行。 test.output_Qian(test.getRoot()); cout&lt;&lt;endl; test.output_Zhong(test.getRoot()); cout&lt;&lt;endl; test.output_Hou(test.getRoot()); cout&lt;&lt;endl; cout&lt;&lt;test.nodeNumbers(test.getRoot()); cout&lt;&lt;endl; cout&lt;&lt;test.deepth(test.getRoot()); cout&lt;&lt;endl; test.output_Level(test.getRoot()); cout&lt;&lt;endl; if(test.search_Qian(t,5)!=NULL) cout&lt;&lt;"success and is"&lt;&lt;test.search_Qian(t,5)-&gt;data&lt;&lt;endl; else cout&lt;&lt;"false"&lt;&lt;endl; int s[3]=&#123;0&#125;; test.countPoint(t,s); for(int i=0;i&lt;3;i++) cout&lt;&lt;s[i]&lt;&lt;endl; int num[10]=&#123;0&#125;; test.countWidth(t,num,0); for(int i=0;i&lt;10;i++) cout&lt;&lt;num[i]&lt;&lt;endl; Node&lt;int&gt; *t2; test.creatBtree_Qian(t2,-1); if(test.equal(t,t2)) cout&lt;&lt;"equal"&lt;&lt;endl; else cout&lt;&lt;"not equal"&lt;&lt;endl;&#125;参考博文：求二叉树的节点个数、深度、四种遍历方法二叉树计数N个结点二叉树有种这个函数称为catalan函数n个节点的二叉树有多少种形态根据遍历顺序画出一棵二叉树根据遍历序列确定二叉树根据二叉树的先序和中序序列画出二叉树的方法值得注意的是根据遍历顺序确定一棵二叉树必须要有一个中序在里面总结与思考通过创建树引发的对指针引用变量的思考：http://lyxf.live/posts/2541aeec/1.关于求深度、节点数，我们使用递归思想，将问题化为一个小树枝，在设置恰当返回条件的前提下，不断向上返回，左右树不断扩大最终返回到树根待补充二叉树非递归遍历线索二叉树参考文章:深入学习二叉树(二) 线索二叉树线索二叉树二叉树的线索化及其遍历（必会）1、二叉树中没有利用的指针n个节点二叉树有n+1个没有利用的指针在N个节点的二叉树中，每个节点有2个指针，所以一共有2N个指针，除了根节点以外，每一个节点都有一个指针从它的父节点指向它，所以一共使用了N-1个指针，所以剩下2N-(N-1)也就是N+1个空指针；2、利用空指针指向前驱后驱原因:如果利用空指针直接记录前驱后驱结点，在遍历的时候会比递归速度要快还能减少建立递归程序的存储空间。若结点的左子树为空，则该结点的左孩子指针指向其前驱结点。若结点的右子树为空，则该结点的右孩子指针指向其后继结点。3、解决判断左右指针是为指向前后驱还是左右孩子添加标志位ltag，rtag，并定义规则如下：ltag为0时，指向左孩子，为1时指向前驱rtag为0时，指向右孩子，为1时指向后继5、实现方法1、首先建立起二叉树2、按某种次序遍历二叉树，在遍历过程中用线索取代空指针即可。12345678910111213141516171819202122//中序遍历进行中序线索化void inThreading(ThrBiTree T, ThrBiTree &amp;pre)&#123; if(T)&#123; inThreading(T-&gt;lchild, pre);//左子树线索化 if(!T-&gt;lchild)&#123;//当前结点的左孩子为空 T-&gt;lTag = Thread; T-&gt;lchild = pre; &#125;else&#123; T-&gt;lTag = Link; &#125; if(!pre-&gt;rchild)&#123;//前驱结点的右孩子为空 pre-&gt;rTag = Thread; pre-&gt;rchild = T; &#125;else&#123; pre-&gt;rTag = Link; &#125; pre = T; inThreading(T-&gt;rchild, pre);//右子树线索化 &#125; &#125;把二叉树看成中序遍历序列，序列的第一个结点（最左下结点）的前驱为NULL，最后一个结点（最右下结点）的后继为NULL。通过设置pre的初始化为NULL和最后对pre（指向最后一个结点）的后继（右子树）设置为NULL来实现。值得注意，我们在一次处理中是处理当前左结点和前驱的右节点，按照这样的顺序递归执行下去的，而不是对当前的左右结点处理6、遍历详见参考文章]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python随记【二】]]></title>
    <url>%2Fposts%2F75ee964e%2F</url>
    <content type="text"><![CDATA[选择与循环字符串字符串格式化解析.format()使用详解字符串方法字符串常用方法字符串常用操作方法.format()函数使用中，{}中的格式控制标记顺序分别为：填充—&gt;对齐—&gt;宽度—&gt;，—&gt;.精度—&gt;类型123456#创建映射表，将字符"abcdef123"一一对应地转换为"uvwxyz@#$"&gt;&gt;&gt; table = ''.maketrans('abcdef123', 'uvwxyz@#$')&gt;&gt;&gt; s = "Python is a greate programming language. I like it!"#按映射表进行替换&gt;&gt;&gt; s.translate(table)'Python is u gryuty progrumming lunguugy. I liky it!'正则表达式正则表达式使用某种预定义的模式去匹配一类具有共同特 征的字符串，主要用于处理字符串，可以快速、准确地完 成复杂的查找、替换等处理要求，在文本编辑与处理、网 页爬虫之类的场合中有重要应用。函数的设计和使用首先了解到Python变量名和它的值是一个类似字典的键值对关系，不同的命名空间可以看作不同的字典，我们在使用变量的时候调用规则是LEGB规则，查找使用一个变量，顺序为L-E-G-B，可以理解顺序查找这几个字典中有没有我们使用的变量名，有则调出使用该变量名映射的值，没有则按照顺序向上一级寻找，除非声明global或者noglobal，这样我们就将这个变量声明到了global或者noglobal字典中，同时调用Python面向对象程序设计&lt;一&gt;基础概念类(Class)是用来描述具有相同属性(Attribute)和方法(Method)对象的集合。属性(Attribute): 类里面用于描述所有对象共同特征的变量或数据。比如学生的名字和分数。方法(Method): 类里面的函数，用来区别类外面的函数, 用来实现某些功能。比如打印出学生的名字和分数。创建类时用变量形式表示的对象属性称为数据成员，用函数形式表示 的对象行为称为成员方法，成员属性和成员方法统称为类的成员。属性是指一种从现实中抽象出来的某种事物的属性，但是实现在变量和函数上&lt;二&gt;python面向对象语法中的特别点1、pass关键字Python提供了一个关键字“pass”，类似于空语句，可以 用在类和函数的定义中或者选择结构中。当暂时没有确定 如何实现功能，或者为以后的软件升级预留空间，或者其 他类型功能时，可以使用该关键字来“占位”。因为python中没有大括号来区别各种结构，所有我们只能使用pass来代表空结构2、构造函数构造函数名称均为__init__3、 self参数和cls参数self表示一个具体的实例本身cls表示这个类本身类的所有实例方法都必须至少有一个名为self的参数，并且必须是方法的第一个形参（如果有多个形参的话）， self参数代表将来要创建的对象本身。在外部通过对象调用对象方法时并不需要传递这个参数， 如果在外部通过类调用对象方法则需要显式为self参数传值。1234例如test1=Test()test1.testP()Test.testP(test1)4、类变量和实例变量的定义类变量：定义在类中且在函数体之外。类变量在所有的实例变量中是共享的类似于静态变量实例变量：定义在实例方法中的变量。一般的实例变量我们设置在构造函数里，当然也可以在其他函数体中创建实例变量的定义必须为sefl.变量名=，若直接使用变量名=则为函数内的局部变量，在类方法中定义的cls.变量名=是类变量访问实例变量也需要self.变量名5、实例方法和类方法和静态方法实例方法：只能通过实例对象调用，因为实例方法第一个定义的参数必须是实例对象本身self。类方法：定义类方法，要使用装饰器@classmethod，定义的第一个参数一般是cls，代表这个类本身，静态方法：定义静态方法使用装饰器@staticmethod，没有默认的必须参数，可以通过类和实例直接调用。self和cls是我们的默认名称比较统一，也可以使用其他名称，但是在python语言的特性下，是不过是我们表面上换了个名字而已类方法和静态方法区别:类方法自带参数cls代表本身类，而静态方法不带参数。所以在函数体中使用类的变量的区别就是类方法可以以cls调用这个类的属性，而静态方法需要以类名去调用，相当于是一个类外函数1234567891011121314151617181920class A(object): a = 'a' @staticmethod def foo1(name): print ('hello', name) print (A.a) # 正常 print (A().foo2('mamq')) def foo2(self, name): print ('hello', name) @classmethod def foo3(cls, name): print ('hello', name) print (A.a) print (cls().foo2(name))A.foo1("lyxf")A.foo3("lyxf")输出结果相同由于python的特性其中中没有public、static 这样的修饰符，所以我们才用了@classmethod修饰器来表示参考文章:python中的cls到底指的是什么，与self有什么区别?6、可动态为自定义类和对象增加或者删除成员动态添加对象属性针对对象动态添加的属性，是绑定在该对象身上的，在同类其他对象上是没有的的。动态添加类属性针对类动态添加的属性，可以增添到使用到所有的该类创建的对象上由于动态语言的特性，哪怕你是后添加的类属性，之前创建的对象也会增加新的类属性动态添加对象行为如果直接添加，调用的时候需要将本身的对象作为参数传入12345678class Demo: passt = Demo()def test(self,a): print(a)t.test=testt.test(t,3)#结果为输出3而特殊的12345678class Demo: passt = Demo()def test(a): print(a)t.test=testt.test(3)#结果为输出3虽然可执行，但是是因为我们没有使用self，如果增加一个函数中定义实例变量就必须使用self，而且这样也不符合类中的定义方法的习惯所以一般不要使用而我们想不传入对象参数，可以使用types模块的MethodTpye功能12345678910import typesclass Demo: passt = Demo()def test(self,a): self.value=a print(self.value)t.test=types.MethodType(test,t)t.test(3)#结果为输出3因为在Python中，函数和方法是有区别的。方法一般指与特定 实例绑定的函数，通过对象调用方法时，对象本身将被作为第一个参数隐式传递过去，普通函数并不具备这个特点。如果我们只是使用‘=’,根据python的特点，我们使用的依旧是函数，但是我们通过MethodTpye功能可以生成一个绑定了对象的方法，这样才真正动态为对象添加了一个方法动态添加类行为同理我们为类动态添加行为1234567891011import typesclass Demo: passt = Demo()def test(cls,a): cls.value=a print(cls.value)Demo.test=types.MethodType(test,Demo)Demo.test(3)t.test(3)#输出为两行3，动态增加了类方法而使用del 可以动态删除类中或者对象的各种属性123例如：del Test.ddel Test.func注意方法只能通过类名+方法名删除，不能通过对象删除，实例变量只能通过对象删除7、私有成员、保护成员与公有成员类里面的私有属性和私有方法以双下划线__开头。私有属性或方法不能在类的外部被使用或直接访问。类里面的保护属性和保护方法以单下划线_开头。不能用于 from module import *公有成员则不加下划线这里特别指出两边都加双下划线是一些特殊函数，如构造函数、析构函数等注意：保护成员可以直接修改123456789101112131415161718class Test: __a="类私有" _b="类保护" d="类公有" def __init__(self): self._c = "实例保护" def __testPrivate(self): print(self.d) t1=Test()print(t1._c)print(Test._b)t1._c="实例保护更改"print(t1._c)#输出为#实例保护#类保护#实例保护更改推荐阅读:Python中的单下划线和双下划线使用场景9、Python中不存在严格意义上的私有成员对象外部可以通过“对象名._类名__xxx”这样 的特殊方式来访问1234567891011121314class Test: __a="类私有" _b="类保护" d="类公有" def __init__(self): self._c = "实例保护" self.__d="实例私有"t=Test()print(Test._Test__a)#这里使用对象名._类名__xxx代表通过t使用类私有变量，若为类名._类名__xxx则代表通过类使用类私有变量print(t._Test__d)#输出为#类私有#实例私有可以理解为Python私有保护机制只是识别后给我们内部“改了名”,在前面增加了单下划线+类名，同理可以使用对象名._类名xxx直接调用私有方法10、property的使用完善封装机制(1)@property和setter、getter修饰器建议阅读：@property(2)property函数建议阅读：property函数12345678910111213141516171819202122class Test: def __init__(self, value): self.__value = value def __get(self): return self.__value def __set(self, v): self.__value = v def __del(self): del self.__value value = property(__get, __set,__del) def show(self): print(self.__value)t=Test(5)t.show()t.value=10t.show()print(t.value)del t.value#输出为#5#10#10修改、读取、删除，需要几种对值的权限操作就在property函数相应顺序（读-&gt;写-&gt;删）放置对应函数我们要理解,使用get，set方法，而不是直接赋值，是因为能在方法中进行各种设值的限制，因为python的特性，动态添加和修改可以修改成任意类型任意大小的值，很容易出错，使用方法可以通过控制语句在其中添加限制条件，选择出符合要求的值进行添加。而property的使用使得这个方法能够想变量一样简单使用&lt;三&gt;常用特殊方法值得注意的是运算符重载就是通过重写特殊方法实现的&lt;四&gt;继承和多态机制1、定义继承类1234567class TestParent: def __init__(self,name): self.name=nameclass Test(TestParent): passtest=Test("parent")print(test.name)在定义的类名后加括号依次写入父类，Python支持多继承2、多态实现根据继承特性:私有成员不会被继承公有成员会被继承，在子类中重写父类的方法，调用子类的对象时会使用重写的方法若子类无构造函数则继承父类构造函数，若有则使用该构造函数而不使用父类的如果需要在派生类中调用基类的方法，可以使用内置函数 super()或者通过“基类名.方法名()”的方式来实现这一目的。。3、多继承机制如果父类中有相同的方法名，而在子类中使用时 没有指定父类名，则Python解释器将从左向右按顺序进行搜索，找到第一个后边不再向后解析在Python 3.x的多继承树中，如果在中间层某类有向上一 层解析的迹象，则会先把本层右侧的其他类方法解析完， 然后从本层最后一个解析的类方法中直接进入上一层并继 续解析，也就是在从子类到超类的反向树中按广度优先解析]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构【四】:特殊数组（C++）]]></title>
    <url>%2Fposts%2Ff2953b2%2F</url>
    <content type="text"><![CDATA[四、串4.1串的顺序存储方式C语言中是方案三王道书中是方案四方案二缺点：用char表示数字，char只有1B，只能表示0-255方案四和方案一中都是多申请一个int元素（在一个结构体中，所以存储也紧随其后）4.2串的链式存储方式char：1B指针：4B存储密度低4.3朴素模式匹配算法其实就是对于主串，按照模式串的长度，从前往后挨个划分为n-m+1 个⼦串，然后挨个匹配。也就是返回子串下标Index中的算法最坏的情况，每个⼦串都要对⽐ m 个字符，共 n-m+1 个⼦串，复杂度 = O((n-m+1)m) = O(nm)最好的情况，每个⼦串的第⼀个字符就匹配失败，共 n-m+1 个⼦串，复杂度 = O(n-m+1) = O(n)4.4KMP算法KMP算法时间复杂度：O(m+n)==KMP算法的核心思想，就是发现在某个位置不匹配后，利用已经读取的部分，看看其中是否蕴含着可匹配的部分，这样我们接着匹配，就不用每次都倒回去了====而且可以知道，这种性质之和匹配串，即模式串内容有关。求出在某个位置不匹配后，模式串指针回退到哪儿形成数组，则是算法关键。==KMP算法最大的特点就是主串的指针不回溯！i：指向主串Tj：指向模式串S讲解： 开始的时候我们匹配到第6位发现不匹配，这个时候我们发现，我们已经读入的T[4]=a和T[5]=b，是和S[1]S[2]是匹配的，我们不用重新开始匹配了，i指针不动，j指向3继续找就行。大体就是这个意思。求next数组==next[1]都⽆脑写 0====next[2]都⽆脑写 1====其他 next：在不匹配的位置前，划⼀根美丽的分界线模式串⼀步⼀步往后退，直到分界线之前“能对上”，或模式串====完全跨过分界线为⽌。此时 j 指向哪⼉，next数组值就是多少==例如：我做的时候，例如上面第6个不匹配了，心理默念abab，从之前匹配的串里的第二个开始匹配，往后推，然后发现第三个aba能匹配，然后看看原来的第六个下边是模式串的第几个。next改进成nextval问题：我们是在第四个发现不匹配的，即当前字符不和g匹配，我们通过next数组使j跳到1，但是我们发现1本身就是指向g！不匹配，又依据算法指向0，然后后i、j后移。我们其实是可以避免这种无意义的对比的。算法：==第一个默认nextval是0====从左往右，对每个序号中的next[j]指向查看，若指向的字符和当前字符一致，则把当前的next[j]修改为next[j]的next[j]==注：一定是从左往右，这样才能依次最优更新。从右往左不是最优的，甚至得依次找到最左的检验到最优。例：之后使用的数组就用nextval就好多维数组多维数组的地址计算:https://blog.csdn.net/jinaoasher/article/details/78637689特殊矩阵对称矩阵的压缩矩阵Array[i*(i+1)/2+j] = Martix([i])([j])(下三角存储i&gt;=j)Array[i*(2n-i-1)/2+j] = Martix([i])([j])(上三角存储i&gt;=j)上三角地址=（2n-i+1）* i/2+j-i=i*(2n-i-1)/2+j123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;using namespace std;template &lt;class T&gt;class SymmetryMatrix&#123; public: SymmetryMatrix(T **a,int n); //动态创建一维数组储存下三角数据 T Access(int i,int j); //给定元素位置通过一位数组访问该数据 void display(); //输出该对称矩阵 protected: T *data; int size; &#125;;template &lt;class T&gt;SymmetryMatrix&lt;T&gt;::SymmetryMatrix(T **a,int n)&#123; int i,j,t=0; size=n; data=new T[n*(n+1)/2]; for(i=0;i&lt;n;i++) for(j=0;j&lt;=i;j++) &#123; data[t++]=a[i][j]; &#125;&#125;template &lt;class T&gt;T SymmetryMatrix&lt;T&gt;::Access(int i,int j)&#123; i-=1; j-=1; if(i&gt;=j) return data[i*(i+1)/2+j]; else return data[j*(j+1)/2+i];&#125;template &lt;class T&gt;void SymmetryMatrix&lt;T&gt;::display()&#123; int i,j; for(i=1;i&lt;=size;i++) &#123; for(j=1;j&lt;=size;j++) &#123; cout&lt;&lt; Access(i,j)&lt;&lt;" "; &#125; cout&lt;&lt;endl; &#125;&#125;int main()&#123; int n,i,j; cout&lt;&lt;"请输入矩阵大小："; cin&gt;&gt;n; int **a=new int*[n]; for(i=0;i&lt;n;i++) a[i]=new int[n]; cout&lt;&lt;"请输入矩阵："&lt;&lt;endl; for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++) cin&gt;&gt;a[i][j]; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;n;j++) cout&lt;&lt;a[i][j]; cout&lt;&lt;endl; &#125; SymmetryMatrix&lt;int&gt; test(a,n); test.display(); test.Access(2,3);&#125;t动态分配二维数组:https://blog.csdn.net/KYJL888/article/details/77846122二维数组作为参数传递：https://blog.csdn.net/kangxidagege/article/details/79475537稀疏矩阵的压缩矩阵（三元组）和转置稀疏矩阵的普通转置与快速转置算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include&lt;iostream&gt;using namespace std;const int defaultSize=10;template &lt;class T&gt;struct Triple&#123; int row,col; //记录该元素的行列值 T data; //记录该元素的值 &#125;;template &lt;class T&gt;class Matrix&#123; public: Matrix(int size=defaultSize); void input(); void outputAsMatrix(); //矩阵形式输出 void output(); Matrix&lt;T&gt; transpose(); Matrix&lt;T&gt; quickTranspose(); protected: Triple&lt;T&gt; *Array; //三元组 int maxSize; //三元组储存的数据的个数 int row,col; //原矩阵行列数 ，避免产生如最后几行全为0，三元组不输入，误判数组少了几行 int notZero; //记录非0元素个数 &#125;;template &lt;class T&gt;Matrix&lt;T&gt;::Matrix(int size) &#123; maxSize=size; Array=new Triple&lt;T&gt; [size]; row=col=0;&#125;template &lt;class T&gt;Matrix&lt;T&gt; Matrix&lt;T&gt;::quickTranspose()&#123; Matrix&lt;T&gt; B(maxSize); //四步创建除了转置三元组外配置完成的稀疏矩阵类 B.col=row; B.row=col; B.notZero=notZero; if(notZero&gt;0) //只有非0元素大于0才进行下面转置操作 &#123; int *num1=new int[col]; //第一个数组记录每个列的非0元素个数 int *num2=new int[col]; //第二个数组记录每个列的第一个非0元素存放在顺序表中第几个位置 for(int i=0;i&lt;col;i++) &#123; num1[i]=0; //初始化0 &#125; for(int i=0;i&lt;notZero;i++) &#123; num1[Array[i].col]++; //利用三元组矩阵元素的列值作为数组的下标直接计算非0元素 &#125; num2[0]=0; //初始化第一个元素为0 for(int i=1;i&lt;col;i++) &#123; num2[i]=num1[i-1]+num2[i-1]; //第i列的第一个非0元素存放位置是上一列的非0元素位置加这一列的非0元素个数； &#125; int t; //储存非0元素所在列数 for(int i=0;i&lt;notZero;i++) &#123; t=num2[Array[i].col]; //********直接利用三元组数组排序号的列调用储存第i列的非0元素初始位置,画图分析更容易********// B.Array[t].col=Array[i].row; B.Array[t].row=Array[i].col; B.Array[t].data=Array[i].data; num2[Array[i].col]++; &#125; delete []num1; delete []num2; return B; &#125; &#125;template &lt;class T&gt;void Matrix&lt;T&gt;::input()&#123; cout&lt;&lt;"输入原矩阵行、列、非零元素个数"; cin&gt;&gt;row&gt;&gt;col&gt;&gt;notZero; cout&lt;&lt;"按顺序输入全部非零元素的行、列、值"&lt;&lt;endl; for(int i=0;i&lt;notZero;i++) cin&gt;&gt;Array[i].row&gt;&gt;Array[i].col&gt;&gt;Array[i].data;&#125;template &lt;class T&gt;void Matrix&lt;T&gt;::output()&#123; cout&lt;&lt;"原矩阵为"&lt;&lt;row&lt;&lt;"行"&lt;&lt;col&lt;&lt;"列"&lt;&lt;notZero&lt;&lt;"个非0元素"&lt;&lt;endl ; for(int i=0;i&lt;notZero;i++) cout&lt;&lt;"Array["&lt;&lt;Array[i].row&lt;&lt;"]"&lt;&lt;"["&lt;&lt;Array[i].col&lt;&lt;"]"&lt;&lt;"="&lt;&lt;Array[i].data&lt;&lt;endl;&#125;template &lt;class T&gt;Matrix&lt;T&gt; Matrix&lt;T&gt;::transpose()&#123; Matrix&lt;T&gt; Trans(maxSize); Trans.col=col; Trans.row=row; Trans.notZero=notZero; int t=1,i,j; for(i=1;i&lt;=col;i++) //列是从小到大排列好的，按列从小到大查询 &#123; for(j=1;j&lt;=notZero;j++) // 每一列都在三元组中遍历查询，从小到大移动到新三元组中 这样重复col次 将全部数据移动完毕 &#123; if(i==Array[j-1].col) &#123; Trans.Array[t-1].col=Array[j-1].row; Trans.Array[t-1].row=Array[j-1].col; Trans.Array[t-1].data=Array[j-1].data; t++; &#125; &#125; if(t&gt;notZero) //转置以经结束，后面可以直接结束了，节省时间 break; &#125; return Trans;&#125;template &lt;class T&gt;void Matrix&lt;T&gt;::outputAsMatrix()&#123; cout&lt;&lt;"储存的矩阵为:"&lt;&lt;endl; int i,j,t=1; for(i=1;i&lt;=row;i++) &#123; for(j=1;j&lt;=col;j++) &#123; if(t&lt;=notZero) &#123; if(Array[t-1].row==i&amp;&amp;Array[t-1].col==j) &#123; cout&lt;&lt;Array[t-1].data&lt;&lt;" "; t++; &#125; else cout&lt;&lt;"0 "; &#125; else cout&lt;&lt;"0 "; &#125; cout&lt;&lt;endl; &#125;&#125;int main()&#123; Matrix&lt;int&gt; test; test.input(); test.output(); test.outputAsMatrix(); test.transpose().outputAsMatrix(); test.quickTranspose().output();&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构【三】:栈和队列（C++）]]></title>
    <url>%2Fposts%2F633c73aa%2F</url>
    <content type="text"><![CDATA[一些题型技巧总结3.1判断输出序列合法性在看到输出序列的某一个元素的时候，意味着其前面的输入元素已经进入栈或者其他数据结构了。进而其前面元素输出的顺序就一定了。例如：输入1、2、3、4输出序列：3、1、2、4我们看到3，说明1、2已经输入了。在栈中后面的输出必定是2在1前面。所以3、1、2、4不对，3、1、4、2这种1在2前面出来的都不对。其他数据结构：输出受限的双端队列由于只有一个删除方向，所以根据给出的输出队列，再根据只有一个删除方向的特点，反推此时应该具有何种序列在数据结构中。再思考如何通过两个方向的插入凑出这个序列。输入受限的双端队列由于只有一个插入方向，所以类似于栈，看见了一个后进的元素，说明前面的元素的位置已经固定了。主要需要的思考就是如何根据两边删除凑出给出的输出序列。3.2中缀表达式转后缀表达式（手算）确定中缀表达式中各个运算符的运算顺序选择下一个运算符，按照「左操作数右操作数运算符」的方式组合成一个新的操作数如果还有运算符没被处理，就继续②注：运算顺序不唯一，因此对应的后缀表达式也不唯一，例如：所以“左优先”原则去做题！3.2中缀表达式转前缀表达式（手算）① 确定中缀表达式中各个运算符的运算顺序② 选择下一个运算符，按照「运算符 左操作数 右操作数」的方式组合成一个新的操作数③ 如果还有运算符没被处理，就继续 ②“右优先”原则：只要右边的运算符能先计算，就优先算 右边 的3.4后缀表达式的计算（机算）①从左往右扫描下一个元素，直到处理完所有元素②若扫描到操作数则压入栈，并回到①；否则执行③③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①注意：先出栈的是“右操作数”若表达式合法，则最后栈中只会留下一个元素，就是最终结果3.5前缀表达式的计算（机算）①从右往左扫描下一个元素，直到处理完所有元素②若扫描到操作数则压入栈，并回到①；否则执行③③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①注意：先出栈的是“左操作数”本质上理解还是一个从左往右扫描，一个从右往左扫描，才导致了差异。3.6中缀表达式转后缀表达式（机算）初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。从左到右处理各个元素，直到末尾。可能遇到三种情况：① 遇到操作数。直接加入后缀表达式。② 遇到界限符。遇到“(”直接入栈；遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到弹出“(”为止。注意：“(”不加入后缀表达式。③ 遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“(” 或栈空则停止。之后再把当前运算符入栈。按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。解释一下③：为何中缀表达式中的运算符，只能依靠判断栈中优先级高于或等于当前运算符的所有运算符，才加入后缀表达式？因为我们不知道当前的运算符能否先执行，即计算机不能从整体知道运算优先级顺序。当我们当前碰到一个运算符，栈中的运算符是比他优先级高的，或者等同优先级的，这才说明运算顺序可以在本运算符之前，故弹出。但是本运算符却不能弹出，只能等它们弹出后进栈，因为它不知道后面的情况，它得等读取后面的符号来决定本身是否能弹出运算。为什么优先级相等可以？因为我们是从左到右扫描，相邻的运算符直接必定有一个”操作数”（可以是整体例如a*b先算了），而这个”操作数”既要进行同级的A运算又要进行同级的B运算。根据左优先原则，可以让前面先计算。而读取一个运算符，发现栈中的运算符比它优先级还小，那就更不用说了，它们肯定不能先于本运算符计算，不能弹出。其实核心就在于，怕后面的尚未读取的部分出现了比当前运算符高的算符，按照当前顺序计算是错误的。因为同级先算无所谓，后面出现的是低级的更是应该。解释一下②很简单，左括号是最高优先级，不需要判断栈里面有比它高或者同级的运算符来出栈，直接入栈。之后按照正常的运行，因为括号中的式子，可以看做独立的另一个表达式。遇到右括号，把左括号之后的运算符全部弹出。不必担心优先级问题，因为中途我们都是按照规则把其中的式子看成独立的另一个表达式。这个时候可以人为，这就是一个表达式扫描完毕了，左括号之后的运算符可以看作是算法中一个式子最后剩下的运算符。注意：中缀表达式转后缀表达式（机算）中，栈用来保存暂时还不能确定运算顺序的运算符。后缀表达式的计算（机算）中，栈用来保存暂时还不能确定运算顺序的操作数。3.7中缀表达式的计算（用栈实现）其实就是中缀转后缀+后缀表达式求值两个算法的结合用栈实现中缀表达式的计算：初始化两个栈，操作数栈和运算符栈若扫描到操作数，压入操作数栈若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈）3.8压缩矩阵（关于数组地址计算）==从存储空间理解：就是计算，初始地址+（存储个数-1）×每个大小====无论是一维还是二维，都是如此！==初始地址其实就是a0或者a00的地址从数组理解（一维0开始，二维00开始）：一维：初始地址+数组下标×每个大小b[M] [N] 中二维行优先：b[i] [j] 的存储地址 = LOC + (i*N + j) * sizeof(ElemType)b[M] [N] 中二维列优先：b[i] [j] 的存储地址 = LOC + ( j*M+ i ) * sizeof(ElemType)非0开始或者非00开始：==转为0或者00再用公式！==例如二维行优先10开始的b[i] [j] 的存储地址 = LOC + ((i-1)*N + j) * sizeof(ElemType)(1)对称矩阵核心思路：根据抽象的模型算出第几个，再根据题目给出的数组起始，算地址。若为0或者00初始，直接算前面有几个元素即可==实际-&gt;数组的转换==按照下三角行优先存怎么算？只存储主对角线+下三角区①数组大小应为多少?等差数列求和： (1+n)*n/2②站在程序员的角度，对称矩阵压缩存储后怎样才能方便使用？可以实现一个“映射”函数矩阵下标-&gt;一维数组下标注意：数组下标是从0到【(1+n)*n/2】-1，即存储个数-1而计算ai,j在数组中的下标，就是计算ai,j是第几个元素，然后-1，或者说就是计算ai,j前面有几个元素！根据对阵矩阵的性质，访问上三角转化为下三角就行：按照下三角列优先存怎么算？==①求aij前面有几个元素====对于j列之前的==，每列：n-j+1个第1列到第j-1列求和：(j-1)(2n-j+2)/2==对于第j列，在aij前面==有：i-j个前面总共有：(j-1)(2n-j+2)/2+i-j个aij是第(j-1)(2n-j+2)/2+i-j+1个元素==②这就是数组下标，对于对称转换，把i和j互换即可。==按照上三角行优先存怎么算？从另一个角度看：上三角行优先就是，下三角列优先的对称形式！所以把下三角列优先的ij互换即可得到。当然按照思路算也一样。前面总共有：(i-1)(2n-i+2)/2+j-i个aij是第(i-1)(2n-i+2)/2+j-i+1个元素按照上三角列优先存怎么算？同理，上三角列优先就是，下三角行优先的对称形式！前面总共有：j(j-1)/2+i-1个aij是第j(j-1)/2+i个元素(2)三角矩阵==存储方法和对称矩阵雷同，就是最后多一个存储单元放对面三角区域内相同的元素C==下三角矩阵上三角矩阵三对角矩阵有几个元素？显然，除了第一行和最后一行为2个比其他行少1个，其他均为三个。一共n行，故为3n-2个。数组起始为0，终止为3n-3其他地方元素和下标的特点？==|i - j|&gt;1 时，aij为0====|i - j|≤1时==,aij为第几个元素？==前i-1行共 3(i-1)-1 个元素====aij是 i 行第 j-i+2 个元素====aij是第 2i+j-2 个元素==如何实现矩阵下标到数组下标的映射？==根据上述，数组下标为0开始的时候下标为k = 2i+j-3==反过来，如何实现数组下标到矩阵下标的映射？==算出来i了之后根据k = 2i+j-3就能得到i 的值==思路就是先求k应该在第几行，得到i，在根据i和k和关系式得到j(3)稀疏矩阵三元组法失去了随机存储特性，只能顺序扫描。十字链表法向右域就是每一行的元素整成一串。向下域就是每一列的元素整成一串。顺序栈123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;iostream&gt;using namespace std;const int stackIncreament=20; //栈满时增加空间大小 template&lt;class T&gt;class Stack&#123; public: Stack(int num); //构造函数 产生数据空间为num的栈 ~Stack()&#123;delete []data;&#125;; //析构函数 void push(T &amp;x); //将数据x压栈 bool pop(T &amp;x); //将顶端数据出栈 bool getTop(T &amp;x); //只是获取顶端数据 bool isEmpty()const; //判空函数 bool isFull()const; //判满函数 int getSize()const; //获取栈中元素个数 void makeEmpty()&#123;top=-1;&#125;; //置空栈 void output(); //输出 protected: T *data; int maxSize; int top; void overflowProcess();&#125; ;template&lt;class T&gt;Stack&lt;T&gt;::Stack(int num)&#123; top=num; data=new T[top--]; if(data==NULL) &#123; cerr&lt;&lt;"申请空间失败"; exit(1); &#125; for(int i=0;i&lt;=top;i++) cin&gt;&gt;data[i];&#125;template&lt;class T&gt;void Stack&lt;T&gt;::push(T &amp;x)&#123; if(isFull()) //判满设置 overflowProcess(); //扩容设置 data[++top]=x;&#125;template&lt;class T&gt;void Stack&lt;T&gt;::overflowProcess()&#123; T *newData=new T[maxSize+stackIncreament]; if(newData==NULL) &#123; cerr&lt;&lt;"申请空间失败"; exit(1); &#125; for(int i=0;i&lt;=top;i++) newData[i]=data[i]; maxSize+=stackIncreament; delete []data; data=newData;&#125;template&lt;class T&gt;bool Stack&lt;T&gt;::pop(T &amp;x)&#123; if(isEmpty()) return false; x=data[top--]; return true; &#125; template&lt;class T&gt;bool Stack&lt;T&gt;::getTop(T &amp;x)&#123; if(isEmpty()) return false; x=data[top]; return true;&#125;template&lt;class T&gt;bool Stack&lt;T&gt;::isFull()const&#123; if(top==maxSize-1) //注意判满条件 return true; else return false; &#125;template&lt;class T&gt;bool Stack&lt;T&gt;::isEmpty()const&#123; if(top==-1) return true; else return false;&#125;template&lt;class T&gt;int Stack&lt;T&gt;::getSize()const&#123; return top+1;&#125;template&lt;class T&gt;void Stack&lt;T&gt;::output()&#123; int i; for( i=top;i&gt;0;i--) cout&lt;&lt;data[i]&lt;&lt;","; cout&lt;&lt;data[i]&lt;&lt;endl;&#125;int main()&#123; int num; cout&lt;&lt;"输入数据个数"; cin&gt;&gt;num; Stack&lt;int&gt; test(num); test.output(); cout&lt;&lt;"输入扩充数据"; cin&gt;&gt;num; test.push(num); test.output(); test.pop(num); test.output();&#125;/*1、压栈的时候注意判满扩容设置 */顺序双栈头和位同时存储数据，向中间靠拢。链栈（带头节点）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;iostream&gt;using namespace std;template &lt;class T&gt;struct LinkNode&#123; T data; LinkNode&lt;T&gt; *next=NULL; LinkNode() &#123; next=NULL; &#125; LinkNode(T x) &#123; data=x; &#125;; LinkNode(LinkNode&lt;T&gt; *p) &#123; next=p; &#125; LinkNode(T x,LinkNode&lt;T&gt; *p) &#123; data=x; next=p; &#125;&#125;;template &lt;class T&gt;class Stack&#123; public: Stack(); //构造函数 ~Stack()&#123;makeEmpty();&#125;; //析构函数 void push(T &amp;x); //将数据x压栈 bool pop(T &amp;x); //将顶端数据出栈 bool getTop(T &amp;x); //只是获取顶端数据 bool isEmpty()const; //判空函数 int getSize()const; //获取栈中元素个数 void makeEmpty(); //置空栈 void output(); //输出 protected: LinkNode&lt;T&gt; *head;&#125;;template&lt;class T&gt;Stack&lt;T&gt;::Stack()&#123; head=new LinkNode&lt;T&gt;;&#125;template&lt;class T&gt;void Stack&lt;T&gt;::push(T &amp;x)&#123; LinkNode&lt;T&gt; *newNode=new LinkNode&lt;T&gt;(x); //使用前插法构建 if(newNode==NULL) &#123; cerr&lt;&lt;"储存分配错误"&lt;&lt;endl; exit(1); &#125; newNode-&gt;next=head-&gt;next; head-&gt;next=newNode;&#125;template&lt;class T&gt;bool Stack&lt;T&gt;::isEmpty()const&#123; if(head-&gt;next==NULL) return true; else return false;&#125;template&lt;class T&gt;bool Stack&lt;T&gt;::pop(T &amp;x)&#123; LinkNode&lt;T&gt; *p; if(isEmpty()) return false; else &#123; p=head-&gt;next; x=p-&gt;data; head-&gt;next=p-&gt;next; delete p; return true; &#125; &#125; template&lt;class T&gt;bool Stack&lt;T&gt;::getTop(T &amp;x)&#123; if(isEmpty()) return false; x=head-&gt;next-&gt;data; return true;&#125;template&lt;class T&gt;int Stack&lt;T&gt;::getSize()const&#123; LinkNode&lt;T&gt; *p=head-&gt;next; int num=0; while(p!=NULL) &#123; num++; p=p-&gt;next; &#125; return num;&#125;template&lt;class T&gt;void Stack&lt;T&gt;::makeEmpty()&#123; LinkNode&lt;T&gt; *p=head-&gt;next; while(head-&gt;next!=NULL) &#123; head-&gt;next=p-&gt;next; delete p; p=head-&gt;next; &#125;&#125;template&lt;class T&gt;void Stack&lt;T&gt;::output()&#123; LinkNode&lt;T&gt; *p=head-&gt;next; while(p!=NULL) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;","; p=p-&gt;next; &#125;&#125;int main()&#123; int num,x; cout&lt;&lt;"输入数据个数"; cin&gt;&gt;num; Stack&lt;int&gt; test; while(num--) &#123; cin&gt;&gt;x; test.push(x); &#125; test.output(); test.pop(x); cout&lt;&lt;x&lt;&lt;endl; test.pop(x); test.pop(x); cout&lt;&lt;test.getSize(); test.output();&#125;/*//使用前插法构建栈*/顺序（循环）队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;iostream&gt;using namespace std;template &lt;class T&gt;class Queue&#123; public: Queue(int size); //构造函数 ~Queue()&#123;delete []data;&#125;; //析构函数 bool enQueue(T &amp;x); //入队函数 bool deQueue(T &amp;x); //出队函数 bool getFront(T &amp;x); //获取队头的元素函数 void makeEmpty(); //置空 bool isEmpty()const; //判空 bool isFull()const; //判满 int getSize()const; //获取队列元素数量 protected: T *data; int front,rear; int maxSize;&#125;;template&lt;class T&gt;Queue&lt;T&gt;::Queue(int size)&#123; maxSize=size+1; //因为需要空出一个作为判断空满状态的空间 data=new T[size]; front=rear=0;&#125;template&lt;class T&gt;bool Queue&lt;T&gt;::isEmpty()const&#123; if(rear==front) //注意判空条件 return true; else return false;&#125;template&lt;class T&gt;bool Queue&lt;T&gt;::isFull()const&#123; if((rear+1)%maxSize==front) //注意判满条件 return true; else return false;&#125;template&lt;class T&gt;int Queue&lt;T&gt;::getSize()const&#123; return (rear-front+maxSize)%maxSize; //注意队列长度如何计算 &#125; template&lt;class T&gt;bool Queue&lt;T&gt;::enQueue(T &amp;x)&#123; if(isFull()) return false; else &#123; data[rear]=x; rear=(rear+1)%maxSize; //注意每次进数后 rear+1 并且求余数 return true; &#125;&#125; template&lt;class T&gt;bool Queue&lt;T&gt;::deQueue(T &amp;x)&#123; if(isEmpty()) return false; x=data[front]; front=(front+1)%maxSize; //注意每次取数后 rear+1 并且求余数 return true; &#125; template&lt;class T&gt;bool Queue&lt;T&gt;::getFront(T &amp;x)&#123; if(isEmpty()) return false; x=data[front]; return true; &#125;template&lt;class T&gt;void Queue&lt;T&gt;::makeEmpty()&#123; front=rear=0;&#125;int main()&#123; int num,x; Queue&lt;int&gt; test1(3); cout&lt;&lt;"输入需要的数据数量"; cin&gt;&gt;num; for(int i=0;i&lt;num;i++) &#123; cin&gt;&gt;x; test1.enQueue(x); &#125; for(int i=0;i&lt;num;i++) &#123; if(test1.deQueue(x)) cout&lt;&lt;x&lt;&lt;","; &#125;&#125; /*1、顺序循环表的判空满有很多种方法，这里我们使用一种方法申请的空间中要有一个空间空出来，用来判断空满状态。 2、rear=front为空3、（rear+1）%maxSize==front 避免如:max=8,7+1!=0判为不满的情况4、入队列 每次都要rear=（rear+1）%maxSize，保存下标在范围内循环5、同理，出队列每次也要front=（front+1）%maxSize6、计算队列长为（rear-front+maxSize）%maxSize，避免负数计算错误*/1、顺序循环表的判空满有很多种方法，这里我们使用一种方法申请的空间中要有一个空间空出来，用来判断空满状态。2、rear=front为空3、（rear+1）%maxSize==front 避免如:max=8,7+1!=0判为不满的情况4、入队列 每次都要rear=（rear+1）%maxSize，保存下标在范围内循环5、同理，出队列每次也要front=（front+1）%maxSize6、计算队列长为（rear-front+maxSize）%maxSize，避免负数计算错误链（循环）队列（带头节点）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include&lt;iostream&gt;using namespace std;template &lt;class T&gt;struct LinkNode&#123; T data; LinkNode *next; LinkNode() &#123; next=NULL; &#125; LinkNode(T x) &#123; data=x; &#125; LinkNode(LinkNode&lt;T&gt; *p) &#123; next=p; &#125; LinkNode(T x,LinkNode&lt;T&gt; *p) &#123; data=x; next=p; &#125; &#125;;template&lt;class T&gt;class Queue&#123; public: Queue(); //构造函数 ~Queue()&#123;makeEmpty();&#125;; //析构函数 bool enQueue(T &amp;x); //入队函数 bool deQueue(T &amp;x); //出队函数 bool getFront(T &amp;x); //获取队头的元素函数 void makeEmpty(); //置空 bool isEmpty()const; //判空 int getSize()const; //获取队列元素数量 void output(); protected: LinkNode&lt;T&gt; *head,*rear; //多定义一个rear,入队列时方便后续插入 &#125;;template&lt;class T&gt;Queue&lt;T&gt;::Queue()&#123; head=rear=new LinkNode&lt;T&gt;; head-&gt;next=head;&#125;template&lt;class T&gt;bool Queue&lt;T&gt;::isEmpty()const&#123; if(head-&gt;next==head) return true; else return false;&#125;template&lt;class T&gt;int Queue&lt;T&gt;::getSize()const&#123; LinkNode&lt;T&gt; *p=head-&gt;next; int num=0; while(p!=head) &#123; num++; p=p-&gt;next; &#125; return num;&#125;template&lt;class T&gt;bool Queue&lt;T&gt;::enQueue(T &amp;x)&#123; LinkNode&lt;T&gt; *newNode=new LinkNode&lt;T&gt;(x); if(newNode==NULL) &#123; cerr&lt;&lt;"申请空间失败"; exit(1); &#125; newNode-&gt;next=rear-&gt;next; rear-&gt;next=newNode; rear=newNode; //移动队尾 return true;&#125; template&lt;class T&gt;bool Queue&lt;T&gt;::deQueue(T &amp;x)&#123; LinkNode&lt;T&gt; *p; if(isEmpty()) return false; else &#123; p=head-&gt;next; x=p-&gt;data; head-&gt;next=p-&gt;next; delete p; return true; &#125; &#125;template&lt;class T&gt;bool Queue&lt;T&gt;::getFront(T &amp;x)&#123; if(isEmpty()) return false; x=head-&gt;next-&gt;data; return true;&#125; template&lt;class T&gt;void Queue&lt;T&gt;::makeEmpty()&#123; LinkNode&lt;T&gt; *p=head-&gt;next; while(head-&gt;next!=head) &#123; head-&gt;next=p-&gt;next; delete p; p=head-&gt;next; &#125;&#125;template&lt;class T&gt;void Queue&lt;T&gt;::output()&#123; LinkNode&lt;T&gt; *p=head-&gt;next; while(p!=head) &#123; cout&lt;&lt;p-&gt;data; p=p-&gt;next; &#125;&#125;int main()&#123; int num,x; Queue&lt;int&gt; test1; cout&lt;&lt;"输入需要的数据数量"; cin&gt;&gt;num; for(int i=0;i&lt;num;i++) &#123; cin&gt;&gt;x; test1.enQueue(x); &#125; test1.output(); for(int i=0;i&lt;num;i++) &#123; test1.deQueue(x); cout&lt;&lt;x&lt;&lt;","; &#125;&#125; /*1、因为是单向循环不是双向循环所以多定义一个rear,入队列时方便后续插入2、后插法创建队列*/1、因为是单向循环不是双向循环所以多定义一个rear,入队列时方便后续插入2、后插法创建队列]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构【二】:循环链表和双向链表(C++)]]></title>
    <url>%2Fposts%2Fbcf5a112%2F</url>
    <content type="text"><![CDATA[循环链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289#include&lt;iostream&gt;using namespace std;template&lt;class T&gt;struct LinkNode&#123; LinkNode *next=NULL; T data;&#125;;template&lt;class T&gt;class List &#123; public: List();//构造函数 List(const T&amp; x);//构造函数 List( List&lt;T&gt;&amp; L);//复制构造函数 ~List()&#123;makeEmpty();&#125;; void makeEmpty();//置空表 int getLength()const;//获取表长 LinkNode&lt;T&gt; *getHead()const&#123;return head;&#125;;//获取头节点地址 LinkNode&lt;T&gt; *Search(T x);// 查询含有数据x节点的地址 失败返回NULL LinkNode&lt;T&gt; *Locate(int i);// 查询第i个 数据的地址 失败返回NULL bool getData(int i,T&amp;x);//用x获取第i个数据 bool setData(int i,T &amp;x);//用x替换第i个位替上的数据 bool Insert(int i,T &amp;x);//在第i个元素后插入数据x bool Remove(int i,T &amp;x);//删除第i个数据并用x返回 bool isEmpyty()const; //判断表空 bool isFull()const ;//判断表满 void inputQianCha();//清空链表，输入结束标志，根据标志判断来输入数据 void inputHouCha();//清空链表，输入结束标志，根据标志判断来输入数据 void output();//输出 List&lt;T&gt;&amp;operator=(List&lt;T&gt; &amp;L); protected: LinkNode&lt;T&gt; *head; &#125;;template &lt;class T&gt;List&lt;T&gt;::List()&#123; head=new LinkNode&lt;T&gt;; head-&gt;next=head; //增加 &#125;template &lt;class T&gt;List&lt;T&gt;::List(const T&amp; x)&#123; head=new LinkNode&lt;T&gt;(x); head-&gt;next=head; //增加 &#125;template &lt;class T&gt;List&lt;T&gt;::List(List&lt;T&gt;&amp; L)&#123; LinkNode&lt;T&gt; *p1,*p2,*newNode,*Lhead; p1=L.getHead()-&gt;next; Lhead=L.getHead(); //增加 p2=head=new LinkNode&lt;T&gt;; //p2=head=new LinkNode&lt;T&gt;;必须要有 new LinkNode&lt;T&gt;，因为此时head还没有构造出来。 while(p1!=Lhead) &#123; newNode=new LinkNode&lt;T&gt;; newNode-&gt;data=p1-&gt;data; p2-&gt;next=newNode; p2=newNode; p1=p1-&gt;next; &#125; p2-&gt;next=head; //增加 &#125;template &lt;class T&gt;void List&lt;T&gt;::makeEmpty()&#123; LinkNode&lt;T&gt; *p=head-&gt;next; while(head-&gt;next!=head) //改变 &#123; head-&gt;next=p-&gt;next; delete p; p=head-&gt;next; &#125;&#125;template &lt;class T&gt;int List&lt;T&gt;::getLength()const&#123; LinkNode&lt;T&gt; *p=head-&gt;next; int num=0; while(p!=head) //改变 &#123; num++; p=p-&gt;next; &#125; return num;&#125;template &lt;class T&gt;LinkNode&lt;T&gt;* List&lt;T&gt;::Search(T x)&#123; LinkNode&lt;T&gt; *p=head-&gt;next; while(p!=head) //修改 &#123; if(p-&gt;data==x) return p; p=p-&gt;next; &#125; return NULL; //修改为NULL，因为循环链表最后元素的下一个指向为head. &#125; template &lt;class T&gt;LinkNode&lt;T&gt;* List&lt;T&gt;::Locate(int i)&#123; if(i&lt;=0) return NULL; int num=1; LinkNode&lt;T&gt; *p=head-&gt;next; while(i!=num&amp;&amp;p!=head) //修改 &#123; num++; p=p-&gt;next; &#125; if(p==head) return NULL; //添加为NULL，因为循环链表最后元素的下一个指向为head. 没找到必须返回NULL else return p;&#125;template &lt;class T&gt;bool List&lt;T&gt;::getData(int i,T&amp;x)&#123; LinkNode&lt;T&gt; *p=Locate(i); if(p==NULL) return false; else &#123; x=p-&gt;data; return true; &#125;&#125;template &lt;class T&gt;bool List&lt;T&gt;::setData(int i,T &amp;x)&#123; LinkNode&lt;T&gt; *p=Locate(i); if(p==NULL) return false; else &#123; p-&gt;data=x; return true; &#125;&#125;template &lt;class T&gt;bool List&lt;T&gt;::Insert(int i,T &amp;x)&#123; LinkNode&lt;T&gt; *p1=Locate(i),*p2; if(p1==NULL) return false; else &#123; p2=new LinkNode&lt;T&gt;(x); if(p2==NULL) &#123; cerr&lt;&lt;"储存分配错误"&lt;&lt;endl; exit(1); &#125; p2-&gt;next=p1-&gt;next; p1-&gt;next=p2; return true; &#125;&#125;template &lt;class T&gt;bool List&lt;T&gt;::Remove(int i,T &amp;x)&#123; LinkNode&lt;T&gt; *p1=Locate(i-1),*p2; if(p1==NULL||p1-&gt;next==head) //修改 return false; else &#123; p2=p1-&gt;next; p1-&gt;next=p2-&gt;next; x=p2-&gt;data; delete p2; return true; &#125; &#125; template &lt;class T&gt;bool List&lt;T&gt;::isEmpyty()const&#123; if(head-&gt;next==head) return true; else return false;&#125;template &lt;class T&gt;bool List&lt;T&gt;::isFull()const &#123; return false;&#125;template &lt;class T&gt;void List&lt;T&gt;::inputQianCha()&#123; makeEmpty(); T endTag,val; LinkNode&lt;T&gt; *newNode; cout&lt;&lt;"请输入结束标志"; cin&gt;&gt;endTag; while(1) &#123; cin&gt;&gt;val; if(val==endTag) break; newNode=new LinkNode&lt;T&gt;; newNode-&gt;data=val; if(newNode==NULL) &#123; cerr&lt;&lt;"储存分配错误"&lt;&lt;endl; exit(1); &#125; newNode-&gt;next=head-&gt;next; head-&gt;next=newNode; &#125; &#125;template &lt;class T&gt;void List&lt;T&gt;::inputHouCha()&#123; makeEmpty(); T endTag,val; LinkNode&lt;T&gt; *newNode,*p=head; cout&lt;&lt;"请输入结束标志"; cin&gt;&gt;endTag; while(1) &#123; cin&gt;&gt;val; if(val==endTag) break; newNode=new LinkNode&lt;T&gt;; newNode-&gt;data=val; if(newNode==NULL) &#123; cerr&lt;&lt;"储存分配错误"&lt;&lt;endl; exit(1); &#125; p-&gt;next=newNode; p=p-&gt;next; &#125; p-&gt;next=head; //增加 &#125;template &lt;class T&gt;void List&lt;T&gt;::output()&#123; LinkNode&lt;T&gt; *p=head-&gt;next; while(p!=head) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;","; p=p-&gt;next; &#125; cout&lt;&lt;endl;&#125;template &lt;class T&gt;List&lt;T&gt;&amp; List&lt;T&gt;::operator=(List&lt;T&gt; &amp;L)&#123; makeEmpty(); //先清空原有的数据 LinkNode&lt;T&gt; *p1,*p2,*newNode,*Lhead; p1=L.getHead()-&gt;next; Lhead=L.getHead(); p2=head; while(p1!=Lhead) &#123; newNode=new LinkNode&lt;T&gt;; newNode-&gt;data=p1-&gt;data; p2-&gt;next=newNode; p2=newNode; p1=p1-&gt;next; &#125; p2-&gt;next=head; return *this; &#125;int main()&#123;List&lt;int&gt; test1,test2; int a,len,i; test1.inputHouCha(); test2.inputQianCha(); test1.output(); test2.output(); test2=test1; test2.output();&#125;/*和单链表区别:主要是构造的时候进行尾部连接头部: 1、构造函数中 添加head-&gt;next=head;2、复制构造函数和重载=号函数中增加Lhead=L.getHead();用while(p1!=Lhead)来判别循环表结束 最后增加p2-&gt;next=head; 为末尾添加head连接； 3、 前插法构造不需要变化，后插法需要在最后增加p2-&gt;next=head; 为末尾添加head连接； 其他函数有需要遍历的，判断结束条件改变为！+head即可: 4、置空函数makeEmpty()获取表长函数getLength()查询数据函数Search(T x)获取第i个元素的地址函数Locate(int i)删除元素函数Remove(int i,T &amp;x)判空函数isEmpyty() 输出函数output()只需要变化判断结束条件head-&gt;next!=head5、返回指针类若遍历后找不到，则返回NULL，因为循环链表最后元素的下一个指向为head而不是NULL 不能用最后的指向代替 。若不修改，会影响调用的判断 6、 其他函数不需要改变 */和单链表区别:主要是构造的时候进行尾部连接头部:1、构造函数中 添加head-&gt;next=head;2、复制构造函数和重载=号函数中增加Lhead=L.getHead();用while(p1!=Lhead)来判别循环表结束 最后增加p2-&gt;next=head; 为末尾添加head连接；3、 前插法构造不需要变化，后插法需要在最后增加p2-&gt;next=head; 为末尾添加head连接；其他函数有需要遍历的，判断结束条件改变为！=head即可:4、置空函数makeEmpty()获取表长函数getLength()查询数据函数Search(T x)获取第i个元素的地址函数Locate(int i)删除元素函数Remove(int i,T &amp;x)判空函数isEmpyty()输出函数output()只需要变化判断结束条件head-&gt;next!=head5、 返回指针类若遍历后找不到，则返回NULL，因为循环链表最后元素的下一个指向为head而不是NULL 不能用最后的指向代替 。若不修改，会影响调用的判断双向链表（带附加头结点的循环链表形式 ）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309#include&lt;iostream&gt;using namespace std;template &lt;class T&gt;struct LinkNode&#123; LinkNode *left=NULL,*next=NULL; T data;&#125; ;template&lt;class T&gt;class List&#123; public: List();//构造函数 List(const T&amp; x);//构造函数 List( List&lt;T&gt;&amp; L);//复制构造函数 ~List()&#123;makeEmpty();&#125;; void makeEmpty();//置空表 int getLength()const;//获取表长 LinkNode&lt;T&gt; *getHead()const&#123;return head;&#125;;//获取头节点地址 LinkNode&lt;T&gt; *Search(T x);// 向后查询含有数据x节点的地址 失败返回NULL LinkNode&lt;T&gt; *Locate(int i,int d);// 查询向右（向左）第i个 数据的地址,d！=0向右查找 d==0向左查找失败返回NULL bool getData(int i,T&amp;x,int d);//用x获取向右（向左）第i个数据， d！=0向右查找 d==0向左查找 bool setData(int i,T &amp;x,int d);//用x替换向右（向左）第i个数据， d！=0向右查找 d==0向左查找 bool Insert(int i,T &amp;x,int d);//在向右（向左）第i个元素后插入数据x d！=0向右查找 d==0向左查找 bool Remove(int i,T &amp;x,int d);//删除第向右（向左）i个数据并用x返回 d！=0向右查找 d==0向左查找 bool isEmpyty()const; //判断表空 bool isFull()const ;//判断表满 void inputQianCha();//输入结束标志，根据标志判断来输入数据 void inputHouCha();//输入结束标志，根据标志判断来输入数据 void output();//输出 List&lt;T&gt;&amp;operator=(List&lt;T&gt; &amp;L); protected: LinkNode&lt;T&gt; *head;&#125;;template &lt;class T&gt;List&lt;T&gt;::List()&#123; head=new LinkNode&lt;T&gt;; head-&gt;next=head; head-&gt;left=head;&#125;template &lt;class T&gt;List&lt;T&gt;::List(const T&amp; x)&#123; head=new LinkNode&lt;T&gt;(x); head-&gt;right=head; head-&gt;left=head;&#125;template &lt;class T&gt;List&lt;T&gt;::List(List&lt;T&gt;&amp; L)&#123; LinkNode&lt;T&gt; *p1,*newNode,*Lhead; p1=L.getHead()-&gt;next; Lhead=L.getHead(); head=new LinkNode&lt;T&gt;; //必须要有 new LinkNode&lt;T&gt;，因为此时head还没有构造出来。 head-&gt;left=head-&gt;next=head; //加上这步构造一个头节点 while(p1!=Lhead) &#123; newNode=new LinkNode&lt;T&gt;; newNode-&gt;data=p1-&gt;data; newNode-&gt;next=head; //后插法四步 ，由于是双向链表，可以直接通过head操作。 newNode-&gt;left=head-&gt;left; head-&gt;left-&gt;next=newNode; head-&gt;left=newNode; p1=p1-&gt;next; //别忘了p1需要往后移动 &#125; &#125;template &lt;class T&gt;void List&lt;T&gt;::makeEmpty() &#123; LinkNode&lt;T&gt; *p=head-&gt;next; while(head-&gt;next!=head) &#123; head-&gt;next=p-&gt;next; delete p; p=head-&gt;next; &#125; head-&gt;left=head; //增添左指向为head &#125;template &lt;class T&gt;void List&lt;T&gt;::inputQianCha()&#123; makeEmpty(); T endTag,val; LinkNode&lt;T&gt; *newNode; cout&lt;&lt;"请输入结束标志"; cin&gt;&gt;endTag; while(1) &#123; cin&gt;&gt;val; if(val==endTag) break; newNode=new LinkNode&lt;T&gt;; newNode-&gt;data=val; if(newNode==NULL) &#123; cerr&lt;&lt;"储存分配错误"&lt;&lt;endl; exit(1); &#125; newNode-&gt;next=head-&gt;next; head-&gt;next=newNode; newNode-&gt;next-&gt;left=newNode; newNode-&gt;left=head; &#125;&#125;template &lt;class T&gt;void List&lt;T&gt;::inputHouCha()&#123; makeEmpty(); T endTag,val; LinkNode&lt;T&gt; *newNode,*p=head; cout&lt;&lt;"请输入结束标志"; cin&gt;&gt;endTag; while(1) &#123; cin&gt;&gt;val; if(val==endTag) break; newNode=new LinkNode&lt;T&gt;; newNode-&gt;data=val; if(newNode==NULL) &#123; cerr&lt;&lt;"储存分配错误"&lt;&lt;endl; exit(1); &#125; newNode-&gt;next=head; newNode-&gt;left=head-&gt;left; head-&gt;left-&gt;next=newNode; head-&gt;left=newNode; &#125;&#125;template &lt;class T&gt;void List&lt;T&gt;::output()&#123; LinkNode&lt;T&gt; *p=head-&gt;next; while(p!=head) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;","; p=p-&gt;next; &#125; cout&lt;&lt;endl;&#125;template &lt;class T&gt;int List&lt;T&gt;::getLength()const&#123; LinkNode&lt;T&gt; *p=head-&gt;next; int num=0; while(p!=head) &#123; num++; p=p-&gt;next; &#125; return num;&#125;template &lt;class T&gt;LinkNode&lt;T&gt;* List&lt;T&gt;::Search(T x)&#123; LinkNode&lt;T&gt; *p=head-&gt;next; while(p!=head) &#123; if(p-&gt;data==x) return p; p=p-&gt;next; &#125; return NULL; //修改为NULL，因为循环链表最后元素的下一个指向为head. &#125;template &lt;class T&gt;LinkNode&lt;T&gt;* List&lt;T&gt;::Locate(int i,int d)&#123; if(i&lt;=0) return NULL; int num=1; LinkNode&lt;T&gt; *p; if(d!=0) //增加判断语句是左查询还是右查询 p=head-&gt;next; else p=head-&gt;left; while(i!=num&amp;&amp;p!=head) //修改 &#123; num++; if(d!=0) //增加判断语句是左查询还是右查询 p=p-&gt;next; else p=p-&gt;left; &#125; if(p==head) return NULL; //添加为NULL，因为循环链表最后元素的下一个指向为head. 没找到必须返回NULL else return p;&#125;template &lt;class T&gt;bool List&lt;T&gt;::getData(int i,T&amp;x,int d)&#123; LinkNode&lt;T&gt; *p=Locate(i,d); if(p==NULL) return false; else &#123; x=p-&gt;data; return true; &#125;&#125;template &lt;class T&gt;bool List&lt;T&gt;::setData(int i,T &amp;x,int d)&#123; LinkNode&lt;T&gt; *p=Locate(i,d); if(p==NULL) return false; else &#123; p-&gt;data=x; return true; &#125;&#125;template &lt;class T&gt;bool List&lt;T&gt;::Insert(int i,T &amp;x,int d)&#123; LinkNode&lt;T&gt; *p1,*newNode; if(i!=0) p1=Locate(i,d); else //增加一种空表插入判断 p1=head; if(p1==NULL) return false; else &#123; newNode=new LinkNode&lt;T&gt;; newNode-&gt;data=x; if(newNode==NULL) &#123; cerr&lt;&lt;"储存分配错误"&lt;&lt;endl; exit(1); &#125; newNode-&gt;next=p1-&gt;next; p1-&gt;next=newNode; newNode-&gt;next-&gt;left=newNode; newNode-&gt;left=p1; return true; &#125;&#125;template &lt;class T&gt;bool List&lt;T&gt;::Remove(int i,T &amp;x,int d)&#123; LinkNode&lt;T&gt; *p1=Locate(i,d); //由于是双向链表，所以不用再找第i-1个了 if(p1==NULL) //修改 return false; else &#123; p1-&gt;left-&gt;next=p1-&gt;next; p1-&gt;next-&gt;left=p1-&gt;left; delete p1; return true; &#125; &#125; template &lt;class T&gt;bool List&lt;T&gt;::isEmpyty()const&#123; if(head-&gt;next==head) return true; else return false;&#125;template &lt;class T&gt;bool List&lt;T&gt;::isFull()const &#123; return false;&#125;template &lt;class T&gt;List&lt;T&gt;&amp; List&lt;T&gt;::operator=(List&lt;T&gt; &amp;L)&#123; makeEmpty(); //清空链表 ，只剩下头节点 LinkNode&lt;T&gt; *p1,*newNode,*Lhead; p1=L.getHead()-&gt;next; Lhead=L.getHead(); while(p1!=Lhead) &#123; newNode=new LinkNode&lt;T&gt;; newNode-&gt;data=p1-&gt;data; newNode-&gt;next=head; //后插法四步 ，由于是双向链表，可以直接通过head操作。 newNode-&gt;left=head-&gt;left; head-&gt;left-&gt;next=newNode; head-&gt;left=newNode; p1=p1-&gt;next; //别忘了p1需要往后移动 &#125; return *this; &#125;int main()&#123; List&lt;int&gt; test1; int a,len; int x; test1.inputHouCha(); test1.output(); test1.makeEmpty(); List&lt;int&gt; test2(test1); test2.output(); &#125; /*双向循环链表和单链表的区别:1、结点中有前驱和后驱两个连接指针2、构造函数中需要对前指针后指针赋头节点值 head-&gt;right=head-&gt;left=head;3、前插法创建和后插法：均需要四步。注意分析。 4、 置空函数需要添加左指向为head 5、按顺序查找并返回地址进行判断添加。之后其他函数如获取数据等直接调用即可 6、插入函数Insert需要多一种第0个元素后插入的条件，即空表插入的条件。 7、删除函数Remove由于是双向链表，所以不用再找第i-1个了 判断也不需要考虑第i-1个是最后一个了。 8、复制构造函数和重载=号，需要清空链表，构造使用后插法则4步即可 */双向循环链表和单链表的区别:1、结点中有前驱和后驱两个连接指针2、构造函数中需要对前指针后指针赋头节点值 head-&gt;right=head-&gt;left=head;3、前插法创建和后插法：均需要四步。注意分析。4、 置空函数需要添加左指向为head5、按顺序查找并返回地址进行判断添加。之后其他函数如获取数据等直接调用即可6、插入函数Insert需要多一种第0个元素后插入的条件，即空表插入的条件。7、删除函数Remove由于是双向链表，所以不用再找第i-1个了 判断也不需要考虑第i-1个是最后一个了。8、复制构造函数和重载=号，需要清空链表，构造使用后插法则4步即可]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构【一】:顺序表和单链表(C++)]]></title>
    <url>%2Fposts%2Fc18506ff%2F</url>
    <content type="text"><![CDATA[2.1线性表线性表：逻辑结构，序列从1开始。数组实现的顺序表：物理结构，数组下标从0开始，有时候做题要注意。2.2顺序表malloc、free 函数的头文件#include stdlib.h动态数组的用法和原理动态数组的用法和静态数组一致但其内在原理：主要是当时malloc返回的时候，强制转换指针类型为我们需要的了。这样我们+1，自动给我们加这个类型的大小。如果我们用其他类型的指针去指，我们+1就会加偏。如下图。原来+1正好+6B，我们强行用int指针开始，+1就会加4B指偏，value也是混乱的。 顺序表的按值查找注意事项结构体判等，C语言中不能直接用==，C++可尝试重载运算符（但写函数更香。）但是在考试中：Tips：《数据结构》考研初试中，手写代码可以直接用“==”，无论 ElemType 是基本数据类型还是结构类型手写代码主要考察学生是否能理解算法思想，不会严格要求代码完全可运行有的学校考《C语言程序设计》，那么…也许就要语法严格一些看往年真题怎么说。其次不费劲就写准确点。2.3单链表typedef和一些注意事项本来，typedef是这么用的： 但是可以简洁化：它等价于：其实我们发现：LNode *L；和LinkList L；意思是一致的，都是声明一个指向单链表第一个结点的指针。但是我们后面会经常遇到两种都用的情况。尤其是教材。==主要是为了强调作用。：====强调这是一个单链表 ——使用 LinkList====强调这是一个结点 ——使用 LNode *==例如：链表初始化不带头节点：带头结点：注意区分头指针和头结点：头指针就是定义的L，无论有没有头结点，L都放在那儿。没有头结点：若有节点则指向第一个节点。有头结点：指向第一个结点，头结点，但是其内不存值。顺序表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227#include&lt;iostream&gt;using namespace std;int defaultSize=100;template &lt;class T&gt;class List&#123;public: List(); List(int sz ); //构造函数 List(List&lt;T&gt;&amp; L); //复制构造函数 ~List() &#123; delete[ ] data; //析构函数 &#125; int getSize() const &#123; return size; //求表最大容量 &#125; int getLength() const &#123; return last+1; //计算表长度 &#125; int Search(T&amp; x) const; //搜索x在表中位置 int Locate(int i) const; //定位第 i 个表项 bool getData(int i, T&amp;x) const; //取下标为i的数据 void setData(int i,T&amp; x); //用x修改下标为i的的值 bool Insert(int i, T&amp; x); //在第i个表项后插入x bool Remove(int i, T&amp; x); //删除第i个表项 通过x返回表项 bool IsEmpty(); //判断表空 bool IsFull(); //判断表满 void input(); //按照数值输n个数据入表 void output(); //输出表的全部数据 void reSize(int newSize); //空间大小重设 List&lt;T&gt;&amp;operator=(List&lt;T&gt;&amp; L);protected: T *data; int size; int last;&#125;;template&lt;class T&gt;List&lt;T&gt;::List()&#123; size=defaultSize; last=-1; data=new T[size];&#125;template&lt;class T&gt;List&lt;T&gt;::List(int sz)&#123; if(sz&gt;0) //SZ&gt;0判断 &#123; size=sz; last=-1; data=new T[sz]; if(data==NULL) &#123; //储存分配错误判断 cerr&lt;&lt;"储存分配错误"&lt;&lt;endl; exit(1); &#125; &#125; &#125;template &lt;class T&gt;List&lt;T&gt;::List(List&lt;T&gt;&amp; L)&#123; T value; size=L.getSize(); last=L.getLength; data=new T[size]; if(data==NULL) &#123; //储存分配错误判断 cerr&lt;&lt;"储存分配错误"&lt;&lt;endl; exit(1); &#125; for(int i=0; i&lt;=last;i++) &#123; L.getData(i,value); data[i]=value; &#125;&#125;template&lt;class T&gt;int List&lt;T&gt;::Search(T&amp; x) const &#123; for(int i=0;i&lt;=last;i++) if(data[i]==x) return i+1; return 0;&#125;template&lt;class T&gt;int List&lt;T&gt;::Locate(int i) const &#123; if(i&gt;1&amp;&amp;i&lt;=last+1) return i; else return 0; &#125;template&lt;class T&gt;bool List&lt;T&gt;::getData(int i, T&amp;x) const &#123; if(i&gt;=0&amp;&amp;i&lt;=last) &#123; x=data[i]; return true; &#125; else return false;&#125;template&lt;class T&gt;void List&lt;T&gt;::setData(int i,T&amp; x)&#123; if(i&gt;=0&amp;&amp;i&lt;=last) &#123; data[i]=x; &#125;&#125;template&lt;class T&gt;bool List&lt;T&gt;::IsFull()&#123; if(last==size-1) return true; else return false; &#125;template&lt;class T&gt;bool List&lt;T&gt;::IsEmpty()&#123; if(last==-1) return true; else return false; &#125;template&lt;class T&gt;bool List&lt;T&gt;::Insert(int i, T&amp; x)&#123; if(last==size-1) //表满，不能插入 return false; if(i&lt;0||i&gt;last+1) //i的值不规范，插入不再原表内，不能插入 return false; for(int j=last;i&gt;=i;j--) //后往前移位 &#123; data[j+1]=data[j]; &#125; last++; //记得个数+1 data[i]=x; return true; &#125;template&lt;class T&gt;bool List&lt;T&gt;::Remove(int i, T&amp; x)&#123; if(last==-1) //表空，不能删除 return false; if(i&lt;0||i&gt;last+1) //i的值不规范，插入不再原表内，不能插入 return false; for(int j=i;i&lt;=last;j++) data[j-1]=data[j]; last--; return true;&#125; template&lt;class T&gt;void List&lt;T&gt;::input()&#123; int num; cout&lt;&lt;"请输入需要输入的数据的个数:"; while(1) &#123; cin&gt;&gt;num; if(num&gt;0&amp;&amp;num&lt;=size) break; cout&lt;&lt;"请输入数值在0到"&lt;&lt;size&lt;&lt;"的数值"; &#125; for(int i=0;i&lt;num;i++) cin&gt;&gt;data[i]; last=num-1; &#125; template&lt;class T&gt; void List&lt;T&gt;::output() &#123; for(int i=0;i&lt;=last;i++) cout&lt;&lt;data[i]&lt;&lt;" "; cout&lt;&lt;endl; &#125; template &lt;class T&gt;void List&lt;T&gt;::reSize(int newSize) &#123; if(newSize &lt;= 0 ) &#123; cerr&lt;&lt;"无效的空间大小!"&lt;&lt;endl; return; &#125; if( newSize!=size) &#123; T * newarray=new T[newSize]; if (newarray == NULL) &#123; cerr&lt;&lt;"存储分配错误!"&lt;&lt;endl; exit(1); &#125; int n=last+1; T* srcptr=data; T* destptr=newarray; while(n--) //将原存储空间的数据复制到新扩充的空间 &#123; *destptr=*srcptr; destptr++; srcptr++; &#125; delete []data; data=newarray; size=newSize; &#125;&#125; template &lt;class T&gt;List&lt;T&gt;&amp; List&lt;T&gt;::operator=(List&lt;T&gt;&amp; L)&#123; size=L.getSize(); last=L.getLength()-1; for(int i=0;i&lt;=last;i++) &#123; L.getData(i,data[i]); &#125; return *this;&#125; int main() &#123; List&lt;int&gt; test1,test3; List&lt;char&gt; test2; test1.input(); test1.output(); test3.output(); test3=test1; test3.output(); &#125;/*1、给i的值进行取数设数判断等操作，添加判断i是否再列表范围内。 插入删除还要判断表满表空的情况 2、 申请空间时记得判断是否申请成功3、bool型，void型根据需要灵活转换 4、根据size的值申请空间时候判断size&gt;0; 5、声明的函数后有const ，下面描述的时候也要有const 6、注意重载=中不需要使用this-&gt;size等。 */单链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278#include&lt;iostream&gt;using namespace std;template &lt;class T&gt;struct LinkNode&#123; T data; LinkNode&lt;T&gt; *next=NULL; &#125;;template &lt;class T&gt;class List&#123; public: List();//构造函数 List(const T&amp; x);//构造函数 List( List&lt;T&gt;&amp; L);//复制构造函数 ~List()&#123;makeEmpty();&#125;; void makeEmpty();//置空表 int getLength()const;//获取表长 LinkNode&lt;T&gt; *getHead()const&#123;return head;&#125;;//获取头节点地址 LinkNode&lt;T&gt; *Search(T x);// 查询含有数据x节点的地址 失败返回NULL LinkNode&lt;T&gt; *Locate(int i);// 查询第i个 数据的地址 失败返回NULL bool getData(int i,T&amp;x);//用x获取第i个数据 bool setData(int i,T &amp;x);//用x替换第i个位替上的数据 bool Insert(int i,T &amp;x);//在第i个元素后插入数据x bool Remove(int i,T &amp;x);//删除第i个数据并用x返回 bool isEmpyty()const; //判断表空 bool isFull()const ;//判断表满 void inputQianCha();//清空链表，输入结束标志，根据标志判断来输入数据 void inputHouCha();//清空链表，输入结束标志，根据标志判断来输入数据 void output();//输出 List&lt;T&gt;&amp;operator=(List&lt;T&gt; &amp;L); protected: LinkNode&lt;T&gt; *head;&#125;;template &lt;class T&gt;List&lt;T&gt;::List()&#123; head=new LinkNode&lt;T&gt;;&#125;template &lt;class T&gt;List&lt;T&gt;::List(const T&amp; x)&#123; head=new LinkNode&lt;T&gt;(x);&#125;template &lt;class T&gt;List&lt;T&gt;::List(List&lt;T&gt;&amp; L)&#123; LinkNode&lt;T&gt; *p1,*p2,*newNode; p1=L.getHead()-&gt;next; p2=head=new LinkNode&lt;T&gt;; //p2=head=new LinkNode&lt;T&gt;;必须要有 new LinkNode&lt;T&gt;，因为此时head还没有构造出来。 while(p1!=NULL) &#123; newNode=new LinkNode&lt;T&gt;; newNode-&gt;data=p1-&gt;data; p2-&gt;next=newNode; p2=newNode; p1=p1-&gt;next; &#125;&#125;template &lt;class T&gt;void List&lt;T&gt;::makeEmpty()&#123; LinkNode&lt;T&gt; *p=head-&gt;next; while(head-&gt;next!=NULL) &#123; head-&gt;next=p-&gt;next; delete p; p=head-&gt;next; &#125;&#125;template &lt;class T&gt;int List&lt;T&gt;::getLength()const&#123; LinkNode&lt;T&gt; *p=head-&gt;next; int num=0; while(p!=NULL) &#123; num++; p=p-&gt;next; &#125; return num;&#125;template &lt;class T&gt;LinkNode&lt;T&gt;* List&lt;T&gt;::Search(T x)&#123; LinkNode&lt;T&gt; *p=head-&gt;next; while(p!=NULL) &#123; if(p-&gt;data==x) return p; p=p-&gt;next; &#125; return p;&#125; template &lt;class T&gt;LinkNode&lt;T&gt;* List&lt;T&gt;::Locate(int i)&#123; if(i&lt;=0) return NULL; int num=1; LinkNode&lt;T&gt; *p=head-&gt;next; while(i!=num&amp;&amp;p!=NULL) &#123; num++; p=p-&gt;next; &#125; return p;&#125;template &lt;class T&gt;bool List&lt;T&gt;::getData(int i,T&amp;x)&#123; LinkNode&lt;T&gt; *p=Locate(i); if(p==NULL) return false; else &#123; x=p-&gt;data; return true; &#125;&#125;template &lt;class T&gt;bool List&lt;T&gt;::setData(int i,T &amp;x)&#123; LinkNode&lt;T&gt; *p=Locate(i); if(p==NULL) return false; else &#123; p-&gt;data=x; return true; &#125;&#125;template &lt;class T&gt;bool List&lt;T&gt;::Insert(int i,T &amp;x)&#123; LinkNode&lt;T&gt; *p1=Locate(i),*p2; if(p1==NULL) return false; else &#123; p2=new LinkNode&lt;T&gt;(x); if(p2==NULL) &#123; cerr&lt;&lt;"储存分配错误"&lt;&lt;endl; exit(1); &#125; p2-&gt;next=p1-&gt;next; p1-&gt;next=p2; return true; &#125;&#125;template &lt;class T&gt;bool List&lt;T&gt;::Remove(int i,T &amp;x)&#123; LinkNode&lt;T&gt; *p1=Locate(i-1),*p2; if(p1==NULL||p1-&gt;next==NULL) return false; else &#123; p2=p1-&gt;next; p1-&gt;next=p2-&gt;next; x=p2-&gt;data; delete p2; return true; &#125; &#125; template &lt;class T&gt;bool List&lt;T&gt;::isEmpyty()const&#123; if(head-&gt;next==NULL) return true; else return false;&#125;template &lt;class T&gt;bool List&lt;T&gt;::isFull()const &#123; return false;&#125;template &lt;class T&gt;void List&lt;T&gt;::inputQianCha()&#123; makeEmpty(); T endTag,val; LinkNode&lt;T&gt; *newNode; cout&lt;&lt;"请输入结束标志"; cin&gt;&gt;endTag; while(1) &#123; cin&gt;&gt;val; if(val==endTag) break; newNode=new LinkNode&lt;T&gt;(val); if(newNode==NULL) &#123; cerr&lt;&lt;"储存分配错误"&lt;&lt;endl; exit(1); &#125; newNode-&gt;next=head-&gt;next; head-&gt;next=newNode; &#125; &#125;template &lt;class T&gt;void List&lt;T&gt;::inputHouCha()&#123; makeEmpty(); T endTag,val; LinkNode&lt;T&gt; *newNode,*p=head; cout&lt;&lt;"请输入结束标志"; cin&gt;&gt;endTag; while(1) &#123; cin&gt;&gt;val; if(val==endTag) break; newNode=new LinkNode&lt;T&gt;; newNode-&gt;data=val; if(newNode==NULL) &#123; cerr&lt;&lt;"储存分配错误"&lt;&lt;endl; exit(1); &#125; p-&gt;next=newNode; p=p-&gt;next; &#125; &#125;template &lt;class T&gt;void List&lt;T&gt;::output()&#123; LinkNode&lt;T&gt; *p=head-&gt;next; while(p!=NULL) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;","; p=p-&gt;next; &#125; cout&lt;&lt;endl;&#125;template &lt;class T&gt;List&lt;T&gt;&amp; List&lt;T&gt;::operator=(List&lt;T&gt; &amp;L)&#123; makeEmpty(); //先清空原有的数据 LinkNode&lt;T&gt; *p1,*p2,*newNode; p1=L.getHead()-&gt;next; p2=head; while(p1!=NULL) &#123; newNode=new LinkNode&lt;T&gt;; newNode-&gt;data=p1-&gt;data; p2-&gt;next=newNode; p2=newNode; p1=p1-&gt;next; &#125; return *this; &#125;int main()&#123; List&lt;int&gt; test1,test2; test1.inputHouCha(); test1.output(); test2=test1; test2.output(); List&lt;int&gt; test3(test2); test3.output(); test3.inputHouCha(); test3.output(); &#125;/*1、置空表2、 Locate查询第i个数据的地址，注意i的合理性判断，注意判断在查找第i个数据前是否链表就结束了 3、 getData获取第i个数据，可以利用 Locate函数，节省代码; 同理，setData、Insert、Remove也一样; 4、 凡是使用new 后面都要考虑申请失败退出程序； 5、删除第i个元素,注意是找到第i-1个元素。 且要判断下一个元素地址也不为空 6、new LinkNode&lt;T&gt;(val)直接将值输入 7、顺序表中为T *data,链表为T data; 8、复制构造函数中p2=head=new LinkNode&lt;T&gt;必须要有 new LinkNode&lt;T&gt;，因为此时head还没有构造出来。而重载=号中head已经是构造出来的了。 */]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理【二】:计算机的计算方法]]></title>
    <url>%2Fposts%2Fd92470a9%2F</url>
    <content type="text"><![CDATA[总导图关于补码1、已知[y补]求[-y补]，无论正负，都可以通过包括符号位在内都取反然后末位加一得到相同数量补码可以表示的范围比相同数量原码和反码多一个，没有±0。所以补码表示的定点小数范围是-1~1-2-n,而反码和原码为-（1-2-n）~1-2-n因为没有±0，所以负数能表示的数比正数多一个。最高位为符号位分界点，0，XXXXXX表示0~2n-1;​ 1,XXXXXXX表示-1~-2n；XXXXXXX均为从全0到全1.浮点数的表示范围1、前提补充：n位二进制数字表示正整数，表示的最大值为2n-1理解1：有一个数字为0，为0~2n-1理解2：根据等比求和公式当n位二进制数字来表示纯小数的时候，表示的最大值为1-2-n，最小值为2-n理解1：最大值根据等比求和公式理解1：最小值为最后一位取1其他位取0，代表的就是2-n阶码、尾码，都分为控制符号部分和数值部分2、设浮点数阶码的数值部分取m位，尾数的数值部分取n位，当浮点数为非规格化数时表示范围：最大正数为2(2m-1)×（1-2-n）理解:最大整数=小数最大+小数点向右位移最多—-&gt;对应为尾数的n位数值部分表示的最大小数的，其小数点再向右移动，移动的位数为m位阶码数值部分表示的最大数最小正数2-(2m-1)×（2-n）理解:类似最大整数进行理解即可最大负数-2-(2m-1)×（2-n）理解:就是最小正数的相反数，数符取1最小负数-2(2m-1)×（1-2-n）理解：就是最大整数的相反数，数符取13、精度由尾数来控制，阶码的数值部分大小用来控制小数点位置IEEE 754标准IEEE754数据格式介绍原码两位乘和补码两位乘法原码两位乘法原理:一次判断两位乘数决定部分积的形成通过笔算分析我们得到:乘数新部分积00原部分积右移两位01原部分积加被乘数后右移两位10原部分积加2倍的被乘数后右移两位11原部分积加3倍的被乘数后右移两位两倍被乘数可以由被乘数左移两位得到，三倍被乘数我们化为减去被乘数再加四倍被乘数，而加被乘数我们可以纳入下一次计算的加一个被乘数，分析如图：最终我们得到原码两位乘法的计算表· 000 -》 部分积加0， 右移两位，c变为0· 001 -》 部分积加|x|， 右移两位，c变为0· 010 -》 部分积加|x|， 右移两位，c变为0· 011 -》 部分积加2|x|，右移两位，c变为0· 100 -》 部分积加2|x|，右移两位，c变为0· 101 -》 部分积减|x|， 右移两位，c变为1· 110 -》 部分积减|x|， 右移两位，c变为1· 111 -》 部分积加0， 右移两位，c变为1计算完毕后不要忘记单独计算符号位加入恢复余数法和不恢复余数法原码恢复余数法和不恢复余数法之后多看例题。其实说是在原码除法中，实际上我感觉就是在用补码，只不过由于符号位分开计算，数值位取绝对值原码补码相同1、符号位单独异或处理得到结果的符号2、将被除数和除数都取绝对值计算除法，下面的所有除数，被除数都是指的绝对值，因为取绝对值后都为正数，所以此时的原码也就是补码3、判断商的值，在机器中我们用减法处理，因为为2进制，只有能商和不能商两种情况，也就是被除数（余数）大于除数商1小于除数商0。所以我们通过计算被除数（余数）-除数大于零还是小于零来计算商值，因为此时被除数和除数是原码也是补码，所以我们可以求负的除数的补码然后将减法运算转化为相应加法运算也是可以的。~&lt;/font4、在我们笔算的过程中，余数后补零，除数右移的操作，转化为机器中余数左移，除数不变的操作。之所以可行,是因为我们只是想判断接下来的商，只需要判断数值大小即可，所以笔算中我们将除数（余数）缩小2-1然后比较大小，机器中我们进行左移，也就是将被除数扩大21然后判断值的大小取商也是可行的，疑问：为什么逻辑左移后偶尔会出现溢出现象，仍然是正确的呢。目前我认为的是，虽然是溢出，但是再次减去除数（加上[-y*]补）仍会回到正确值其实这样理解是正确的，因为所说是溢出，其实是人为规定的，n位下的溢出，在n+1位下就是正常数值，这样就能解释为啥溢出再除2返回仍然正确，另外，在计算机中可没有小数点和逗号，就是一串数字，这串数字我们人为设置了这么多，所以在计算机中这个长度下有溢出，是固定设计好的。假设我们笔算，n位下溢出了，我们添加一位化为n+1位就没有溢出了，同样可以解释补码的两位乘中我们设置三位符号位的情况下，有类似2倍x的绝对值是001.10101的情况和负数为111.10101的情况，前者是在我们人为规定的长度下溢出，但是实际上它在n+2位下不溢出可以代表2被x的绝对值大小，而符号位全为1是因为我们人为规定就是需要6位，前面多的三位全部用来判断符号了恢复余数法运算规则余数 Ri＞0 上商 “1”，2Ri – y*余数 Ri＜0 上商 “0”， Ri + y* 恢复余数不恢复余数法运算规则余数 Ri＞0 上商“1” 2Ri – y*余数 Ri&lt;0 上商“0” 2Ri + y*特点第一次上商判溢出上商 n+1 次，移 n 次（最后一次上商后不再移），用移位的次数判断除法是否结束补码不恢复余数法求商的符号位：​ 如果被除数与除数同号，用被除数减去除数，​ 如果被除数与除数异号，用被除数加上除数。​ 然后判断余数：如果所得余数与除数同号上商“1”，​ 如果所得余数与除数异号上商“0”。求商的数值部分：​ 如果上次上商“1”，将余数左移一位后减去除数，​ 如果上次上商“0”，将余数左移一位后加上除数，​ 然后判断余数：如果所得余数与除数同号上商“1”，​ 如果所得余数与除数异号上商“0”。​ ……如此重复n-1次若对商的精度没有特殊要求，商的最后一位采用恒置“1”的方法，并省略最低n+1的操作。此 时最大误差为±2n1、开始记下除数的符号位，明确全过程比较法则：同减上1异加上0 2、首先被除数和除数比较，决定开始除数加减，不决定上商3、之后都是余数和除数符号的比较，决定上商的数值4、每次上商后都要移位，之后根据商值判断下一步加减除数比较方便。1减0加5、最后一位移位后直接上1补码除和原码的加减交替法除比较加法次数多1，是因为原码最后一位商值仍旧需要加减后根据余数判断，而补码直接固定设为1左移即可浮点加减关于为什么S&gt;0时，[S]补=00.1XXXX……X、S&lt;0时，[S]补=11.0XXXX……X1、S为真值，所以规格化数的1/2≤|S|&lt;12、真值S&gt;0的时候，不变，仍旧为真值的规格化形式00.1XXXX……X3、真值S&lt;0的时候,符号位取1，规格化后数值部分取反加1后就有了[S]补=11.0XXXX……X4、特殊情况：S=-1/2的时候，[S]补=11.10000…0.规定其不是规格化数字​ S=-1，[S]补=11.0000.0,小数补码允许表示-1，故看作规格化数​ S=-1的原码用一位符号位表示为1.000….0关于溢出判断的范围。由于规格化的问题。尾数能够表示的最小正数，最大负数并不是实际补码的能表示的最小整数和最大负数。例如:阶码为7位阶符2位，尾数为n位数符2位的情况下：首先明确阶码大小范围为-128~+127最小负数：-1×2127（因为补码可以表示真值-1为最小规格化负数，为11.000…0，尾数取最大）最大正数：(1-2n)×2127（因为补码可以表示真值（1-2^n）为最小规格化正小数尾数，为00.1111..1尾数取最大）最大负数:（-2-1-2-n）×2-128(因为规格化问题，-1/2规定不为最小规格化小数，只能表示真值为2-1+2-n的最小规格化正数，所以真值为11.1000….01,规格化补码为11.0111…..1)最小正数：2-1×2-128(因为补码可以表示最小为+1/2的规格化数字，规格化补码为00.10000000)简易判断方法:1、首先我们知道固定S&gt;0时候规格码00.1XXXX……X​ S&lt;0时候规格码11.0XXXX……X2、再根据补码的分布规律：​ 符号位为0（正数）：数值位由0000….0到1111……1表示的真值逐渐增大。例如:0~+127​ 符号位为1（负数）：数值位由0000….0到1111……1表示的真值逐渐增大。例如：-128~-1​ 我们可以很容易得到规格化下:00.1XXXX……X和11.0XXXX……X的表示的真值的大小和X的关系 ：​ 正数：00.11111….1最大00.10000…最小​ 负数:11.0111…..1最大11.000……最小3、根据补码可以很容易获得真值大小快速进位链​ MOOC讲解算术逻辑单元博客笔记最初始的加法器:然后我们要知道加法器的和以及进位，可以根据和在两位加数和进位三个数中，三个全为1或者只有一个为1的情况下才为1，进位输出在其中三个或者两个为1的情况下进位才为1，由此可得到公式:进位经过化简后可以得到:这个公式将会是之后所有改进的基础串行加法器串行进位链是指并行加法器中的进位信号采用串行传递。将AiBi和Ai+bi分别记作di，ti。已知两个加数我们就能得到di、ti。这样每一个进位都可以表示为:这样我们可以得到串行进位链：并行进位链并行进位链是指并行加法器中的进位信号是同时产生的，又称为先行进位、跳跃进位等。通常并行进位链有单重分组和双重分组两种实现方案。单重分组跳跃进位我们将C0带入C1，再将得到的C1带入C2，以此类推得到：这样我们的进位可以通过最初的进位和各位的加数进行与或操作获得，不必等待前一个进位再计算，这样我们可以得到单重分组跳跃进位链双重分组跳跃进位链双重分组跳跃进位就是将n位全加器分成若干大组，每个大组中又包含若干小组，而每个大组内所包含的各个小组的最高位进位是同时产生的，大组与大组间采用串行进位。1、d和t由小组内的每位加数可直接获得，D和T可根据每个小组内的d和t直接获得，所以给出每位加数，可以直接获得各个小组的D和T2、根据公式推导：小组内根据d和t和初始进位，可以求出每一位的进位，大组内，根据D和T根据初始进位，可以直接算出每个小组的最高位进位3、根据此规律。我们将计算过程化为：①同时计算大组全部D、T，初始进位小组内的低位进位②根据D、T和初始进位，同时计算出大组内的所有小组的最高进位③根据计算出的全部大组内小组的最高进位，作为下一位的进位输入，根据d和t，同时计算出全部小组的低位进位。同时下一个大组的初始进位也就获得了④根据d、t初始进位，D、T初始进位计算出下一个大组的第一个小组的全部低位进位和全部大组的高位进位⑤根据d、t和各个小组的初始进位，计算出所有小组的低位进位。⑥若还有大组，则以此类推4、补充：为了该算法实现，我们可以从上面看出D、T真的就是为了获得小组最高位的进位而生，你可以选择规定其他的D、T计算别的进位，但是对此算法无益。5、本质思路：初始进位-&gt;获得全部小组的最高位进位-&gt;作为下一个小组的初始进位-&gt;每个小组都能获得初始进位就能计算出小组内的任何进位]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理【一】:存储器导图总览和补充说明]]></title>
    <url>%2Fposts%2F9494c647%2F</url>
    <content type="text"><![CDATA[总导图秒的换算和DRAM的刷新1秒(s) ＝1000毫秒(ms)1毫秒(ms)＝1000微秒 (us)1微秒(us)＝1000纳秒 (ns)1纳秒(ns)＝1000皮秒 (ps)DRAM三种刷新方式详解储存单位换算1B=8bit1KB=1024B1MB=1024KB1GB=1024M1TB=1024GB译码驱动方式使用重合法比线选法可以减少地址译码输出线的使用。如1M的内存，同样20地址线，线选法需要2^20条线译码输出线。而使用10×10重合法只需要 2^10+ 2^10条存储器与CPU的连接如何门电路逻辑图判断高电平和低电平电路图中输入输出加圆圈代表低电平有效存储器的校验汉明码详解，通俗易懂提高访存速度的措施帮助理解高位交叉低位交叉1帮助理解高位交叉低位交叉2Cache-储存地址映射理解三种映射方式根据映射方式设计地址：1、看清按字寻址还是按字节寻址。2、计算直接映射：主存字块标记Cache字块地址字块内地址主存可以含有2^n 个Cache，则为n位地址Cache可以含2^n个字块，则为n位地址字或者字节数量（看寻址方式）为2^n,则为n位地址全相连映射：主存字块标记字块内地址主存含有2^n个字块，则为n位地址字或者字节数量（看寻址方式）为2^n,则为n位地址a路组相连映射：首先将a化为2^x。主存字块标记组地址字块内地址主存可以含有2^n 个Cache，则为n+x位地址Cache可以含2^n个字块，则为n-x位地址字或者字节数量（看寻址方式）为2^n,则为n位地址]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python随记【一】]]></title>
    <url>%2Fposts%2F45f87a96%2F</url>
    <content type="text"><![CDATA[一些小知识Python的数字可以随意大小字符串和元组为不可变序列，不能通过下标的方式修改其中的值Python使用基于值的内存管理方式Python具有自动内存管理功能Python赋值语句的执行过程是：首先把等号右侧表达式的值计算出来，然后在内存中寻找一个位置把值存放进去，最后创建变量并指向这个内存地址。Python中的变量并不直接存储值，而是存储了值的内存地址或者引用，这也是变量类型随时可以改变的原因。数字整数类型可以分为十进制、16进制、8进制、2进制。十六进制必须以0x开头：0xfa、0x10,x：hexadecimal8进制0o开头：0o35、0o11o：octal2进制0b开头：0b101、0b100b：binary浮点数如0.37、1.2e2、10.e-5Python支持复数的加减乘除计算c.real查看实部c.imag查看虚部c.conjugate（）返回共轭负数1234567891011a=5+2j;b=6-3j;c=a+b;d=a*b;e=a/b;print(c);print(d);print(e);结果：(11-1j)(36-3j)(0.5333333333333333+0.6j)3.X版本支持使用单个下划线作为数字分隔符，帮助人们记忆识别。1_000_000_000字符串Python中单引号、双引号、三单引号、三双引号可以嵌套来表示复杂字符串123x=&quot;&quot;&quot;&apos;Let&apos;s go&apos;&quot;&quot;&quot;;print(x);结果：&apos;Let&apos;s go&apos;注意不能产生歧义嵌套：如三个双引号套一个双引号成四个双引号会出错。字符串有多种方式合并1234567x=&apos;ly&apos;&apos;xf&apos;;print(x);x=x+&apos;lyxf&apos;;print(x);结果为：lyxflyxlyxf建议使用join（）函数，+很耗资源字符串格式化123456a=&apos;lyxf&apos;;b=19;x=&quot;&quot;&quot;My %s My age %d&quot;&quot;&quot;%(a,b);print(x);结果：My lyxf My age 19注意百分号%（a，b）；转义字符描述\\反斜杠符号&#39;单引号&quot;双引号\a响铃\b退格(Backspace)\e转义\000空\n换行\v纵向制表符\t横向制表符\r回车\f换页\oyy八进制数，yy代表的字符，例如：\o12代表换行\xyy十六进制数，yy代表的字符，例如：\x0a代表换行\other其它的字符以普通格式输出操作符描述实例a=’Hello’+字符串连接&gt;&gt;&gt;a + b ‘HelloPython’*重复输出字符串（还可以用于列表元组等）&gt;&gt;&gt;a * 2 ‘HelloHello’[]通过索引获取字符串中字符&gt;&gt;&gt;a[1] ‘e’[ : ]截取字符串中的一部分(实际输出为前闭后开的区间)&gt;&gt;&gt; a[1:4] ‘ell’in成员运算符 - 如果字符串中包含给定的字符返回 True&gt;&gt;&gt;”H” in a Truenot in成员运算符 - 如果字符串中不包含给定的字符返回 True&gt;&gt;&gt;”M” not in a Truer/R原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母”r”（可以大小写）以外，与普通字符串有着几乎完全相同的语法。注意最后一个字符不能为\&gt;&gt;&gt;print r’\n’ \n &gt;&gt;&gt; print R’\n’ \n运算符**返回x 的y次幂1a**b 为10的21次方//取整除 - 向下取接近除数的整数1234&gt;&gt;&gt; 9//24&gt;&gt;&gt; -9//2-5%求余，结果与右侧的运算数符号一致1-17%4=3;17%-4=-3;Python中1&lt;3&lt;5是允许的&lt;还可以用于比较字符串、列表、集合测试是否为子集成员运算符in如果在指定的序列（字符串、列表、元组）中找到值返回 True，否则返回 False。not in同理位运算符：按位运算符是把数字看作二进制来进行计算的。(假设a=60)位运算符还可以用来进行集合运算&amp;按位与、求交集|按位或、求并集^按位异或、求对称差集，差集用-来求Python 3.5之后有@用来矩阵相乘~按位取反、&lt;&lt;运算数的各二进位全部左移若干位,a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000&gt;&gt;把”&gt;&gt;”运算数的各二进位全部右移若干位a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111逻辑运算符（惰性求值、只计算必须计算的表达式）：andornotpython不支持++和--运算！！！。哪怕有时候可以执行也是另有含义常用内置函数查看变量类型—–print(type(x));整数转化位二进制—–bin()1bin(3)=0b11整数转化位八进制—–oct()1oct(9)=0o11整数转化位十六进制—–hex()10x11实数转化为整数—–int（）1int(3.5)=3把数字字符串按照指定进制转化位10进制—-int（）12int('101',16)=257int('x2',36)=1190比较函数max()、min()，可添加比较规则key1234X=['21','1234','9']max(x)='9';max(x,key=len)='1234';max(x,key=int)='1234';使用del()删除对象。del无法删除元组或者字符串中的元素，只能删除整个元组或者字符串，因为两者均为不可变序列。12x=(1,2,3);del x;读取用户键盘输入：str=input()。返回结果为一个字符串。需要其他类型需要转换为相应类型使用。基本输入输出：print()。zip() zip() 函数用于将可迭代对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象。https://www.cnblogs.com/wushuaishuai/p/7766470.html模块的导入和使用import 模块名 [as 别名]12345import mathprint(math.sin(0.5))或者import math as sxprint(sx.sin(0.5))直接引入某个模块中的函数使用。from 模块名 import 对象名 [as 别名]12345from math import sinprint(sin(0.5))或者from math import sin as zxprint(zx(0.5))from 模块名 import*可以导入全部改模块全部函数直接使用，但是大量占用内存不推荐。每个import语句只导入一个模块，最好按照标准库、扩展库、自定义库的先后顺序导入。因为后面导入有可能会覆盖前面的导入。Python代码规范缩进类定义、函数定义、循环结构、with块，行尾的冒号表示缩进的开始。python使用缩进来表示代码块同一个级别的代码块的缩进量必须相同一般而言以四个空格（一个Tab）为基本缩进单位123456if True: print ("Answer") print ("True")else: print ("Answer") print ("False") # 缩进不一致，会导致运行错误如果一行太长可以在行尾加上续行符\来换行分成多行，也可以使用大括号包含多行内容1234x=1+2+3\ +4+5\ +6print(x);注释以#开始，表示本行#之后的内容为注释一对三单引号或者一对三双引号之间的且不属于任何语句的内容将被解释器认为是注释必要的空格与空行更加美观运算符两侧、逗号后面建议增加一个空格。不同代码块之间、不同的函数定义之间增加一个空行。序列1.关于各类生成式，我的理解是左面是组成该类数据结构的元素，右面的for或者if等是对该元素的“生成方式2.简单理解可哈希=不可变3.列表、元组、字符串支持双向索引，第一个元素下标为0，第二个元素下标为1，以此类推；最后一个元素下标为-1，倒数第二个元素下标为-2，以此类推”可变：列表、字典、集合，其他不可变无序：字典、集合，其他有序1.列表（list）2.元组（tuple）Python3序列赋值、序列解包详解（上）Python3序列赋值、序列解包详解（下）生成器、迭代器、推导式——思维导图什么是Python中的生成器推导式？—列表推导式、字典推导式、集合推导式和生成器表达式，这四个表达式各自之间有着许多相似之处。如果将四者之间的类似点总结为“推导式”，将极大地简化相关概念。它们之间的相似点远大于不同之处，生成器解释3.字典（dict）字典内置函数&amp;方法globals()返回包含当前作用域内所有全局变量和值的字典locals()返回包含当前作用域内所有局部变量和值的字典4.集合（set）集合内置函数创建空集合为set=set()创建空字典为dict={}]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python环境搭建]]></title>
    <url>%2Fposts%2F4e85da05%2F</url>
    <content type="text"><![CDATA[文章十分小白，仅用于本人学习记录，输入密码查看 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse的使用]]></title>
    <url>%2Fposts%2F7aba6338%2F</url>
    <content type="text"><![CDATA[文章十分小白，仅用于本人学习记录，输入密码查看 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我在搭建博客时遇到的那些问题]]></title>
    <url>%2Fposts%2F18589%2F</url>
    <content type="text"><![CDATA[关于更改或取消绑定域名后，仍旧自动跳转清理谷歌浏览器缓存。hexo d命令报错 ERROR Deployer not found: git前提：已经在站点配置文件写入了1234deploy: type: git repository: https://github.com/lyxf2000/lyxf2000.github.io.git branch: master但是执行，hexo d报错：1ERROR Deployer not found: git解决：在站点目录下输入下面的插件安装hexo-deployer-git插件1npm install hexo-deployer-git --save无法使用一些自定义页面设置原因：由于未知原因，NexT-7.3版本，没有_custom文件解决：重新使用 NexT-7.2以及之前版本。文章的删除先删除本地文章hexo ghexo d透明设置，使得搜索栏出现全透明BUG暂未解决其他问题，均在hexo美化中解决不再赘述]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用PicGo与腾讯云搭建图床]]></title>
    <url>%2Fposts%2F17870%2F</url>
    <content type="text"><![CDATA[一、前言本来想使用七牛云+Mpic来搭建图床，毕竟每个月都有10G免费额度，够用的了，但是七牛云改革了，一个月后需要备案自己的域名才能继续免费使用，有些麻烦。搜寻了网上的信息后最终决定使用腾讯云COS和PicGo搭建图床。一是不用备案，还有6个月免费额度，其次毕竟鹅厂，比较可靠。二、使用腾讯云COSⅠ.注册腾讯云COS链接Ⅱ.使用对象储存在产品中选择对象储存。Ⅲ.创建储存桶​ 创建储存桶-》访问权限勾选公有读，私有写。​ 储存区域填写临近本地的。Ⅳ.防盗链存储桶列表-&gt;基础配置-&gt;防盗链设置-&gt;referer:自己的域名防盗链可以使得除了你的指定域名之外不可读取你的文件，但是由于本人博客暂时没有大量的访问，也没有开放推广的想法，而且为了使得PicGo能够预览图片方便，所以个人就不加防盗链了Ⅴ.可以使用COS客户端来获取连接。由于本人感觉使用PicGo更加方便，在此就不再示范了，需要的自行下载使用。三、使用PicGoⅠ.下载PicGo项目GitHub下载地址macOS用户请下载最新版本的dmg文件，windows用户请下载最新版本的exe文件，linux用户请下载AppImage文件。如果你是Arch类的Linux用户，可以直接通过aurman -S picgo-appimage来安装PicGo。感谢 @houbaron 的贡献！如果你是macOS用户，可以使用brew cask来安装PicGo: brew cask install picgo。感谢 @womeimingzi11 的贡献！如果你是Windows用户，还可以使用 Scoop 来安装PicGo: scoop bucket add helbing https://github.com/helbing/scoop-Ⅱ.设置PicGo1.查明COS版本COS V4.0COS V5.0不带V4就是5，不再赘述选择相应版本2.查询并且设置APPID、SecretId和SecretKey访问：https://console.cloud.tencent.com/cam/capi查询后填写。3.查询并且设置bucket名以及存储区域代号访问：https://console.cloud.tencent.com/cos5/bucket查询后填写。之后设定为默认图床重启就可以使用了。四、备注默认快捷键为ctrl+shift+p可以自行设置里更改。更多功能或者帮助可查询配置手册：https://picgo.github.io/PicGoDoc/zh/guide/config.html#%E8%85%BE%E8%AE%AF%E4%BA%91cos]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-Next主题美化]]></title>
    <url>%2Fposts%2F51370%2F</url>
    <content type="text"><![CDATA[插入音乐使用html插入1&lt;audio src=&quot;http://music.163.com/song/media/outer/url?id=你的网易云歌曲ID.mp3&quot; style=&quot;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;&quot; controls=&quot;controls&quot; loop=&quot;loop&quot; preload=&quot;meta&quot;&gt;Your browser does not support the audio tag.&lt;/audio&gt;替换你需要的网易云歌曲的ID即可。缺点：除了网易云音乐外，其他你需要的MP3地址自行搜索，而且界面不美观，功能也少，不推荐直接使用网易云音乐外链播放器在网页网易云搜索歌曲点击生成外链播放器：进行尺寸和播放模式设置后复制HEML代码，添加进文章的合适位置即可。因为版权问题有时不能使用网易云的解决方法：思路：获得MP3，歌词，封面文件，上传到你的私人云端获得外链。使用Aplayer插件进行插入播放器，下面给出的是几种免费获得文件的方法Ⅰ.首先获得音乐MP3文件，和歌词Lrc和封面文件获得MP3和LRC方法一：网易云链接替换1.获得歌曲mp3文件http://music.163.com/song/media/outer/url?id=你需要的网易云歌曲的ID.mp3下载MP3文件即可。也可以使用该网站获取MP32.获得歌词lrc文件浏览器输入http://music.163.com/api/song/media?id=你的网易云歌曲ID得到下面页面从第一个[HH:MM:SS] 开始复制，到最后的[HH:MM:SS]和之后的一句歌词为止截取复制，新建DOC文档，粘贴进去，就是获取lyric:&quot;........&quot; 中的部分： 使用替换功能：将\n替换为`特殊格式：段落标记`得到歌词文件，下图为部分歌词：之后改名，保存为lrc文件即可手工得到歌词文件如果发现歌词出现乱码，在保存的时候选择另存为，然后点击底部的工具选项，选择Web选项，将编码设置为Unicode(UTF-8)即可。最近发现了一个获取歌词新方法：使用这个软件可以直接下载网易云的歌曲歌词，还带翻译，点我进入该大佬项目下载使用即可。推荐使用插件中的歌单歌词下载功能，然后新建一个歌单，把你想下载歌词的歌放进去，通过该方法可以不用通过本地文件下载。下载的歌词在软件文件夹下的Lyrics文件夹中。获得MP3和LRC方法二：使用Music tools软件下载地址使用软件下载音乐，同时会自动下载歌词lrc文件。缺点是偶尔会有下载不了的情况，还有些情况会发现下载的是翻唱获取封面图片网易云音乐：进入该神奇网站输入你的音乐网址 例如https://music.163.com/#/album?id=36146063神奇的得到封面图片QQ音乐直接右键图片另存为其他音乐和其他方法自行寻找不再赘述。最近发现了一个获取封面的方法：Ⅱ.将上面获得的文件上传至你的私人云端获得外链（由于当时建立图床的时候用了腾讯云COS，现在正好就一起用了）使用方法一也可以不用下载和上传音乐，直接使用：http://music.163.com/song/media/outer/url?id=你需要的网易云歌曲的ID.mp3也可以的在云储存里获得Mp3链接和Lrc歌词链接 这里我直接使用了COSBrowser 工具进行上传和获取链接，很方便Ⅲ.安装插件，在文章里写入即可在站点文件夹下：$ npm install hexo-tag-aplayer --save文章里的写入操作：单曲：1&#123;% aplayer &quot;歌曲名&quot; &quot;歌手名&quot; &quot;https://什么什么什么.mp3&quot; &quot;https://封面图.jpg&quot; &quot;lrc:https://歌词.lrc&quot; %&#125;歌词标签：除了使用标签 lrc 选项来设定歌词，你也可以直接使用 aplayerlrc 标签来直接插入歌词文本在博客中：123&#123;% aplayerlrc &quot;title&quot; &quot;author&quot; &quot;url&quot; &quot;autoplay&quot; %&#125;[00:00.00]lrc here&#123;% endaplayerlrc %&#125;支持歌单12345678910111213141516171819202122232425&#123;% aplayerlist %&#125;&#123; &quot;narrow&quot;: false, //是否关闭进度页面 &quot;theme&quot;: &quot;#FFD700&quot;, //进度条和歌曲选中的颜色 &quot;autoplay&quot;: false, //自动播放 &quot;showlrc&quot;: 3, //歌词设置类型3：把歌词放到LRC文件里 1：歌词放到JS字符串 &quot;mutex&quot;: true, //其他播放时暂停 &quot;music&quot;: [ &#123; &quot;title&quot;: &quot;歌曲名&quot;, &quot;author&quot;: &quot;歌手名&quot;, &quot;url&quot;: &quot;https://什么什么什么.mp3&quot;, &quot;pic&quot;: &quot;https://封面图.jpg&quot;, &quot;lrc&quot;: &quot;https://歌词.lrc&quot; &#125;, &#123; &quot;title&quot;: &quot;歌曲名&quot;, &quot;author&quot;: &quot;歌手名&quot;, &quot;url&quot;: &quot;https://什么什么什么.mp3&quot;, &quot;pic&quot;: &quot;https://封面图.jpg&quot;, &quot;lrc&quot;: &quot;https://歌词.lrc&quot; &#125; ]&#125;&#123;% endaplayerlist %&#125;更多详情请参照：https://github.com/MoePlayer/hexo-tag-aplayer想要直接使用使用你的云音乐或者其他音乐歌单Ⅰ.直接使用网易云外链播放器直接将https://music.163.com/#/outchain/0/替换成歌单ID就可以越过版权问题获取外链，直接添加进文章的相应位置即可。虽然快捷但是使用起来会卡卡的而且无版权音乐一样不能听，没有其他功能，不推荐。Ⅱ.使用Aplayer插件进行设置（推荐）在站点文件夹下：$ npm install hexo-tag-aplayer --save在站点配置文件_config.yml下写入下列代码来配置Meting：12aplayer: meting: trueID获取网易云为例：打开你的歌单浏览器地址栏就会显示你的歌单ID：在你的文章中写入代码最简单的：1&#123;% meting &quot;你的歌单ID&quot; &quot;平台类型&quot; &quot;playlist&quot; %&#125;自定义：1&#123;% meting &quot;ID&quot; &quot;平台类型&quot; &quot;playlist&quot; &quot;autoplay&quot; &quot;mutex:false&quot; &quot;listmaxheight:340px&quot; &quot;preload:none&quot; &quot;theme:#ad7a86&quot;%&#125;其他可设置选项如下:选项默认值描述id需要自己填写song id / playlist id / album id / search keyword 歌曲 id / 播放列表 id / 相册 id / 搜索关键字server需要自己填写Music platform: netease, tencent, kugou, xiami, baidu 音乐平台: netease, tencent, kugou, xiami, baidutype需要自己填写song, playlist, album, search, artistfixedfalseEnable fixed mode （开启吸底模式）minifalseEnable mini mode （开启迷你模式）loopallPlayer loop play, values: ‘all’, ‘one’, ‘none’ 列表循环模式：all, one,noneorderlistPlayer play order, values: ‘list’, ‘random’ 列表播放模式： list, randomvolume0.7播放器音量lrctype0歌词格式类型歌词设置类型 1：歌词放到JS字符串 3：把歌词放到LRC文件里listfoldedfalse指定音乐播放列表是否折叠autoplayfalse自动播放，移动端浏览器暂时不支持此功能mutextrue该选项开启时，如果同页面有其他 player 播放，该播放器会暂停listmaxheight340px播放列表的最大长度preloadautoThe way to load music, can be none, metadata, auto 音乐文件预载入模式，可选项： none, metadata, autostoragenamemetingjsLocalStorage key that store player setting 存储播放器设置的LocalStorage键theme#ad7a86播放器风格色彩设置例如我的设置：12&#123;% meting &quot;699716432&quot; &quot;netease&quot; &quot;playlist&quot; &quot;theme:#FFD700&quot; &quot;mode:circulation&quot; &quot;mutex:true&quot; &quot;listmaxheight:280px&quot; &quot;preload:auto&quot; &quot;autoplay&quot; &quot;listfolded&quot; %&#125;//需要自动播放则添加&quot;autoplay&quot;即可效果如下：更多使用请阅读：Aplayer注意：一个文档里面不支持包含metingJS、Aplayer同时播放​ 歌单的更新可能会在你的网易云更新后有一两天延迟在博客首页创建歌单页面先查看本文上个问题中“想要直接使用使用你的云音乐或者其他音乐歌单”的解决方法，安装aplayer插件，配置Metting，查询歌单ID。1.新建歌单页面hexo new page playlist2.修改页面类型在 /Hexo/source 生成的playlist文件夹，修改index.md如下：123title: 歌单date: 2019-08-25 17:44:37type: &quot;playlist&quot;3.修改图标在主题配置文件_config.yml下搜索menu并添加playlist: /playlist/ || music修改如下：1234567menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive playlist: /playlist/ || music在themes/next/languages/zh-Hans.yml 中找到menu 添加中文翻译：1234567891011menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 playlist: 歌单 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益 4044.载入歌单打开 /Hexo/source 生成的playlist文件夹，将你的设置添加到index.md中去我的设置如下：1&#123;% meting &quot;699716432&quot; &quot;netease&quot; &quot;playlist&quot; &quot;theme:#FFD700&quot; &quot;mode:circulation&quot; &quot;mutex:true&quot; &quot;listmaxheight:500px&quot; &quot;preload:auto&quot; &quot;autoplay&quot; %&#125;如何设置请见上个问题中“想要直接使用使用你的云音乐或者其他音乐歌单”给你的博客站点加入播放器上述问题，解决文章或者中的音乐插入，这儿我们讨论在博客站点加入播放器添加使用网易云生成的外链播放器打开/themes/next/layout/_macro/sidebar.swig搜索theme.links，也就是友情链接，再这一项之后添加网易云外链。：12345678910111213141516&#123;% if theme.links %&#125; &lt;div&gt; &lt;div class=&quot;links-of-blogroll-title&quot;&gt; ....省略部分代码 &lt;/div&gt; &lt;ul class=&quot;links-of-blogroll-list&quot;&gt; ....省略部分代码 &lt;/ul&gt; &lt;/div&gt;&#123;% endif %&#125;//添加 &lt;div id=&quot;music163player&quot;&gt; &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=5239700&amp;auto=0&amp;height=66&quot;&gt; &lt;/iframe&gt; &lt;/div&gt; //结束直接在网易云网站搜索生成外链就行，也不用想去生成跨版权播放器，生成了也播放不了。使用audio标签修改同样的文件，同样的位置，添加下面代码123456789101112131415&#123;% if theme.links %&#125; &lt;div&gt; &lt;div class=&quot;links-of-blogroll-title&quot;&gt; ....省略部分代码 &lt;/div&gt; &lt;ul class=&quot;links-of-blogroll-list&quot;&gt; ....省略部分代码 &lt;/ul&gt; &lt;/div&gt;&#123;% endif %&#125;//添加 &lt;div id=&quot;music163player&quot;&gt; &lt;audio src=&quot;http://music.163.com/song/media/outer/url?id=你的网易云歌曲ID.mp3&quot; style=&quot;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;&quot; controls=&quot;controls&quot; loop=&quot;loop&quot; preload=&quot;meta&quot;&gt;Your browser does not support the audio tag.&lt;/audio&gt; &lt;/div&gt; //结束src=&quot;http://什么什么.mp3&quot;可自行更改，若想自动播放则在src=&quot;http://什么什么.mp3&quot; 之后添加autoplay即可优点是可以跨版权播放，缺点是不太美观，只有播放功能使用aplayer进行设置播放器点击访问Aplayer源码：GitHub Aplayer。下载到本地，解压后将dist文件夹复制到themes\next\source文件夹下。新建themes\next\source\dist\music.js文件，添加内容：12345678910111213141516171819202122const ap = new APlayer(&#123; container: document.getElementById(&apos;aplayer&apos;), fixed: true, //吸底模式 autoplay: false, //自动播放 lrcType: 1, //歌词载入模式 1为直接在JS文件中写入，3为lrc文件使用但是我总是失败 audio: [ &#123; name: &quot;歌曲名字&quot;, artist: &quot;歌曲作者&quot;, url: &quot;http://music.163.com/song/media/outer/url?id=你需要的网易云歌曲的ID.mp3&quot;, //歌曲链接 cover: &quot;http://什么什么.jpg&quot;, //封面 lrc : &quot;[00:00.13] 编曲：接个吻，开一枪\n[00:01.10] 混音......&quot; &#125;,&#123; name: &quot;歌曲名字&quot;, artist: &quot;歌曲作者&quot;, url: &quot;http://music.163.com/song/media/outer/url?id=你需要的网易云歌曲的ID.mp3&quot;, //歌曲链接 cover: &quot;http://什么什么.jpg&quot;, //封面 lrc : &quot;[00:00.13] 编曲：接个吻，开一枪\n[00:01.10] 混音......&quot; &#125;, ]&#125;);其他参数解释点击这里打开themes\next\layout\_layout.swig文件，在&lt;body&gt;&lt;/body&gt;里面添加下面代码：1234&lt;link rel=&quot;stylesheet&quot; href=&quot;/dist/APlayer.min.css&quot;&gt;&lt;div id=&quot;aplayer&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/dist/music.js&quot;&gt;&lt;/script&gt;hexo s 。下面给出几点注意url的MP3链接自行设置，上述设置是为了方便我使用网易云直接填ID即可歌词的设置我使用模式3载入lrc文件总是显示不可用，于是换了模式1，在lrc :&#39;&#39;中自己写入歌词，歌词直接在http://music.163.com/api/song/media?id=你的网易云歌曲ID 获取lyric:&quot;&quot;中的内容即可。英文歌无中文翻译，需要自己在每一句后面加（翻译）。新的简单获取歌词的简单方法已经在上面获取歌词的问题中给出，打开文件，复制内容通过word替换功能，被替换选特殊格式段落标记，替换填空白即可将歌词全部转为一行，之后填入music.js中的lrc:&quot;&quot;使用注意单双引号的影响即可 该方法能够有效解决自己添加翻译的麻烦，不需要翻译的话直接用2.即可源文档介绍使用单引号，这里我全部改成了双引号，因为我发现lrc选项填写英文歌词偶尔会出现单引号会引起不必要的BUG，双引号要少一些，出现的话删除即可歌词中的\n等可有可无，只要时间歌词格式使用正确即可，这里有是因为从网页中复制下来就带。保存music.js时候用UTF-8编码，默认的ANSI会导致中文乱码获得封面的方法有很多，除了上面问题中由该网站获取保存到云端的方法外下面再给出一种简单的方法首先用谷歌浏览器打开网易云搜索你的歌曲，在封面处右键选则检查选项ctrl+c复制即可，黏贴在cover中打赏功能设置打赏功能在主题配置文件_config.yml 下，搜索reward_settings 进行修改:12345678# Reward (Donate)reward_settings: enable: true //true启用 animation: true //true启用 comment: 坚持原创技术分享，您的支持将鼓励我继续创作！恰饭^.^~ //可以自行设置文字reward: wechatpay: //你的微信收款图片地址 alipay: //你的支付宝收款图片地址这里的收款图片地址，我均用截图上传至腾讯云COS端进行链接调用了。打赏抖动消除修改文件 next/source/css/_common/components/post/post-reward.styl，找到函数 ，如下：1234567891011if hexo-config(&apos;reward_settings.animation&apos;) &#123; &amp; &gt; div:hover p &#123; animation: roll 0.1s infinite linear; &#125; @keyframes roll &#123; from &#123; transform: rotateZ(30deg); &#125; to &#123; transform: rotateZ(-30deg);通过修改animation: roll 0s infinite linear; 或者修改两个rotateZ(0deg)都可以取消鬼畜抖动小萌物设置在博客根目录下，执行npm install hexo-helper-live2d --save修改站点配置文件或主题配置文件我修改的是站点配置文件，添加下列字段：123456789101112131415161718192021222324252627# Live2D## https://github.com/EYHN/hexo-helper-live2dlive2d: enable: true # enable: false scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-koharu # npm-module package name # 填写你所需要的看板娘名称 # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url display: position: right #左右放置 width: 200 #宽 height: 400 #高 mobile: show: true # 手机中是否展示 react: opacity: 0.9 #透明度更多设置：点击这里通过npm安装依赖的看板娘文件npm install live2d-widget-model-name，其中name是你选择的官方看板娘的名字，如我选择的是koharu，则为npm install live2d-widget-model-koharu。重新运行hexo clean &amp;&amp; hexo d -g则可在主页看到了。点击这里预览看板娘来选择名称深度功能，换衣、对话等等：点击这里修改插入图片的大小打开文件/themes/next/source/css/_custom/custom.styl添加以下代码：1234.image-size-400&#123; //表示插入的图片的宽度为 400px width: 90%&#125;width的值可以自行调整，可以直接设置值：width: 400文章中的使用：1&lt;img src=&quot;你的图片链接&quot; class=&quot;image-size-400&quot; /&gt;想使用原大小不加入class=&quot;image-size-400&quot;即可。文内直接使用：&lt;img src=&quot;你的图片链接&quot; width=90% /&gt;就可以，但是最初我试的时候不行，也不知道为啥，可能是因为当时为了查看图片安装了fancybox插件之后就可以了？文章添加封面功能方法一：直接使用配置文件在根目录下scaffolds文件夹打开post.md,增加photos:属性123456title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: categories: copyright: true photos: //填写你的封面url地址这样新建文章在photos:后添加图片url地址即可添加封面。以前的文章想要加封面，手动加入 photos 即可建议配合文章折叠功能：点我查看若是觉得该方法下图片与题目留白太宽，不美观：点我查看解决方法二：自行添加打开\themes\next\layout\_macro\post.swing文件，搜索post.description在如下位置添加代码：123456&lt;p&gt;&lt;/p&gt;&#123;% if post.summary_img %&#125; &lt;div class=&quot;out-img-topic&quot;&gt; &lt;img src=&#123;&#123; post.summary_img &#125;&#125; class=&quot;image-size-400&quot;&gt; &lt;/div&gt;&#123;% endif %&#125;&lt;p&gt;&lt;/p&gt;是我看图片太过靠顶部不美观加的，让图片和顶部有一些距离，可以删除添加后例如：123456789101112131415 .......... &lt;/span&gt; &#123;% endif %&#125; &lt;p&gt;&lt;/p&gt;&#123;% if post.summary_img %&#125; &lt;div class=&quot;out-img-topic&quot;&gt; &lt;img src=&#123;&#123; post.summary_img &#125;&#125; class=&quot;image-size-400&quot;&gt; &lt;/div&gt;&#123;% endif %&#125; &#123;% if post.description and (not theme.excerpt_description or not is_index) %&#125; &lt;div class=&quot;post-description&quot;&gt;&#123;# #&#125;&#123;&#123; post.description &#125;&#125;&#123;# #&#125;&lt;/div&gt; &#123;% endif %&#125; ................在新建的文章添加一个字段属性：summary_img。summary_img 的值是图片的链接或者路径，若为空则不加入封面图片如：12345678---title: testdate: categories: tags: comments: summary_img: https://什么什么.png---使用方法二，可以配合修改插入图片大小来实现封面大小调整如果你加入了修改图片大小的代码，这时候直接在summary_img: 中填写图片链接，显示大小会是你设置的大小。为了方便以后使用在根目录下scaffolds文件夹打开post.md,增加summary_img:属性1234567title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: categories: copyright: true photos: //填写你的封面url地址summary_img: //填写你的封面url地址两个方法可同时开启，想用哪个用哪个。文章加密访问博客根目录下npm install --save hexo-blog-encrypt在站点配置文件中添加123456# Securityencrypt: # hexo-blog-encrypt enable: true tags: # 配置标签加密 - &#123;name: test, password: test&#125; - &#123;name: diary, password: diary&#125;然后在你的文章的头部添加上对应的字段，如 password, abstract, message在在根目录下scaffolds文件夹打开post.md增加passward: abstract: message:123456789title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: categories: copyright: true photos:passwprd: abstract: Something was encrypted, please enter password to read.message: Welcome to my blog, please enter password to read.这样以后写文章后password项 为空则不需要密码，输入内容则为密码。password: 是该博客加密使用的密码abstract: 是该博客的摘要，会显示在博客的列表页message: 这个是博客查看时，密码输入框上面的描述性文字标签加密，加密模板更改等查看：https://github.com/MikeCoder/hexo-blog-encrypt/blob/v2.x/ReadMe.zh.md博文置顶功能安装插件12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --savew然后在需要置顶的文章的Front-matter中加上top: 任意数字即可。例如：12345678title: testcopyright: truedate: 2019-08-27 22:11:44tags:categories:photos:password:top: 10多个置顶，数字越大，置顶越靠前，若TOP值为空则默认时间排序设置置顶标志打开：/blog/themes/next/layout/_macro 目录下的post.swig文件，定位到&lt;div class=&quot;post-meta&quot;&gt;标签下，插入如下代码：12345&#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125;例：修改模板文件，方便以后使用在根目录下scaffolds文件夹打开post.md,增加top属性12345678title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: categories: copyright: true photos:password: top:自定义鼠标样式自定义鼠标样式在themes\next\source\css\_custom的custom.styl文件中添加123* &#123; cursor: url(&quot;https://你的鼠标样式.ico&quot;),auto!important &#125;需要是ico或者cur文件，将你的链接填进去就行了。添加评论功能（来必力）到官网注册账号选择City版（免费），安装。（会生成 来必力City版安装代码以及 data-uid ，或者 进入管理页面-&gt;代码管理-&gt;一般网站，可以查看）然后打开主题目录的配置文件/next/_config.yml，定位到livere_uid字段，将UID填入即可1234# LiveRe comments system# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: //填写你的UID自定义文章的评论开启与关闭：在根目录下scaffolds文件夹打开post.md,增加comments:属性123456789title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: categories: copyright: true photos:password: top:comments:这样新建文章填写comments：true/false 来开启/关闭本文章的评论功能，空写为默认开启。以前的文章可以手动加入。预览文章标题与文章留白间距修改默认留白太大了，不美观，我们自行修改。在themes\next\source\css\_custom打开custom.styl文件添加：123.posts-expand .post-meta &#123; margin: 10px 0 10px 0;&#125;效果:觉得不够的话自己修改值就行。写文章时文字增加背景色块打开themes/next/source/css/_custom/custom.styl,增加以下内容：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/ /颜色块-黄span#inline-yellow &#123;display:inline;padding:.2em .6em .3em;font-size:80%;font-weight:bold;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0;background-color: #f0ad4e;&#125;// 颜色块-绿span#inline-green &#123;display:inline;padding:.2em .6em .3em;font-size:80%;font-weight:bold;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0;background-color: #5cb85c;&#125;// 颜色块-蓝span#inline-blue &#123;display:inline;padding:.2em .6em .3em;font-size:80%;font-weight:bold;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0;background-color: #2780e3;&#125;// 颜色块-紫span#inline-purple &#123;display:inline;padding:.2em .6em .3em;font-size:80%;font-weight:bold;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0;background-color: #9954bb;&#125;写文章时候格式&lt;span id=&quot;inline-颜色&quot;&gt;内容&lt;/span&gt;例如:&lt;span id=&quot;inline-blue&quot;&gt;蓝色背景块&lt;/span&gt;样式如下：蓝色背景块添加其他颜色背景块打开themes/next/source/css/_custom/custom.styl,增加：12345678910111213span#inline-你增加的颜色名字 &#123;display:inline;padding:.2em .6em .3em;font-size:80%;font-weight:bold;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0;background-color: 修改为你喜欢的颜色代码;&#125;例如：新增灰色背景块修改引用边框颜色打开themes/next/source/css/_custom/custom.styl,增加以下内容：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150// 左侧边框红色块级p#div-border-left-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#125;// 左侧边框黄色块级p#div-border-left-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #f0ad4e;&#125;// 左侧边框绿色块级p#div-border-left-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #5cb85c;&#125;// 左侧边框蓝色块级p#div-border-left-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #2780e3;&#125;// 左侧边框紫色块级p#div-border-left-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #9954bb;&#125;// 右侧边框红色块级p#div-border-right-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #df3e3e;&#125;// 右侧边框黄色块级p#div-border-right-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #f0ad4e;&#125;// 右侧边框绿色块级p#div-border-right-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #5cb85c;&#125;// 右侧边框蓝色块级p#div-border-right-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #2780e3;&#125;// 右侧边框紫色块级p#div-border-right-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #9954bb;&#125;// 上侧边框红色p#div-border-top-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #df3e3e;&#125;// 上侧边框黄色p#div-border-top-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #f0ad4e;&#125;// 上侧边框绿色p#div-border-top-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #5cb85c;&#125;// 上侧边框蓝色p#div-border-top-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #2780e3;&#125;// 上侧边框紫色p#div-border-top-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #9954bb;&#125;写文章时候的格式&lt;p id=&quot;div-border-位置-颜色&quot;&gt;内容&lt;/p&gt;例如&lt;p id=&quot;div-border-top-blue&quot;&gt;顶部蓝色&lt;/p&gt;的效果如下:顶部蓝色自行增加颜色修改哪一类就找哪一类，例如修改上部就找下面:打开themes/next/source/css/_custom/custom.styl,增加：12345678910// X侧边框X色p#div-border-位置-颜色位置 &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px; //宽度border-radius: 3px; //border-top-color: 你的颜色代码;&#125;例如：新增右侧灰色边框：右侧灰色主题自带样式写作说明生成引号的文本居中引用语法:1&#123;% cq %&#125;内容&#123;% endcq %&#125;样例：123456&#123;% cq %&#125;人生乃是一面镜子，从镜子里认识自己，我要称之为头等大事，也只是我们追求的目的！&#123;% endcq %&#125;人生乃是一面镜子，从镜子里认识自己，我要称之为头等大事，也只是我们追求的目的！作者声明标明的引用语法:1&#123;% blockquote 作者 %&#125;内容&#123;% endblockquote %&#125;例如：1&#123;% blockquote --JunYuan %&#125;Test&#123;% endblockquote %&#125;Test--JunYuan主题自带样式note标签语法:1&lt;div class=&quot;note 名称&quot;&gt;&lt;p&gt;内容&lt;/p&gt;&lt;/div&gt;名称为：default/primary等下面名称default（灰色）灰色样式primary(紫色)紫色样式success（绿色）绿色样式info(蓝色)蓝色样式warning(橙色样式)橙色样式danger（红色样式）红色样式2. 在**主题配置文件**`_config.yml`下可以修改note标签的风格，和开关其中的图标显示。修改后需要重新hexo s才会显示123456789101112note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: flat //选择你的样式simple/modern/flat icons: false //是否开启note图标显示。 border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0图标显示:不显示：note样式自行选择不再演示。主题自带样式lable标签主题配置文件 中需要配置下，没有自行添加:12# Label tag.label: true语法:1&#123;% label default@default %&#125;@ 前面的是label的名字，后面的是要显示的文字1&#123;% label primary@测试primar显示效果 %&#125;测试样例:测试primar显示效果主题自带样式的tab标签（选项卡）在 主题配置文件 中需要配置,没有的自行添加：1234567# Tabs tag.tabs: enable: true transition: tabs: true labels: true border_radius: 0语法:1234567891011&#123;% tabs %&#125; &lt;!-- tab --&gt;内容1&lt;!-- endtab --&gt;&lt;!-- tab --&gt;内容2&lt;!-- endtab --&gt;&lt;!-- tab --&gt;内容3&lt;!-- endtab --&gt;&#123;% endtabs %&#125;说明：123说明：&#123;% tabs %&#125; 中可添加选项卡名称和初次出现在第几个选项卡,否则默认按数字生成名称，初次显示为第一个选项卡。若数字为-1则为隐藏选项卡内容，点击才出现。例如:下面设置的效果：1234567891011&#123;% tabs 测试,2%&#125;&lt;!-- tab --&gt;内容1&lt;!-- endtab --&gt;&lt;!-- tab --&gt;内容2&lt;!-- endtab --&gt;&lt;!-- tab --&gt;内容3&lt;!-- endtab --&gt;&#123;% endtabs %&#125;测试 1测试 2测试 3内容1内容2内容3主题自带样式的按钮语法:12&lt;a id=&quot;download&quot; href=&quot;https://地址&quot;&gt;&lt;i class=&quot;fa fa-图标名&quot;&gt;&lt;/i&gt;&lt;span&gt; 内容&lt;/span&gt;&lt;/a&gt;例如12&lt;a id=&quot;download&quot; href=&quot;https://www.baidu.com&quot;&gt;&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;&lt;span&gt;百度&lt;/span&gt;&lt;/a&gt;&lt;a id=&quot;download&quot; href=&quot;https://www.baidu.com&quot;&gt;&lt;i class=&quot;fa fa-download&quot;&gt;&lt;/i&gt;&lt;span&gt;点我下载&lt;/span&gt;&lt;/a&gt; 百度 点我下载图标名称来自Font Awesome主题自带样式的更多内容https://hexo.io/docs/tag-plugins.html# 文中添加图标语法：&lt;i class=&quot;fa fa-图标名&quot;&gt;&lt;/i&gt;例如：1我想使用下载图标:&lt;i class=&quot;fa fa-download&quot;&gt;&lt;/i&gt;,使用心性图标&lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt;。我想使用下载图标:,使用心性图标。自定义数字显示打开\themes\next\source\css\_custom中的custom.styl文件添加代码:12345678910// 自定义的数字块span#inline-toc &#123; display: inline-block; border-radius: 80% 100% 90% 20%; background-color: rgb(227, 242, 253); color: #555; padding: 0.05em 0.4em; margin: 2px 5px 2px 0px; line-height: 1.5;&#125;语法:&lt;span id=&quot;inline-toc&quot;&gt;你的数字&lt;/span&gt;样例：1测试：&lt;span id=&quot;inline-toc&quot;&gt;1558888&lt;/span&gt;测试：1558888插入视频Ⅰ.直接用标签1.使用iframe标签很多大型视频网站的分享功能都会带一个嵌入我们可以获得iframe标签来插入，很方便12&lt;iframe width=&quot;100%&quot; height=&quot;480&quot; src=&quot;播放源&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;//可自行更改width和height,百分比或者数值都可以2.使用Video标签1&lt;video width="100%" height="100%" controls&gt;&lt;source src="地址或者什么什么.mp4等类型地址"&gt;&lt;/video&gt;样例演示：1&lt;video width=&quot;100%&quot; height=&quot;100%&quot; controls&gt;&lt;source src=&quot;https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/%E8%A7%86%E9%A2%91/Miracles-Axel%20Johansson%20%20Tina%20Stachowiak.mp4&quot;&gt;&lt;/video&gt;如下：3.其他标签如embed、object等自行百度。由于iframe不能自己觉得是否自动播放，这里使用了video标签作为演示## Ⅱ.使用Dplayer插件播放在博客根目录下npm install hexo-tag-dplayer --save使用格式：1&#123;% dplayer &quot;url=http://什么什么.mp4&quot; &quot;pic=http://什么什么.jpg&quot; &quot;loop=yes&quot; &quot;theme=#FADFA3&quot; &quot;autoplay=false&quot; &quot;token=tokendemo&quot; %&#125;其他参数和使用方法：点我查看静态资源压缩因为使用gulp老是出错，所以换了hexo-neat插件根据该文配置即可根目录下npm install hexo-neat --save站点配置文件添加12345678910111213141516171819202122# hexo-neat# 博文压缩neat_enable: true# 压缩htmlneat_html: enable: true exclude:# 压缩css neat_css: enable: true exclude: - &apos;**/*.min.css&apos;# 压缩jsneat_js: enable: true mangle: true output: compress: exclude: - &apos;**/*.min.js&apos; - &apos;**/jquery.fancybox.pack.js&apos; - &apos;**/index.js&apos;使用直接hexo三连即可。注意neat 的使用可能会导致一些我们添加的效果失效。如鼠标点击爆炸效果。我们需要将配置中的 JS选项的enable:的值该为false即可。SEO优化参考以下博主的方法即可hexo 博客百度站长平台自动链接提交hexo高阶教程：教你怎么让你的hexo博客在搜索引擎中排第一SEOHexo博客Next主题SEO优化方法Hexo-next百度和谷歌搜索优化感谢最后特别感谢这些文章的帮助：1.关于Hexo6.0搭建个人博客(主题优化进阶篇)2.Hexo主题 —— NexT优化3.Hexo的Next主题详细配置4.【持续更新】最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析5.Hexo博客Next主题优化总结6.hexo的next主题个性化配置教程7.Hexo Next 博客自定义配置8.关于Hexo6.0搭建个人博客(主题优化高级篇)9.Hexo框架下用NexT(v7.0+)主题美化博客10.hexo-next主题下的美化11.NexT主题的配置和优化指南12.Hexo+NexT 打造一个炫酷博客14.Hexo 添加Aplayer播放器15.Hexo NexT主题中添加网页音乐播放器功能16.Hexo搭建个人博客系列17.打造个性超赞博客 Hexo + NexT + GitHub Pages 的超深度优化]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>hexo美化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-Next主题美化]]></title>
    <url>%2Fposts%2F2063%2F</url>
    <content type="text"><![CDATA[配置博客基本信息在站点根目录下_config.yml中进行基础配置我使用Notepad++打开编辑，也可以直接使用记事本，推荐Sublime Text，但是下载和安装汉化插件需要链外网说明:hexo 下的config.yml 称为站点配置文件_themes/主题名 中的_config.yml 称为主题配置文件常用languageLanguageExampleCode🇨🇳 Chinese (Simplified)简体中文zh-CN🇹🇼 Chinese (Traditional)繁體中文zh-TW🇭🇰 Chinese (Hong Kong)繁體中文-香港zh-HK🇺🇸 EnglishEnglishen🇯🇵 Japanese日本語ja🇰🇷 Korean한국어ko常用语言需要在主题下的language目录里检查是否含有该语言配置文件例如在NexT主题下，中文不能使用zh-Hans①可以写zh-CN②可以将主题文件下的zh-CN改名为zh-Hans超链接颜色修改要修改的body超链接的样式在themes\next\source\css\_common\components\post\post.styl里,在这里添加条目:1234.post-body a &#123; color: #428BCA;//字体为蓝色 font-weight: bold;//字体为粗体，不想使用可以删除&#125;也可以添加如下文本链接为蓝色，鼠标放上去为橙色12345678910.post-body p a &#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 新连接图示菜单设置在主题配置文件下找到以下代码：123456789menu: home: / || home //首页 #about: /about/ || user //关于 #tags: /tags/ || tags //标签 #categories: /categories/ || th //分类 archives: /archives/ || archive //归档 #schedule: /schedule/ || calendar //日程表 #sitemap: /sitemap.xml || sitemap //站点地图 #commonweal: /404/ || heartbeat //公益404需要哪个就把取消注释关掉（就是删除前面的#）NexT分主题设置同样在主题配置文件中，找到Scheme Settings12345# Schemesscheme: 选择你喜欢的主题#scheme: Mist#scheme: Pisces#scheme: Gemini侧栏设置侧栏设置包括：侧栏位置、侧栏显示与否、文章间距、返回顶部按钮等等打开 主题配置文件 找到sidebar字段12345678910111213141516sidebar:# Sidebar Position - 侧栏位置（只对Pisces | Gemini两种风格有效） position: left //靠左放置 #position: right //靠右放置# Sidebar Display - 侧栏显示时机（只对Muse | Mist两种风格有效） #display: post //默认行为，在文章页面（拥有目录列表）时显示 display: always //在所有页面中都显示 #display: hide //在所有页面中都隐藏（可以手动展开） #display: remove //完全移除 offset: 12 //文章间距（只对Pisces | Gemini两种风格有效） b2t: false //返回顶部按钮（只对Pisces | Gemini两种风格有效） scrollpercent: true //返回顶部按钮的百分比头像设置打开 主题配置文件 找到Sidebar Avatar字段1234567url: /images/avatar.gif# If true, the avatar would be dispalyed in circle.rounded: true# The value of opacity should be choose from 0 to 1 to set the opacity of the avatar.opacity: 1# If true, the avatar would be rotated with the cursor.rotated: true这是头像的路径，只需把你的头像命名为header.jpg（随便命名）放入themes/next/source/images中，将avatar的路径名改成你的头像名就OK啦！也可以直接使用图片链接例如：http://example.com/avatar.png在Next7.X版本下可以：rounded:决定是否使用圆形图像（true/false）rotated：决定是否使用头像选择（true/false）opacity：头像透明度（0~1）如果是椭圆的是因为原图片不是方形的，找一个宽高像素一样的图片即可，之前版本不知道支持不支持代码高亮设置在站点配置文件_config.yml中搜索highlight修改如下12345highlight: enable: true line_number: true auto_detect: true tab_replace:在站点配置文件_config.yml中搜索highlight修改highlight_theme: normal中normal改为你喜欢的 ：normalnightnight eightiesnight bluenight bright添加阅读全文按钮，和其按键样式修改。是文章不再全部展示，添加阅读文章选项，选择阅读。方法一：1在你的文章中添加&lt;!--more--&gt;,你想再哪儿截止就在哪儿添加方法二：在主题配置文件_config.yml 下搜索auto_excerpt123auto_excerpt: enable: true //改为true即启用 length: 50 //多少字开始文章折叠，自行设置同时使用方法1和方法2时会以一为准修改样式：找到themes\next\source\css\_custom\custom.styl文件,添加下面代码块：12345678910111213141516171819// [Read More]按钮样式.post-button .btn &#123; color: #555 !important; background-color: rgb(255, 255, 255); border-radius: 3px; font-size: 15px; box-shadow: inset 0px 0px 10px 0px rgba(0, 0, 0, 0.35); border: none !important; transition-property: unset; padding: 0px 15px;&#125;.post-button .btn:hover &#123; color: rgb(255, 255, 255) !important; border-radius: 3px; font-size: 15px; box-shadow: inset 0px 0px 10px 0px rgba(0, 0, 0, 0.35); background-image: linear-gradient(90deg, #a166ab 0%, #ef4e7b 25%, #f37055 50%, #ef4e7b 75%, #a166ab 100%);&#125;修改网站标题栏背景颜色打开 themes/*/source/css/_custom/custom.styl ,在里面写下如下代码：123.site-meta &#123; background: #FF8C00; //修改为自己喜欢的颜色&#125;点击侧栏头像返回主页打开/themes/next/layout/_macro/sidebar.swig 找到下面代码123&lt;img class=&quot;site-author-image&quot; itemprop=&quot;image&quot; src=&quot;&#123;&#123; url_for( theme.avatar | default(theme.images + &apos;/avatar.gif&apos;) ) &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125;&quot; /&gt;在其前后加上&lt;a href=&quot;/&quot;&gt;&lt;/a&gt;即可,如下：12345&lt;a href=&quot;/&quot;&gt; &lt;img class=&quot;site-author-image&quot; itemprop=&quot;image&quot; src=&quot;&#123;&#123; url_for( theme.avatar | default(theme.images + &apos;/avatar.gif&apos;) ) &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125;&quot; /&gt;&lt;/a&gt;添加分类模块1、新建一个分类页面1$ hexo new page categories2、你会发现你的source文件夹下有了categorcies/index.md，打开index.md文件进行编辑1234title: 分类 date: 你的时间,会自动创建. type: &quot;categories&quot; comments: false3、打开 主题配置文件 找到menu，将categorcies取消注释4、把文章归入分类只需在文章的顶部标题下方添加categories字段，即可自动创建分类名并加入对应的分类中例：12title: 分类测试文章标题categories: 分类名添加标签模块1、新建一个标签页面1$ hexo new page tags2、你会发现你的source文件夹下有了tags/index.md，打开index.md文件进行编辑1234title: 标签date: 你的时间,会自动创建.type: &quot;tags&quot;comments: false3、打开 主题配置文件 找到menu，将tags取消注释4、把文章添加标签只需在文章的顶部标题下方添加tags字段，即可自动创建标签名并归入对应的标签中举个栗子：12345title: 标签测试文章标题tags: - 标签1 - 标签2 ...添加多个标签注意不要在第一行写添加关于模块1、新建一个关于页面1$ hexo new page about2、你会发现你的source文件夹下有了about/index.md，打开index.md文件即可编辑关于你的信息，可以随便编辑。3、打开 主题配置文件 找到menu，将about取消注释4、进行内容编辑添加搜索功能1、安装 hexo-generator-searchdb 插件1$ npm install hexo-generator-searchdb --save2、打开 站点配置文件 找到Extensions在下面添加123456# 搜索search: path: search.xml field: post format: html limit: 100003、打开 主题配置文件 找到Local search，将enable设置为true个人社交连接修改theme/_config.yaml文件下的social属性，按照格式设置即可：例：123social: GitHub: https://github.com/yourname || github Bilibili: https://space.bilibili.com/yournum || bilibili||右边为FontAwesome图标名称可自行更改图标取自https://fontawesome.com/icons?from=io友情链接添加在主题配置文件_config.yml下搜索links ：注意设置：12links_layout: block # 一行显示一个链接links_layout: inline #紧凑显示链接然后在下面自行添加好友的链接，或者随意：123456links: #Title: http://example.com 百度: https://www.baidu.com/ 谷歌: https://www.google.com/?hl=zh_CN 知乎: https://www.zhihu.com/ 掘金: https://juejin.im/新建文章模板更改在根目录下scaffolds文件夹打开post.md123456title: &#123;&#123; title &#125;&#125;//题目date: &#123;&#123; date &#125;&#125;//日期tags: //标签 categories: //分类copyright: true //版权信息说明photos: //主页文章显示图片修改文章底部标签的符合“#”修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;设置网站LOGO去别的网站下载或者制作ioc图标32*32，并将图标名称改为favicon.ico，然后把图标放在/themes/next/source/images里，并且修改主题配置文件：找到字段favicon:12345favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg可以看到有四种效果,一般我们只需将medium换成我们自己图标路径就行了。使用动态背景在主题配置文件_config.yml 下搜索canvas123456789101112131415161718# Canvas-nest# Dependencies: https://github.com/theme-next/theme-next-canvas-nestcanvas_nest: enable: true onmobile: true # display on mobile or not color: &quot;0,0,255&quot; # RGB values, use &apos;,&apos; to separate 颜色 opacity: 0.5 # the opacity of line: 0~1 透明度我改成1 zIndex: -1 # z-index property of the background count: 99 # the number of lines 修改线的数量 我改成240# JavaScript 3D library.# Dependencies: https://github.com/theme-next/theme-next-three# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false需要启用哪个，哪个就改成true网上都是这么说的，但是我使用后没反应。后来发现得下载下来才可以。1.进入theme/next目录2.git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest3.从新开启网页即可。其他三种也需要下载才能使用使用加载进度条同样类似动态背景，我们直接启用config是不行的，需要先下载。1.进入theme/next目录2.git clone https://github.com/theme-next/theme-next-pace source/lib/pace3.在主题配置文件_config.yml 下搜索pace123456pace: true# Themes list:# pace-theme-big-counter | pace-theme-bounce | pace-theme-barber-shop | pace-theme-center-atom# pace-theme-center-circle | pace-theme-center-radar | pace-theme-center-simple | pace-theme-corner-indicator# pace-theme-fill-left | pace-theme-flash | pace-theme-loading-bar | pace-theme-mac-osx | pace-theme-minimalpace_theme: pace-theme-center-atompace: 改为truepace_theme: 从上面选择其中一个修改博客底部显示隐藏网页底部powered By Hexo打开themes/next/layout/_partials/footer.swig,直接隐藏以下代码即可,建议不要删除，即添加&lt;!--和--&gt;代码如下:123456789101112131415161718&lt;!--&#123;% if theme.footer.powered.enable %&#125; &lt;div class=&quot;powered-by&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot;&apos; + nofollow + &apos; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&#123;% if theme.footer.powered.version %&#125; v&#123;&#123; hexo_env(&apos;version&apos;) &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.powered.enable and theme.footer.theme.enable %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.footer.theme.enable %&#125; &lt;div class=&quot;theme-info&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; &amp;mdash; &#123;# #&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot;&#123;&#123; nofollow &#125;&#125; href=&quot;https://github.com/theme-next/hexo-theme-next&quot;&gt;&#123;# #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;# #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; version &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;--&gt;修改网页底部桃心还是打开themes/next/layout/_partials/footer.swig，找到字段with-love;123&lt;span class=&quot;with-love&quot; id=&quot;animate&quot;&gt; &lt;i class=&quot;fa fa-&#123;&#123; theme.footer.icon.name &#125;&#125;&quot;&gt;&lt;/i&gt; &lt;/span&gt;然后在图标库中找到你想要的图标,修改如下:123&lt;span class=&quot;with-love&quot; id=&quot;animate&quot;&gt; &lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt; &lt;/span&gt;其中heart为图标名字,只要icon-后面的就行了;实现网站底部访问量显示和全站字数显示打开主题配置文件_config.yml,修改如下代码:12345678busuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye使用该方法是以icon图标显示。我们也可以直接修改\layout\_partials\footer.swig文件。在文件第一行添加1&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;在最后添加12345678910111213141516171819202122&lt;!-- 不蒜字统计 --&gt;&lt;div&gt; &lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 访问人数：&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; &lt;/span&gt;&amp;nbsp;|&amp;nbsp; &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 总访问量：&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; &lt;/span&gt;&amp;nbsp;|&amp;nbsp; &lt;!-- 添加博客全站总字数统计--&gt; &lt;i class=&quot;fa fa-pencil&quot;&gt;&lt;/i&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共 &#123;&#123; totalcount(site) &#125;&#125; 字&lt;/span&gt;&lt;/div&gt; &#123;% if theme.footer.custom_text %&#125; &lt;div class=&quot;footer-custom&quot;&gt;&#123;# #&#125;&#123;&#123; theme.footer.custom_text &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;文字统计功能需要安装npm install hexo-wordcount --save让心变红并且跳起来首先修改主题配置文件：12文件位置：~/hexo/themes/next/_config.ymlcopyfooter: icon: user修改成heart然后修改footer.swig：12文件位置：~/hexo/themes/next/layout/_partials/footer.swigcopy&lt;span class=&quot;with-love&quot;&gt;修改成&lt;span class=&quot;with-love&quot; id=&quot;heart&quot;&gt;接着编辑custom.styl：1文件位置：~/hexo/themes/next/source/css/_custom/custom.styl在其中加入1234567891011121314151617// 自定义页脚跳动的心样式@keyframes heartAnimate&#123; 0%,100%&#123;transform:scale(1);&#125; 10%,30%&#123;transform:scale(0.9);&#125; 20%,40%,60%,80%&#123;transform:scale(1.1);&#125; 50%,70%&#123;transform:scale(1.1);&#125;&#125;#heart &#123; animation: heartAnimate 1.33s ease-in-out infinite;&#125;.with-love &#123; color: rgb(255, 0, 0);&#125;其中color的值可以改成你自己喜欢的，RGB颜色这里:https://tool.oschina.net/commons?type=3显示网站运行时间在themes/layout/_parrials/footer.swing 中添加：1234567891011121314151617181920212223242526&lt;span&gt;本站已运行&lt;span id=&quot;showDays&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;script&gt; var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var birthDay = Date.UTC(2019,08,01,14,00,00); // 这里设置建站时间 setInterval(function() &#123; var today = new Date(); var todayYear = today.getFullYear(); var todayMonth = today.getMonth()+1; var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); var now = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond); var diff = now - birthDay; var diffYears = Math.floor(diff/years); var diffDays = Math.floor((diff/days)-diffYears*365); var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours); var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes); var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds); document.getElementById(&apos;showDays&apos;).innerHTML=&quot;&quot;+diffYears+&quot;年&quot;+diffDays+&quot;天&quot;+diffHours+&quot;小时&quot;+diffMinutes+&quot;分钟&quot;+diffSeconds+&quot;秒&quot;; &#125;, 1000);&lt;/script&gt;文末添加版权声明主题配置文件_config.yml下搜索creative_commons:12345creative_commons: license: by-nc-sa sidebar: false post: false language:将post后面改为true之后在站点配置文件_config.yml下修改url，改成你的域名，否则版权本文链接显示不是你的站点名：123456# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://lyxf.liveroot: /permalink: :year/:month/:day/:title/permalink_defaults:文末添加结束语在路径\themes\next\layout\_macro中新建passage-end-tag.swig文件,并添加以下内容：12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #555;font-size:14px;&quot;&gt;-------------------本文结束 &lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt; 感谢阅读-------------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt;接着打开\themes\next\layout\_macro\post.swig文件，在end post body后加代码：12345678910&#123;#####################&#125; &#123;### END POST BODY ###&#125; &#123;#####################&#125;//添加 &lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt;//结束需要重新hexo s 才会生效效果如下：文章浏览进度显示和回到顶部功能在主题配置文件_config.yml下找back2top:123456back2top: enable: true # Back to top in sidebar. sidebar: false # Scroll percent label in b2t button. scrollpercent: false全部改为true即可。图片放大查看功能打开主题配置文件_config.yml，搜索fancybox字段，设置其值为true进入到theme/next/文件夹下，打开git bash，1git clone https://github.com/theme-next/theme-next-fancybox3 source/lib/fancybox给页面添加背景图片在themes\next\source\css\_custom目录下custom文件添加1234567891011body &#123; background: url(填写背景图链接) no-repeat; /* 背景图垂直、水平均居中 */ background-position: center center; /* 当内容高度大于图片高度时，背景图像的位置相对于viewport固定 */ background-attachment: fixed; /* 让背景图基于容器大小伸缩 */ background-size: cover; /* 设置背景颜色，背景图加载过程中会显示背景色 */ background-color: rgba(0, 0, 0, 0.5);&#125;页面透明度修改在themes\next\source\css\_custom目录下custom文件添加123456789.header-inner&#123; opacity: 0.8; &#125;.main-inner &#123; // margin-top: 60px; // padding: 60px 60px 60px 60px; opacity: 0.8;&#125;.header-inner下为侧边栏透明度.main-inner下为主页面透明度添加页面阴影在themes\next\source\css\_custom目录下custom文件添加123456789// 主页文章添加阴影.post &#123; margin-top: 20px; //大小自行调整 margin-bottom: 20px; //大小自行调整 padding: 10px; //大小自行调整 -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125;文章界面添加字数显示和阅读时长功能在themes\next\layout_macro\post.swig文件中categories代码区域后面添加：1234567891011121314151617&lt;span class=&quot;post-time&quot;&gt; &amp;nbsp; | &amp;nbsp;&lt;span class=&quot;post-meta-item-icon&quot;&gt; &lt;i class=&quot;fa fa-calendar-o&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;span class=&quot;post-meta-item-text&quot;&gt;字数统计:&lt;/span&gt;&lt;span class=&quot;post-count&quot;&gt;&#123;&#123; wordcount(post.content) &#125;&#125;(字)&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;post-time&quot;&gt; &amp;nbsp; | &amp;nbsp;&lt;span class=&quot;post-meta-item-icon&quot;&gt;&lt;i class=&quot;fa fa-calendar-o&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;span class=&quot;post-meta-item-text&quot;&gt;阅读时长≈&lt;/span&gt;&lt;span class=&quot;post-count&quot;&gt;&#123;&#123; min2read(post.content) &#125;&#125;(分)&lt;/span&gt;&lt;/span&gt;小型代码块颜色修改打开\themes\next\source\css\ _variables\base.styl文件，找到下列代码段12345678// Code &amp; Code Blocks// --------------------------------------------------$code-font-family = $font-family-monospace$code-font-size = 14px$code-font-size = unit(hexo-config(&apos;font.codes.size&apos;), px) if hexo-config(&apos;font.codes.size&apos;) is a &apos;unit&apos;$code-border-radius = 3px$code-foreground = #fc6423 $code-background = #FFFACD$code-foreground = #fc6423指代码颜色$code-background = #FFFACD指背景颜色上面是我修改后的颜色，可以自行根据颜色代码修改。添加点击爆炸效果复制代码点击这里新建记事本，粘贴代码，改名为firework.js放入themes\next\source\js文件夹中打开\themes\next\layout\_layout.swig 文件。在最后，但是在&lt;/body&gt;前面添加12 &lt;!-- 页面点击礼花效果 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/firework.js&quot;&gt;&lt;/script&gt;重新hexo s即可需要不同效果只需要获取代码更改firework.js即可爆炸特效：点击这里爱心特效：点击这里文字特效：点击这里（PS:文字可自己更改）Pisces/Gemini主题修改主题内容宽度在source/css/_schemes/Picses/_layout.styl文件末尾添加如下代码：12345678910111213141516171819202122232425262728293031323334// 以下为新增代码！！header&#123; width: 90% !important; &#125;header.post-header &#123; width: auto !important;&#125;.container .main-inner &#123; width: 90%; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125;.header &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.container .main-inner &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.content-wrap &#123; +tablet() &#123; width: 100% !important; &#125; +mobile() &#123; width: 100% !important; &#125;&#125;几个百分比可以自行更改。后来我感觉原版就挺好就改回去了在页面右上角或者左上角实现fork me on github选择样式GitHub Ribbons,修改图片跳转链接,将&lt;a href=&quot;https://github.com/you&quot;&gt;中的链接换为自己Github链接：打开 themes/next/layout/_layout.swig 文件，把代码复制到&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面。文内跳转功能”锚点”的设置语法：123&lt;p id=&quot;XXX&quot;&gt;应该跳转到的地方的文字&lt;/p&gt;&lt;a href=&quot;#XXX&quot;&gt;你的跳转按钮的文字&lt;/a&gt;两个XXX为相同的，可以理解为做一个对接。相同的才会跳转，这样一篇文章可以使用多个锚点，只需要更改XXX即可测试跳转到上个问题添加爆炸效果：123&lt;p id=&quot;test&quot;&gt;添加点击爆炸效果&lt;/p&gt;&lt;a href=&quot;#test&quot;&gt;点我查看&lt;/a&gt;样例如下：点我查看部署在github上开启HTTPS在你的博客仓库下打开setting选项，找到Enforce HTTPS，打钩即可。因为感觉会影响加载速度，对百度爬取不友好，暂时不考虑开启HTTPs，等换个部署，配置优化加载后再考虑hexo链接优化之前的permalink是这样的permalink: :year/:month/:day/:title/四级url太过繁琐我们来使用hexo-abbrlink插件来优化。在根目录下npm install hexo-abbrlink --save在站点配置文件_config.yml中修改permalink为如下：12345permalink: :abbrlink/abbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hexpermalink_defaults:之后我们的链接就会是例如这样：http://lyxf.live/posts/2063/简单许多感谢最后特别感谢这些文章的帮助：1.关于Hexo6.0搭建个人博客(主题优化进阶篇)2.Hexo主题 —— NexT优化3.Hexo的Next主题详细配置4.【持续更新】最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析5.Hexo博客Next主题优化总结6.hexo的next主题个性化配置教程7.Hexo Next 博客自定义配置8.关于Hexo6.0搭建个人博客(主题优化高级篇)9.Hexo框架下用NexT(v7.0+)主题美化博客10.hexo-next主题下的美化11.NexT主题的配置和优化指南12.Hexo+NexT 打造一个炫酷博客14.Hexo 添加Aplayer播放器15.Hexo NexT主题中添加网页音乐播放器功能16.Hexo搭建个人博客系列17.打造个性超赞博客 Hexo + NexT + GitHub Pages 的超深度优化​]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>hexo美化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown文本写作的的进阶（进阶学习）]]></title>
    <url>%2Fposts%2F64191%2F</url>
    <content type="text"><![CDATA[一、颜色、字体和大小相关设置Ⅰ.文字的颜色、大小、字体设置：&lt;font color=填写颜色 size=填写大小 face=填写字体名字&gt;书写内容&lt;/font&gt;内容可以调换顺序SIZE的大小浏览器默认为3，我们可以1-7选择不需修改的东西可以不写例：&lt;font color=填写颜色&gt;书写内容&lt;/font&gt;只更改颜色字体一般用不到，但是可以改成宋体仿宋黑体楷体微软正黑体等等，百度HTML字体查询即可。Ⅱ.文字背景的颜色设置&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#bfe1f1&gt;文本内容&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;样例：背景色是：#bfe1f1-该编辑只能用在一行的开头Ⅲ.颜色代码颜色代码常用颜色可以直接打英文：redgreegreenblueorangeyellowgreyⅣ.文字居中位置设置1&lt;center&gt;这一行居中&lt;/center&gt;二、上标和下标书写Ⅰ.上标&lt;sup&gt;内容&lt;/SUP&gt;样例：232Ⅱ.下标&lt;SUB&gt;内容&lt;/SUB&gt;样例：X2三、导出文件Ⅰ.导出通过typora的文件选项中的导出，我们可以导出下列文件图像htmlPDFword文件需要下载使用 pandoc,我们可以不直接使用pandoc，安装后就可以直接使用typora进行转换了，安装后不行的话就重启机器即可四、插入图片的排版Ⅰ.插入原图片![](图片地址)一般直接使用图床复制黏贴即可Ⅱ.修改图片大小&lt;img width=&#39;宽度&#39; height=&#39;长度&#39; src=&quot;图片网址&quot;&gt;根据比例：&lt;img src=&quot;图片地址&quot; width=&quot;60%&quot;&gt;Ⅲ.修改图片位置（最终渲染网页文件根据主题变化，若不能变化可具体查找主题文件&gt;）&lt;img width = &quot;宽度&quot; height =&quot;长度&quot; src =&quot;图片网址&quot; align=&quot;位置&quot;&gt;位置包括居中：center居左：left居右：rightⅣ.图片并排放置（最终渲染网页文件根据主题变化，若不能变化可具体查找主题文件&gt;）123&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;图片地址&quot; width=&quot;30%&quot; &gt;&lt;img src=&quot;图片地址&quot; width=&quot;30%&quot; &gt;&lt;img src=&quot;图片地址&quot; width=&quot;30%&quot; &gt;&lt;/div&gt;]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Typora</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用typora进行Markdown文本写作（基础操作）]]></title>
    <url>%2Fposts%2F28758%2F</url>
    <content type="text"><![CDATA[一、基本快捷键MarkDown书写撤销：ctrl+z选中当前词语，多次按可以向前选择不同词语：ctrl+d选中当前行：ctrl+l开启/关闭源码模式：ctrl+z对内容加粗：ctrl+B下划线添加:ctrl+u进行倾斜体变换:ctrl+I对应MarkDown语言为两个‘*’。倾斜+加粗: 六个星号’*’搜索状态下按f3查找下一个。替换操作:ctrl+h==+内容+==可以使内容高亮。（该功能可能不支持博客显示，可用HTML支持进行操作）建立行内代码块:ctrl+shift+Tab键上面的飘号也可以使用两次Tab键上面的飘号来建立，但是需要转换shift使得飘号键可以打出来。建立代码块：ctrl+shift+k也可以使用三个Tab键上面的飘号来建立，三个飘号后面加语言可以直接写，不用再选择语言了。添加无序列表：++Space or - + Space or *+ Space无序列表状态+Tab可以调转为次级列表。无序列表状态+回车X2可以调转上一级无序列表。*添加有序列表: * 数字+小数点+Space自动生成，回车可继续按照顺序生成添加任务列表： -+ [Space]+Space生成任务列表,回车可继续生成 text1 测试2段落书写：ctrl+0ctrl+1~6为1到6级标题。分割线：三个或者更多‘-’删除线：四个波浪符号（shitf+波浪键），删除线测试。超链接操作：ctrl+k进行前面方括号写名字，后面小括号写地址。例如：百度 PS：需要加上http总之就是浏览器该网址地址的全部部分插入表格：ctrl+t第一行标题为加粗在左侧边框可以进行拖动在上侧边框可以进行列拖动ctrl+方向键直接在表格内移动不需要看光标位置表格内右键具有插入等更多功能支持网页端表格复制转换（直接复制后在空白处粘贴即可）引用使用:MarkDown语言比快捷键快捷，为&gt;+Space,PS: 只能用在行的开头快捷键为shift+ctrl+q.引用中的每行开头可以继续使用引用测试1测试2测试3几次引用就用几次回车退出注释：[^数字]之后在文末打上[^数字]：后面是描述。。。测试：AABBCCDD按不出^1的.上标：^内容^该功能可能不支持博客显示，可写好后用图片法插入测^试^下标：~内容~该功能可能不支持博客显示，可写好后用图片法插入测试内联公式：$公式$，$是美元符号,可以使用MathJax呈现LaTeX数学表达式，该功能可能不支持博客显示，可写好后用图片法插入$e^2$emoji::任意字母之后进行选择 PS:冒号是英文冒号，该功能可能不支持博客显示，可写好后用图片法插入:umbrella:*进行图片插入操作: *shift+ctrl+i也可以直接拖动图片进入。复制网络图片的地址直接粘贴利用微博图床,复制该图网址，进行上传目录生成：[toc]（该功能不支持某些主题，但是某些博客主题自带完成的目录功能，例如：NexT）[TOC]二、MarkDown的拓展书写HTML的支持，进行自定义图片大小和缩放。LaTex公式支持流程图支持（Mermaid，Flowchart，Sequence）比较实用的Mermaid,该功能不支持博客，可以输出图片进行插入。12345graph TD;开始--&gt;条件A;开始--&gt;条件B;条件A--&gt;结束;条件B--&gt;结束;]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Typora</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
</search>
