<!-- build time:Tue Oct 12 2021 10:18:24 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link rel="stylesheet" href="/lib/pace/pace-theme-center-atom.min.css?v=1.0.2"><meta name="google-site-verification" content="4fXg7_br-6EcJkwb-a6Ci2NLdRf7aMleAsM1L9S1nBI"><link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="/css/main.css?v=7.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/2.ico?v=7.2.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/1.ico?v=7.2.0"><link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.2.0",sidebar:{position:"left",display:"post",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!0,fancybox:!0,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="一、关系数据理论问题——什么是一个好的数据库逻辑设计?关系模式存在的问题 ：数据冗余度太大，浪费存储空间更新异常（Update Anomalies）插入异常（Insertion Anomalies），该插入的数据插不进去删除异常（Deletion Anomalies），不该删除的数据也删去了好的模式不会发生插入异常、删除异常、更新异常、数据冗余应尽可能少。这是由于模式中的某些数据依赖引起的。1、数"><meta name="keywords" content="数据库系统概论"><meta property="og:type" content="article"><meta property="og:title" content="数据库系统概论【五】"><meta property="og:url" content="http://lyxf2000.github.io/posts/ca3f1943/index.html"><meta property="og:site_name" content="乐屿心扉"><meta property="og:description" content="一、关系数据理论问题——什么是一个好的数据库逻辑设计?关系模式存在的问题 ：数据冗余度太大，浪费存储空间更新异常（Update Anomalies）插入异常（Insertion Anomalies），该插入的数据插不进去删除异常（Deletion Anomalies），不该删除的数据也删去了好的模式不会发生插入异常、删除异常、更新异常、数据冗余应尽可能少。这是由于模式中的某些数据依赖引起的。1、数"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20200422165022.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20200422165608.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20200422170425.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20200422175151.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20200430112705.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/1588819105382.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/1588819288849.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/1588819437551.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20200630103341.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20200630103359.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20200611092835.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20200611093054.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20200611122442.png"><meta property="og:updated_time" content="2021-03-15T08:17:40.289Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="数据库系统概论【五】"><meta name="twitter:description" content="一、关系数据理论问题——什么是一个好的数据库逻辑设计?关系模式存在的问题 ：数据冗余度太大，浪费存储空间更新异常（Update Anomalies）插入异常（Insertion Anomalies），该插入的数据插不进去删除异常（Deletion Anomalies），不该删除的数据也删去了好的模式不会发生插入异常、删除异常、更新异常、数据冗余应尽可能少。这是由于模式中的某些数据依赖引起的。1、数"><meta name="twitter:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20200422165022.png"><link rel="canonical" href="http://lyxf2000.github.io/posts/ca3f1943/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>数据库系统概论【五】 | 乐屿心扉</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">乐屿心扉</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">Keep Thinking</h1></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-playlist"><a href="/playlist/" rel="section"><i class="menu-item-icon fa fa-fw fa-music"></i><br>歌单</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://lyxf2000.github.io/posts/ca3f1943/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="峻源"><meta itemprop="description" content="乐于心，乐与心，乐之屿，心扉间"><meta itemprop="image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="乐屿心扉"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">数据库系统概论【五】</h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-04-22 15:11:31" itemprop="dateCreated datePublished" datetime="2020-04-22T15:11:31+08:00">2020-04-22</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-03-15 16:17:40" itemprop="dateModified" datetime="2021-03-15T16:17:40+08:00">2021-03-15</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库系统概论/" itemprop="url" rel="index"><span itemprop="name">数据库系统概论</span></a></span> </span><span class="post-time">&nbsp; | &nbsp; <span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">字数统计:</span> <span class="post-count">6.4k(字)</span> </span><span class="post-time">&nbsp; | &nbsp; <span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">阅读时长≈</span> <span class="post-count">22(分)</span></span><br><p></p></div></header><div class="post-body" itemprop="articleBody"><h2 id="一、关系数据理论"><a href="#一、关系数据理论" class="headerlink" title="一、关系数据理论"></a>一、关系数据理论</h2><hr><p><strong>问题——什么是一个好的数据库逻辑设计?</strong></p><p><strong>关系模式存在的问题 ：</strong></p><ul><li>数据冗余度太大，浪费存储空间</li><li>更新异常（Update Anomalies）</li><li>插入异常（Insertion Anomalies），该插入的数据插不进去</li><li>删除异常（Deletion Anomalies），不该删除的数据也删去了</li></ul><p><strong>好的模式不会发生插入异常、删除异常、更新异常、数据冗余应尽可能少。</strong></p><p><strong>这是由于模式中的某些数据依赖引起的。</strong></p><h3 id="1、数据依赖"><a href="#1、数据依赖" class="headerlink" title="1、数据依赖"></a>1、数据依赖</h3><p><strong>数据依赖是一个关系内部属性与属性之间的一种约束关系</strong>，通过属性间值的相等与否体现出来的数据间的相互联系。 是现实世界属性间相互联系的抽象、是数据内在的性质、<strong>是语义的体现</strong></p><ul><li><strong>函数依赖(Functional Dependency，简记为FD)</strong></li><li>多值依赖(Multivalued Dependency，简记为MVD)</li><li>连接依赖</li><li>……</li></ul><h3 id="2、关系模式的简化表示"><a href="#2、关系模式的简化表示" class="headerlink" title="2、关系模式的简化表示"></a>2、关系模式的简化表示</h3><p>R(U, D, DOM, F)</p><ul><li>R：关系名，是符号化的元组语义</li><li><strong>U：该关系的属性集合</strong></li><li>D：属性组U中属性所来自的域</li><li>DOM：属性向域的映象集合</li><li><strong>F：属性间数据的依赖关系集合</strong></li></ul><p>简化：<strong>R &lt;U,F&gt;</strong></p><p>影响数据库模式设计的主要是 <strong>该关系的属性集合U 和 属性间数据的依赖关系集合F</strong></p><h3 id="3、规范化-关系的规范化理论"><a href="#3、规范化-关系的规范化理论" class="headerlink" title="3、规范化-关系的规范化理论"></a>3、规范化-关系的规范化理论</h3><h4 id="1-函数依赖"><a href="#1-函数依赖" class="headerlink" title="(1)函数依赖"></a>(1)函数依赖</h4><p>设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，<strong>r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等则称“X函数确定Y”或“Y函数依赖于X”，记作X→Y。X称为这个函数依赖的决定属性组，也称为决定因素(Determinant)。</strong></p><blockquote><p><font size="4" color="red"><strong>将它想成函数，f（x）=y。所以！一个x只能对应一个值！而一个y可以对应多个x！</strong></font></p><p><font size="4" color="red"><strong>问题经常问的是“基本”函数依赖，就是根据语义写最直接的那个函数依赖</strong></font></p></blockquote><p>例： S(Sno, Sname, Ssex, Sage, Sdept)</p><p>F＝ {Sno→Sname，Sno→Ssex，Sno→Sage，Sno→Sdept}</p><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20200422165022.png" alt></p><p><font size="4" color="red"><strong>函数依赖是语义范畴的概念。只能根据数据的语义来确定函数依赖。</strong></font></p><h4 id="2-平凡函数依赖与非平凡函数依赖"><a href="#2-平凡函数依赖与非平凡函数依赖" class="headerlink" title="(2)平凡函数依赖与非平凡函数依赖"></a>(2)平凡函数依赖与非平凡函数依赖</h4><p>X→Y，Y⊈X，则称X→Y是非平凡的函数依赖。</p><p>X→Y，但Y⊆X ，则称X→Y是平凡的函数依赖。</p><p><strong>即推出的结果不在原因之内</strong></p><p>例：在关系SC(Sno, Cno, Grade)中，</p><p>非平凡函数依赖： (Sno, Cno) → Grade</p><p>平凡函数依赖： (Sno, Cno) → Sno (Sno, Cno) → Cno</p><p><strong>对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义，因此若不特别声明， 我们总是讨论非平凡函数依赖。</strong></p><h4 id="3-完全函数依赖与部分函数依赖"><a href="#3-完全函数依赖与部分函数依赖" class="headerlink" title="(3)完全函数依赖与部分函数依赖"></a>(3)完全函数依赖与部分函数依赖</h4><p><strong>完全函数依赖：</strong>设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。</p><p><strong>部分函数依赖：</strong>设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。</p><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20200422165608.png" alt></p><p><font size="4" color="red">*<em>即依据是最小的不能在缺少一个属性了就是完全函数依赖，能推出但是原因中的部分即可推出就是部分函数依赖 *</em></font></p><h4 id="4-传递函数依赖"><a href="#4-传递函数依赖" class="headerlink" title="(4)传递函数依赖"></a>(4)传递函数依赖</h4><p>在R（U，F）中，如果X→Y，（Y⊈X），<strong>Y↛X</strong>，Y→Z，则称Z对X传递函数依赖.记为：X → Z。</p><p><strong>注意: 如果Y→X, 即X←→Y，则Z直接依赖于X。</strong></p><p><font size="4" color="red"><strong>全部路径都是单向的才叫传递函数依赖</strong></font></p><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20200422170425.png" alt></p><h3 id="4、从函数依赖看码"><a href="#4、从函数依赖看码" class="headerlink" title="4、从函数依赖看码"></a>4、从函数依赖看码</h3><p>设K为关系模式R&lt;U，F&gt;中的属性或属性组合。</p><p><font size="4" color="red"><strong>问题问码是主码,因为主码可简称码</strong></font></p><p><font size="4" color="red"><strong>主码，候选码都简称码，如果题目中出现码这个字，需要我们自行根据上下文判断,一般是主码</strong></font></p><ul><li><p><strong>码是数据系统中的基本概念。所谓码就是能唯一标识实体的属性，他是整个实体集的性质，而不是单个实体的性质。它包括超码，候选码，主码。</strong></p></li><li><p><strong>若K → U（U完全依赖K），则K称为R的一个候选码(Candidate Key)。</strong></p><ul><li><font size="4" color="red"><strong>即K能够推出所有的其他属性，且为最小集。则K为候选码</strong></font></li></ul></li><li><ul><li><strong>候选码是最小的超码，即K的任意一个真子集都不是候选码</strong></li></ul></li><li><p><strong>主码：若关系模式R有多个候选码，则选定其中的一个做为主码(Primary key)。</strong></p></li><li><p><strong>主属性：包含在任何一个候选码中的属性 ，称为主属性（Prime attribute）</strong></p></li><li><p><strong>非主属性：不包含在任何码中的属性称为非主属性（Nonprime attribute）或非码属性（Non-key attribute）</strong></p></li><li><p><strong>全码：整个属性组是码，称为全码（All-key）</strong></p></li><li><p><strong>外码：关系模式 R&lt;U,F&gt;中属性或属性组X 并非 R的码，但 X 是另一个关系模式的码，则称 X 是R 的外部码（Foreign key）也称外码。</strong></p></li></ul><h3 id="5、范式"><a href="#5、范式" class="headerlink" title="5、范式"></a>5、范式</h3><p>范式是符合某一种级别的关系模式的集合。关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式。</p><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20200422175151.png" alt></p><ul><li><p><strong>第一范式（1NF）：的所有属性都是不可分的基本数据项</strong></p></li><li><p><strong>第二范式（2NF）:在第一范式的基础上，每一个非主属性都完全函数依赖于主属性</strong></p><ul><li><strong>主码若是单一属性则一定满足第二范式</strong></li><li><strong>投影解决</strong></li></ul></li><li><p><strong>第三范式（3ND）:在第二范式的基础上，非主键列必须直接依赖于主键，不能存在传递依赖</strong></p><ul><li><strong>即第二范式基础上，非主属性之间不能存在函数依赖</strong></li><li><strong>投影解决</strong></li></ul></li><li><p><strong>BC范式（BCNF）：在第三范式的基础上，每一个决定因素都包含候选键，也就是说，只要属性或属性组A能够决定任何一个属性B，则A的子集中必须有候选键。BCNF范式排除了任何属性(不光是非主属性，2NF和3NF所限制的都是非主属性)对候选键的传递依赖与部分依赖。</strong></p><ul><li><p><strong>即在第三范式的基础上，不能有主键依赖于非主键等情况(注意主键不一定是一个，可能是多组主键)。排除了任何属性对候选键的传递依赖与部分依赖。</strong></p></li><li><p>例如：学生ID和专业是联合主键这个表的设计满足三范式，有主键，不存在主键的部分依赖，不存在非主键的传递依赖。但是这里存在另一个依赖关系，“专业”函数依赖于“导师”，也就是说每个导师只做一个专业方面的导师，只要知道了是哪个导师，我们自然就知道是哪个专业的了。</p><table><thead><tr><th>StudentId</th><th>Major</th><th>Advisor</th><th>MajGPA</th></tr></thead><tbody><tr><td>1</td><td>人工智能</td><td>Edward</td><td>4.0</td></tr><tr><td>2</td><td>大数据</td><td>William</td><td>3.8</td></tr><tr><td>1</td><td>大数据</td><td>William</td><td>3.7</td></tr><tr><td>3</td><td>大数据</td><td>Joseph</td><td>4.0</td></tr></tbody></table></li><li><p><strong>投影解决</strong></p></li><li><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20200430112705.png" alt></p></li></ul></li></ul><blockquote><p>第二范式（2NF）和第三范式（3NF）的概念很容易混淆，区分它们的关键点在于：</p><p>2NF：非主键列是否完全依赖于主键，还是依赖于主键的一部分；</p><p>3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列。</p></blockquote><h2 id="二、数据库设计"><a href="#二、数据库设计" class="headerlink" title="二、数据库设计"></a>二、数据库设计</h2><hr><p><strong>1、</strong> <strong>需求分析阶段</strong></p><p>准确了解用户的需求，撰写需求说明</p><p><strong>2、概念设计阶段</strong></p><p>它是整个数据库设计的关键，通过对用户需求进行综合，归纳与抽象，形成一个独立于具体DBMS的概念模型。E-R图的设计在此阶段。</p><blockquote><p><strong>绘制E-R图为重点，详细查看软件工程。</strong></p></blockquote><p><strong>3、逻辑结构设计阶段</strong></p><p>将概念结果转换为某个DBMS所支持的数据模型。也就是指E-R图和关系模型的转换，具体为将实体，实体的属性和实体之间的联系转换为关系模式。</p><p><strong>4、数据库物理设计阶段</strong></p><p>为逻辑结果选取一个最适合应用环境的物理结构，包括存储结构和存取方法。</p><p><strong>5、数据库实施阶段</strong></p><p>此阶段利用SQL语句实现逻辑结构设计和物理设计阶段的内容，包括建立数据库，编制与调试应用程序等。</p><p><strong>6、数据库运行和维护阶段</strong></p><p>运行过程中不断的调整，修改和优化数据库系统。</p><blockquote><p><strong>ER图：①透过关系，n可转化为多条线②两个实体之间必有一个关系（一般是动词，与两个实体名词构成主谓宾关系）</strong></p><ul><li><strong>假设有 A，B 两个实体，首先判断一个 A 对应几个 B，再判断一个 B 对应几个 A</strong></li><li><strong>如果<code>两边都是 1:1</code>，那么 A 与 B 就是<code>一对一</code>的关系；</strong></li><li><strong>如果<code>两边只有一个 1:n</code>，那么 A 与 B 就是<code>一对多</code>的关系；</strong></li><li><strong>如果<code>两边都是 1:n</code>，那么 A 与 B 就是<code>多对多</code>的关系</strong></li></ul><p><strong>转化为关系模型:</strong><br><strong>多对多：</strong><br><strong>实体：①都是属性摆出来先选出主键、</strong><br><strong>关系：①摆出来，加入链接的实体主键联合起来作为主键，同时又各自作为外键；②自身属性加进去</strong><br><strong>一对多：</strong><br><strong>实体：①都是属性摆出来先选出主键；②另外n部分的实体加入1部分的主键作为外键</strong><br><strong>关系：①关系的属性加入到N部分进去作为普通属性</strong><br><strong>一对一：</strong><br><strong>实体：①都是属性摆出来先选出主键；②双方各自加入对方的主键作为外键；</strong><br><strong>关系：①关系的属性加入到两个实体进去作为普通属性</strong></p></blockquote><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/1588819105382.png" alt></p><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/1588819288849.png" alt></p><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/1588819437551.png" alt></p><blockquote><p><strong>注意：一个关系可以连出多个实体</strong></p><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20200630103341.png" alt></p><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20200630103359.png" alt></p></blockquote><h2 id="三、嵌入式SQL"><a href="#三、嵌入式SQL" class="headerlink" title="三、嵌入式SQL"></a>三、嵌入式SQL</h2><blockquote><p><a href="https://blog.csdn.net/qq_22841811/article/details/51789551" target="_blank" rel="noopener">4-4嵌入式SQL</a></p><p><a href="https://blog.csdn.net/qq_43909184/article/details/90175703?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9" target="_blank" rel="noopener">嵌入式SQL语句</a></p><p><a href="https://blog.csdn.net/lxw983520/article/details/80918581?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1" target="_blank" rel="noopener">存储过程和函数</a></p><p><a href="https://blog.csdn.net/henni_719/article/details/79739603" target="_blank" rel="noopener">PL/SQL存储过程操作实例及其讲解说明</a></p><p><a href="https://www.cnblogs.com/youseiraws/p/8628671.html" target="_blank" rel="noopener">PL/SQL存储过程</a></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>] <span class="keyword">PROCEDURE</span> procedure_name </span><br><span class="line">[(parameter_name [<span class="keyword">IN</span> | <span class="keyword">OUT</span> | <span class="keyword">IN</span> <span class="keyword">OUT</span>] <span class="keyword">type</span> [, ...])] </span><br><span class="line">&#123;<span class="keyword">IS</span> | <span class="keyword">AS</span>&#125; </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">  &lt; procedure_body &gt; </span><br><span class="line"><span class="keyword">END</span> procedure_name;</span><br></pre></td></tr></table></figure><ul><li><em>procedure-name</em>是要创建的存储过程的名称。</li><li>*[OR REPLACE]*选项允许修改现有的过程。</li><li>可选参数列表包含参数的名称，模式和类型。<code>IN</code>表示将从外部传递的值，<code>OUT</code>表示将用于返回过程外的值的参数。</li><li><em>procedure-body</em>包含可执行部分。</li><li>使用<code>AS</code>关键字而不是<code>IS</code>关键字来创建存储过程。</li></ul><blockquote><p>以下示例演示如何创建一个简单的存储过程，执行时它只显示字符串<code>“Hello World！”</code>在屏幕上。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; SET SERVEROUTPUT ON SIZE 99999;</span><br><span class="line">&gt; CREATE OR REPLACE PROCEDURE greetings </span><br><span class="line">&gt; AS </span><br><span class="line">&gt; BEGIN </span><br><span class="line">&gt;    dbms_output.put_line('Hello World!'); </span><br><span class="line">&gt; END; </span><br><span class="line">&gt; /</span><br><span class="line">&gt; -- 执行存储过程</span><br><span class="line">&gt; exec greetings;</span><br><span class="line">&gt; -- 或者</span><br><span class="line">&gt; EXECUTE greetings;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="四、数据库恢复技术"><a href="#四、数据库恢复技术" class="headerlink" title="四、数据库恢复技术"></a>四、数据库恢复技术</h2><hr><h3 id="1、事务"><a href="#1、事务" class="headerlink" title="1、事务"></a>1、事务</h3><p>所谓事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单元。</p><p><strong>事务定义语句</strong>：</p><ul><li><code>BEGIN TRANSACTION</code>： 为事务的开始</li><li><code>COMMIT</code>： 提交事务的所有操作</li><li><code>ROLLBACK</code>： 当出现错误时，将已完成操作全部撤销，回滚到事务开始时的状态</li></ul><p><strong>定义方式</strong>：</p><ul><li><strong>显示定义</strong>： 显示调用数据库定义语句</li><li><strong>隐式定义</strong>： 系统按默认规则自动进行</li></ul><p><strong>事务的特性(ACID)：原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)和持续性(Durability)</strong></p><ul><li><p><strong>(1) 原子性</strong></p><ul><li>事务是数据库的逻辑工作单位，事务中包含的诸操作要么都做，要么都不做。</li></ul></li><li><p><strong>(2) 一致性</strong></p><ul><li>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。</li></ul></li><li><p><strong>(3) 隔离性</strong></p><ul><li>一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰</li></ul></li><li><p><strong>(4) 持续性</strong></p><ul><li>指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其执行结果有任何影响。</li></ul></li></ul><p><strong>事务是恢复和并发控制的基本单位。保证事务ACID特性是事务管理的重要任务。</strong></p><p><strong>故障种类以及恢复策略</strong></p><ul><li><p><strong>(1) 事务内部的故障</strong></p><p>有的可以通过事务程序本身发现，如转账时发现账户余额不足。更多的故障是非预期的，是不能由应用程序处理的，如运算溢出、并发事务发生死锁而被选中撤销该事务、违反了某些完整性限制等</p><ul><li><p>恢复策略：</p><p>1&gt; 反向扫描日志文件，查找该事务的更新操作<br>2&gt; 对事务的更新操作执行逆操作<br>3&gt; 继续查找该事务的其他更新操作，并做同样处理，直至读到该事务的开始标记，事务故障恢复就完成了。</p></li></ul></li><li><p><strong>(2) 系统故障</strong></p><p>指造成系统停止运转的任何事件，使得系统要重新启动。例如：硬件错误(CPU故障)、操作系统故障、DBMS代码错误、系统断电等。这类故障影响正在运行的所有事务，但不破坏数据库。这时主存内容，尤其是数据库缓冲区(在内存)中的内容都被丢失，所有运行事务都非正常终止。发生故障时，一些尚未完成的事务的结果可能已送入物理数据库，从而造成数据库可能处于不正确的状态。</p><p><strong>恢复子系统必须在系统重新启动时让所有非正常终止的事务回滚，强行撤销(UNDO)所有未完成事务。另一方面，有些已完成的事务可能有一部分甚至全部留在缓冲区，尚未写回到磁盘上的物理数据库中，系统故障使得这些事务对数据库的修改部分或全部丢失，这也会使数据库处于不一致状态，因此应将这些事务已提交的结果重新写入数据库。所以系统重新启动后，恢复子系统除需要撤销所有未完成的事务，还需要重做(REDO)所有已提交的事务，以将数据库真正恢复到一致状态。</strong></p><ul><li><p>恢复策略：</p><p><strong>1.正向扫描日志文件，找出故障发生前已经提交的事务（有BEGIN有COMMIT），记入重做事务。同时找出未完成的事务（只有BEGIN），加入撤销队列</strong></p><p><strong>2.对撤销队列中的事务进行撤销处理：反向扫描并执行逆操作</strong></p><p><strong>3.对重做队列中的各个事务进行重做处理：正向扫描并重做</strong></p></li></ul></li><li><p>(3) 介质故障</p><p>也称硬故障，如磁盘损坏、磁头碰撞、强磁场干扰等。</p><ul><li><p>恢复策略</p><p>1.装入最新的数据库后备副本，对于动态转储还需同时装入转储开始时刻的日志文件副本</p><p>2.装入相应的日志文件副本（转储结束时刻的日志文件副本），重做已完成的事务</p></li></ul></li><li><p>(4) 计算机病毒：产生故障的原因，本身不是故障，可能产生故障2或3</p></li></ul><h3 id="2、恢复的实现技术"><a href="#2、恢复的实现技术" class="headerlink" title="2、恢复的实现技术"></a>2、恢复的实现技术</h3><p>建立冗余数据：</p><ol><li>数据转储</li></ol><ul><li><p>静态转储：系统中无运行事务时进行的转储，转储期间不允许任何事务执行。<br>优点：得到的一定是一个数据一致性的副本<br>缺点：降低了数据库的可用性</p><p>动态转储：转储和用户事务可以并发执行<br>优点：系统可用性较好<br>缺点：转储得到的副本不一定一致，因此必须建立日志文件等级转储期间各事务对数据库的修改活动</p><p>海量转储：每次转储整个数据库，恢复更方便<br>增量转储：每次只转储上一次转储后更新过的数据，恢复较复杂</p></li><li><p>登记日志文件</p><p>具有检查点的恢复技术</p></li></ul><p>1、 在日志文件中增加检查点记录</p><p>2、 增加重新开始文件</p><p>3、 恢复子系统在登录日记文件期间动态地维护日志</p><h2 id="五、并发控制"><a href="#五、并发控制" class="headerlink" title="五、并发控制"></a>五、并发控制</h2><hr><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p><strong>不同的多事务执行方式</strong>：</p><ul><li><strong>事务串行执行</strong>： 每个时刻只有一个事务运行</li><li><strong>交叉并发方式</strong>： 并行事务的并行操作轮流交叉运行</li><li><strong>同时并发方式</strong>： 每个处理机可以运行一个事务，多个处理机可以同时运行多个事务</li></ul><p><strong>并发控制原因</strong>： 防止多个事务并发存取数据库时产生的同时读取和/或修改同一数据而造成的数据不一致性</p><ul><li>并发控制能保证事务的一致性，<strong>事务是并发控制的基本单位</strong></li></ul><p><strong>事务并发执行带来的数据不一致问题</strong>：</p><ul><li><p><strong>丢失修改</strong>： 事务 T1 和 T2 读入同一数据并修改，T2 提交的结果破坏 T1 的提交，导致 T1 的修改被丢失</p></li><li><p><strong>不可重复读</strong>： 事务 T1 读取数据后，事务 T2 执行更新操作，使 T1 无法再现前一次读取结果</p><blockquote><ul><li><p>包含三种情况： 后两种不可重复读有时也称为幻影现象</p><p>事务 T1 读取某数据后，事务 T2 对其修改，当事务 T1 再次读该数据时，得到与前一次不同的值<br>事务 T1 读取某数据后，事务 T2 删除其中部分记录，当 T1 再次读该数据时，发现某些记录消失<br>事务 T1 读取某数据后，事务 T2 插入一些记录，当 T1 再次读该数据时，发现多了一些记录</p></li></ul></blockquote></li></ul><ul><li><strong>读脏数据</strong>： 事务 T2 读取事务 T1 修改的数据后，数据库回滚到 T1 修改前，则 T2 读取的数据即为脏数据</li></ul><h3 id="2、封锁"><a href="#2、封锁" class="headerlink" title="2、封锁"></a>2、封锁</h3><ul><li><p><strong>封锁</strong>： 事务 T 在对某个数据对象操作之前，先向系统发出请求，对其加锁。</p><blockquote><p>加锁后事务 T 就对该数据对象有了一定的控制，在事务 T 释放锁之前，其它的事务不能更新此数据对象</p></blockquote></li></ul><p><strong>封锁类型</strong>：</p><ul><li><strong>排它锁(X锁)</strong>： 又称<strong>写锁</strong>，若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A</li><li><strong>共享锁(S锁)</strong>： 又称<strong>读锁</strong>，若事务 T 对数据对象 A 加上 S 锁，则其它事务只能读取 A，不能修改 A</li></ul><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20200611092835.png" alt></p><p><strong>封锁协议</strong>：</p><ul><li><p><strong>一级封锁协议</strong>：事务 T 在修改数据 A 之前，先对其加 X 锁，直到事务结束才释放</p><blockquote><p><strong>解决了丢失修改问题</strong></p></blockquote></li><li><p><strong>二级封锁协议</strong>：事务 T 在读数据 A 之前，先对其加 S 锁，读完后释放</p><blockquote><p><strong>解决了丢失修改与读脏数据问题</strong></p></blockquote></li><li><p><strong>三级封锁协议</strong>：事务 T 在读数据 A 之前，先对其加 S 锁，直到事务结束后释放</p><blockquote><p><strong>解决了丢失修改、读脏数据、不可重复读问题</strong></p></blockquote></li></ul><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20200611093054.png" alt></p><h3 id="3、活锁和死锁"><a href="#3、活锁和死锁" class="headerlink" title="3、活锁和死锁"></a>3、活锁和死锁</h3><h4 id="1-活锁"><a href="#1-活锁" class="headerlink" title="(1)活锁"></a>(1)活锁</h4><ul><li>事务 T1 封锁了数据 R</li><li>事务 T2 又请求封锁 R，于是 T2 等待</li><li>T3 也请求封锁 R，当 T1 释放了 R 上的封锁之后系统首先批准了 T3 的请求，T2 仍然等待<br>T4</li><li>又请求封锁 R，当 T3 释放了 R 上的封锁之后系统又批准了T4的请求……</li><li>T2 有可能永远等待，这就是活锁的情形</li></ul><h4 id="2-死锁"><a href="#2-死锁" class="headerlink" title="(2)死锁"></a>(2)死锁</h4><ul><li><p><strong>死锁</strong>： 多个事务因竞争资源而出现的互相等待现象</p><ul><li>事务T1封锁了数据A，事务T2封锁了数据B，然后T1请求封锁B，与此同时T2也请求封锁A，但因为两个事务的请求都需要等待对方释放锁，这样就出现了永远在等待对方的死锁。</li></ul></li><li><p><strong>死锁的预防</strong>：</p><ul><li><strong>一次封锁法</strong>： 要求每个事务必须一次将所有要使用的数据全部加锁，否则不能继续执行</li><li><strong>顺序封锁法</strong>： 预先对数据对象规定一个封锁顺序，所有事物都按该顺序实施封锁</li></ul></li><li><p><strong>破坏死锁产生条件的预防方法</strong>：</p><ul><li><strong>破坏互斥条件</strong>：让资源允许共享</li><li><strong>破坏不可剥夺条件</strong>：有两种方法<br>① 当其申请的资源得不到满足时，放弃其原先占有的资源<br>② 高优先级进程申请的资源被占用时，将强迫该低优先级进程放弃已占有资源</li><li><strong>破坏零散请求条件</strong>：采用静态分配策略，即当一个进程在得到其所需要的所有资源之后才执行</li><li><strong>破坏循环等待条件</strong>：按照资源的特性，给资源从小到大编号，进程必须按照从小到大的顺序申请资源，且规定进程占有的资源号必须小于申请的资源号才能提出申请</li></ul></li></ul><ul><li><p><strong>死锁的诊断</strong>：</p><ul><li><p><strong>超时法</strong>： 若事务等待时间超过规定时限，就认为发生死锁</p><blockquote><ul><li>时间设置短，容易误判</li><li>时间设置长，死锁不能及时发现</li></ul></blockquote></li><li><p><strong>等待图法</strong>： 采用<code>有向图 G = (T, U)</code></p><ul><li><code>T</code>： 为结点集合，每个结点表示正在运行的事务</li><li><code>U</code>： 为边的集合，每条边表示事务等待的情况</li></ul><blockquote><p>若 T1 等待 T2，则画一条从 T1 指向 T2 的边</p></blockquote></li></ul></li></ul><h3 id="4、并发调度的可串行性"><a href="#4、并发调度的可串行性" class="headerlink" title="4、并发调度的可串行性"></a>4、并发调度的可串行性</h3><ul><li><p><strong>可串行化调度</strong>： 多个事务的并发执行正确，当且仅当其结果与按某一次序串行执行这些事务时的结果相同</p><blockquote><ul><li><strong>可串行性是并发事务正确调度的准则</strong></li><li>一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度</li></ul></blockquote></li><li><p><strong>冲突可串行化调度</strong>： 调度 Sc 在保证冲突操作次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度 Sc’，如果 Sc’ 是串行的，称调度 Sc 为冲突可串行化的调度</p><blockquote><p>一个调度是冲突可串行化，一定是可串行化的调度</p><p><strong>冲突可串行化调度</strong>是<strong>可串行化调度</strong>的<strong>充分条件</strong>，不是必要条件。还有不满足冲突可串行化条件的可串行化调度。</p></blockquote></li><li><p><strong>冲突操作</strong>： 指不同的事务对同一个数据的读写操作和写写操作</p></li></ul><h3 id="5、两段锁协议"><a href="#5、两段锁协议" class="headerlink" title="5、两段锁协议"></a>5、两段锁协议</h3><ul><li><p><strong>两段锁协议：</strong> 指所有事务必须<strong>分两个阶段</strong>对数据项<strong>加锁和解锁</strong>。在对任何数据进行<strong>读、写操作之前</strong>，事务首先要获得<strong>对该数据的封锁</strong>，在<strong>释放一个封锁之后</strong>，事务不<strong>再申请和获得任何其他封锁</strong></p><ul><li><p><strong>第一阶段是获得封锁，也称为扩展阶段</strong></p><ul><li>事务可以申请获得任何数据项上的任何类型的锁，但是<strong>不能释放任何锁</strong></li></ul></li><li><p><strong>第二阶段是释放封锁，也称为收缩阶段</strong></p><ul><li>事务可以释放任何数据项上的任何类型的锁，但是<strong>不能再申请任何锁</strong></li></ul></li><li><p>同样的，事务遵守两段锁协议是可串行化调度的<strong>充分条件</strong>，而不是必要条件。</p><blockquote><p><strong>若并发事务都遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的</strong><br>若并发事务的一个调度是可串行化的，不一定所有事务都符合两段锁协议</p></blockquote></li></ul></li><li><p>封锁粒度(Granularity)：<strong>封锁对象的大小</strong><br>封锁粒度与系统的<strong>并发度</strong>和<strong>并发控制的开销</strong>密切相关：</p><ul><li><blockquote><p>封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；<br>封锁的粒度越小，并发度较高，但系统开销也就越大</p></blockquote></li><li><p>同时考虑封锁开销和并发度两个因素，适当选择封锁粒度</p><blockquote><ul><li>需要处理多个关系的大量元组的用户事务：以数据库为封锁单位</li><li>需要处理大量元组的用户事务：以关系为封锁单元</li><li>只处理少量元组的用户事务：以元组为封锁单位</li></ul></blockquote></li><li><p><strong>多粒度树：</strong><br>以树形结构来表示<strong>多级封锁粒度</strong>；根结点是整个数据库，表示最大的数据粒度；叶结点表示最小的数据粒度<br>如下图 三级粒度树。根结点为数据库，数据库的子结点为关系，关系的子结点为元组：</p><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20200611122442.png" alt></p><p>多粒度封锁协议：<br>① 允许多粒度树中的每个结点被独立地加锁<br>② 对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁<br>③ 在多粒度封锁中一个数据对象可能以两种方式封锁：显式封锁和隐式封锁<br>显式封锁： 直接加到数据对象上的封锁<br>隐式封锁： 是该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁<br>（ps：显式封锁和隐式封锁的效果是一样的）<br>对某个数据对象加锁，系统要检查：</p></li></ul></li></ul><blockquote><p><a href="https://blog.csdn.net/yin__ren/article/details/87649655?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-7" target="_blank" rel="noopener">数据库复习总结</a></p><p><a href="https://blog.csdn.net/qq_43974000/article/details/106157643?%3E?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-3" target="_blank" rel="noopener">数据库系统概论 第十一章课</a></p></blockquote></div><div><div><div style="text-align:center;color:#555;font-size:14px">-----------------------本文结束 <i class="fa fa-heart"></i> 感谢阅读-----------------------</div></div></div><div><div id="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！恰饭^.^~</div><button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20190826214611.png" alt="峻源 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20190826214431.png" alt="峻源 支付宝"><p>支付宝</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>峻源</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://lyxf2000.github.io/posts/ca3f1943/" title="数据库系统概论【五】">http://lyxf2000.github.io/posts/ca3f1943/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/数据库系统概论/" rel="tag"><i class="fa fa-tag">数据库系统概论</i></a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/f464089a/" rel="next" title="计算机图形学【一】"><i class="fa fa-chevron-left"></i> 计算机图形学【一】</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/posts/a22a3b/" rel="prev" title="Web系统设计【四】">Web系统设计【四】 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80NjM0NC8yMjg1NQ=="></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><a href="/"><img class="site-author-image" itemprop="image" src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/avatar.gif" alt="峻源"></a><p class="site-author-name" itemprop="name">峻源</p><div class="site-description motion-element" itemprop="description">乐于心，乐与心，乐之屿，心扉间</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">122</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">17</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">21</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:1194320636@qq.com" title="QE-Mail &rarr; mailto:1194320636@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i>QE-Mail</a> </span><span class="links-of-author-item"><a href="https://music.163.com/#/playlist?id=699716432" title="CloudMusic &rarr; https://music.163.com/#/playlist?id=699716432" rel="noopener" target="_blank"><i class="fa fa-fw fa-music"></i>CloudMusic</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://www.baidu.com/" title="https://www.baidu.com/" rel="noopener" target="_blank">百度</a></li><li class="links-of-blogroll-item"><a href="https://www.google.com/?hl=zh_CN" title="https://www.google.com/?hl=zh_CN" rel="noopener" target="_blank">谷歌</a></li><li class="links-of-blogroll-item"><a href="https://www.zhihu.com/" title="https://www.zhihu.com/" rel="noopener" target="_blank">知乎</a></li><li class="links-of-blogroll-item"><a href="https://juejin.im/" title="https://juejin.im/" rel="noopener" target="_blank">掘金</a></li><li class="links-of-blogroll-item"><a href="https://github.com/" title="https://github.com/" rel="noopener" target="_blank">github</a></li><li class="links-of-blogroll-item"><a href="https://www.luogu.org/" title="https://www.luogu.org/" rel="noopener" target="_blank">洛谷</a></li></ul></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、关系数据理论"><span class="nav-number">1.</span> <span class="nav-text">一、关系数据理论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、数据依赖"><span class="nav-number">1.1.</span> <span class="nav-text">1、数据依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、关系模式的简化表示"><span class="nav-number">1.2.</span> <span class="nav-text">2、关系模式的简化表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、规范化-关系的规范化理论"><span class="nav-number">1.3.</span> <span class="nav-text">3、规范化-关系的规范化理论</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-函数依赖"><span class="nav-number">1.3.1.</span> <span class="nav-text">(1)函数依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-平凡函数依赖与非平凡函数依赖"><span class="nav-number">1.3.2.</span> <span class="nav-text">(2)平凡函数依赖与非平凡函数依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-完全函数依赖与部分函数依赖"><span class="nav-number">1.3.3.</span> <span class="nav-text">(3)完全函数依赖与部分函数依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-传递函数依赖"><span class="nav-number">1.3.4.</span> <span class="nav-text">(4)传递函数依赖</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、从函数依赖看码"><span class="nav-number">1.4.</span> <span class="nav-text">4、从函数依赖看码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、范式"><span class="nav-number">1.5.</span> <span class="nav-text">5、范式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、数据库设计"><span class="nav-number">2.</span> <span class="nav-text">二、数据库设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、嵌入式SQL"><span class="nav-number">3.</span> <span class="nav-text">三、嵌入式SQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、数据库恢复技术"><span class="nav-number">4.</span> <span class="nav-text">四、数据库恢复技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、事务"><span class="nav-number">4.1.</span> <span class="nav-text">1、事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、恢复的实现技术"><span class="nav-number">4.2.</span> <span class="nav-text">2、恢复的实现技术</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、并发控制"><span class="nav-number">5.</span> <span class="nav-text">五、并发控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、概述"><span class="nav-number">5.1.</span> <span class="nav-text">1、概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、封锁"><span class="nav-number">5.2.</span> <span class="nav-text">2、封锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、活锁和死锁"><span class="nav-number">5.3.</span> <span class="nav-text">3、活锁和死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-活锁"><span class="nav-number">5.3.1.</span> <span class="nav-text">(1)活锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-死锁"><span class="nav-number">5.3.2.</span> <span class="nav-text">(2)死锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、并发调度的可串行性"><span class="nav-number">5.4.</span> <span class="nav-text">4、并发调度的可串行性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、两段锁协议"><span class="nav-number">5.5.</span> <span class="nav-text">5、两段锁协议</span></a></li></ol></li></ol></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love" id="heart"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">峻源</span></div><span>本站已运行<span id="showDays"></span></span><script>var seconds=1e3,minutes=60*seconds,hours=60*minutes,days=24*hours,years=365*days,birthDay=Date.UTC(2019,8,1,14,0,0);setInterval(function(){var e=new Date,s=e.getFullYear(),t=e.getMonth()+1,a=e.getDate(),o=e.getHours(),r=e.getMinutes(),n=e.getSeconds(),h=Date.UTC(s,t,a,o,r,n),u=h-birthDay,d=Math.floor(u/years),y=Math.floor(u/days-365*d),i=Math.floor((u-(365*d+y)*days)/hours),l=Math.floor((u-(365*d+y)*days-i*hours)/minutes),M=Math.floor((u-(365*d+y)*days-i*hours-l*minutes)/seconds);document.getElementById("showDays").innerHTML=""+d+"年"+y+"天"+i+"小时"+l+"分钟"+M+"秒"},1e3)</script><div><i class="fa fa-user-md"></i> <span id="busuanzi_container_site_uv">访问人数：<span id="busuanzi_value_site_uv"></span> </span>&nbsp;|&nbsp; <i class="fa fa-eye"></i> <span id="busuanzi_container_site_pv">总访问量：<span id="busuanzi_value_site_pv"></span> </span>&nbsp;|&nbsp; <i class="fa fa-pencil"></i> <span class="post-count">博客全站共 453.9k 字</span></div></div></footer></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=3.4.1"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script><script src="/js/utils.js?v=7.2.0"></script><script src="/js/motion.js?v=7.2.0"></script><script src="/js/affix.js?v=7.2.0"></script><script src="/js/schemes/pisces.js?v=7.2.0"></script><script src="/js/scrollspy.js?v=7.2.0"></script><script src="/js/post-details.js?v=7.2.0"></script><script src="/js/next-boot.js?v=7.2.0"></script><script>window.livereOptions={refer:"posts/ca3f1943/"},function(e,t){var n,r=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&(n=e.createElement(t),n.src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,r.parentNode.insertBefore(n,r))}(document,"script")</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><link rel="stylesheet" href="/dist/APlayer.min.css"><div id="aplayer"></div><script type="text/javascript" src="/dist/APlayer.min.js"></script><script type="text/javascript" src="/dist/music.js"></script><script type="text/javascript" src="/js/firework.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":220,"height":400},"mobile":{"show":false},"react":{"opacity":0.9},"log":false});</script></body></html><!-- rebuild by neat -->