<!-- build time:Tue Oct 12 2021 10:18:25 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link rel="stylesheet" href="/lib/pace/pace-theme-center-atom.min.css?v=1.0.2"><meta name="google-site-verification" content="4fXg7_br-6EcJkwb-a6Ci2NLdRf7aMleAsM1L9S1nBI"><link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="/css/main.css?v=7.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/2.ico?v=7.2.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/1.ico?v=7.2.0"><link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.2.0",sidebar:{position:"left",display:"post",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!0,fancybox:!0,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="前言此程序是数据结构课程设计（运气好抽了个最简单的emmm^^）,但是从这个相对简单的课设也学到了不少东西，下面做下记录1、C++中指针的指针和引用（1）首先再次深入了解指针和指针的指针实际上，指针保存的就是我们存放数据的存储空间地址，指针的指针就是保存的存放指针的存储空间地址，通过指针保存的地址，我们通过*p能够对该指针指向的地址的空间的内容进行操作由此，我们能够得到一个结论1、实际上指针的指针"><meta name="keywords" content="数据结构"><meta property="og:type" content="article"><meta property="og:title" content="数据结构【二叉排序树实现和应用】"><meta property="og:url" content="http://lyxf2000.github.io/posts/980b4487/index.html"><meta property="og:site_name" content="乐屿心扉"><meta property="og:description" content="前言此程序是数据结构课程设计（运气好抽了个最简单的emmm^^）,但是从这个相对简单的课设也学到了不少东西，下面做下记录1、C++中指针的指针和引用（1）首先再次深入了解指针和指针的指针实际上，指针保存的就是我们存放数据的存储空间地址，指针的指针就是保存的存放指针的存储空间地址，通过指针保存的地址，我们通过*p能够对该指针指向的地址的空间的内容进行操作由此，我们能够得到一个结论1、实际上指针的指针"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191215112106.png"><meta property="og:updated_time" content="2021-05-27T10:23:36.503Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="数据结构【二叉排序树实现和应用】"><meta name="twitter:description" content="前言此程序是数据结构课程设计（运气好抽了个最简单的emmm^^）,但是从这个相对简单的课设也学到了不少东西，下面做下记录1、C++中指针的指针和引用（1）首先再次深入了解指针和指针的指针实际上，指针保存的就是我们存放数据的存储空间地址，指针的指针就是保存的存放指针的存储空间地址，通过指针保存的地址，我们通过*p能够对该指针指向的地址的空间的内容进行操作由此，我们能够得到一个结论1、实际上指针的指针"><meta name="twitter:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191215112106.png"><link rel="canonical" href="http://lyxf2000.github.io/posts/980b4487/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>数据结构【二叉排序树实现和应用】 | 乐屿心扉</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">乐屿心扉</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">Keep Thinking</h1></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-playlist"><a href="/playlist/" rel="section"><i class="menu-item-icon fa fa-fw fa-music"></i><br>歌单</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://lyxf2000.github.io/posts/980b4487/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="峻源"><meta itemprop="description" content="乐于心，乐与心，乐之屿，心扉间"><meta itemprop="image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="乐屿心扉"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">数据结构【二叉排序树实现和应用】</h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-12-14 18:15:05" itemprop="dateCreated datePublished" datetime="2019-12-14T18:15:05+08:00">2019-12-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-05-27 18:23:36" itemprop="dateModified" datetime="2021-05-27T18:23:36+08:00">2021-05-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span> </span><span class="post-time">&nbsp; | &nbsp; <span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">字数统计:</span> <span class="post-count">8k(字)</span> </span><span class="post-time">&nbsp; | &nbsp; <span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">阅读时长≈</span> <span class="post-count">33(分)</span></span><br><p></p></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此程序是数据结构课程设计（运气好抽了个最简单的emmm^^）,但是从这个相对简单的课设也学到了不少东西，下面做下记录</p><h1 id="1、C-中指针的指针和引用"><a href="#1、C-中指针的指针和引用" class="headerlink" title="1、C++中指针的指针和引用"></a>1、C++中指针的指针和引用</h1><h3 id="（1）首先再次深入了解指针和指针的指针"><a href="#（1）首先再次深入了解指针和指针的指针" class="headerlink" title="（1）首先再次深入了解指针和指针的指针"></a>（1）首先再次深入了解指针和指针的指针</h3><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191215112106.png" alt></p><p>实际上，指针保存的就是我们存放数据的存储空间地址，指针的指针就是保存的存放指针的存储空间地址，通过指针保存的地址，<strong>我们通过<code>*p</code>能够对该指针指向的地址的空间的内容进行操作</strong></p><p><font size="4" color="red"><strong>由此，我们能够得到一个结论1、实际上指针的指针也是归于指针变量的范畴，他不是多层概念，指针是我们希望通过地址对一个数据进行操作而引入的，指针和指针指向的数据就是一个两层概念，指针的指针只不过是我们希望通过地址对指针变量进行修改而创建的 ，以此类推我们希望通过地址对指针的指针进行修改，就需要创建相应类型的指针的指针的指针。。。。往后也一样。</strong></font></p><h3 id="（2）引用"><a href="#（2）引用" class="headerlink" title="（2）引用"></a>（2）引用</h3><p>我们都知道<strong>引用就是变量的别名，操作一个变量的引用也就相当于操作变量本身</strong></p><p>但是<strong>引用是在编译的过程中被处理的，实际上就是在编译层面对程序员进行的一个比较友好的语法，而在实现上是由编译器完成了地址的传递，实质上还是指针</strong></p><p><font size="4" color="red"><strong>讲人话，第二个结论：使用一个引用变量操作，就相当于使用一个指向原数据的指针来对原数据进行操作，只不过过程被隐藏了，同时创造引用的人封装这个过程的同时还增加了一些，引用不能为空，引用不能更改等等的规定，防止使用中不必要的错误”</strong></font></p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test1(int *a)</span><br><span class="line">&#123;</span><br><span class="line">	*a=2;</span><br><span class="line">&#125;</span><br><span class="line">void test2(int &amp;a)&#123;</span><br><span class="line">	a=3;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int b=0;</span><br><span class="line">	cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">	test1(&amp;b);//因为通过上一部分，我们知道指针就是存储数据存储单元的地址的，这里我们直接使用&amp;取地址</span><br><span class="line">	cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">	test2(b);</span><br><span class="line">	cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">/*输出为：</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">3*/</span><br></pre></td></tr></table></figure><p><font size="4" color="red"><strong>也就是说，使用引用变量a=b,就是*a=b，但是创建指针，使用时带星花，都省略了，表面理解就是“起了个别名”</strong></font></p><p><font size="4" color="red"><strong>规定引用不能为空，也是为了概念上契合“起个别名”，没有赋值，去给谁起别名操作呢？，引用不能改变，“别名”强制绑定一个对象，不能更改。</strong></font></p><p><font size="4" color="red"><strong>这里再添加一个误区说明，在C++中NULL的设定不是我们理解上的“空”而是：</strong></font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__cplusplus)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> NULL 0    <span class="comment">// C++中使用0作为NULL的值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> NULL ((void *)0)    <span class="comment">// C中使用((void *)0)作为NULL的值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><font size="4" color="red"><strong>所以一般来说NULL就是地址为0的概念，不是“空”，而大多机器中地址0中的内容一般是不准许用户更改的。一般用于系统或者硬件调用。所以NULL可以赋予给引用变量，编译通过但是一般不要对其进行操作</strong></font></p><h3 id="（3）函数返回引用值"><a href="#（3）函数返回引用值" class="headerlink" title="（3）函数返回引用值"></a>（3）函数返回引用值</h3><p><strong>问题：函数内部创建的变量都是局部变量，即私有的，作用域就在函数之内，为什么却可以把值传出去呢呢？根本就在于实现机制中，类似于形式参数，函数结束返回时，将局部变量值拷贝给一个临时变量，然后将这个临时变量返回给调用函数，这样即使局部变量在返回时已经释放内存，也不影响返回的变量值</strong></p><p>既然类似于形式参数，那么我们返回值能不能类似的使用引用呢？</p><p><strong>答案是肯定可以的</strong></p><p>一个函数的返回值定义为引用形式，就相当于真的<strong>“返回了它本身”</strong>没有副本的概念。</p><p><font size="4" color="red"><strong>然而实际上，它的实现依旧是指针。实际上封装的的操作就是用指针接受返回的&amp;a，再用这个指针去操作其对应值。所以对应的，我们想要使用这个引用值，必须要使用引用变量，否则和返回非引用效果相同。同时，我们也明确到，这个引用返回必须不能是局部变量，否则函数结束，释放空间，我们引用返回封装中本质上返回的地址所存储的值也就不明确了。虽然编译可以通过只是给予警告，有时该局部空间也没有被重新分配保持原值，但是这样是没有保障的，风险极大，故我们一般不能使用。</strong></font></p><p><font size="4" color="red"><strong>当然如果非要返回一个局部变量的引用，可以new 类型(初值) 申请一个堆内存的临时变量，这样只要不delete释放，那么在程序退出之前内存就不会被释放，直到不再使用时便可delete掉.</strong></font></p><p><strong>通常情况下，我们希望做到通过一个函数，真的对外部原数据进行操作，而不是局部数据，这样使用引用参数或者指针参数是足够的，但是，若我们想对函数得到的返回值结果再次进入一个函数进行操作，且仍然实际上是操作这个返回值（前提已经是这个返回值变量不是局部变量了），那么我们就必须使用返回引用同时使用引用变量接受或者返回地址同时使用指针接受，然后再进入另一个参数为引用或者指针的函数进行操作才可以</strong></p><p>例如本次的二叉排序树的查询和插入操作：</p><p><strong>我们希望使用查询的结果作为插入的输入，进行对以root为根的树的操作，我们查找不到某数据后必定为结果NULL，这也是我们希望插入的位置，但是NULL是我们希望插入节点的父节点的指针域，我们希望链接上父节点，即将父节点的NULL修改后指向我们新插入的节点，就必须使用返回指针的指针或者返回指针引用（前面讲过，这是两层概念，而非多层，我们希望对指针内容原数据修改，就使用指针的指针），这样再进入插入函数操作我们才能真正意义上的做到父节点链接新节点，否则我们只是创建副本接受了NULL的这个值，做不到真正的使用父结点的指针域</strong></p><p>使用指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Node</span>&lt;T&gt;** <span class="title">BSTree</span>&lt;T&gt;:</span>:search(T data,Node&lt;T&gt; *&amp;ptr)&#123;</span><br><span class="line">	<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>) <span class="keyword">return</span> &amp;ptr;	<span class="comment">//指针为空，说明没有找到该节点 返回&amp;ptr。此时ptr的值为NULL而&amp;ptr不为NULL; </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(data&lt;ptr-&gt;data) search(data,ptr-&gt;left);<span class="comment">//查找数据小于该节点数据，进入左子树查找 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(data&gt;ptr-&gt;data) search(data,ptr-&gt;right);<span class="comment">//查找数据大于该节点数据，进入右子树查找 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> &amp;ptr;								<span class="comment">//查找数据等于该节点数据，返回指向该节点的指针的指针。 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">BSTree</span>&lt;T&gt;:</span>:insertMain(T data,Node&lt;T&gt; *&amp;ptr)&#123;</span><br><span class="line">	Node&lt;T&gt; **p=search(data,ptr);<span class="comment">//使用search函数，根据查找原理，可以查找到该节点的插入位置 </span></span><br><span class="line">	<span class="keyword">if</span>(*p==<span class="literal">NULL</span>)&#123;				<span class="comment">//若为*p为空则说明找到了插入位置 </span></span><br><span class="line">		*p=<span class="keyword">new</span> Node&lt;T&gt;;			<span class="comment">//申请空间 </span></span><br><span class="line">		(*p)-&gt;data=data;		<span class="comment">//存储数据 </span></span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Node</span>&lt;T&gt;*&amp; <span class="title">BSTree</span>&lt;T&gt;:</span>:search(T data,Node&lt;T&gt; *&amp;ptr)&#123;</span><br><span class="line">	<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>) <span class="keyword">return</span> ptr;	<span class="comment">//指针为空，说明没有找到该节点 返回&amp;ptr。此时ptr的值为NULL而&amp;ptr不为NULL; </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(data&lt;ptr-&gt;data) search(data,ptr-&gt;left);<span class="comment">//查找数据小于该节点数据，进入左子树查找 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(data&gt;ptr-&gt;data) search(data,ptr-&gt;right);<span class="comment">//查找数据大于该节点数据，进入右子树查找 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> ptr;								<span class="comment">//查找数据等于该节点数据，返回指向该节点的指针的引用。 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">BSTree</span>&lt;T&gt;:</span>:insertMain(T data,Node&lt;T&gt; *&amp;ptr)&#123;</span><br><span class="line">	Node&lt;T&gt; *&amp;p=search(data,ptr);<span class="comment">//使用search函数，根据查找原理，可以查找到该节点的插入位置 </span></span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;				<span class="comment">//若为p为空则说明找到了插入位置 </span></span><br><span class="line">		p=<span class="keyword">new</span> Node&lt;T&gt;;			<span class="comment">//申请空间 </span></span><br><span class="line">		p-&gt;data=data;		<span class="comment">//存储数据 </span></span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）总结："><a href="#（4）总结：" class="headerlink" title="（4）总结："></a>（4）总结：</h3><p>1、引用其实本质就是地址</p><p>2、当函数返回值类型为引用时，一般就用引用类型去接收，或者就使用了引用的作用，如果用非引用类型接受，就等于将函数返回的引用的数据值，复制给了该接收对象，和函数返回非引用类型是一样的效果。<br>3、当函数返回值类型为引用时，如果不考虑接收问题，则有一个特性，则是可以直接操作该函数返回的引用，如放在=左面 +=等.</p><p>4、错象:当在函数内部定义了局部变量(本质就是为一段内存取了一个名字，并占用)，出了这个函数，这个局部变量不可再使用，也就是这个局部变量并不指向 任何一个内存了，但是这个局部变量原来所指的内存如果没有被系统重新分配，里面的值仍然没有变,如果有一个引用指向该局部变量，在局部变量被释放内存以 后，如果没有被系统重新将这段内存分配，那么其值仍可用。</p><p>5、不可以将常引用当作函数返回值返回.</p><p>6、用引用作函数参数和返回值类型的好处。直接是地址操作，不需要将值一一复制给形参，</p><p>7、返回值不需要有临时变量的存在，也不需要调用任何构造函数。节省了开销</p><p>8、一般当函数形参需要复杂类型的数据时，最好用引用，可以节省系统开销，</p><p>9、能用常引用的地方尽量用常引用。</p><p>10、如果非要返回一个局部变量的引用，可以new 类型(初值) 申请一个堆内存的临时变量，这样只要不delete释放，那么在程序退出之前内存就不会被释放，直到不再使用时便可delete掉.</p><blockquote><p>推荐详细阅读：</p><p>总结选自：<a href="https://blog.csdn.net/tlxxm/article/details/8860760" target="_blank" rel="noopener">https://blog.csdn.net/tlxxm/article/details/8860760</a></p><p><a href="https://www.cnblogs.com/hoodlum1980/archive/2012/06/19/2554270.html" target="_blank" rel="noopener">C++引用的实现</a></p></blockquote><h1 id="2、封装一棵树"><a href="#2、封装一棵树" class="headerlink" title="2、封装一棵树"></a>2、封装一棵树</h1><p>我们希望<strong>“定义一棵树”</strong>，真的就是定义一棵树，<strong>它的操作就是默认对本树操作</strong>，<strong>所以我们将很多递归程序或者具有使用根节点的程序分成两部分，主实现函数放入private域，不予公开，而添加调用函数，内容就是使用主实现函数，但是我们认为固定设定参数，例如树根指针就是本树的root</strong></p><p>类似的操作我们在本次二叉树封装中进行了很多：</p><p>主实现函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">		<span class="comment">//节点数 </span></span><br><span class="line">		Node&lt;T&gt;* root; <span class="comment">//根节点	</span></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">insertMain</span><span class="params">(T data,Node&lt;T&gt; *&amp;ptr)</span></span>; <span class="comment">//插入节点主函数 </span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">destroyTreeMain</span><span class="params">(Node&lt;T&gt; *p)</span></span>;<span class="comment">//销毁树主函数 </span></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">deepthMain</span><span class="params">(Node&lt;T&gt; *p)</span></span>;<span class="comment">//计算树的高度主函数 </span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">inOrderMain</span><span class="params">(Node&lt;T&gt; *ptr)</span></span>;<span class="comment">//中序遍历主函数 </span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">outputLevelMain</span><span class="params">(Node&lt;T&gt; *p)</span></span>;<span class="comment">//层次遍历主函数</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">outPutTreeByGraphMain</span><span class="params">(Node&lt;T&gt; *t,<span class="keyword">int</span> h)</span></span>;<span class="comment">//可视化遍历主函数;</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">sortedArrayToLowestBST_Main</span><span class="params">(T data[],<span class="keyword">int</span> min,<span class="keyword">int</span> max)</span></span>;<span class="comment">//根据一有序序列创建高度最小的BSTree主函数</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">getPNumInEvrDeepth</span><span class="params">(<span class="keyword">int</span> deepth,<span class="keyword">int</span> num[],Node&lt;T&gt; *ptr)</span></span>; <span class="comment">//获取每一层次的节点个数存入数组num中，方便计算AVL；</span></span><br></pre></td></tr></table></figure><p>调用函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:		</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(T data)</span></span>&#123;insertMain(data,root);&#125;; <span class="comment">//插入节点调用函数 	 	 		</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">sortedArrayToLowestBST</span><span class="params">()</span></span>;<span class="comment">//根据一有序序列创建高度最小的BSTree调用函数</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;inOrderMain(root);<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;<span class="comment">//中序遍历调用函数 </span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">outputLevel</span><span class="params">()</span></span>&#123;outputLevelMain(root);<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;		<span class="comment">//层次遍历调用函数</span></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">deepth</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deepthMain(root);&#125;;<span class="comment">//计算树的高度调用函数 </span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">destroyTree</span><span class="params">()</span></span>&#123;destroyTreeMain(root);root=<span class="literal">NULL</span>;&#125;;<span class="comment">//销毁树调用 </span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">outPutTreeByGraph</span><span class="params">()</span></span>&#123;outPutTreeByGraphMain(root,<span class="number">0</span>);&#125;; <span class="comment">//树的图像输出调用</span></span><br></pre></td></tr></table></figure><p><strong>这样从外部看，我们定义一个二叉排序树，对其进行创建、增删改查都是默认对这一个树进行操作，不再需要树根指针等参数了。</strong></p><h1 id="3、图形化输出一棵树"><a href="#3、图形化输出一棵树" class="headerlink" title="3、图形化输出一棵树"></a>3、图形化输出一棵树</h1><p><strong>其实很简单：就是利用了右子树—&gt;父结点—&gt;左子树遍历，根据结点所处的层数和指针域状况中间夹杂着一些符合的判断添加</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BSTree</span>&lt;T&gt;:</span>:outPutTreeByGraphMain(Node&lt;T&gt; *t,<span class="keyword">int</span> h)&#123;</span><br><span class="line">	<span class="keyword">if</span>(t!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		outPutTreeByGraphMain(t-&gt;right,h+<span class="number">1</span>);<span class="comment">//右子树输出，h变量说明深度控制之后的空格输出 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;h;i++)				<span class="comment">//根据深度说明输出层数相适应的空格，使每一层节点在一竖列 </span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"   "</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;t-&gt;data;						<span class="comment">//空格输出完才输出数据 </span></span><br><span class="line">		<span class="keyword">if</span>(t-&gt;left!=<span class="literal">NULL</span>&amp;&amp;t-&gt;right!=<span class="literal">NULL</span>)	<span class="comment">//输出完才输出数据，根据子节点，左右都有则输出'&lt;' +换行 </span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"&lt;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;left==<span class="literal">NULL</span>&amp;&amp;t-&gt;right!=<span class="literal">NULL</span>)<span class="comment">//只有右子树则输出'/' +换行 </span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"/"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;left!=<span class="literal">NULL</span>&amp;&amp;t-&gt;right==<span class="literal">NULL</span>)<span class="comment">//只有左子树则输出'\' +换行 </span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"\\"</span>&lt;&lt;<span class="built_in">endl</span>;						</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;						<span class="comment">//左右子树为空则输出换行</span></span><br><span class="line">		outPutTreeByGraphMain(t-&gt;left,h+<span class="number">1</span>);		<span class="comment">//输出左子树 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就能横向打印一个树了（<strong>结点数少的时候慢清晰的，能够直观根据树形判断自己的树功能是否正确，代码也不复杂，挺实用的</strong>）</p><h1 id="4、本树的模板类的进一步封装体会"><a href="#4、本树的模板类的进一步封装体会" class="headerlink" title="4、本树的模板类的进一步封装体会"></a>4、本树的模板类的进一步封装体会</h1><p>功能较多，为了使用更方便，于是在<strong>main函数中</strong>设计了一个菜单功能，但是，<strong>在这个设计中，不同类型的树，对于停止标记符号也不同，因为停止符号也设计成了模板T类符号，没有进行统一化，这样相关函数中输入才好设计，否则若设计了固定停止符号为‘#’，在一个int型的树中，我们万一有数据就是‘#’代表的ASCII码，就会停止，所以这样设计不是很好。而固定输入数据个数，万一个数打错了又要从新来过。最好还是设计一个停止标记，每种树设计一种对应类型的停止标记。而这样设计带来了一个问题，那就是菜单中是固定的调用，我们如何确认是哪种树呢？只是为了不同类型树使用不同标记而再次复制粘贴修改一两句代码显然是不合理的。</strong></p><p><strong>于是，我们将这个菜单功能也进行模板化，参数就是类型树和对应的停止标志，这样就合理了！</strong></p><p>最终，我们的主函数只有寥寥几句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BSTree&lt;<span class="keyword">int</span>&gt; intTree;</span><br><span class="line">	BSTree&lt;<span class="keyword">char</span>&gt; charTree;</span><br><span class="line">	BSTree&lt;<span class="keyword">double</span>&gt; floatTree; </span><br><span class="line">	function(intTree,<span class="number">-1</span>);</span><br><span class="line">	function(charTree,<span class="string">'#'</span>);</span><br><span class="line">	function(floatTree,<span class="number">-1.0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不同的树使用不同的模板类型的function即可，封装的很漂亮</strong></p><h1 id="5、switch-case和"><a href="#5、switch-case和" class="headerlink" title="5、switch case和{}"></a>5、switch case和{}</h1><p><strong>总结一句话：只要case中带变量不带括号，编译器都会报错，使用switch case的时候建议每个匹配选项后的执行区域推荐使用{}括起来，或者干脆不要将变量带入case中。</strong></p><h1 id="6、其他小坑"><a href="#6、其他小坑" class="headerlink" title="6、其他小坑"></a>6、其他小坑</h1><p><strong>找合法序列时候使用单个读取而不是真的读取一个序列，导致有时一个序列中途就判断是错误的，那么后续的字符会被输入流读入菜单选项中，尽管使用了非正确功能序号不予相应的循环，但是若万一系列中多余的数据就符合菜单功能序号，就会出现非法调用功能的严重BUG，所以最终还是使用了动态数组存储然后删除</strong></p><h1 id="7、最终代码"><a href="#7、最终代码" class="headerlink" title="7、最终代码"></a>7、最终代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">//创建节点 </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	T data;</span><br><span class="line">	Node&lt;T&gt;* left=<span class="literal">NULL</span>;</span><br><span class="line">	Node&lt;T&gt;* right=<span class="literal">NULL</span>; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建BSTree类 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">BSTree</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		BSTree();</span><br><span class="line">		Node&lt;T&gt;* getRoot()&#123;<span class="keyword">return</span> root;&#125;;</span><br><span class="line">		Node&lt;T&gt;** search(T data,Node&lt;T&gt; *&amp;ptr);<span class="comment">//在以ptr为根的二叉排序树中查询节点返回指向该节点的指针的指针					</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">creatBSTree</span><span class="params">(T stopSign)</span></span>;<span class="comment">//以root为根创建BSTree；		 </span></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(T data)</span></span>;	<span class="comment">//删除节点		 </span></span><br><span class="line">		<span class="function"><span class="keyword">double</span> <span class="title">getAVL</span><span class="params">()</span></span>;<span class="comment">//获取查询的平均查找长度		 </span></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">judgeLegalSequence</span><span class="params">(T stopSign)</span></span>;<span class="comment">//判断某序列是否是合法查找序列</span></span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(T data)</span></span>&#123;insertMain(data,root);&#125;; <span class="comment">//插入节点调用函数 	 	 		</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">sortedArrayToLowestBST</span><span class="params">()</span></span>;<span class="comment">//根据一有序序列创建高度最小的BSTree调用函数</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;inOrderMain(root);<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;<span class="comment">//中序遍历调用函数 </span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">outputLevel</span><span class="params">()</span></span>&#123;outputLevelMain(root);<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;		<span class="comment">//层次遍历调用函数</span></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">deepth</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> deepthMain(root);&#125;;<span class="comment">//计算树的高度调用函数 </span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">destroyTree</span><span class="params">()</span></span>&#123;destroyTreeMain(root);root=<span class="literal">NULL</span>;&#125;;<span class="comment">//销毁树调用 </span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">outPutTreeByGraph</span><span class="params">()</span></span>&#123;outPutTreeByGraphMain(root,<span class="number">0</span>);&#125;; <span class="comment">//树的图像输出调用</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="comment">//节点数 </span></span><br><span class="line">		Node&lt;T&gt;* root; <span class="comment">//根节点	</span></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">insertMain</span><span class="params">(T data,Node&lt;T&gt; *&amp;ptr)</span></span>; <span class="comment">//插入节点主函数 </span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">destroyTreeMain</span><span class="params">(Node&lt;T&gt; *p)</span></span>;<span class="comment">//销毁树主函数 </span></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">deepthMain</span><span class="params">(Node&lt;T&gt; *p)</span></span>;<span class="comment">//计算树的高度主函数 </span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">inOrderMain</span><span class="params">(Node&lt;T&gt; *ptr)</span></span>;<span class="comment">//中序遍历主函数 </span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">outputLevelMain</span><span class="params">(Node&lt;T&gt; *p)</span></span>;<span class="comment">//层次遍历主函数</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">outPutTreeByGraphMain</span><span class="params">(Node&lt;T&gt; *t,<span class="keyword">int</span> h)</span></span>;<span class="comment">//可视化遍历主函数;</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">sortedArrayToLowestBST_Main</span><span class="params">(T data[],<span class="keyword">int</span> min,<span class="keyword">int</span> max)</span></span>;<span class="comment">//根据一有序序列创建高度最小的BSTree主函数</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">getPNumInEvrDeepth</span><span class="params">(<span class="keyword">int</span> deepth,<span class="keyword">int</span> num[],Node&lt;T&gt; *ptr)</span></span>; <span class="comment">//获取每一层次的节点个数存入数组num中，方便计算AVL；</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">BSTree</span>&lt;T&gt;:</span>:BSTree()&#123;</span><br><span class="line">	root=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Node</span>&lt;T&gt;** <span class="title">BSTree</span>&lt;T&gt;:</span>:search(T data,Node&lt;T&gt; *&amp;ptr)&#123;</span><br><span class="line">	<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>) <span class="keyword">return</span> &amp;ptr;	<span class="comment">//指针为空，说明没有找到该节点 返回&amp;ptr。此时ptr的值为NULL而&amp;ptr不为NULL; </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(data&lt;ptr-&gt;data) search(data,ptr-&gt;left);<span class="comment">//查找数据小于该节点数据，进入左子树查找 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(data&gt;ptr-&gt;data) search(data,ptr-&gt;right);<span class="comment">//查找数据大于该节点数据，进入右子树查找 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> &amp;ptr;								<span class="comment">//查找数据等于该节点数据，返回指向该节点的指针的指针。 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">BSTree</span>&lt;T&gt;:</span>:insertMain(T data,Node&lt;T&gt; *&amp;ptr)&#123;</span><br><span class="line">	Node&lt;T&gt; **p=search(data,ptr);<span class="comment">//使用search函数，根据查找原理，可以查找到该节点的插入位置 </span></span><br><span class="line">	<span class="keyword">if</span>(*p==<span class="literal">NULL</span>)&#123;				<span class="comment">//若为*p为空则说明找到了插入位置 </span></span><br><span class="line">		*p=<span class="keyword">new</span> Node&lt;T&gt;;			<span class="comment">//申请空间 </span></span><br><span class="line">		(*p)-&gt;data=data;		<span class="comment">//存储数据 </span></span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span>  <span class="title">BSTree</span>&lt;T&gt;:</span>:creatBSTree(T stopSign)&#123;</span><br><span class="line">	destroyTree();			<span class="comment">//摧毁原有的树</span></span><br><span class="line">	T data;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;data;</span><br><span class="line">	<span class="keyword">while</span>(data!=stopSign)&#123;</span><br><span class="line">		insert(data);	<span class="comment">//创建一个BSTree的过程就是从空树开始不断插入节点的过程 </span></span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">BSTree</span>&lt;T&gt;:</span>:remove(T data)&#123;</span><br><span class="line">	Node&lt;T&gt; **p=search(data,root);</span><br><span class="line">	<span class="keyword">if</span>(*p!=<span class="literal">NULL</span>)&#123;				<span class="comment">//若*p不为空，则查找该节点成功，准备删除该节点 </span></span><br><span class="line">		<span class="keyword">if</span>((*p)-&gt;left!=<span class="literal">NULL</span>&amp;&amp;(*p)-&gt;right!=<span class="literal">NULL</span>)&#123;	<span class="comment">//对左右子树都不为空的情况进行删除 </span></span><br><span class="line">			Node&lt;T&gt; *temp=(*p)-&gt;right;</span><br><span class="line">			<span class="keyword">while</span>(temp-&gt;left!=<span class="literal">NULL</span>)	<span class="comment">//找到右子树的中序遍历的第一个节点 </span></span><br><span class="line">			temp=temp-&gt;left;</span><br><span class="line">			T data=temp-&gt;data; <span class="comment">//保存该值，否则删除右子树的中序遍历的第一个节点后，该值会消失，无法赋给*p节点 </span></span><br><span class="line">			remove(temp-&gt;data);<span class="comment">//由于右子树的中序遍历的第一个节点一定无左子树，我们可以直接用右子树链接，remove函数中已经定于了该操作，我们直接调用，提高代码复用率 </span></span><br><span class="line">			(*p)-&gt;data=data;<span class="comment">//右子树的中序遍历的第一个节点的值替换该节点的值		</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			Node&lt;T&gt; *temp=*p;		<span class="comment">//备份该节点</span></span><br><span class="line">			<span class="keyword">if</span>((*p)-&gt;left==<span class="literal">NULL</span>) *p=(*p)-&gt;right;<span class="comment">//如果该需要删除的节点左子树为空，则删除后使用该节点的右子树替代； </span></span><br><span class="line">			<span class="keyword">else</span> *p=(*p)-&gt;left;					<span class="comment">//如果该需要删除的节点右子树为空，则删除后使用该节点的左子树替代； 并且这种处理方式包含了都为空的处理，即赋值NULL </span></span><br><span class="line">			<span class="keyword">delete</span> temp;			<span class="comment">//删除该节点 </span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>; 		<span class="comment">//若*p为空，则查找该节点失败 ，返回false </span></span><br><span class="line">&#125;<span class="comment">//实际上，删除一个点，若是左右子树至少有一个为空，则备份被删除的节点的指针，然后直接子树链接上其父节点指向删除节点的指针（，</span></span><br><span class="line"><span class="comment">// 判左空则使用右子树链接，判右空则使用左子树链接，这样就包括了双空的情况了。）最后使用备份指针释放空间即可。</span></span><br><span class="line"><span class="comment">//若是该左右子树全不是空则实际上转为使用 右子树的中序遍历的第一个节点 或者左子树中序遍历最后一个节点的值替换该节点的值</span></span><br><span class="line"><span class="comment">//然后删除只有右子树（或者左子树，取决于使用哪个作为替换节点）的替换节点，而这种删除左右子树至少有一个为空的操作，直接在此调用remove就可以完成，提高代码复用率 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BSTree</span>&lt;T&gt;:</span>:getPNumInEvrDeepth(<span class="keyword">int</span> deepth,<span class="keyword">int</span> num[],Node&lt;T&gt; *ptr)&#123;</span><br><span class="line">	<span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		num[deepth]++;<span class="comment">//该节点不为空，则该层数节点数+1；								</span></span><br><span class="line">		getPNumInEvrDeepth(deepth+<span class="number">1</span>,num,ptr-&gt;left);<span class="comment">//本层深度+1进入左子节点， </span></span><br><span class="line">		getPNumInEvrDeepth(deepth+<span class="number">1</span>,num,ptr-&gt;right);<span class="comment">//本层深度+1进入右子节点，</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">double</span> <span class="title">BSTree</span>&lt;T&gt;:</span>:getAVL()&#123;</span><br><span class="line">	<span class="keyword">int</span> *num=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];<span class="comment">//创建数组用于存储各个层次的节点数 </span></span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>,pointNumber=<span class="number">0</span>;<span class="comment">//sum用于存储各个层次的节点数×层数，pointNumber存储节点个数； </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)<span class="comment">//初始化数组全为0 </span></span><br><span class="line">	num[i]=<span class="number">0</span>;</span><br><span class="line">	getPNumInEvrDeepth(<span class="number">1</span>,num,root);<span class="comment">//使用 getPNumInEvrDeepth函数获取每一层次的节点个数存储到num数组中；</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">	<span class="keyword">if</span>(num[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">		sum+=num[i]*i;		<span class="comment">//加和各个层次的节点数×层数</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;num[i]&lt;&lt;<span class="string">"×"</span>&lt;&lt;i;</span><br><span class="line">		<span class="keyword">if</span>(num[i+<span class="number">1</span>]!=<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"+"</span>; </span><br><span class="line">		pointNumber+=num[i];<span class="comment">//加和各个层次的节点数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">")"</span>&lt;&lt;<span class="string">"×1/"</span>&lt;&lt;pointNumber&lt;&lt;<span class="string">"="</span>;</span><br><span class="line">	<span class="keyword">delete</span> num;				<span class="comment">//删除辅助数组 </span></span><br><span class="line">	<span class="keyword">if</span>(pointNumber==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//若 pointNumber==0，则为空树，我们选择AVL置0 </span></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">double</span>)sum/pointNumber;<span class="comment">//根据AVL的定义可以推算出，成功查找的AVL= (double)sum/pointNumber; </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">BSTree</span>&lt;T&gt;:</span>:judgeLegalSequence(T stopSign)&#123;	<span class="comment">//该方法判断一个序列，查找该序列最后一个数据所形成的通路是否正好是该序列 </span></span><br><span class="line">	T *data=<span class="keyword">new</span> T[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;data[i];</span><br><span class="line">		<span class="keyword">if</span>(data[i]==stopSign)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node&lt;T&gt; *ptr=root;	</span><br><span class="line">	<span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(data[t]!=stopSign&amp;&amp;root!=<span class="literal">NULL</span>)&#123;<span class="comment">//data[t]!=stopSign用来判断空序列，ptr！=NULL来判断序列超长情况的错误序列 </span></span><br><span class="line">		<span class="keyword">if</span>(data[t++]!=ptr-&gt;data)	<span class="comment">//如果数据不等于该节点的数据则不是合法序列。直接跳出判断循环，进入非正确查找序列处理阶段 ,若正确相当于执行了t++进入下一个判断； </span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(data[t]==stopSign)&#123;	<span class="comment">//遇到终止标志，序列判断结束，到这里说明没有不合法数据，进入正确找序列处理阶段，删除动态存储数组并return true。</span></span><br><span class="line">		<span class="keyword">delete</span> data;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">if</span>(data[t]&lt;ptr-&gt;data)	<span class="comment">//没有遇到终止标志进入下一个数据判断，数据比本节点数据小，则进入左节点判断 </span></span><br><span class="line">		ptr=ptr-&gt;left;</span><br><span class="line">		<span class="keyword">else</span>					<span class="comment">//数据比本节点数据大，则进入左节点判断 ，这里必不可能等于，因为上一个节点等于ptr-&gt;data,而二叉排序树无相同节点 </span></span><br><span class="line">		ptr=ptr-&gt;right; 		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> data;<span class="comment">//失败时的删除data动态数组 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//说明为空序列或者序列超长或序列数据的确非正确的查找序列，返回错误序列			</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span>  <span class="title">BSTree</span>&lt;T&gt;:</span>:sortedArrayToLowestBST()&#123;</span><br><span class="line">	destroyTree();			<span class="comment">//摧毁原有的树 </span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"输入有序序列包含的数据个数："</span>; </span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"依次输入"</span>&lt;&lt;n&lt;&lt;<span class="string">"个数据："</span>; </span><br><span class="line">	T *data=<span class="keyword">new</span> T [n];		<span class="comment">//动态创建存储数据的数组，创建树后之后可以删除节省空间； </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;data[i];			<span class="comment">//存入数据 </span></span><br><span class="line">	sortedArrayToLowestBST_Main(data,<span class="number">0</span>,n<span class="number">-1</span>);<span class="comment">//进入根据有序序列建立高度最小的二叉排序树主函数 </span></span><br><span class="line">	<span class="keyword">delete</span> data;			<span class="comment">//建立完成删除存储数组 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BSTree</span>&lt;T&gt;:</span>:sortedArrayToLowestBST_Main(T data[],<span class="keyword">int</span> min,<span class="keyword">int</span> max)&#123;</span><br><span class="line">	<span class="keyword">if</span>(min&lt;=max)&#123;</span><br><span class="line">		insert(data[(max+min)/<span class="number">2</span>]);		<span class="comment">//若min&lt;max则取下标mid=(max+min)/2即区间的中间值进行插入树操作。 </span></span><br><span class="line">		sortedArrayToLowestBST_Main(data,min,(max+min)/<span class="number">2</span><span class="number">-1</span>);<span class="comment">//再从mid往左的区间进行递归 </span></span><br><span class="line">		sortedArrayToLowestBST_Main(data,(max+min)/<span class="number">2</span>+<span class="number">1</span>,max);<span class="comment">//从mid的往右的区间进行递归 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BSTree</span>&lt;T&gt;:</span>:inOrderMain(Node&lt;T&gt; *ptr)&#123;</span><br><span class="line">	<span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		inOrderMain(ptr-&gt;left);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ptr-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		inOrderMain(ptr-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BSTree</span>&lt;T&gt;:</span>:outputLevelMain(Node&lt;T&gt; *p)</span><br><span class="line">&#123;</span><br><span class="line">	Node&lt;T&gt; *Queue[<span class="number">100</span>];			<span class="comment">//建立一个容量100的结点指针数组作为队列 </span></span><br><span class="line">	<span class="keyword">int</span> front=<span class="number">0</span>,rear=<span class="number">0</span>;				<span class="comment">//建立队首和队位指针 </span></span><br><span class="line">	<span class="keyword">if</span>(root!=<span class="literal">NULL</span>)					<span class="comment">//判空 </span></span><br><span class="line">	&#123;</span><br><span class="line">		Queue[rear++]=p;						<span class="comment">//1、先将根入队</span></span><br><span class="line">		<span class="keyword">while</span>(front!=rear)						<span class="comment">//2、设置队列非空循环条件 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;Queue[front]-&gt;data&lt;&lt;<span class="string">" "</span>;		<span class="comment">//3、输出结点的值 </span></span><br><span class="line">			<span class="keyword">if</span>(Queue[front]-&gt;left!=<span class="literal">NULL</span>)		<span class="comment">//4、若该结点左子树不为空则入队列</span></span><br><span class="line">			&#123;</span><br><span class="line">				Queue[rear]=Queue[front]-&gt;left;	<span class="comment">//补充:注意先存数据再将尾指针加1 </span></span><br><span class="line">				rear=(rear+<span class="number">1</span>)%<span class="number">100</span>;		<span class="comment">//5、为了充分使用空间，我们使用循环队列，队尾+1取余 </span></span><br><span class="line">			&#125;		</span><br><span class="line">			<span class="keyword">if</span>(Queue[front]-&gt;right!=<span class="literal">NULL</span>)		<span class="comment">//6、若该结点右子树不为空则入队列</span></span><br><span class="line">			&#123;</span><br><span class="line">				Queue[rear]=Queue[front]-&gt;right; </span><br><span class="line">				rear=(rear+<span class="number">1</span>)%<span class="number">100</span>;		<span class="comment">//7、同理队尾+1取余 </span></span><br><span class="line">			&#125;</span><br><span class="line">			front=(front+<span class="number">1</span>)%<span class="number">100</span>;		<span class="comment">//8、将输出过的结点出队列 </span></span><br><span class="line">		&#125; 				</span><br><span class="line">	&#125; 	</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">int</span>  <span class="title">BSTree</span>&lt;T&gt;:</span>:deepthMain(Node&lt;T&gt; *p)&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftDeepth=deepthMain(p-&gt;left);		<span class="comment">//计算左子树高度 </span></span><br><span class="line">    <span class="keyword">int</span> rightDeepth=deepthMain(p-&gt;right);	<span class="comment">//计算右子树高度			</span></span><br><span class="line">    <span class="keyword">return</span> max(leftDeepth,rightDeepth)+<span class="number">1</span>;	<span class="comment">//取左右子树的最高高度再+1，max()函数需要头文件#include &lt;algorithm&gt; </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BSTree</span>&lt;T&gt;:</span>:destroyTreeMain(Node&lt;T&gt; *p)&#123;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		destroyTreeMain(p-&gt;left);	<span class="comment">//若有左子树则进入摧毁左子树递归 </span></span><br><span class="line">		destroyTreeMain(p-&gt;right);	<span class="comment">//若有右子树则进入摧毁右子树递归  </span></span><br><span class="line">		<span class="keyword">delete</span> p;					<span class="comment">//删除该节点 </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BSTree</span>&lt;T&gt;:</span>:outPutTreeByGraphMain(Node&lt;T&gt; *t,<span class="keyword">int</span> h)&#123;</span><br><span class="line">	<span class="keyword">if</span>(t!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		outPutTreeByGraphMain(t-&gt;right,h+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;h;i++)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"   "</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;t-&gt;data;</span><br><span class="line">		<span class="keyword">if</span>(t-&gt;left!=<span class="literal">NULL</span>&amp;&amp;t-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"&lt;"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;left==<span class="literal">NULL</span>&amp;&amp;t-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"/"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;left!=<span class="literal">NULL</span>&amp;&amp;t-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"\\"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		outPutTreeByGraphMain(t-&gt;left,h+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">menu</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"应用选择:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"			0:退出"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"			1*:创建：输入待排序序列,创建排序二叉树"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"			2*:删除：输入一个数据,在本树中查找该数据,若查找到则删除,若没有查找到则输出提示信息"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"			3*:求AVL：计算本树的平均成功查找长度"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"			4*:判断合法查找序列：输入一个序列,判断该序列是否是二叉排序树的合法查找序列"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"			5*:输入一个有序序列,创建高度最小的二叉排序树"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"			6:查找：输入数据,在本树中查询是否含有该数据"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"			7:插入：输入数据,在本树中插入数据为该数据的新结点"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"			8:中序遍历输出"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"			9:层次遍历输出"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"			10:树的高度输出"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"			11:销毁树"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"			12:图像打印本树"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"			13:调出菜单"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">function</span>(<span class="title">BSTree</span>&lt;T&gt; <span class="title">tree</span>,<span class="title">T</span> <span class="title">stopSign</span>)&#123;</span></span><br><span class="line">		menu();</span><br><span class="line">		<span class="keyword">int</span> option;</span><br><span class="line">		<span class="keyword">bool</span> select=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">while</span>(select)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入正确选择功能序号，非正确功能信号不会响应："</span>; </span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;option;</span><br><span class="line">			<span class="keyword">if</span>(option&gt;=<span class="number">0</span>&amp;&amp;option&lt;=<span class="number">13</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="keyword">switch</span>(option)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span> :&#123;</span><br><span class="line">				select=<span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; 				</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span> :&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"输入数据序列,以"</span>&lt;&lt;stopSign&lt;&lt;<span class="string">"为结束标志："</span> ; </span><br><span class="line">				tree.creatBSTree(stopSign);</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"创建完毕"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;			</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span> :&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"输入待删除数据："</span> ;</span><br><span class="line">				T t1;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;t1;</span><br><span class="line">				<span class="keyword">if</span>(tree.remove(t1))</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"删除成功"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"删除失败,树中无该数据"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span> :&#123;</span><br><span class="line">				<span class="keyword">if</span>(tree.getRoot()==<span class="literal">NULL</span>)&#123;</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;<span class="string">"空树！AVL=0"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;<span class="string">"本树的平均成功查找长度为："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;tree.getAVL()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				&#125;	 </span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;			</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span> :&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"输入序列,以"</span>&lt;&lt;stopSign&lt;&lt;<span class="string">"为结束标志："</span>;</span><br><span class="line">				<span class="keyword">if</span>(tree.judgeLegalSequence(stopSign))</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"该查找序列合法"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"该查找序列不合法"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; 			</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"该操作会摧毁之前的树,进行重新建树,继续请输入1,取消输入0："</span>;</span><br><span class="line">				<span class="keyword">int</span> t;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">				<span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">					tree.sortedArrayToLowestBST();</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;<span class="string">"创建成功"</span>;</span><br><span class="line">					<span class="keyword">break</span>;			</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"创建失败"</span>&lt;&lt;<span class="built_in">endl</span>; 		</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; 				</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span> :&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"输入待查找数据："</span> ;</span><br><span class="line">				T t2;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;t2;</span><br><span class="line">				Node&lt;T&gt; *root=tree.getRoot();</span><br><span class="line">				Node&lt;T&gt; **p=tree.search(t2,root);</span><br><span class="line">				<span class="keyword">if</span>(*p!=<span class="literal">NULL</span>)</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"查找成功"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"查找失败,树中无该数据"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">break</span>; </span><br><span class="line">			&#125; 				</span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span> :&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"输入待插入数据："</span> ;</span><br><span class="line">				T t3;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;t3;</span><br><span class="line">				<span class="keyword">if</span>(tree.insert(t3))</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"插入结点成功"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"已有该节点，插入失败"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;				</span><br><span class="line">			<span class="keyword">case</span> <span class="number">8</span> :&#123;</span><br><span class="line">				tree.inOrder();</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"输出完毕"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;				</span><br><span class="line">			<span class="keyword">case</span> <span class="number">9</span> :&#123;</span><br><span class="line">				tree.outputLevel();</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"输出完毕"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;				</span><br><span class="line">			<span class="keyword">case</span> <span class="number">10</span> :&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"本树的高度为："</span>&lt;&lt;tree.deepth()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">11</span> :&#123;</span><br><span class="line">				tree.destroyTree();</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"摧毁完毕"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">12</span>:&#123;</span><br><span class="line">				<span class="keyword">if</span>(tree.getRoot()==<span class="literal">NULL</span>)</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"空树！打印失败"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				tree.outPutTreeByGraph();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">13</span>:&#123;</span><br><span class="line">				menu();</span><br><span class="line">				<span class="keyword">break</span>;		</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"该树的功能调用程序结束"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BSTree&lt;<span class="keyword">int</span>&gt; intTree;</span><br><span class="line">	BSTree&lt;<span class="keyword">char</span>&gt; charTree;</span><br><span class="line">	BSTree&lt;<span class="keyword">double</span>&gt; floatTree; </span><br><span class="line">	function(intTree,<span class="number">-1</span>);</span><br><span class="line">	function(charTree,<span class="string">'#'</span>);</span><br><span class="line">	function(floatTree,<span class="number">-1.0</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">测试数据：</span></span><br><span class="line"><span class="comment">建树序列：25 18 46 2 53 39 32 4 74 67 21 -1</span></span><br><span class="line"><span class="comment">判断合法1：25 46 39 -1</span></span><br><span class="line"><span class="comment">判断合法2：25 14 53  -1</span></span><br><span class="line"><span class="comment">有序序列建立高度最低的树：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div><div><div><div style="text-align:center;color:#555;font-size:14px">-----------------------本文结束 <i class="fa fa-heart"></i> 感谢阅读-----------------------</div></div></div><div><div id="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！恰饭^.^~</div><button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20190826214611.png" alt="峻源 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20190826214431.png" alt="峻源 支付宝"><p>支付宝</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>峻源</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://lyxf2000.github.io/posts/980b4487/" title="数据结构【二叉排序树实现和应用】">http://lyxf2000.github.io/posts/980b4487/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/数据结构/" rel="tag"><i class="fa fa-tag">数据结构</i></a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/a05558a1/" rel="next" title="数据结构【九】排序"><i class="fa fa-chevron-left"></i> 数据结构【九】排序</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/posts/fa28adca/" rel="prev" title="数据结构【零】总概述">数据结构【零】总概述 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80NjM0NC8yMjg1NQ=="></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><a href="/"><img class="site-author-image" itemprop="image" src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/avatar.gif" alt="峻源"></a><p class="site-author-name" itemprop="name">峻源</p><div class="site-description motion-element" itemprop="description">乐于心，乐与心，乐之屿，心扉间</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">122</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">17</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">21</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:1194320636@qq.com" title="QE-Mail &rarr; mailto:1194320636@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i>QE-Mail</a> </span><span class="links-of-author-item"><a href="https://music.163.com/#/playlist?id=699716432" title="CloudMusic &rarr; https://music.163.com/#/playlist?id=699716432" rel="noopener" target="_blank"><i class="fa fa-fw fa-music"></i>CloudMusic</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://www.baidu.com/" title="https://www.baidu.com/" rel="noopener" target="_blank">百度</a></li><li class="links-of-blogroll-item"><a href="https://www.google.com/?hl=zh_CN" title="https://www.google.com/?hl=zh_CN" rel="noopener" target="_blank">谷歌</a></li><li class="links-of-blogroll-item"><a href="https://www.zhihu.com/" title="https://www.zhihu.com/" rel="noopener" target="_blank">知乎</a></li><li class="links-of-blogroll-item"><a href="https://juejin.im/" title="https://juejin.im/" rel="noopener" target="_blank">掘金</a></li><li class="links-of-blogroll-item"><a href="https://github.com/" title="https://github.com/" rel="noopener" target="_blank">github</a></li><li class="links-of-blogroll-item"><a href="https://www.luogu.org/" title="https://www.luogu.org/" rel="noopener" target="_blank">洛谷</a></li></ul></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1、C-中指针的指针和引用"><span class="nav-number">2.</span> <span class="nav-text">1、C++中指针的指针和引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#（1）首先再次深入了解指针和指针的指针"><span class="nav-number">2.0.1.</span> <span class="nav-text">（1）首先再次深入了解指针和指针的指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（2）引用"><span class="nav-number">2.0.2.</span> <span class="nav-text">（2）引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（3）函数返回引用值"><span class="nav-number">2.0.3.</span> <span class="nav-text">（3）函数返回引用值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（4）总结："><span class="nav-number">2.0.4.</span> <span class="nav-text">（4）总结：</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#2、封装一棵树"><span class="nav-number">3.</span> <span class="nav-text">2、封装一棵树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3、图形化输出一棵树"><span class="nav-number">4.</span> <span class="nav-text">3、图形化输出一棵树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4、本树的模板类的进一步封装体会"><span class="nav-number">5.</span> <span class="nav-text">4、本树的模板类的进一步封装体会</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5、switch-case和"><span class="nav-number">6.</span> <span class="nav-text">5、switch case和{}</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6、其他小坑"><span class="nav-number">7.</span> <span class="nav-text">6、其他小坑</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7、最终代码"><span class="nav-number">8.</span> <span class="nav-text">7、最终代码</span></a></li></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love" id="heart"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">峻源</span></div><span>本站已运行<span id="showDays"></span></span><script>var seconds=1e3,minutes=60*seconds,hours=60*minutes,days=24*hours,years=365*days,birthDay=Date.UTC(2019,8,1,14,0,0);setInterval(function(){var e=new Date,s=e.getFullYear(),t=e.getMonth()+1,a=e.getDate(),o=e.getHours(),r=e.getMinutes(),n=e.getSeconds(),h=Date.UTC(s,t,a,o,r,n),u=h-birthDay,d=Math.floor(u/years),y=Math.floor(u/days-365*d),i=Math.floor((u-(365*d+y)*days)/hours),l=Math.floor((u-(365*d+y)*days-i*hours)/minutes),M=Math.floor((u-(365*d+y)*days-i*hours-l*minutes)/seconds);document.getElementById("showDays").innerHTML=""+d+"年"+y+"天"+i+"小时"+l+"分钟"+M+"秒"},1e3)</script><div><i class="fa fa-user-md"></i> <span id="busuanzi_container_site_uv">访问人数：<span id="busuanzi_value_site_uv"></span> </span>&nbsp;|&nbsp; <i class="fa fa-eye"></i> <span id="busuanzi_container_site_pv">总访问量：<span id="busuanzi_value_site_pv"></span> </span>&nbsp;|&nbsp; <i class="fa fa-pencil"></i> <span class="post-count">博客全站共 453.9k 字</span></div></div></footer></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=3.4.1"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script><script src="/js/utils.js?v=7.2.0"></script><script src="/js/motion.js?v=7.2.0"></script><script src="/js/affix.js?v=7.2.0"></script><script src="/js/schemes/pisces.js?v=7.2.0"></script><script src="/js/scrollspy.js?v=7.2.0"></script><script src="/js/post-details.js?v=7.2.0"></script><script src="/js/next-boot.js?v=7.2.0"></script><script>window.livereOptions={refer:"posts/980b4487/"},function(e,t){var n,r=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&(n=e.createElement(t),n.src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,r.parentNode.insertBefore(n,r))}(document,"script")</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><link rel="stylesheet" href="/dist/APlayer.min.css"><div id="aplayer"></div><script type="text/javascript" src="/dist/APlayer.min.js"></script><script type="text/javascript" src="/dist/music.js"></script><script type="text/javascript" src="/js/firework.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":220,"height":400},"mobile":{"show":false},"react":{"opacity":0.9},"log":false});</script></body></html><!-- rebuild by neat -->