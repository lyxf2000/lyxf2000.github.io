<!-- build time:Tue Oct 12 2021 10:23:21 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link rel="stylesheet" href="/lib/pace/pace-theme-center-atom.min.css?v=1.0.2"><meta name="google-site-verification" content="4fXg7_br-6EcJkwb-a6Ci2NLdRf7aMleAsM1L9S1nBI"><link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="/css/main.css?v=7.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/2.ico?v=7.2.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/1.ico?v=7.2.0"><link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.2.0",sidebar:{position:"left",display:"post",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!0,fancybox:!0,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="需要知道的图的相关基本概念无向图有向图权度、出度、入度边和弧：无向图中边就叫边，有向图中边叫做弧，还有弧头和弧尾之分，带箭头一端为弧头。路径和回路：从一个顶点到另一顶点途径的所有顶点组成的序列（包含这两个顶点），称为一条路径。如果路径中第一个顶点和最后一个顶点相同，则此路径称为”回路”（或”环”）。简单路径（回路）：顶点不重复的路径（回路）完全图:无向图中任意两个点之间都有边，有向图中任意两个点有"><meta name="keywords" content="数据结构"><meta property="og:type" content="article"><meta property="og:title" content="数据结构【七】:图"><meta property="og:url" content="http://lyxf2000.github.io/posts/7dc31fbc/index.html"><meta property="og:site_name" content="乐屿心扉"><meta property="og:description" content="需要知道的图的相关基本概念无向图有向图权度、出度、入度边和弧：无向图中边就叫边，有向图中边叫做弧，还有弧头和弧尾之分，带箭头一端为弧头。路径和回路：从一个顶点到另一顶点途径的所有顶点组成的序列（包含这两个顶点），称为一条路径。如果路径中第一个顶点和最后一个顶点相同，则此路径称为”回路”（或”环”）。简单路径（回路）：顶点不重复的路径（回路）完全图:无向图中任意两个点之间都有边，有向图中任意两个点有"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111191711.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111191735.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111191900.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111191913.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111192845.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111192901.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/%E7%9F%A9%E9%98%B5%E5%82%A8%E5%AD%98DFS%E6%96%B0.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8BFS%E6%96%B0.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191126174423.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/%E5%9B%BE%E7%89%871.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604154211735.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604154249630.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604154835331.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604151536823.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604152004115.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604151644042.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604151546193.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604151933442.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111191711.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111191735.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111191900.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111191913.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604170312021.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604160124890.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111192845.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111192901.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604170440065.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604161626658.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604162514402.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604163635829.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604163618229.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604164638869.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604165249337.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604180112418.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604180437229.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604181306893.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604181140708.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604181505918.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604181740612.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604192536036.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604192642278.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604193015722.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604193345470.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604193650364.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604193549749.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604193630526.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604193615547.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604194459629.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604195244303.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604200152588.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604200229997.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604200414600.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604200719718.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604200110980.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604202455016.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604202814675.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604202950410.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604203134556.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604203215905.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604204927186.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604205355183.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604205522543.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604205619365.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604205640991.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604210903353.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604213727606.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604214141172.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604214400401.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604214449533.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604214626043.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604214510301.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604215051829.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604215310602.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605091124642.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605091225903.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605091301952.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605091537586.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605091401274.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605091710074.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605091725141.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191126174423.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605094355372.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605095330936.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605095435830.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605095733091.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605100018047.png"><meta property="og:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605102308632.png"><meta property="og:updated_time" content="2021-10-11T12:54:27.689Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="数据结构【七】:图"><meta name="twitter:description" content="需要知道的图的相关基本概念无向图有向图权度、出度、入度边和弧：无向图中边就叫边，有向图中边叫做弧，还有弧头和弧尾之分，带箭头一端为弧头。路径和回路：从一个顶点到另一顶点途径的所有顶点组成的序列（包含这两个顶点），称为一条路径。如果路径中第一个顶点和最后一个顶点相同，则此路径称为”回路”（或”环”）。简单路径（回路）：顶点不重复的路径（回路）完全图:无向图中任意两个点之间都有边，有向图中任意两个点有"><meta name="twitter:image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111191711.png"><link rel="canonical" href="http://lyxf2000.github.io/posts/7dc31fbc/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>数据结构【七】:图 | 乐屿心扉</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">乐屿心扉</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">Keep Thinking</h1></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-playlist"><a href="/playlist/" rel="section"><i class="menu-item-icon fa fa-fw fa-music"></i><br>歌单</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://lyxf2000.github.io/posts/7dc31fbc/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="峻源"><meta itemprop="description" content="乐于心，乐与心，乐之屿，心扉间"><meta itemprop="image" content="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="乐屿心扉"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">数据结构【七】:图</h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-11-11 18:31:45" itemprop="dateCreated datePublished" datetime="2019-11-11T18:31:45+08:00">2019-11-11</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-10-11 20:54:27" itemprop="dateModified" datetime="2021-10-11T20:54:27+08:00">2021-10-11</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span> </span><span class="post-time">&nbsp; | &nbsp; <span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">字数统计:</span> <span class="post-count">10.8k(字)</span> </span><span class="post-time">&nbsp; | &nbsp; <span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">阅读时长≈</span> <span class="post-count">38(分)</span></span><br><p></p></div></header><div class="post-body" itemprop="articleBody"><h2 id="需要知道的图的相关基本概念"><a href="#需要知道的图的相关基本概念" class="headerlink" title="需要知道的图的相关基本概念"></a>需要知道的图的相关基本概念</h2><hr><ul><li><p>无向图</p></li><li><p>有向图</p></li><li><p>权</p></li><li><p>度、出度、入度</p></li><li><p><strong>边和弧：无向图中边就叫边，有向图中边叫做弧，还有弧头和弧尾之分，带箭头一端为弧头。</strong></p></li><li><p><strong>路径和回路：从一个顶点到另一顶点途径的所有顶点组成的序列（包含这两个顶点），称为一条路径。如果路径中第一个顶点和最后一个顶点相同，则此路径称为”回路”（或”环”）。</strong></p><ul><li><strong>简单路径（回路）：顶点不重复的路径（回路）</strong></li></ul></li><li><p><strong>完全图:无向图中任意两个点之间都有边，有向图中任意两个点有互相通往对方的弧</strong></p><ul><li>具有 n 个顶点的完全图，图中边的数量为 n(n-1)/2；而对于具有 n 个顶点的有向完全图，图中弧的数量为 n(n-1)。</li></ul></li><li><p><strong>稀疏图和稠密图：边数e&lt;nlogn为稀疏图反之为稠密图</strong></p></li><li><p><strong>简单图：无重复的边或顶点到自身的边</strong></p></li><li><p><strong>连通图：无向图中，如果任意两个顶点之间都能够连通</strong></p><ul><li><strong>连通分量：若无向图不是连通图，但图中存储某个极大子图符合连通图的性质，则称该子图为连通分量。</strong></li></ul></li><li><p><strong>强连通图：有向图中，任意两个顶点之间能够连通</strong></p><ul><li><strong>强连通分量：若有向图不是连通图，但图中存储某个极大子图符合强连通图的性质，则称该子图为强连通分量。</strong></li></ul></li><li><p><strong>网：图上的边或弧带有权则称为网。</strong></p></li><li><p><strong>生成树:无向图中连通且n个顶点n-1条边称为生成树。有向图中一顶点入度为0其余顶点入度为1的叫有向树。一个有向图由若干棵有向树构成生成森林。</strong></p></li></ul><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><hr><h3 id="1-邻接矩阵存储"><a href="#1-邻接矩阵存储" class="headerlink" title="1.邻接矩阵存储"></a>1.邻接矩阵存储</h3><h4 id="（1）图象理解"><a href="#（1）图象理解" class="headerlink" title="（1）图象理解"></a>（1）图象理解</h4><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111191711.png" alt></p><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111191735.png" alt></p><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111191900.png" alt></p><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111191913.png" alt></p><h4 id="（2）语言构造"><a href="#（2）语言构造" class="headerlink" title="（2）语言构造"></a>（2）语言构造</h4><p>根据图象理解，我们可以在类中<strong>动态定义一个一维数组存储节点，一个二维数组存储邻接矩阵</strong></p><h3 id="2-邻接表存储"><a href="#2-邻接表存储" class="headerlink" title="2.邻接表存储"></a>2.邻接表存储</h3><h4 id="（1）图象理解-1"><a href="#（1）图象理解-1" class="headerlink" title="（1）图象理解"></a>（1）图象理解</h4><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111192845.png" alt></p><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111192901.png" alt></p><p><font size="4" color="red"><strong>若为有权图，则需要在结点中添加代表权值的变量</strong></font></p><p>根据图象理解，<strong>我们先定义两个结构体节点，一个为邻接表的结点，一个为邻接表中存储其联通关系的链表结点。</strong></p><blockquote><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_35644234/article/details/57083107" target="_blank" rel="noopener">数据结构—图的详细介绍</a></p><p><a href="https://www.cnblogs.com/w-wanglei/p/figure.html" target="_blank" rel="noopener">大话数据结构-图</a></p></blockquote><h2 id="图的遍历（DFS和BFS）"><a href="#图的遍历（DFS和BFS）" class="headerlink" title="图的遍历（DFS和BFS）"></a>图的遍历（DFS和BFS）</h2><hr><h4 id="1、Depth-First-Search深度优先探索"><a href="#1、Depth-First-Search深度优先探索" class="headerlink" title="1、Depth First Search深度优先探索"></a>1、Depth First Search深度优先探索</h4><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/%E7%9F%A9%E9%98%B5%E5%82%A8%E5%AD%98DFS%E6%96%B0.png" alt></p><p><font size="4" color="red"><strong>所以我们DFS分两个函数主要是因为这个辅助数组一般方式下不能放入递归函数体中，不然每次都会创建</strong></font></p><h4 id="2、Breadth-First-Search广度优先探索"><a href="#2、Breadth-First-Search广度优先探索" class="headerlink" title="2、Breadth First Search广度优先探索"></a>2、Breadth First Search广度优先探索</h4><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8BFS%E6%96%B0.png" alt></p><p><font size="4" color="red"><strong>BFS可以在一个过程中完成，分两部分是为了解决多连通分量的情况，利用同DFS</strong></font></p><div class="note success"><p>注意:1、DFS和BFS的主函数其实是一样的,区别在于子过程2、判断结点信息只需要在主过程判断一次传进来的点位置就可以了，因为子过程调用一定是正确的存在的点位置</p></div>#### 3、补充<div class="note success"><p>无论是BFS还是DFS，设n个点e个边，用邻接矩阵作存储结构，查找每一个顶点的邻接点所需时间为O(n)，遍历图的时间复杂度为O(n2)。用邻接表作存储结构，查找所有的邻接点所需时间为O(e)，每个顶点仅被访问1次即所需时间为O(n)遍历图的时间复杂度为O(n+e) 。</p></div>- 利用 DFS 或 BFS 可以获取图的生成树<blockquote><p>推荐阅读</p><p><a href="https://www.cnblogs.com/skywang12345/p/3711483.html" target="_blank" rel="noopener">图的遍历之 深度优先搜索和广度优先搜索</a></p></blockquote><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><hr><h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><blockquote><p>推荐阅读</p><p><a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/30/2615542.html" target="_blank" rel="noopener">最小生成树-Prim算法和Kruskal算法</a></p></blockquote><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><hr><h4 id="1、求一点到其他点的最短路径（单源最短路径）"><a href="#1、求一点到其他点的最短路径（单源最短路径）" class="headerlink" title="1、求一点到其他点的最短路径（单源最短路径）"></a>1、求一点到其他点的最短路径（单源最短路径）</h4><h5 id="①Dijkstra算法"><a href="#①Dijkstra算法" class="headerlink" title="①Dijkstra算法"></a>①Dijkstra算法</h5><p><strong>复杂度O(n<sup>2</sup>)</strong></p><p><font size="4" color="red"><strong>注意：Dijkstra算法不能允许权值为负</strong></font></p><blockquote><p>推荐阅读</p><p><a href="https://www.jianshu.com/p/ff6db00ad866" target="_blank" rel="noopener">深入理解 Dijkstra 算法实现原理</a></p><p><a href="https://blog.csdn.net/qq_35644234/article/details/60870719" target="_blank" rel="noopener">最短路径问题—Dijkstra算法详解</a></p></blockquote><h5 id="②bellman-ford算法"><a href="#②bellman-ford算法" class="headerlink" title="②bellman-ford算法"></a>②bellman-ford算法</h5><p><font size="4" color="red"><strong>注意：bellman-ford算法允许权值为负</strong></font></p><h4 id="3、求任意两点的最短路径"><a href="#3、求任意两点的最短路径" class="headerlink" title="3、求任意两点的最短路径"></a>3、求任意两点的最短路径</h4><h5 id="①Floyd算法"><a href="#①Floyd算法" class="headerlink" title="①Floyd算法"></a>①Floyd算法</h5><blockquote><p><a href="https://www.jianshu.com/p/f27f9b88a24a" target="_blank" rel="noopener">傻子也能看懂的弗洛伊德算法（转）</a></p></blockquote><p><strong>复杂度O(n<sup>3</sup>)</strong></p><p><font size="4" color="red"><strong>注意： 通常可以在任何图中使用，包括有向图、带负权边的图。但是不能有带负权的边组成的回路</strong></font></p><h2 id="AOV（Activity-On-Vertices）网络和拓扑排序"><a href="#AOV（Activity-On-Vertices）网络和拓扑排序" class="headerlink" title="AOV（Activity On Vertices）网络和拓扑排序"></a>AOV（Activity On Vertices）网络和拓扑排序</h2><hr><h4 id="1、AVO网络"><a href="#1、AVO网络" class="headerlink" title="1、AVO网络"></a>1、AVO网络</h4><p>活动网络可以用来描述生产计划、施工过程、生产流程、程序流程等工程中各子工程的安排问题。 一般一个工程可以分成若干个子工程，这些子工程称为活动（Activity）。完成了这些活动，整个工程就完成了。</p><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191126174423.png" alt></p><p>我们可以用上图的有向图来表示课程之间的先修关系。在这种有向图中，顶点表示课程学习活动，有向边表示课程之间的先修关系。例如顶点C1到C8有一条有向边，表示课程C1必须在课程C8之前先学习完。</p><p>实际上，在这种有向图中，用顶点表示活动，<strong>用有向边表示活动u必须先于活动v进行。这种有向图叫做活动网络（Activity on Vertices），记做AOV网络。</strong></p><p><strong>前驱与后继：</strong>在AOV网络中，如果存在有向边，则称活动u必须在活动v之前进行，并称u是v的直接前驱，v是u的直接后继。如果存在有向路径，则称u是v的前驱，v是u的后继。</p><p><strong>有向环与有向无环图：</strong>从前驱与后继的传递性和反自反性可以看出，AOV网络中不能出现有向回路（或称为有向环）。<strong>不含有向回路的有向图称为有向无环图(DAG, Directed Acyclic Graph)。</strong></p><p><font size="4" color="red"><strong>在AOV网络中如果出现了有向回路，则意味着某项活动以自己作为先决条件，这是不对的。</strong></font></p><h4 id="2、拓扑排序"><a href="#2、拓扑排序" class="headerlink" title="2、拓扑排序"></a>2、拓扑排序</h4><p><strong>1、</strong>判断有向无环图的方法是对AOV网络构造它的拓扑有序序列（Topological Order Sequence）；</p><p><strong>2、</strong>构造这种AOV网络全部顶点的拓扑有序序列的运算称为拓扑排序，即将<strong>各个顶点排列成一个线性有序的序列，使得AOV网络中所有存在的前驱和后继关系都能得到满足。</strong></p><p><strong>3、</strong><font size="4" color="red"><strong>一个AOV网络的拓扑有序序列可能不是唯一的；</strong></font></p><p><strong>4、</strong>拓扑排序实现方法：</p><p><strong>（1）从AOV网络中选择一个入度为0（即没有直接前驱）的顶点并输出；</strong></p><p><strong>（2）从AOV网络中删除该顶点及该顶点发出的所有边；</strong></p><p><strong>（3）重复步骤（1）和（2），直至找不到入度为0的顶点。</strong></p><p><strong>经过上述步骤后，有两种结果：（1）所有的顶点都被输出，也就是整个拓扑排序完成了；（2）仍有顶点没有被输出，只剩下入度不为0的顶点，即存在有环图。</strong></p><blockquote><p>摘选自：</p><p><a href="https://www.cnblogs.com/fzl194/p/8747537.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/fzl194/p/8747537.html" target="_blank" rel="noopener">AOV网络和Kahn算法拓扑排序</a></a></p><p><a href="http://www.voidcn.com/article/p-kjwwcsbi-bes.html" target="_blank" rel="noopener">AOV网络与拓扑（一）</a></p></blockquote><h2 id="AOE（Activity-On-Edge）网络与关键路径"><a href="#AOE（Activity-On-Edge）网络与关键路径" class="headerlink" title="AOE（Activity On Edge）网络与关键路径"></a>AOE（Activity On Edge）网络与关键路径</h2><hr><h3 id="1、AOE网络"><a href="#1、AOE网络" class="headerlink" title="1、AOE网络"></a>1、AOE网络</h3><h4 id="AOE网的基础概念"><a href="#AOE网的基础概念" class="headerlink" title="AOE网的基础概念"></a>AOE网的基础概念</h4><p>定义:如果在<strong>无环的带权有向图</strong>中用<strong>有向边表示一个工程中的活动用边上的权值表示活动的持续时间用顶点表示事件</strong>则这样的有向图叫做用边表示活动的网络，简称<strong>AOE网络</strong></p><p><font size="4" color="red"><strong>一定要注意：AOV网中，点代表活动，AOE网中边代表活动两者是不同的。</strong></font></p><p><strong>实践和活动的理解，AOE网中边为活动，点为事件，可理解事件是一个“检查点”，它是一种“状态”，只有“检查”到通向该事件的活动全部完成的状态，才能进入下面的活动</strong></p><ul><li>AOE网中没有入边的顶点称为<strong>始点</strong></li><li>AOE网中没有出边的顶点称为<strong>终点</strong></li></ul><h4 id="AOE网的性质"><a href="#AOE网的性质" class="headerlink" title="AOE网的性质"></a>AOE网的性质</h4><p>1、<strong>只有进入某顶点的各活动都结束，该顶点所代表的事件才能发生</strong></p><p>2、<strong>只有某顶点所代表的事件发生后，从该顶点出发的各活动才能开始</strong></p><h4 id="AOE网的应用"><a href="#AOE网的应用" class="headerlink" title="AOE网的应用"></a>AOE网的应用</h4><p>AOE在工程方面非常有用：</p><p>例如：</p><p>（1）完成整个工程<strong>至少需要多少时间</strong>（假设没有环）；</p><p>（2）为缩短完成工程所需时间，<strong>应当加快那些活动</strong>？</p><p><font size="4" color="red"><strong>因为在工程当中，很多活动是并行的，所以有些活动是导致工期长短的关键活动，不能拖延，而有些活动是可以在一定范围内延迟的，这是计算关键路径的原因！</strong></font></p><h3 id="2、关键路径"><a href="#2、关键路径" class="headerlink" title="2、关键路径"></a>2、关键路径</h3><h4 id="关键路径的相关概念"><a href="#关键路径的相关概念" class="headerlink" title="关键路径的相关概念"></a>关键路径的相关概念</h4><p>从源点到各个顶点，以至从源点到汇点的有向路径可能不止一条。这些路径的长度也可能不同，完成不同路径的活动所需时间不同，但只有各条路径上所有活动都完成了，整个工程才完成。<strong>完成整个工程所需时间取决于从源点到汇点的最长路径长度，即在该路径上所有活动的持续时间之和，给路径称为关键路径</strong>。</p><p>为了找出关键路径，必须找出<strong>关键活动，即不按期完成就会影响整个工程完成的活动</strong>。</p><p><strong>关键路径上的所有活动都是关键活动。</strong></p><h4 id="四个和计算关键路径相关的量"><a href="#四个和计算关键路径相关的量" class="headerlink" title="四个和计算关键路径相关的量"></a>四个和计算关键路径相关的量</h4><ul><li>事件最早可能开始时间Ve[k]：求法为源点到该顶点的最大长度，需要<strong>正向计算取大得出</strong></li><li>事件最迟允许开始时间Vl[k]：需要<strong>逆向计算取小得到</strong></li><li>活动最早开始时间e[i]：<strong>活动代表的是边，它的最早开始时间和它作为某个点出度的事件的最早开始时间相同</strong></li><li>活动的最晚开始时间l[i]：<strong>通过该边作为入度指向的事件的最晚触发事件逆向计算得到</strong></li></ul><h4 id="计算关键路径"><a href="#计算关键路径" class="headerlink" title="计算关键路径"></a>计算关键路径</h4><p><font size="4" color="red"><strong>计算各个活动的时间余量l[k]-e[k]，时间余量为0即（l[k]=e[k]）者为关键活动</strong></font></p><div class="note success"><p>多个或一个活动的完成才能决定一个事件的触发，它取决于触发事件的活动中最长的一个，我们从始点开始计算每个事件的最早开始时间，也就是计算每个点相对始点的最大路径，一直计算到终点，就计算出了完成工程的最早时间，通过工程完成的最早时间我们能逆推每个事件完成的最晚时间，然后通过每个事件得出每个工程的最晚开始时间</p></div>**通过最大路径计算得到每个事件的最早发生时间-->最终得到工程完成最早时间（终点事件的触发时间）-->逆推每个事件的最晚触发时间-->通过每个事件的最晚触发时间能逆推每个活动的最晚开始时间-->比较每个活动的最早开始时间（由相关量性质可知，计算过事件的最早发生时间，活动的最早发生时间也就确定了）和最晚开始时间，没有时间余量的活动为关键活动-->解决为缩短工期能够加快那些活动的问题**<p><strong>只有加快关键活动才能加快进程，但是值得注意的是，我们只能在现实中尽快督促完成，<em>若是理想化直接提前很长时间完成关键活动，实际上AOE网就会改变，关键路径也就不一定是原样了</em></strong></p><p><strong>其次，可能有多条关键路径，只提⾼⼀条关键路径上的关键活动速度并不能缩短整个⼯程的⼯期，只有加快那些包括在所有关键路径上的关键活动（<em>所有关键路径都有出现的活动</em>）才能达到缩短⼯期的⽬的。</strong></p><p>例：</p><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/%E5%9B%BE%E7%89%871.png" alt></p><p>第一步：</p><p>事件a最早发生时间：0 同时得到：活动(a,b)最早发生时间=活动(a,c)最早发生时间=事件a最早发生时间=0</p><p>事件b最早发生时间：4 同时得到：活动(b,d)最早发生时间=事件b最早发生时间=4</p><p>事件c最早发生时间：3 同时得到：活动(c,d)最早发生时间=事件c最早发生时间=3</p><p>事件d最早发生时间：8</p><p>第二步(<strong>没有体现出一个事件引起多个活动的情况的最晚时间，但是我们要知道肯定是取最晚时间中最早的那个</strong>)：</p><p>事件d最晚发生时间：8</p><p>事件b最晚发生时间：6</p><p>事件c最晚发生时间：3</p><p>第三步：</p><p>活动(b,d)最晚发生时间：6</p><p>活动(c,d)最晚发生时间:3</p><p>活动(a,b)最晚发生时间:2</p><p>活动(a,c)最晚发生时间:0</p><p>第四步：</p><p>活动(a,c)最晚发生时间-活动(a,c)最早发生时间=0-0=0</p><p>活动(a,b)最晚发生时间-活动(a,b)最早发生时间=2-0=2</p><p>活动(c,d)最晚发生时间-活动(c,d)最早发生时间=3-3=0</p><p>活动(b,d)最晚发生时间-活动(b,d)最早发生时间=6-4=2</p><p><strong>所以，关键路径为a-&gt;c-&gt;d,关键活动为(a,c)、(c,d)</strong></p><div class="note warning"><p>注意：1、关键路径可能有多条2、并不是改变任何一个关键活动的时间都可以改变总时间</p></div><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="6-1图的相关基本概念"><a href="#6-1图的相关基本概念" class="headerlink" title="6.1图的相关基本概念"></a>6.1图的相关基本概念</h2><ul><li><p>无向图</p><ul><li><strong>圆括号（x,y）表示无向边</strong></li></ul></li><li><p>有向图</p><ul><li><strong>尖括号&lt;x,y&gt;表示有向边</strong></li></ul></li><li><p>权</p></li><li><p>度、出度、入度</p><ul><li><strong>无向图：度数=边数×2</strong></li><li><strong>有向图：①度数=边数×2=出度+入度②出度=入度=边数</strong></li></ul></li><li><p><strong>边和弧：无向图中边就叫边，有向图中边叫做弧，还有弧头和弧尾之分，带箭头一端为弧头。</strong></p></li><li><p><strong>路径和回路：从一个顶点到另一顶点途径的所有顶点组成的序列（包含这两个顶点），称为一条路径。如果路径中第一个顶点和最后一个顶点相同，则此路径称为”回路”（或”环”）。</strong></p><ul><li><strong>简单路径（回路）：顶点不重复的路径（回路）</strong></li><li><strong>==常见考点：n个顶点的图，若 |E|&gt;n-1，则一定有回路==</strong></li></ul></li><li><p><strong>完全图:无向图中任意两个点之间都有边，有向图中任意两个点有互相通往对方的弧</strong></p><ul><li><strong>具有 n 个顶点的完全图，图中边的数量为 n(n-1)/2；即<img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604154211735.png" alt="image-20210604154211735" style="zoom:50%"></strong></li><li><strong>而对于具有 n 个顶点的有向完全图，图中弧的数量为 n(n-1)。即<img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604154249630.png" alt="image-20210604154249630" style="zoom:33%"></strong></li></ul></li><li><p><strong>稀疏图和稠密图：边数e&lt;nlogn为稀疏图反之为稠密图</strong></p></li><li><p><strong>简单图：无重复的边或顶点到自身的边</strong></p></li><li><p><strong>连通图：无向图中，如果任意两个顶点之间都能够连通</strong></p><ul><li><strong>连通分量：若无向图不是连通图，但图中存储某个极大子图符合连通图的性质，则称该子图为连通分量。</strong><ul><li><strong>极大：子图必须连通，且包含尽可能多的顶点和边</strong></li></ul></li></ul></li><li><p><strong>强连通图：有向图中，任意两个顶点之间能够连通</strong></p><ul><li><strong>强连通分量：若有向图不是连通图，但图中存储某个极大子图符合强连通图的性质，则称该子图为强连通分量。</strong><ul><li><strong>极大：子图必须连通，且包含尽可能多的顶点和边</strong></li></ul></li></ul></li><li><p><strong>网：图上的边或弧带有权则称为网。</strong></p></li><li><p><strong>生成树:连通图中连通且n个顶点n-1条边称为生成树。</strong></p><ul><li><strong>有向图中一顶点入度为0其余顶点入度为1的叫有向树。</strong></li></ul></li><li><p><strong>生成森林:在<em>非连通图</em>中，<em>连通分量的生成树</em>构成了非连通图的生成森林。</strong></p><ul><li><strong>一个有向图由若干棵有向树构成生成森林。</strong></li></ul></li><li><p><strong>子图和生成子图的区别</strong></p><ul><li><strong>生成子图和原图的点集是一样的。而子图的点集可以是原图的点集子集</strong></li></ul></li></ul><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604154835331.png" alt="image-20210604154835331"></p><h3 id="6-1-1关于连通图和强连通图"><a href="#6-1-1关于连通图和强连通图" class="headerlink" title="6.1.1关于连通图和强连通图"></a>6.1.1关于连通图和强连通图</h3><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604151536823.png" alt="image-20210604151536823"></p><blockquote><p>第一行如何理解？</p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604152004115.png" alt="image-20210604152004115" style="zoom:67%"><p>第二行如何理解 ？</p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604151644042.png" alt="image-20210604151644042" style="zoom:67%"><p>排除一个点，其他的点两两组合都直接连通（即n-1个点组成完全图，x(x-1)/2，当然此时x是n-1）。</p></blockquote><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604151546193.png" alt="image-20210604151546193"></p><blockquote><p>如何理解？</p><p>就是n个顶点连成一个环。</p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604151933442.png" alt="image-20210604151933442" style="zoom:67%"></blockquote><h2 id="6-2图的存储结构"><a href="#6-2图的存储结构" class="headerlink" title="6.2图的存储结构"></a>6.2图的存储结构</h2><h3 id="6-2-1邻接矩阵存储"><a href="#6-2-1邻接矩阵存储" class="headerlink" title="6.2.1邻接矩阵存储"></a>6.2.1邻接矩阵存储</h3><h4 id="（1）图象理解-2"><a href="#（1）图象理解-2" class="headerlink" title="（1）图象理解"></a>（1）图象理解</h4><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111191711.png" alt></p><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111191735.png" alt></p><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111191900.png" alt></p><blockquote><p>注：有时候也把子集到自己设为0即主对角线为0。</p><p>0或∞都代表无弧</p></blockquote><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111191913.png" alt></p><h4 id="（2）语言构造-1"><a href="#（2）语言构造-1" class="headerlink" title="（2）语言构造"></a>（2）语言构造</h4><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604170312021.png" alt="image-20210604170312021" style="zoom:80%"><p>根据图象理解，我们可以在类中<strong>动态定义一个一维数组存储节点，一个二维数组存储邻接矩阵</strong></p><p><strong>n个点的图信息的空间复杂度：O(n^2^)</strong></p><ul><li>O(n)的点信息</li><li>O(n^2^)的边信息</li><li>O(n)+O(n^2^)=O(n^2^)</li></ul><p><strong>适合用于存储稠密图</strong></p><p><strong>无向图的邻接矩阵是对称矩阵，可以压缩存储（只存储上三角区/下三角区）</strong></p><h4 id="（3）题目"><a href="#（3）题目" class="headerlink" title="（3）题目"></a>（3）题目</h4><h5 id="求度"><a href="#求度" class="headerlink" title="求度"></a>求度</h5><p><strong>如何求无向图中某个节点的度？</strong></p><ul><li>该行或列中有几个非0元素就是几度。</li></ul><p><strong>如何求有向图中某个节点的出度、入度、度？</strong></p><ul><li>出度：该行中有几个非0元素就是几出度。</li><li>入度：该列中有几个非0元素就是几入度。</li><li>度=出度+入度</li></ul><h5 id="邻接矩阵法的性质"><a href="#邻接矩阵法的性质" class="headerlink" title="邻接矩阵法的性质"></a>邻接矩阵法的性质</h5><p>邻接矩阵法求顶点的度/出度/入度的时间复杂度为 O(|V|)</p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604160124890.png" alt="image-20210604160124890" style="zoom:80%"><h3 id="6-2-2邻接表存储"><a href="#6-2-2邻接表存储" class="headerlink" title="6.2.2邻接表存储"></a>6.2.2邻接表存储</h3><h4 id="（1）图象理解-3"><a href="#（1）图象理解-3" class="headerlink" title="（1）图象理解"></a>（1）图象理解</h4><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111192845.png" alt></p><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191111192901.png" alt></p><p><font size="4" color="red"><strong>若为有权图，则需要在结点中添加代表权值的变量</strong></font></p><p>根据图象理解，<strong>我们先定义两个结构体节点，一个为邻接表的结点，一个为邻接表中存储其联通关系的链表结点。</strong></p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604170440065.png" alt="image-20210604170440065" style="zoom:80%"><h4 id="（2）题目"><a href="#（2）题目" class="headerlink" title="（2）题目"></a>（2）题目</h4><p><strong>无向图：边结点的数量是2|E|，整体空间复杂度为O(|V| + 2|E|)</strong></p><ul><li><strong>*每条边对应两份冗余信息，删除顶点、删除边等操作时间复杂度高</strong></li></ul><p><strong>有向图：边结点的数量是|E|，整体空间复杂度为O(|V| + |E|)</strong></p><p><strong>结点相邻的边存储顺序可任意。所以存储方式不唯一</strong></p><p>思考：如何求顶点的度、入度、出度？</p><ul><li>无向图：遍历边链表，找到与该点相邻的所有的边</li><li>有向图<ul><li>出度：遍历该节点的边链表</li><li>入度：把所有节点的边链表都遍历一遍</li><li>度=出度+入度</li></ul></li></ul><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604161626658.png" alt="image-20210604161626658" style="zoom:67%"><h3 id="6-2-3十字链表存储有向图"><a href="#6-2-3十字链表存储有向图" class="headerlink" title="6.2.3十字链表存储有向图"></a>6.2.3十字链表存储有向图</h3><blockquote><p>如何理解？</p><p>顶点节点：分为弧头和弧尾。</p><ul><li>弧头：指向该点的弧</li><li>弧尾：该点指出的弧</li></ul><p>边节点：弧头和弧尾编号、相同弧头和弧尾的链指向。</p><ul><li>沿着相同弧头的链(橙色)：得到入度</li><li>沿着相同弧尾的链(绿色)：得到出度</li></ul></blockquote><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604162514402.png" alt="image-20210604162514402" style="zoom:67%"><p><strong>空间复杂度：O(|V|+|E|)</strong></p><p><strong>==如何找到指定顶点的所有出边？——顺着绿色线路找==</strong></p><p><strong>==如何找到指定顶点的所有入边？——顺着橙色线路找==</strong></p><p><strong>注意：十字链表只用于存储有向图</strong></p><h3 id="6-2-4邻接多重表存储无向图"><a href="#6-2-4邻接多重表存储无向图" class="headerlink" title="6.2.4邻接多重表存储无向图"></a>6.2.4邻接多重表存储无向图</h3><blockquote><p>理解：</p><p>一个边节点可以看做两个点节点。</p><p>颜色相同的看做一类。</p><p>例如A指出去之后，按照橙色的继续往下找即可找出所有A相连的边。</p><p>B指出去之后，按照绿色的继续往下找即可找出所有与B相连的边。</p></blockquote><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604163635829.png" alt="image-20210604163635829" style="zoom:67%"><p><strong>删除一个边AB：只需要把指针顺着往下指就可以了。</strong></p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604163618229.png" alt="image-20210604163618229" style="zoom:80%"><p>删除一个点：例如E，删除该点和连接的边即可。</p><ul><li><strong>？对于指向该链中的节点的节点需要修改也不方便啊？？</strong><ul><li>应该例如删除结点E，需要删除后面两个边节点，而指向这两个边节点的节点，我需要从节点编号为1、2、4的都查一遍。？</li></ul></li></ul><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604164638869.png" alt="image-20210604164638869" style="zoom:67%"><p><strong>空间复杂度：O(|V|+|E|)</strong></p><p><strong>删除边、删除节点等操作很方便</strong></p><p><strong>注意：邻接多重表只适用于存储无向图</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604165249337.png" alt="image-20210604165249337" style="zoom:67%"><h2 id="6-3图的基本操作"><a href="#6-3图的基本操作" class="headerlink" title="6.3图的基本操作"></a>6.3图的基本操作</h2><ul><li>Adjacent(G,x,y)：判断图G是否存在边&lt;x, y&gt;或(x, y)。<ul><li>无向图=有向图<ul><li>邻接矩阵:O(1)</li><li>邻接表：O(1)~O(|V|)</li></ul></li></ul></li></ul><ul><li>Neighbors(G,x)：列出图G中与结点x邻接的边。<ul><li>无向图<ul><li>邻接矩阵：O(|V|)</li><li>邻接表：O(1)~O(|V|)</li></ul></li><li>有向图<ul><li>邻接矩阵：O(|V|)</li><li>邻接表：<ul><li>出边：O(1)~O(|V|)</li><li>入边：O(|E|)</li></ul></li></ul></li></ul></li></ul><ul><li>InsertVertex(G,x)：在图G中插入顶点x。<ul><li>无向图<ul><li>邻接矩阵O(1) （节点数组和边二维数组并无溢出的情况）</li><li>邻接表O(1)</li></ul></li><li>有向图也类似</li></ul></li></ul><ul><li>DeleteVertex(G,x)：从图G中删除顶点x。<ul><li>无向图<ul><li>邻接矩阵：O(|V|)<ul><li>在顶点节点增加bool判断结点是否有效。删除直接置位false，然后修改该行和列的数据为0.这样避免了大量的数据挪移。</li></ul></li><li>邻接表：O(1)~O(|E|)<ul><li>最好：没有连接任何边O(1)</li><li>最坏：该节点和其他所有点都有边，需要遍历所有边结点O(E)</li></ul></li></ul></li><li>有向图<ul><li>邻接矩阵 :O(|V|) 和无向图一样</li><li>邻接表<ul><li>删出边：O(1)~O(|V|)</li><li>删入边：O(|E|)</li></ul></li></ul></li></ul></li></ul><ul><li><p>AddEdge(G,x,y)：若无向边(x, y)或有向边&lt;x, y&gt;不存在，则向图G中添加该边。</p><ul><li>无向图<ul><li>邻接矩阵：O(1) ，改两个</li><li>邻接表：O(1) ，添两个</li></ul></li><li>有向图<ul><li>邻接矩阵：O(1) ，改一个</li><li>邻接表：O(1) ，添一个</li></ul></li></ul></li><li><p>FirstNeighbor(G,x)：求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点<br>或图中不存在x，则返回-1。</p><ul><li>无向图<ul><li>邻接矩阵：O(1)~O(|V|)，需要找到第一个非0元素</li><li>邻接表：O(1)，第一个若有就是</li></ul></li><li>有向图<ul><li>邻接矩阵：O(1)~O(|V|)，出边扫行，入边扫列，和上面一样。</li><li>邻接表<ul><li>找出边邻接点：O(1)</li><li>找入边邻接点：O(1) ~O(|E|)</li></ul></li></ul></li></ul></li><li><p>NextNeighbor(G,x,y)：假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一<br>个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。</p><ul><li>无向图<ul><li>邻接矩阵：O(1)~O(|V|)，往后面扫描，需要找到第一个非0元素</li><li>邻接表：O(1)，往后面扫描，第一个若有就是</li></ul></li><li>有向图<ul><li>邻接矩阵：O(1)~O(|V|)，出边扫行，入边扫列，和上面一样。</li><li>邻接表<ul><li>找出边邻接点：O(1)</li><li>找入边邻接点：O(1) ~O(|E|)</li></ul></li></ul></li></ul></li></ul><p>Get_edge_value(G,x,y)：获取图G中边(x, y)或&lt;x, y&gt;对应的权值。</p><p>Set_edge_value(G,x,y,v)：设置图G中边(x, y)或&lt;x, y&gt;对应的权值为v</p><p><strong>等同于找边。</strong></p><p>Adjacent(G,x,y)：判断图G是否存在边&lt;x, y&gt;或(x, y)。</p><ul><li>无向图=有向图<ul><li>邻接矩阵:O(1)</li><li>邻接表：O(1)~O(|V|)</li></ul></li></ul><h2 id="6-4图的⼴度优先遍历BFS-Breadth-First-Search"><a href="#6-4图的⼴度优先遍历BFS-Breadth-First-Search" class="headerlink" title="6.4图的⼴度优先遍历BFS(Breadth First Search)"></a>6.4图的⼴度优先遍历BFS(Breadth First Search)</h2><h3 id="6-4-1算法解释"><a href="#6-4-1算法解释" class="headerlink" title="6.4.1算法解释"></a>6.4.1算法解释</h3><p><strong>⼴度优先遍历（Breadth-First-Search, BFS）要点：</strong></p><ol><li><strong>找到与⼀个顶点相邻的所有顶点</strong></li><li><strong>标记哪些顶点被访问过</strong></li><li><strong>需要⼀个辅助队列</strong></li></ol><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604180112418.png" alt="image-20210604180112418" style="zoom:80%"><p>==<strong><em>队列循环用来处理队列中的每一个结点。</em></strong>==</p><p>==<strong><em>for循环用来处理每一个结点的相邻结点，判断是否访问过，没访问过则访问然后入队。</em></strong>==</p><blockquote><p><strong>增加一个函数，主要是为了解决非连通图的问题（多个连通分量，对每一个连通分量调用BFS函数）</strong></p><ul><li><strong>是通过辅助数组，查看BFS后是否有没访问过的节点,若有则再BFS</strong></li></ul><p><strong>==对于⽆向图，调⽤BFS函数的次数=连通分量数==</strong></p></blockquote><h3 id="6-4-2遍历序列的可变性"><a href="#6-4-2遍历序列的可变性" class="headerlink" title="6.4.2遍历序列的可变性"></a>6.4.2遍历序列的可变性</h3><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604180437229.png" alt="image-20210604180437229" style="zoom:67%"><p><strong>同⼀个图的<u>邻接矩阵</u>表示⽅式<u>唯⼀</u>，因此⼴度优先遍历序列<u>唯⼀</u></strong></p><p><strong>同⼀个图<u>邻接表</u>表示⽅式<u>不唯⼀</u>，因此⼴度优先遍历序列<u>不唯⼀</u></strong></p><blockquote><p>就是同一层，谁先入队的问题。</p></blockquote><h3 id="6-4-3复杂度分析"><a href="#6-4-3复杂度分析" class="headerlink" title="6.4.3复杂度分析"></a>6.4.3复杂度分析</h3><p><strong>空间复杂度：最坏情况，辅助<u>队列</u>⼤⼩为 O(|V|)</strong></p><p>邻接矩阵存储的图：</p><ul><li><p>访问 |V| 个顶点需要O(|V|)的时间</p></li><li><p>查找每个顶点的邻接点都需要O(|V|)的时间，⽽总共有|V|个顶点</p></li><li><p>O(|V|^2^)+O |V| = O(|V|^2^)</p></li></ul><p><strong>==时间复杂度= O(|V|^2^)==</strong></p><p>邻接表存储的图：</p><ul><li>访问 |V| 个顶点需要O(|V|)的时间</li><li>查找各个顶点的邻接点共需要O(2|E|)=O(|E|)的时间，<ul><li>⽆向图O(2|E|)，约去系数成O(|E|)</li><li>有向图直接就是O(|E|)</li></ul></li><li>O(|V|)+O(|E|)=O(|V|+|E|)</li></ul><p><strong>==时间复杂度= O(|V|+|E|)==</strong></p><h3 id="6-4-4⼴度优先⽣成树和⼴度优先⽣成森林"><a href="#6-4-4⼴度优先⽣成树和⼴度优先⽣成森林" class="headerlink" title="6.4.4⼴度优先⽣成树和⼴度优先⽣成森林"></a>6.4.4⼴度优先⽣成树和⼴度优先⽣成森林</h3><p><strong><em>⼴度优先生成树是以第一次访问该节点的顺序构成的树</em></strong></p><p><strong>⼴度优先生成树由⼴度优先遍历过程确定。由于邻接表的表示⽅式不唯⼀，因此基于邻接表的⼴度优先⽣成树也不唯⼀。</strong></p><p>例如<img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604181306893.png" alt="image-20210604181306893" style="zoom:67%">以2为初始节点的广度优先生产树</p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604181140708.png" alt="image-20210604181140708" style="zoom:80%"><p><strong>对⾮连通图的⼴度优先遍历，可得到⼴度优先⽣成森林</strong></p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604181505918.png" alt="image-20210604181505918" style="zoom:67%"><h3 id="6-4-5练习：有向图的BFS过程"><a href="#6-4-5练习：有向图的BFS过程" class="headerlink" title="6.4.5练习：有向图的BFS过程"></a>6.4.5练习：有向图的BFS过程</h3><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604181740612.png" alt="image-20210604181740612" style="zoom:67%"><p>5次和1次</p><h2 id="6-5图的深度优先遍历"><a href="#6-5图的深度优先遍历" class="headerlink" title="6.5图的深度优先遍历"></a>6.5图的深度优先遍历</h2><h3 id="6-5-1算法解释"><a href="#6-5-1算法解释" class="headerlink" title="6.5.1算法解释"></a>6.5.1算法解释</h3><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604192536036.png" alt="image-20210604192536036" style="zoom:67%"><h3 id="6-5-2复杂度分析"><a href="#6-5-2复杂度分析" class="headerlink" title="6.5.2复杂度分析"></a>6.5.2复杂度分析</h3><p>空间复杂度：来⾃函数调⽤栈，最坏情况，递归深度为O(|V|)</p><p>空间复杂度：最好情况，O(1)</p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604192642278.png" alt="image-20210604192642278" style="zoom:67%"> <img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604193015722.png" alt="image-20210604193015722" style="zoom:80%"><blockquote><p>可以看出DFS和BFS的复杂度一样</p></blockquote><h3 id="6-5-3遍历序列的可变性"><a href="#6-5-3遍历序列的可变性" class="headerlink" title="6.5.3遍历序列的可变性"></a>6.5.3遍历序列的可变性</h3><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604193345470.png" alt="image-20210604193345470" style="zoom:67%"><p><strong>同⼀个图的邻接矩阵表示⽅式唯⼀，因此深度优先遍历序列唯⼀</strong></p><p><strong>同⼀个图邻接表表示⽅式不唯⼀，因此深度优先遍历序列不唯⼀</strong></p><h3 id="6-5-4深度优先⽣成树和深度优先⽣成森林"><a href="#6-5-4深度优先⽣成树和深度优先⽣成森林" class="headerlink" title="6.5.4深度优先⽣成树和深度优先⽣成森林"></a>6.5.4深度优先⽣成树和深度优先⽣成森林</h3><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604193650364.png" alt="image-20210604193650364" style="zoom:67%"> <img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604193549749.png" alt="image-20210604193549749" style="zoom:67%"><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604193630526.png" alt="image-20210604193630526" style="zoom:67%"><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604193615547.png" alt="image-20210604193615547" style="zoom:67%"></p><h3 id="6-5-5图的遍历与图的连通性"><a href="#6-5-5图的遍历与图的连通性" class="headerlink" title="6.5.5图的遍历与图的连通性"></a>6.5.5图的遍历与图的连通性</h3><p><strong>对<u>⽆向图</u>进⾏BFS/DFS遍历==调⽤BFS/DFS函数的次数=连通分量数==</strong></p><p><strong>对于连通图，只需调⽤1次 BFS/DFS</strong></p><p><strong>对<u>有向图</u>进⾏BFS/DFS遍历调⽤BFS/DFS函数的次数要具体问题<u>具体分析</u></strong></p><p><strong>若起始顶点到其他各顶点都有路径，则只需调⽤1次BFS/DFS 函数</strong></p><p><strong>对于强连通图，从任⼀结点出发都只需调⽤1次 BFS/DFS</strong></p><h2 id="6-6最⼩⽣成树"><a href="#6-6最⼩⽣成树" class="headerlink" title="6.6最⼩⽣成树"></a>6.6最⼩⽣成树</h2><h3 id="6-6-1生成树的概念"><a href="#6-6-1生成树的概念" class="headerlink" title="6.6.1生成树的概念"></a>6.6.1生成树的概念</h3><p><strong>连通图</strong>的生成树是<strong>包含图中全部顶点</strong>的一个<strong>极小连通子图</strong>。</p><p>若图中<strong><u>顶点数为n</u></strong>，则它的<strong><u>生成树含有 n-1 条边</u></strong>。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。</p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604194459629.png" alt="image-20210604194459629" style="zoom:67%"><p><strong>之前我们学习过：⼴度优先⽣成树、深度优先⽣成树</strong></p><p><strong>现在我们学习最⼩⽣成树（最⼩代价树）</strong></p><p>对于⼀个<strong><u>带权连通⽆向图</u></strong>G = (V, E)，⽣成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设R为G的所有⽣成树的集合，若T为R中边的<strong><u>权值之和最⼩的⽣成树</u></strong>，则T称为G的最⼩⽣成树（Minimum-Spanning-Tree, MST）。</p><ul><li><strong>最⼩⽣成树可能有多个，但边的权值之和总是唯⼀且最⼩的</strong></li><li><strong>最⼩⽣成树的边数 = 顶点数 - 1。砍掉⼀条则不连通，增加⼀条边则会出现回路</strong></li><li><strong>如果⼀个连通图本身就是⼀棵树，则其最⼩⽣成树就是它本身</strong></li><li><strong>只有连通图才有⽣成树，⾮连通图只有⽣成森林</strong></li></ul><h3 id="6-6-2Prim-算法（普⾥姆）选点"><a href="#6-6-2Prim-算法（普⾥姆）选点" class="headerlink" title="6.6.2Prim 算法（普⾥姆）选点"></a>6.6.2Prim 算法（普⾥姆）选点</h3><p><strong>Prim 算法（普⾥姆）：从某⼀个顶点开始构建⽣成树；每次将代价最⼩的新顶点纳⼊⽣成树，直到所有顶点都纳⼊为⽌。</strong></p><blockquote><p>推荐阅读</p><p><a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/30/2615542.html" target="_blank" rel="noopener">最小生成树-Prim算法和Kruskal算法</a></p></blockquote><h3 id="6-6-3Kruskal-算法（克鲁斯卡尔）选边"><a href="#6-6-3Kruskal-算法（克鲁斯卡尔）选边" class="headerlink" title="6.6.3Kruskal 算法（克鲁斯卡尔）选边"></a>6.6.3Kruskal 算法（克鲁斯卡尔）选边</h3><p><strong>Kruskal 算法（克鲁斯卡尔）：每次选择⼀条权值最⼩的边，使这条边的两头连通（原本已经连通的就不选）直到所有结点都连通</strong></p><h3 id="6-6-4对比"><a href="#6-6-4对比" class="headerlink" title="6.6.4对比"></a>6.6.4对比</h3><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604195244303.png" alt="image-20210604195244303" style="zoom:67%"><p><strong>时间复杂度是如何得到的？</strong></p><p><strong>介绍算法的实现思想，并加以分析。</strong></p><h4 id="1-Prim-算法的实现思想"><a href="#1-Prim-算法的实现思想" class="headerlink" title="(1)Prim 算法的实现思想"></a>(1)Prim 算法的实现思想</h4><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604200152588.png" alt="image-20210604200152588" style="zoom:50%"> <img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604200229997.png" alt="image-20210604200229997" style="zoom:50%"><p><strong>再次循环遍历，更新还没加⼊的各个顶点的lowCost值</strong></p><blockquote><p><strong><u>其实就是看看对于新加入的结点，谁和它相连并且还没有加入生成树，并且若代价低则更新。</u></strong></p></blockquote><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604200414600.png" alt="image-20210604200414600" style="zoom:67%"><blockquote><p><strong>可见，加入V3后，有V1、V2、V4、V5与其相连，并且更新连接代价更小的。</strong></p><p><strong>由6、5、∞、∞变成5、4、6、4</strong></p></blockquote><p>一直执行到结束。不再赘述详见课件或视频。</p><p>分析：</p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604200719718.png" alt="image-20210604200719718" style="zoom:67%"><p><strong>其实就是：需要n-1轮处理，每一轮处理需要遍历两次，O(n-1)×O(2n)=O(n^2^)</strong></p><h4 id="2-Kruskal-算法的实现思想"><a href="#2-Kruskal-算法的实现思想" class="headerlink" title="(2)Kruskal 算法的实现思想"></a>(2)Kruskal 算法的实现思想</h4><p>初始：将各条边按权值排序</p><p>第1轮：检查第1条边的两个顶点是否连通（是否属于同⼀个集合）</p><p>………….</p><p>第6轮：检查第6条边的两个顶点是否连通（是否属于同⼀个集合）</p><p><strong>共执⾏ e 轮，每轮判断两个顶点是否属于同⼀集合，需要 O(log 2 e)总时间复杂度 O(elog 2 e)</strong></p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604200110980.png" alt="image-20210604200110980" style="zoom:67%"><h2 id="6-7最短路径"><a href="#6-7最短路径" class="headerlink" title="6.7最短路径"></a>6.7最短路径</h2><h3 id="6-7-1单源最短路径"><a href="#6-7-1单源最短路径" class="headerlink" title="6.7.1单源最短路径"></a>6.7.1单源最短路径</h3><h4 id="1-BFS算法（无权图）"><a href="#1-BFS算法（无权图）" class="headerlink" title="(1)BFS算法（无权图）"></a>(1)BFS算法（无权图）</h4><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604202455016.png" alt="image-20210604202455016" style="zoom:67%"><p><strong>初始化：本节点的d[]为0，其他为∞，path[]为-1</strong><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604202814675.png" alt="image-20210604202814675" style="zoom:80%"></p><p><strong>以2为根节点，遍历到1和6，修改相应d[w]=d[u]+1，path[w]=u.</strong></p><p><strong>则1和6的d[]变为1，path变为2，代表原点到本节点的长度为1，和上一个路径来源为2。</strong></p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604202950410.png" alt="image-20210604202950410" style="zoom:80%"><p><strong>BFS继续运作，以此类推得到：</strong></p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604203134556.png" alt="image-20210604203134556" style="zoom:80%"> <img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604203215905.png" alt="image-20210604203215905" style="zoom:67%"><blockquote><p><strong>==局限性：BFS算法求单源最短路径只适⽤于⽆权图，或所有边的权值都相同的图==</strong></p></blockquote><h4 id="2-Dijkstra算法（带权图、无权图）"><a href="#2-Dijkstra算法（带权图、无权图）" class="headerlink" title="(2)Dijkstra算法（带权图、无权图）"></a>(2)Dijkstra算法（带权图、无权图）</h4><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604204927186.png" alt="image-20210604204927186" style="zoom:67%"><blockquote><p><u><strong>此时，只有V0到V1和V4的路径，我们取最短，V4。置final为true</strong></u></p><p><u><strong>然后看<em>和V4相连</em>并且其 <em>final 值为false</em>的点，看看从V4到它们的路径是不是比原来小，是就更新dist[]和path[]的值。</strong></u></p></blockquote><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604205355183.png" alt="image-20210604205355183" style="zoom:67%"><blockquote><p>可见第一轮更新了V2和V3的信息。下面进行第二轮。</p></blockquote><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604205522543.png" alt="image-20210604205522543" style="zoom:67%"><blockquote><p>可见更新了V2的信息。以此类推直到结束</p></blockquote><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604205619365.png" alt="image-20210604205619365" style="zoom:67%"><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604205640991.png" alt="image-20210604205640991" style="zoom:67%"><p><strong>其实就是：需要n-1轮处理，每一轮处理需要遍历两次，一次求最小结点一次遍历相邻结点，O(n-1)×O(2n)=O(n^2^)</strong></p><p><strong><u>可以看出，和之前我们学的普里姆算法非常相似！</u></strong></p><blockquote><p>两者的区别在于，每次更新路径的不一样</p><p>prim更新的是未标记集合到已标记集合之间的距离</p><ul><li>比较的是当前结点到新节点的权和之前相应的dist大小，更新的就是边的权</li></ul><p>Dijkstra更新的是源点到未标记集合之间的距离</p><ul><li>比较的是(当前结点的dist+到新节点的权)和之前相应的dist大小，更新的是结点的dist+到新节点的权，</li></ul></blockquote><p><font size="4" color="red"><strong>注意：Dijkstra算法不能允许权值为负</strong></font></p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604210903353.png" alt="image-20210604210903353" style="zoom:67%"><h3 id="6-7-2各顶点间的最短路径"><a href="#6-7-2各顶点间的最短路径" class="headerlink" title="6.7.2各顶点间的最短路径"></a>6.7.2各顶点间的最短路径</h3><h4 id="1-Floyd算法（带权图、无权图）"><a href="#1-Floyd算法（带权图、无权图）" class="headerlink" title="(1)Floyd算法（带权图、无权图）"></a>(1)Floyd算法（带权图、无权图）</h4><p>使⽤动态规划思想，将问题的求解分为多个阶段</p><p>对于n个顶点的图G，求任意⼀对顶点 Vi —&gt; Vj 之间的最短路径可分为如下⼏个阶段：</p><p>#初始：不允许在其他顶点中转，最短路径是？</p><p>#0：若允许在 V 0 中转，最短路径是？</p><p>#1：若允许在 V 0 、V 1 中转，最短路径是？</p><p>#2：若允许在 V 0 、V 1 、V 2 中转，最短路径是？</p><p>…</p><p>#n-1：若允许在 V 0 、V 1 、V 2 …… V n-1 中转，最短路径是？</p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604213727606.png" alt="image-20210604213727606" style="zoom:67%"><blockquote><p><u><strong>对于路径矩阵A某个元素，此时是假设允许在某个节点中转。</strong></u></p><p><u><strong>则比较某两点之间的路径值，和以某个节点中转得到的路径值。若中转的值小，则更新这个路径值。</strong></u></p><p><u><strong>并且在path矩阵中标记中转点，表示两点之间需要中转。</strong></u></p></blockquote><p><strong>例如上面的V2到V1若以V0为中转点：</strong></p><p><strong>∞&gt;5+6=11</strong></p><p><strong>所以更新A[V2] [V1]为11.并且在path[V2] [V1]中更新中转点0。</strong></p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604214141172.png" alt="image-20210604214141172" style="zoom:67%"><blockquote><p>以此类推以V0为中转点的时候，按此算法扫描整个数组</p></blockquote><p><strong>再以V1为中转点，按此算法扫描整个数组</strong></p><p><strong>可知：13&gt;6+4=10</strong></p><p><strong>所以更新A[V0] [V2]为11.并且在path[V0] [V2]中更新中转点1。</strong></p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604214400401.png" alt="image-20210604214400401" style="zoom:67%"><p><strong>再以V2位中转点…..</strong></p><p><strong>最终：</strong></p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604214449533.png" alt="image-20210604214449533" style="zoom:67%"><h5 id="如何找具体路径？"><a href="#如何找具体路径？" class="headerlink" title="如何找具体路径？"></a>如何找具体路径？</h5><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604214626043.png" alt="image-20210604214626043" style="zoom:67%"><p><strong>利用上述算法结果如上：</strong></p><p><strong>我们找V0到V4 最短路径⻓度</strong></p><p><strong>首先：V0 V4</strong></p><p><strong>因为path[0] [4]=3，所以为 V0 V3 V4</strong></p><p><strong>path[3] [4]=-1，所以V3 V4之间无中转。</strong></p><p><strong>path[0] [3]=2，所以V0 V3之间有中转V2。即V0 V2 V3 V4</strong></p><p><strong>再看V0和V2之间、V2和V3之间，得到：V0 V2 V1 V3 V4</strong></p><p><strong>再看V2和V1之间、V1和V3之间，得到：V0 V2 V1 V3 V4</strong></p><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p><strong>核心代码：</strong></p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604214510301.png" alt="image-20210604214510301" style="zoom:80%"><p><font size="4" color="red"><strong>注意： 通常可以在任何图中使用，包括有向图、带负权边的图。但是不能有带负权的边组成的回路</strong></font></p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604215051829.png" alt="image-20210604215051829" style="zoom:67%"><p>因为每跑一圈，路径就-2。</p><h4 id="2-n次Dijkstra-算法"><a href="#2-n次Dijkstra-算法" class="headerlink" title="(2)n次Dijkstra 算法"></a>(2)n次Dijkstra 算法</h4><p><strong>也可⽤ Dijkstra 算法求所有顶点间的最短路径，重复 |V| 次即可==，总的时间复杂度也是O(|V| 3 )==</strong></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210604215310602.png" alt="image-20210604215310602" style="zoom:67%"><h2 id="6-8有向⽆环图（DAG）"><a href="#6-8有向⽆环图（DAG）" class="headerlink" title="6.8有向⽆环图（DAG）"></a>6.8有向⽆环图（DAG）</h2><p>有向⽆环图：若⼀个<strong><u>有向图中不存在环</u></strong>，则称为有向⽆环图，简称DAG图（Directed Acyclic Graph）</p><h3 id="6-8-1有向⽆环图（DAG）描述表达式"><a href="#6-8-1有向⽆环图（DAG）描述表达式" class="headerlink" title="6.8.1有向⽆环图（DAG）描述表达式"></a>6.8.1有向⽆环图（DAG）描述表达式</h3><p>对于一个计算表达式用树的形式：</p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605091124642.png" alt="image-20210605091124642" style="zoom:67%"><p><strong>我们发现有重复的子树，其实可以合并。</strong></p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605091225903.png" alt="image-20210605091225903" style="zoom:67%"><p>可看出a+d依旧可以合并。</p><p>b和b也可以合并，最终：</p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605091301952.png" alt="image-20210605091301952" style="zoom:67%"><h4 id="解题⽅法"><a href="#解题⽅法" class="headerlink" title="解题⽅法"></a>解题⽅法</h4><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605091537586.png" alt="image-20210605091537586" style="zoom:67%"> <img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605091401274.png" alt="image-20210605091401274" style="zoom:67%"><p>再给一个例子：</p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605091710074.png" alt="image-20210605091710074" style="zoom:67%"><p>合并后：</p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605091725141.png" alt="image-20210605091725141" style="zoom:67%"><h3 id="6-8-2AOV（Activity-On-Vertices）网络和拓扑排序"><a href="#6-8-2AOV（Activity-On-Vertices）网络和拓扑排序" class="headerlink" title="6.8.2AOV（Activity On Vertices）网络和拓扑排序"></a>6.8.2AOV（Activity On Vertices）网络和拓扑排序</h3><h4 id="1-AOV（Activity-On-Vertices）网络"><a href="#1-AOV（Activity-On-Vertices）网络" class="headerlink" title="(1)AOV（Activity On Vertices）网络"></a>(1)AOV（Activity On Vertices）网络</h4><p>活动网络可以用来描述生产计划、施工过程、生产流程、程序流程等工程中各子工程的安排问题。 一般一个工程可以分成若干个子工程，这些子工程称为活动（Activity）。完成了这些活动，整个工程就完成了。</p><p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20191126174423.png" alt></p><p>我们可以用上图的有向图来表示课程之间的先修关系。在这种有向图中，顶点表示课程学习活动，有向边表示课程之间的先修关系。例如顶点C1到C8有一条有向边，表示课程C1必须在课程C8之前先学习完。</p><p>实际上，在这种有向图中，用顶点表示活动，<strong>用有向边表示活动u必须先于活动v进行。这种有向图叫做活动网络（Activity on Vertices），记做AOV网络。</strong></p><p><strong>前驱与后继：</strong>在AOV网络中，如果存在有向边，则称活动u必须在活动v之前进行，并称u是v的直接前驱，v是u的直接后继。如果存在有向路径，则称u是v的前驱，v是u的后继。</p><p>AOV网络中不能出现有向回路（或称为有向环）。 <font size="4" color="red"><strong>在AOV网络中如果出现了有向回路，则意味着某项活动以自己作为先决条件，这是不对的。AOV网络是有向无环图。</strong></font></p><h4 id="2-拓扑排序"><a href="#2-拓扑排序" class="headerlink" title="(2)拓扑排序"></a>(2)拓扑排序</h4><p><strong>1、</strong>判断有向无环图的方法是对AOV网络构造它的拓扑有序序列（Topological Order Sequence）；</p><p><strong>2、</strong>构造这种AOV网络全部顶点的拓扑有序序列的运算称为拓扑排序，即将<strong>各个顶点排列成一个线性有序的序列，使得AOV网络中所有存在的前驱和后继关系都能得到满足。</strong></p><p><strong>3、</strong><font size="4" color="red"><strong>一个AOV网络的拓扑有序序列可能不是唯一的；</strong></font></p><p><strong>4、</strong>拓扑排序实现方法：</p><p><strong>（1）从AOV网络中选择一个入度为0（即没有直接前驱）的顶点并输出；</strong></p><p><strong>（2）从AOV网络中删除该顶点及该顶点发出的所有边；</strong></p><p><strong>（3）重复步骤（1）和（2），直至找不到入度为0的顶点。</strong></p><p><strong>经过上述步骤后，有两种结果：</strong></p><ul><li><p><strong>（1）所有的顶点都被输出，也就是整个拓扑排序完成了；</strong></p></li><li><p><strong>（2）仍有顶点没有被输出，只剩下入度不为0的顶点，即存在有环图。</strong></p></li></ul><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605094355372.png" alt="image-20210605094355372" style="zoom:67%"><blockquote><p>代码解释：</p><p>初始化indegree数组省略了。它包含各个顶点的度的信息。</p><p>扫描indegree数组把度为0的顶点需要压栈。</p><p>当栈不为空{</p><p>出栈一个顶点，并把序号输入到打印数组中。</p><p>对该顶点的邻接表扫描 {</p><p>把指向的节点的度数-1，在indegree数组中执行。</p><p>若减1后该点度数为0则入栈。</p><p>​ }</p><p>}</p><p>最后，数组的元素数量count等于结点数，则代表无剩余结点，拓扑排序成功。否则失败。</p><p><strong>==时间复杂度：O(|V|+|E|)==</strong></p><p><strong>==若采⽤邻接矩阵，则需O(|V| 2 )==</strong></p></blockquote><p>例：</p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605095330936.png" alt="image-20210605095330936" style="zoom:67%"><p>初始化扫描indegree数组，把度为0的压栈。</p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605095435830.png" alt="image-20210605095435830" style="zoom:67%"><p>出栈2，写入print数组，扫描结点2的邻接表，对相应结点在indegree数组中的度数减1.发现并没有减1后为0的节点不需要压栈。</p><blockquote><p>之后的执行都和这差不多，除了减1为0就压栈有区别。详见课件或者视频。</p></blockquote><h4 id="3-逆拓扑排序"><a href="#3-逆拓扑排序" class="headerlink" title="(3)逆拓扑排序"></a>(3)逆拓扑排序</h4><p><strong>其实就是和拓扑排序反过来，先找出度为0的顶点输出，删除该顶点和相关边。</strong></p><p><strong>不断进行下去。最后没有顶点了就逆拓扑排序完成。</strong></p><p><strong>若仍旧有顶点没有被输出，只剩下出度不为0的顶点，即存在有环图。</strong></p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605095733091.png" alt="image-20210605095733091" style="zoom:67%"><blockquote><p>实现和拓扑排序差不多，只不过我们需要的是outdegree数组。并且扫描入度边需要扫描整个边节点。</p><p>邻接矩阵就方便很多，扫描列即可。</p><p><strong><u>但是，也可以用逆邻接表，这样就和拓扑排序几乎一致了，只需要初始化和使用outdegree数组，扫描逆邻接表。</u></strong></p></blockquote><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605100018047.png" alt="image-20210605100018047" style="zoom:67%"><blockquote><p>使用DFS算法实现逆拓扑排序。</p><p>深度优先的最后一个结点肯定是没有再指向其他结点的节点，即出度为0的节点。</p><p>再结合程序使用递归调用栈的特点。输出肯定是逆序的。就是逆拓扑排序。</p></blockquote><h2 id="6-9AOE（Activity-On-Edge）网络与关键路径"><a href="#6-9AOE（Activity-On-Edge）网络与关键路径" class="headerlink" title="6.9AOE（Activity On Edge）网络与关键路径"></a>6.9AOE（Activity On Edge）网络与关键路径</h2><h3 id="6-9-1AOE网络"><a href="#6-9-1AOE网络" class="headerlink" title="6.9.1AOE网络"></a>6.9.1AOE网络</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="(1)概念"></a>(1)概念</h4><p>定义:如果在<strong>无环的带权有向图</strong>中用<strong>有向边表示一个工程中的活动用边上的权值表示活动的持续时间用顶点表示事件</strong>则这样的有向图叫做用边表示活动的网络，简称<strong>AOE网络</strong></p><p><font size="4" color="red"><strong>一定要注意：AOV网中，点代表活动，AOE网中边代表活动两者是不同的。</strong></font></p><p><strong>事件和活动的理解，AOE网中边为活动，点为事件，可理解事件是一个“检查点”，它是一种“状态”，只有“检查”到通向该事件的活动全部完成的状态，才能进入下面的活动</strong></p><ul><li>AOE网中没有入边的顶点称为<strong>始点（源点）</strong></li><li>AOE网中没有出边的顶点称为<strong>终点（汇点）</strong></li></ul><h4 id="2-AOE网的性质"><a href="#2-AOE网的性质" class="headerlink" title="(2)AOE网的性质"></a>(2)AOE网的性质</h4><p>1、<strong>只有进入某顶点的各活动都结束，该顶点所代表的事件才能发生,另外，有些活动是可以并⾏进⾏的</strong></p><p>2、<strong>只有某顶点所代表的事件发生后，从该顶点出发的各活动才能开始</strong></p><h4 id="3-AOE网的应用"><a href="#3-AOE网的应用" class="headerlink" title="(3)AOE网的应用"></a>(3)AOE网的应用</h4><p>AOE在工程方面非常有用：</p><p>例如：</p><p>（1）完成整个工程<strong>至少需要多少时间</strong>（假设没有环）；</p><p>（2）为缩短完成工程所需时间，<strong>应当加快那些活动</strong>？</p><p><font size="4" color="red"><strong>因为在工程当中，很多活动是并行的，所以有些活动是导致工期长短的关键活动，不能拖延，而有些活动是可以在一定范围内延迟的，这是计算关键路径的原因！</strong></font></p><h3 id="6-9-2关键路径"><a href="#6-9-2关键路径" class="headerlink" title="6.9.2关键路径"></a>6.9.2关键路径</h3><h4 id="1-关键路径的相关概念"><a href="#1-关键路径的相关概念" class="headerlink" title="(1)关键路径的相关概念"></a>(1)关键路径的相关概念</h4><p>从源点到各个顶点，以至从<strong>源点到汇点的有向路径可能不止一条</strong>。这些路径的长度也可能不同，完成不同路径的活动所需时间不同，<strong><u>但只有各条路径上所有活动都完成了，整个工程才完成。完成整个工程所需时间<em>取决于从源点到汇点的最长路径长度</em>，即在该路径上所有活动的持续时间之和，给路径称为关键路径</u></strong>。</p><p>为了找出关键路径，必须找出<strong>关键活动，即不按期完成就会影响整个工程完成的活动</strong>。</p><p><strong>关键路径上的所有活动都是关键活动。</strong></p><h4 id="2-四个和计算关键路径相关的量"><a href="#2-四个和计算关键路径相关的量" class="headerlink" title="(2)四个和计算关键路径相关的量"></a>(2)四个和计算关键路径相关的量</h4><ul><li>事件最早可能开始时间Ve[k]：求法为源点到该顶点的最大长度，需要<strong>正向计算取大得出</strong></li><li>事件最迟允许开始时间Vl[k]：需要<strong>逆向计算取小得到</strong></li><li>活动最早开始时间e[i]：<strong>活动代表的是边，它的最早开始时间和它作为某个点出度的事件的最早开始时间相同</strong></li><li>活动的最晚开始时间l[i]：<strong>通过该边作为入度指向的事件的最晚触发事件逆向计算得到</strong></li></ul><h4 id="3-计算关键路径"><a href="#3-计算关键路径" class="headerlink" title="(3)计算关键路径"></a>(3)计算关键路径</h4><p><font size="4" color="red"><strong>计算各个活动的时间余量l[k]-e[k]，时间余量为0即（l[k]=e[k]）者为关键活动</strong></font></p><p>多个或一个活动的完成才能决定一个事件的触发，它取决于触发事件的活动中最长的一个，我们从始点开始计算每个事件的最早开始时间，也就是计算每个点相对始点的最大路径，一直计算到终点，就计算出了完成工程的最早时间，通过工程完成的最早时间我们能逆推每个事件完成的最晚时间，然后通过每个事件得出每个工程的最晚开始时间</p><p><strong>通过最大路径计算得到每个事件的最早发生时间–&gt;最终得到工程完成最早时间（终点事件的触发时间）–&gt;逆推每个事件的最晚触发时间–&gt;通过每个事件的最晚触发时间能逆推每个活动的最晚开始时间–&gt;比较每个活动的最早开始时间（由相关量性质可知，计算过事件的最早发生时间，活动的最早发生时间也就确定了）和最晚开始时间，没有时间余量的活动为关键活动–&gt;解决为缩短工期能够加快那些活动的问题（只有加快关键活动才能加快进程，但是值得注意的是，我们只能在现实中尽快督促完成，若是理想化直接提前很长时间完成关键活动，实际上AOE网就会改变，关键路径也就不一定是原样了）</strong></p><p><strong>==我们按照按拓扑排序序列进行上述操作。==</strong></p><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/image-20210605102308632.png" alt="image-20210605102308632" style="zoom:67%"></div><div><div><div style="text-align:center;color:#555;font-size:14px">-----------------------本文结束 <i class="fa fa-heart"></i> 感谢阅读-----------------------</div></div></div><div><div id="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！恰饭^.^~</div><button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20190826214611.png" alt="峻源 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/20190826214431.png" alt="峻源 支付宝"><p>支付宝</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>峻源</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://lyxf2000.github.io/posts/7dc31fbc/" title="数据结构【七】:图">http://lyxf2000.github.io/posts/7dc31fbc/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/数据结构/" rel="tag"><i class="fa fa-tag">数据结构</i></a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/54ce560e/" rel="next" title="数据结构【五】树"><i class="fa fa-chevron-left"></i> 数据结构【五】树</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/posts/b67e1f92/" rel="prev" title="计算机组成原理【五】:控制单元的功能">计算机组成原理【五】:控制单元的功能 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80NjM0NC8yMjg1NQ=="></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><a href="/"><img class="site-author-image" itemprop="image" src="https://lyxf2000-1259802619.cos.ap-beijing.myqcloud.com/avatar.gif" alt="峻源"></a><p class="site-author-name" itemprop="name">峻源</p><div class="site-description motion-element" itemprop="description">乐于心，乐与心，乐之屿，心扉间</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">122</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">17</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">21</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:1194320636@qq.com" title="QE-Mail &rarr; mailto:1194320636@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i>QE-Mail</a> </span><span class="links-of-author-item"><a href="https://music.163.com/#/playlist?id=699716432" title="CloudMusic &rarr; https://music.163.com/#/playlist?id=699716432" rel="noopener" target="_blank"><i class="fa fa-fw fa-music"></i>CloudMusic</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://www.baidu.com/" title="https://www.baidu.com/" rel="noopener" target="_blank">百度</a></li><li class="links-of-blogroll-item"><a href="https://www.google.com/?hl=zh_CN" title="https://www.google.com/?hl=zh_CN" rel="noopener" target="_blank">谷歌</a></li><li class="links-of-blogroll-item"><a href="https://www.zhihu.com/" title="https://www.zhihu.com/" rel="noopener" target="_blank">知乎</a></li><li class="links-of-blogroll-item"><a href="https://juejin.im/" title="https://juejin.im/" rel="noopener" target="_blank">掘金</a></li><li class="links-of-blogroll-item"><a href="https://github.com/" title="https://github.com/" rel="noopener" target="_blank">github</a></li><li class="links-of-blogroll-item"><a href="https://www.luogu.org/" title="https://www.luogu.org/" rel="noopener" target="_blank">洛谷</a></li></ul></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#需要知道的图的相关基本概念"><span class="nav-number">1.</span> <span class="nav-text">需要知道的图的相关基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图的存储结构"><span class="nav-number">2.</span> <span class="nav-text">图的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-邻接矩阵存储"><span class="nav-number">2.1.</span> <span class="nav-text">1.邻接矩阵存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）图象理解"><span class="nav-number">2.1.1.</span> <span class="nav-text">（1）图象理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）语言构造"><span class="nav-number">2.1.2.</span> <span class="nav-text">（2）语言构造</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-邻接表存储"><span class="nav-number">2.2.</span> <span class="nav-text">2.邻接表存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）图象理解-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">（1）图象理解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图的遍历（DFS和BFS）"><span class="nav-number">3.</span> <span class="nav-text">图的遍历（DFS和BFS）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、Depth-First-Search深度优先探索"><span class="nav-number">3.0.1.</span> <span class="nav-text">1、Depth First Search深度优先探索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、Breadth-First-Search广度优先探索"><span class="nav-number">3.0.2.</span> <span class="nav-text">2、Breadth First Search广度优先探索</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#最小生成树"><span class="nav-number">4.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Kruskal算法"><span class="nav-number">4.0.1.</span> <span class="nav-text">Kruskal算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Prim算法"><span class="nav-number">4.0.2.</span> <span class="nav-text">Prim算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最短路径"><span class="nav-number">5.</span> <span class="nav-text">最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、求一点到其他点的最短路径（单源最短路径）"><span class="nav-number">5.0.1.</span> <span class="nav-text">1、求一点到其他点的最短路径（单源最短路径）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#①Dijkstra算法"><span class="nav-number">5.0.1.1.</span> <span class="nav-text">①Dijkstra算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#②bellman-ford算法"><span class="nav-number">5.0.1.2.</span> <span class="nav-text">②bellman-ford算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、求任意两点的最短路径"><span class="nav-number">5.0.2.</span> <span class="nav-text">3、求任意两点的最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#①Floyd算法"><span class="nav-number">5.0.2.1.</span> <span class="nav-text">①Floyd算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOV（Activity-On-Vertices）网络和拓扑排序"><span class="nav-number">6.</span> <span class="nav-text">AOV（Activity On Vertices）网络和拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、AVO网络"><span class="nav-number">6.0.1.</span> <span class="nav-text">1、AVO网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、拓扑排序"><span class="nav-number">6.0.2.</span> <span class="nav-text">2、拓扑排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOE（Activity-On-Edge）网络与关键路径"><span class="nav-number">7.</span> <span class="nav-text">AOE（Activity On Edge）网络与关键路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、AOE网络"><span class="nav-number">7.1.</span> <span class="nav-text">1、AOE网络</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AOE网的基础概念"><span class="nav-number">7.1.1.</span> <span class="nav-text">AOE网的基础概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOE网的性质"><span class="nav-number">7.1.2.</span> <span class="nav-text">AOE网的性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOE网的应用"><span class="nav-number">7.1.3.</span> <span class="nav-text">AOE网的应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、关键路径"><span class="nav-number">7.2.</span> <span class="nav-text">2、关键路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#关键路径的相关概念"><span class="nav-number">7.2.1.</span> <span class="nav-text">关键路径的相关概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四个和计算关键路径相关的量"><span class="nav-number">7.2.2.</span> <span class="nav-text">四个和计算关键路径相关的量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算关键路径"><span class="nav-number">7.2.3.</span> <span class="nav-text">计算关键路径</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#补充"><span class="nav-number"></span> <span class="nav-text">补充</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1图的相关基本概念"><span class="nav-number">1.</span> <span class="nav-text">6.1图的相关基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1关于连通图和强连通图"><span class="nav-number">1.1.</span> <span class="nav-text">6.1.1关于连通图和强连通图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2图的存储结构"><span class="nav-number">2.</span> <span class="nav-text">6.2图的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1邻接矩阵存储"><span class="nav-number">2.1.</span> <span class="nav-text">6.2.1邻接矩阵存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）图象理解-2"><span class="nav-number">2.1.1.</span> <span class="nav-text">（1）图象理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）语言构造-1"><span class="nav-number">2.1.2.</span> <span class="nav-text">（2）语言构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）题目"><span class="nav-number">2.1.3.</span> <span class="nav-text">（3）题目</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#求度"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">求度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#邻接矩阵法的性质"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">邻接矩阵法的性质</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2邻接表存储"><span class="nav-number">2.2.</span> <span class="nav-text">6.2.2邻接表存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）图象理解-3"><span class="nav-number">2.2.1.</span> <span class="nav-text">（1）图象理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）题目"><span class="nav-number">2.2.2.</span> <span class="nav-text">（2）题目</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-3十字链表存储有向图"><span class="nav-number">2.3.</span> <span class="nav-text">6.2.3十字链表存储有向图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-4邻接多重表存储无向图"><span class="nav-number">2.4.</span> <span class="nav-text">6.2.4邻接多重表存储无向图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">2.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3图的基本操作"><span class="nav-number">3.</span> <span class="nav-text">6.3图的基本操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4图的⼴度优先遍历BFS-Breadth-First-Search"><span class="nav-number">4.</span> <span class="nav-text">6.4图的⼴度优先遍历BFS(Breadth First Search)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-1算法解释"><span class="nav-number">4.1.</span> <span class="nav-text">6.4.1算法解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-2遍历序列的可变性"><span class="nav-number">4.2.</span> <span class="nav-text">6.4.2遍历序列的可变性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-3复杂度分析"><span class="nav-number">4.3.</span> <span class="nav-text">6.4.3复杂度分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-4⼴度优先⽣成树和⼴度优先⽣成森林"><span class="nav-number">4.4.</span> <span class="nav-text">6.4.4⼴度优先⽣成树和⼴度优先⽣成森林</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-5练习：有向图的BFS过程"><span class="nav-number">4.5.</span> <span class="nav-text">6.4.5练习：有向图的BFS过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5图的深度优先遍历"><span class="nav-number">5.</span> <span class="nav-text">6.5图的深度优先遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-1算法解释"><span class="nav-number">5.1.</span> <span class="nav-text">6.5.1算法解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-2复杂度分析"><span class="nav-number">5.2.</span> <span class="nav-text">6.5.2复杂度分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-3遍历序列的可变性"><span class="nav-number">5.3.</span> <span class="nav-text">6.5.3遍历序列的可变性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-4深度优先⽣成树和深度优先⽣成森林"><span class="nav-number">5.4.</span> <span class="nav-text">6.5.4深度优先⽣成树和深度优先⽣成森林</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-5图的遍历与图的连通性"><span class="nav-number">5.5.</span> <span class="nav-text">6.5.5图的遍历与图的连通性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6最⼩⽣成树"><span class="nav-number">6.</span> <span class="nav-text">6.6最⼩⽣成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-1生成树的概念"><span class="nav-number">6.1.</span> <span class="nav-text">6.6.1生成树的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-2Prim-算法（普⾥姆）选点"><span class="nav-number">6.2.</span> <span class="nav-text">6.6.2Prim 算法（普⾥姆）选点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-3Kruskal-算法（克鲁斯卡尔）选边"><span class="nav-number">6.3.</span> <span class="nav-text">6.6.3Kruskal 算法（克鲁斯卡尔）选边</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-4对比"><span class="nav-number">6.4.</span> <span class="nav-text">6.6.4对比</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Prim-算法的实现思想"><span class="nav-number">6.4.1.</span> <span class="nav-text">(1)Prim 算法的实现思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Kruskal-算法的实现思想"><span class="nav-number">6.4.2.</span> <span class="nav-text">(2)Kruskal 算法的实现思想</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-7最短路径"><span class="nav-number">7.</span> <span class="nav-text">6.7最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-1单源最短路径"><span class="nav-number">7.1.</span> <span class="nav-text">6.7.1单源最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-BFS算法（无权图）"><span class="nav-number">7.1.1.</span> <span class="nav-text">(1)BFS算法（无权图）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Dijkstra算法（带权图、无权图）"><span class="nav-number">7.1.2.</span> <span class="nav-text">(2)Dijkstra算法（带权图、无权图）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#分析"><span class="nav-number">7.1.2.1.</span> <span class="nav-text">分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-2各顶点间的最短路径"><span class="nav-number">7.2.</span> <span class="nav-text">6.7.2各顶点间的最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Floyd算法（带权图、无权图）"><span class="nav-number">7.2.1.</span> <span class="nav-text">(1)Floyd算法（带权图、无权图）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#如何找具体路径？"><span class="nav-number">7.2.1.1.</span> <span class="nav-text">如何找具体路径？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分析-1"><span class="nav-number">7.2.1.2.</span> <span class="nav-text">分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-n次Dijkstra-算法"><span class="nav-number">7.2.2.</span> <span class="nav-text">(2)n次Dijkstra 算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">7.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-8有向⽆环图（DAG）"><span class="nav-number">8.</span> <span class="nav-text">6.8有向⽆环图（DAG）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-8-1有向⽆环图（DAG）描述表达式"><span class="nav-number">8.1.</span> <span class="nav-text">6.8.1有向⽆环图（DAG）描述表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解题⽅法"><span class="nav-number">8.1.1.</span> <span class="nav-text">解题⽅法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-8-2AOV（Activity-On-Vertices）网络和拓扑排序"><span class="nav-number">8.2.</span> <span class="nav-text">6.8.2AOV（Activity On Vertices）网络和拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-AOV（Activity-On-Vertices）网络"><span class="nav-number">8.2.1.</span> <span class="nav-text">(1)AOV（Activity On Vertices）网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-拓扑排序"><span class="nav-number">8.2.2.</span> <span class="nav-text">(2)拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#代码实现"><span class="nav-number">8.2.2.1.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-逆拓扑排序"><span class="nav-number">8.2.3.</span> <span class="nav-text">(3)逆拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实现"><span class="nav-number">8.2.3.1.</span> <span class="nav-text">实现</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-9AOE（Activity-On-Edge）网络与关键路径"><span class="nav-number">9.</span> <span class="nav-text">6.9AOE（Activity On Edge）网络与关键路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-9-1AOE网络"><span class="nav-number">9.1.</span> <span class="nav-text">6.9.1AOE网络</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-概念"><span class="nav-number">9.1.1.</span> <span class="nav-text">(1)概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-AOE网的性质"><span class="nav-number">9.1.2.</span> <span class="nav-text">(2)AOE网的性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-AOE网的应用"><span class="nav-number">9.1.3.</span> <span class="nav-text">(3)AOE网的应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-9-2关键路径"><span class="nav-number">9.2.</span> <span class="nav-text">6.9.2关键路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-关键路径的相关概念"><span class="nav-number">9.2.1.</span> <span class="nav-text">(1)关键路径的相关概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-四个和计算关键路径相关的量"><span class="nav-number">9.2.2.</span> <span class="nav-text">(2)四个和计算关键路径相关的量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-计算关键路径"><span class="nav-number">9.2.3.</span> <span class="nav-text">(3)计算关键路径</span></a></li></ol></li></ol></li></ol></li></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love" id="heart"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">峻源</span></div><span>本站已运行<span id="showDays"></span></span><script>var seconds=1e3,minutes=60*seconds,hours=60*minutes,days=24*hours,years=365*days,birthDay=Date.UTC(2019,8,1,14,0,0);setInterval(function(){var e=new Date,s=e.getFullYear(),t=e.getMonth()+1,a=e.getDate(),o=e.getHours(),r=e.getMinutes(),n=e.getSeconds(),h=Date.UTC(s,t,a,o,r,n),u=h-birthDay,d=Math.floor(u/years),y=Math.floor(u/days-365*d),i=Math.floor((u-(365*d+y)*days)/hours),l=Math.floor((u-(365*d+y)*days-i*hours)/minutes),M=Math.floor((u-(365*d+y)*days-i*hours-l*minutes)/seconds);document.getElementById("showDays").innerHTML=""+d+"年"+y+"天"+i+"小时"+l+"分钟"+M+"秒"},1e3)</script><div><i class="fa fa-user-md"></i> <span id="busuanzi_container_site_uv">访问人数：<span id="busuanzi_value_site_uv"></span> </span>&nbsp;|&nbsp; <i class="fa fa-eye"></i> <span id="busuanzi_container_site_pv">总访问量：<span id="busuanzi_value_site_pv"></span> </span>&nbsp;|&nbsp; <i class="fa fa-pencil"></i> <span class="post-count">博客全站共 453.9k 字</span></div></div></footer></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=3.4.1"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script><script src="/js/utils.js?v=7.2.0"></script><script src="/js/motion.js?v=7.2.0"></script><script src="/js/affix.js?v=7.2.0"></script><script src="/js/schemes/pisces.js?v=7.2.0"></script><script src="/js/scrollspy.js?v=7.2.0"></script><script src="/js/post-details.js?v=7.2.0"></script><script src="/js/next-boot.js?v=7.2.0"></script><script>window.livereOptions={refer:"posts/7dc31fbc/"},function(e,t){var n,r=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&(n=e.createElement(t),n.src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,r.parentNode.insertBefore(n,r))}(document,"script")</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><link rel="stylesheet" href="/dist/APlayer.min.css"><div id="aplayer"></div><script type="text/javascript" src="/dist/APlayer.min.js"></script><script type="text/javascript" src="/dist/music.js"></script><script type="text/javascript" src="/js/firework.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/koharu.model.json"},display:{position:"right",width:220,height:400},mobile:{show:!1},react:{opacity:.9},log:!1})</script></body></html><!-- rebuild by neat -->